/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/asynckit/index.js":
/*!****************************************!*\
  !*** ./node_modules/asynckit/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports =
{
  parallel      : __webpack_require__(/*! ./parallel.js */ "./node_modules/asynckit/parallel.js"),
  serial        : __webpack_require__(/*! ./serial.js */ "./node_modules/asynckit/serial.js"),
  serialOrdered : __webpack_require__(/*! ./serialOrdered.js */ "./node_modules/asynckit/serialOrdered.js")
};


/***/ }),

/***/ "./node_modules/asynckit/lib/abort.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/abort.js ***!
  \********************************************/
/***/ ((module) => {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),

/***/ "./node_modules/asynckit/lib/async.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/async.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defer = __webpack_require__(/*! ./defer.js */ "./node_modules/asynckit/lib/defer.js");

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),

/***/ "./node_modules/asynckit/lib/defer.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/defer.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),

/***/ "./node_modules/asynckit/lib/iterate.js":
/*!**********************************************!*\
  !*** ./node_modules/asynckit/lib/iterate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(/*! ./async.js */ "./node_modules/asynckit/lib/async.js")
  , abort = __webpack_require__(/*! ./abort.js */ "./node_modules/asynckit/lib/abort.js")
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),

/***/ "./node_modules/asynckit/lib/state.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/state.js ***!
  \********************************************/
/***/ ((module) => {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),

/***/ "./node_modules/asynckit/lib/terminator.js":
/*!*************************************************!*\
  !*** ./node_modules/asynckit/lib/terminator.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var abort = __webpack_require__(/*! ./abort.js */ "./node_modules/asynckit/lib/abort.js")
  , async = __webpack_require__(/*! ./async.js */ "./node_modules/asynckit/lib/async.js")
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),

/***/ "./node_modules/asynckit/parallel.js":
/*!*******************************************!*\
  !*** ./node_modules/asynckit/parallel.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(/*! ./lib/iterate.js */ "./node_modules/asynckit/lib/iterate.js")
  , initState  = __webpack_require__(/*! ./lib/state.js */ "./node_modules/asynckit/lib/state.js")
  , terminator = __webpack_require__(/*! ./lib/terminator.js */ "./node_modules/asynckit/lib/terminator.js")
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),

/***/ "./node_modules/asynckit/serial.js":
/*!*****************************************!*\
  !*** ./node_modules/asynckit/serial.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var serialOrdered = __webpack_require__(/*! ./serialOrdered.js */ "./node_modules/asynckit/serialOrdered.js");

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),

/***/ "./node_modules/asynckit/serialOrdered.js":
/*!************************************************!*\
  !*** ./node_modules/asynckit/serialOrdered.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(/*! ./lib/iterate.js */ "./node_modules/asynckit/lib/iterate.js")
  , initState  = __webpack_require__(/*! ./lib/state.js */ "./node_modules/asynckit/lib/state.js")
  , terminator = __webpack_require__(/*! ./lib/terminator.js */ "./node_modules/asynckit/lib/terminator.js")
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),

/***/ "./node_modules/axios/lib/adapters/adapters.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/adapters/adapters.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./http.js */ "./node_modules/axios/lib/adapters/http.js");
/* harmony import */ var _xhr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xhr.js */ "./node_modules/axios/lib/adapters/xhr.js");
/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetch.js */ "./node_modules/axios/lib/adapters/fetch.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");






const knownAdapters = {
  http: _http_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  xhr: _xhr_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  fetch: _fetch_js__WEBPACK_IMPORTED_MODULE_2__["default"]
}

_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(adapter) || adapter === null || adapter === false;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  getAdapter: (adapters) => {
    adapters = _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__["default"](`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__["default"](
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
});


/***/ }),

/***/ "./node_modules/axios/lib/adapters/fetch.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/adapters/fetch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/composeSignals.js */ "./node_modules/axios/lib/helpers/composeSignals.js");
/* harmony import */ var _helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/trackStream.js */ "./node_modules/axios/lib/helpers/trackStream.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ "./node_modules/axios/lib/helpers/progressEventReducer.js");
/* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/resolveConfig.js */ "./node_modules/axios/lib/helpers/resolveConfig.js");
/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/settle.js */ "./node_modules/axios/lib/core/settle.js");










const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
}

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"](`Response type '${type}' is not supported`, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NOT_SUPPORT, config);
      })
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isBlob(body)) {
    return body.size;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isSpecCompliantForm(body)) {
    const _request = new Request(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArrayBufferView(body) || _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isURLSearchParams(body)) {
    body = body + '';
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(body)) {
    return (await encodeText(body)).byteLength;
  }
}

const resolveBodyLength = async (headers, body) => {
  const length = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = (0,_helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_3__["default"])(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = (0,_helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_4__["default"])([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader)
      }

      if (_request.body) {
        const [onProgress, flush] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventDecorator)(
          requestContentLength,
          (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.asyncDecorator)(onUploadProgress))
        );

        data = (0,_helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__.trackStream)(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventDecorator)(
        responseContentLength,
        (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.asyncDecorator)(onDownloadProgress), true)
      ) || [];

      response = new Response(
        (0,_helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__.trackStream)(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_7__["default"])(resolve, reject, {
        data: responseData,
        headers: _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_8__["default"].from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      })
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Network Error', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].from(err, err && err.code, config, request);
  }
}));




/***/ }),

/***/ "./node_modules/axios/lib/adapters/http.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/adapters/http.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __setProxy: () => (/* binding */ __setProxy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./../core/settle.js */ "./node_modules/axios/lib/core/settle.js");
/* harmony import */ var _core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../core/buildFullPath.js */ "./node_modules/axios/lib/core/buildFullPath.js");
/* harmony import */ var _helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./../helpers/buildURL.js */ "./node_modules/axios/lib/helpers/buildURL.js");
/* harmony import */ var proxy_from_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! proxy-from-env */ "./node_modules/proxy-from-env/index.js");
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ "http");
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! https */ "https");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var follow_redirects__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! follow-redirects */ "./node_modules/follow-redirects/index.js");
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zlib */ "zlib");
/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../env/data.js */ "./node_modules/axios/lib/env/data.js");
/* harmony import */ var _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../defaults/transitional.js */ "./node_modules/axios/lib/defaults/transitional.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _helpers_fromDataURI_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../helpers/fromDataURI.js */ "./node_modules/axios/lib/helpers/fromDataURI.js");
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _helpers_AxiosTransformStream_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../helpers/AxiosTransformStream.js */ "./node_modules/axios/lib/helpers/AxiosTransformStream.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! events */ "events");
/* harmony import */ var _helpers_formDataToStream_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../helpers/formDataToStream.js */ "./node_modules/axios/lib/helpers/formDataToStream.js");
/* harmony import */ var _helpers_readBlob_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../helpers/readBlob.js */ "./node_modules/axios/lib/helpers/readBlob.js");
/* harmony import */ var _helpers_ZlibHeaderTransformStream_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../helpers/ZlibHeaderTransformStream.js */ "./node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js");
/* harmony import */ var _helpers_callbackify_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../helpers/callbackify.js */ "./node_modules/axios/lib/helpers/callbackify.js");
/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ "./node_modules/axios/lib/helpers/progressEventReducer.js");




























const zlibOptions = {
  flush: zlib__WEBPACK_IMPORTED_MODULE_5__.constants.Z_SYNC_FLUSH,
  finishFlush: zlib__WEBPACK_IMPORTED_MODULE_5__.constants.Z_SYNC_FLUSH
};

const brotliOptions = {
  flush: zlib__WEBPACK_IMPORTED_MODULE_5__.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib__WEBPACK_IMPORTED_MODULE_5__.constants.BROTLI_OPERATION_FLUSH
}

const isBrotliSupported = _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isFunction(zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress);

const {http: httpFollow, https: httpsFollow} = follow_redirects__WEBPACK_IMPORTED_MODULE_4__;

const isHttps = /https:?/;

const supportedProtocols = _platform_index_js__WEBPACK_IMPORTED_MODULE_9__["default"].protocols.map(protocol => {
  return protocol + ':';
});

const flushOnFinish = (stream, [throttled, flush]) => {
  stream
    .on('end', flush)
    .on('error', flush);

  return throttled;
}

/**
 * If the proxy or config beforeRedirects functions are defined, call them with the options
 * object.
 *
 * @param {Object<string, any>} options - The options object that was passed to the request.
 *
 * @returns {Object<string, any>}
 */
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}

/**
 * If the proxy or config afterRedirects functions are defined, call them with the options
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
 * @param {string} location
 *
 * @returns {http.ClientRequestArgs}
 */
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxy_from_env__WEBPACK_IMPORTED_MODULE_0__.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    // Basic proxy authorization
    if (proxy.username) {
      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
    }

    if (proxy.auth) {
      // Support proxy auth object form
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
      }
      const base64 = Buffer
        .from(proxy.auth, 'utf8')
        .toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }

    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    // Replace 'host' since options is not a URL object
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;
    }
  }

  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    // Configure proxy for redirected request, passing the original config proxy to apply
    // the exact same logic as if the redirected request was performed by axios directly.
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}

const isHttpAdapterSupported = typeof process !== 'undefined' && _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].kindOf(process) === 'process';

// temporary hotfix

const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;

    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    }

    const _resolve = (value) => {
      done(value);
      resolve(value);
    };

    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    }

    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);
  })
};

const resolveFamily = ({address, family}) => {
  if (!_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isString(address)) {
    throw TypeError('address must be a string');
  }
  return ({
    address,
    family: family || (address.indexOf('.') < 0 ? 6 : 4)
  });
}

const buildAddressEntry = (address, family) => resolveFamily(_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isObject(address) ? address : {address, family});

/*eslint consistent-return:0*/
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let {data, lookup, family} = config;
    const {responseType, responseEncoding} = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;

    if (lookup) {
      const _lookup = (0,_helpers_callbackify_js__WEBPACK_IMPORTED_MODULE_10__["default"])(lookup, (value) => _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isArray(value) ? value : [value]);
      // hotfix to support opt.all option which is required for node 20.x
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }

          const addresses = _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];

          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      }
    }

    // temporary internal emitter until the AxiosRequest class will be implemented
    const emitter = new events__WEBPACK_IMPORTED_MODULE_7__.EventEmitter();

    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', abort);
      }

      emitter.removeAllListeners();
    }

    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });

    function abort(reason) {
      emitter.emit('abort', !reason || reason.type ? new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_11__["default"](null, config, req) : reason);
    }

    emitter.once('abort', reject);

    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
      }
    }

    // Parse url
    const fullPath = (0,_core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_12__["default"])(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, _platform_index_js__WEBPACK_IMPORTED_MODULE_9__["default"].hasBrowserEnv ? _platform_index_js__WEBPACK_IMPORTED_MODULE_9__["default"].origin : undefined);
    const protocol = parsed.protocol || supportedProtocols[0];

    if (protocol === 'data:') {
      let convertedData;

      if (method !== 'GET') {
        return (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_13__["default"])(resolve, reject, {
          status: 405,
          statusText: 'method not allowed',
          headers: {},
          config
        });
      }

      try {
        convertedData = (0,_helpers_fromDataURI_js__WEBPACK_IMPORTED_MODULE_14__["default"])(config.url, responseType === 'blob', {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].from(err, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_REQUEST, config);
      }

      if (responseType === 'text') {
        convertedData = convertedData.toString(responseEncoding);

        if (!responseEncoding || responseEncoding === 'utf8') {
          convertedData = _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].stripBOM(convertedData);
        }
      } else if (responseType === 'stream') {
        convertedData = stream__WEBPACK_IMPORTED_MODULE_6__.Readable.from(convertedData);
      }

      return (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_13__["default"])(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: 'OK',
        headers: new _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_16__["default"](),
        config
      });
    }

    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
        'Unsupported protocol ' + protocol,
        _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_REQUEST,
        config
      ));
    }

    const headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_16__["default"].from(config.headers).normalize();

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    // User-Agent is specified; handle case where no UA header is desired
    // Only set header if it hasn't been set in config
    headers.set('User-Agent', 'axios/' + _env_data_js__WEBPACK_IMPORTED_MODULE_17__.VERSION, false);

    const {onUploadProgress, onDownloadProgress} = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;

    // support for spec compliant FormData objects
    if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);

      data = (0,_helpers_formDataToStream_js__WEBPACK_IMPORTED_MODULE_18__["default"])(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${_env_data_js__WEBPACK_IMPORTED_MODULE_17__.VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
      // support for https://www.npmjs.com/package/form-data api
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isFormData(data) && _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());

      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util__WEBPACK_IMPORTED_MODULE_3__.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          /*eslint no-empty:0*/
        } catch (e) {
        }
      }
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isBlob(data) || _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isFile(data)) {
      data.size && headers.setContentType(data.type || 'application/octet-stream');
      headers.setContentLength(data.size || 0);
      data = stream__WEBPACK_IMPORTED_MODULE_6__.Readable.from((0,_helpers_readBlob_js__WEBPACK_IMPORTED_MODULE_19__["default"])(data));
    } else if (data && !_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isStream(data)) {
      if (Buffer.isBuffer(data)) {
        // Nothing to do...
      } else if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_REQUEST,
          config
        ));
      }

      // Add Content-Length header if data exists
      headers.setContentLength(data.length, false);

      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
          'Request body larger than maxBodyLength limit',
          _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_REQUEST,
          config
        ));
      }
    }

    const contentLength = _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].toFiniteNumber(headers.getContentLength());

    if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }

    if (data && (onUploadProgress || maxUploadRate)) {
      if (!_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isStream(data)) {
        data = stream__WEBPACK_IMPORTED_MODULE_6__.Readable.from(data, {objectMode: false});
      }

      data = stream__WEBPACK_IMPORTED_MODULE_6__.pipeline([data, new _helpers_AxiosTransformStream_js__WEBPACK_IMPORTED_MODULE_20__["default"]({
        maxRate: _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].toFiniteNumber(maxUploadRate)
      })], _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].noop);

      onUploadProgress && data.on('progress', flushOnFinish(
        data,
        (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.progressEventDecorator)(
          contentLength,
          (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.asyncDecorator)(onUploadProgress), false, 3)
        )
      ));
    }

    // HTTP basic authentication
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password || '';
      auth = username + ':' + password;
    }

    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ':' + urlPassword;
    }

    auth && headers.delete('authorization');

    let path;

    try {
      path = (0,_helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_22__["default"])(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, '');
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }

    headers.set(
      'Accept-Encoding',
      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false
      );

    const options = {
      path,
      method: method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };

    // cacheable-lookup integration hotfix
    !_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isUndefined(lookup) && (options.lookup = lookup);

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https__WEBPACK_IMPORTED_MODULE_2__ : http__WEBPACK_IMPORTED_MODULE_1__;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
      options.maxBodyLength = Infinity;
    }

    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }

    // Create the request
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;

      const streams = [res];

      const responseLength = +res.headers['content-length'];

      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new _helpers_AxiosTransformStream_js__WEBPACK_IMPORTED_MODULE_20__["default"]({
          maxRate: _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].toFiniteNumber(maxDownloadRate)
        });

        onDownloadProgress && transformStream.on('progress', flushOnFinish(
          transformStream,
          (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.progressEventDecorator)(
            responseLength,
            (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.asyncDecorator)(onDownloadProgress), true, 3)
          )
        ));

        streams.push(transformStream);
      }

      // decompress the response body transparently if required
      let responseStream = res;

      // return the last request in case of redirects
      const lastRequest = res.req || req;

      // if decompress disabled we should not decompress
      if (config.decompress !== false && res.headers['content-encoding']) {
        // if no content, but headers still say that it is encoded,
        // remove the header not confuse downstream operations
        if (method === 'HEAD' || res.statusCode === 204) {
          delete res.headers['content-encoding'];
        }

        switch ((res.headers['content-encoding'] || '').toLowerCase()) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'x-gzip':
        case 'compress':
        case 'x-compress':
          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__WEBPACK_IMPORTED_MODULE_5__.createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'deflate':
          streams.push(new _helpers_ZlibHeaderTransformStream_js__WEBPACK_IMPORTED_MODULE_23__["default"]());

          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__WEBPACK_IMPORTED_MODULE_5__.createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'br':
          if (isBrotliSupported) {
            streams.push(zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress(brotliOptions));
            delete res.headers['content-encoding'];
          }
        }
      }

      responseStream = streams.length > 1 ? stream__WEBPACK_IMPORTED_MODULE_6__.pipeline(streams, _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].noop) : streams[0];

      const offListeners = stream__WEBPACK_IMPORTED_MODULE_6__.finished(responseStream, () => {
        offListeners();
        onFinished();
      });

      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_16__["default"](res.headers),
        config,
        request: lastRequest
      };

      if (responseType === 'stream') {
        response.data = responseStream;
        (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_13__["default"])(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;

        responseStream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destroy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            responseStream.destroy();
            reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"]('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_RESPONSE, config, lastRequest));
          }
        });

        responseStream.on('aborted', function handlerStreamAborted() {
          if (rejected) {
            return;
          }

          const err = new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
            'stream has been aborted',
            _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });

        responseStream.on('error', function handleStreamError(err) {
          if (req.destroyed) return;
          reject(_core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].from(err, null, config, lastRequest));
        });

        responseStream.on('end', function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== 'arraybuffer') {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === 'utf8') {
                responseData = _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(_core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].from(err, null, config, response.request, response));
          }
          (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_13__["default"])(resolve, reject, response);
        });
      }

      emitter.once('abort', err => {
        if (!responseStream.destroyed) {
          responseStream.emit('error', err);
          responseStream.destroy();
        }
      });
    });

    emitter.once('abort', err => {
      reject(err);
      req.destroy(err);
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      // @todo remove
      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
      reject(_core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].from(err, null, config, req));
    });

    // set tcp keep alive to prevent drop connection by peer
    req.on('socket', function handleRequestSocket(socket) {
      // default interval of sending ack packet is 1 minute
      socket.setKeepAlive(true, 1000 * 60);
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      const timeout = parseInt(config.timeout, 10);

      if (Number.isNaN(timeout)) {
        reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
          'error trying to parse `config.timeout` to int',
          _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_OPTION_VALUE,
          config,
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devouring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_24__["default"];
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ETIMEDOUT : _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }


    // Send the request
    if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isStream(data)) {
      let ended = false;
      let errored = false;

      data.on('end', () => {
        ended = true;
      });

      data.once('error', err => {
        errored = true;
        req.destroy(err);
      });

      data.on('close', () => {
        if (!ended && !errored) {
          abort(new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_11__["default"]('Request stream has been aborted', config, req));
        }
      });

      data.pipe(req);
    } else {
      req.end(data);
    }
  });
});

const __setProxy = setProxy;


/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../core/settle.js */ "./node_modules/axios/lib/core/settle.js");
/* harmony import */ var _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defaults/transitional.js */ "./node_modules/axios/lib/defaults/transitional.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/parseProtocol.js */ "./node_modules/axios/lib/helpers/parseProtocol.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ "./node_modules/axios/lib/helpers/progressEventReducer.js");
/* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/resolveConfig.js */ "./node_modules/axios/lib/helpers/resolveConfig.js");











const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = (0,_helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_0__["default"])(config);
    let requestData = _config.data;
    const requestHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Request aborted', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Network Error', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_4__["default"];
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"](
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ETIMEDOUT : _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      _utils_js__WEBPACK_IMPORTED_MODULE_5__["default"].forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"].isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_7__["default"](null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = (0,_helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_8__["default"])(_config.url);

    if (protocol && _platform_index_js__WEBPACK_IMPORTED_MODULE_9__["default"].protocols.indexOf(protocol) === -1) {
      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Unsupported protocol ' + protocol + ':', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
});


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/bind.js */ "./node_modules/axios/lib/helpers/bind.js");
/* harmony import */ var _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Axios.js */ "./node_modules/axios/lib/core/Axios.js");
/* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./helpers/formDataToJSON.js */ "./node_modules/axios/lib/helpers/formDataToJSON.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cancel/CancelToken.js */ "./node_modules/axios/lib/cancel/CancelToken.js");
/* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cancel/isCancel.js */ "./node_modules/axios/lib/cancel/isCancel.js");
/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./env/data.js */ "./node_modules/axios/lib/env/data.js");
/* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./helpers/toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _helpers_spread_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./helpers/spread.js */ "./node_modules/axios/lib/helpers/spread.js");
/* harmony import */ var _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./helpers/isAxiosError.js */ "./node_modules/axios/lib/helpers/isAxiosError.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./adapters/adapters.js */ "./node_modules/axios/lib/adapters/adapters.js");
/* harmony import */ var _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./helpers/HttpStatusCode.js */ "./node_modules/axios/lib/helpers/HttpStatusCode.js");




















/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"](defaultConfig);
  const instance = (0,_helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.request, context);

  // Copy axios.prototype to instance
  _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(instance, _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype, context, {allOwnKeys: true});

  // Copy context to instance
  _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance((0,_core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__["default"])(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(_defaults_index_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

// Expose Axios class to allow class inheritance
axios.Axios = _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"];

// Expose Cancel & CancelToken
axios.CanceledError = _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_5__["default"];
axios.CancelToken = _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_6__["default"];
axios.isCancel = _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_7__["default"];
axios.VERSION = _env_data_js__WEBPACK_IMPORTED_MODULE_8__.VERSION;
axios.toFormData = _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_9__["default"];

// Expose AxiosError class
axios.AxiosError = _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_10__["default"];

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = _helpers_spread_js__WEBPACK_IMPORTED_MODULE_11__["default"];

// Expose isAxiosError
axios.isAxiosError = _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_12__["default"];

// Expose mergeConfig
axios.mergeConfig = _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__["default"];

axios.AxiosHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_13__["default"];

axios.formToJSON = thing => (0,_helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_14__["default"])(_utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__["default"].getAdapter;

axios.HttpStatusCode = _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__["default"];

axios.default = axios;

// this module should only have a default export
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axios);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");




/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__["default"](message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CancelToken);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CanceledError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CanceledError.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");





/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].call(this, message == null ? 'canceled' : message, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].inherits(CanceledError, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"], {
  __CANCEL__: true
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanceledError);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isCancel)
/* harmony export */ });


function isCancel(value) {
  return !!(value && value.__CANCEL__);
}


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/buildURL.js */ "./node_modules/axios/lib/helpers/buildURL.js");
/* harmony import */ var _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InterceptorManager.js */ "./node_modules/axios/lib/core/InterceptorManager.js");
/* harmony import */ var _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dispatchRequest.js */ "./node_modules/axios/lib/core/dispatchRequest.js");
/* harmony import */ var _mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _buildFullPath_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./buildFullPath.js */ "./node_modules/axios/lib/core/buildFullPath.js");
/* harmony import */ var _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/validator.js */ "./node_modules/axios/lib/helpers/validator.js");
/* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");











const validators = _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__["default"](),
      response: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__["default"]()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};

        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = (0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        }
      } else {
        _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) {
      // do nothing
    } else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }

    _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].assertOptions(config, {
      baseUrl: validators.spelling('baseURL'),
      withXsrfToken: validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].merge(
      headers.common,
      headers[config.method]
    );

    headers && _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__["default"].concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [_dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__["default"].bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = (0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this.defaults, config);
    const fullPath = (0,_buildFullPath_js__WEBPACK_IMPORTED_MODULE_6__["default"])(config.baseURL, config.url, config.allowAbsoluteUrls);
    return (0,_helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_7__["default"])(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request((0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request((0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Axios);


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosError.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosError.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);

  _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosError);


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosHeaders.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosHeaders.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/parseHeaders.js */ "./node_modules/axios/lib/helpers/parseHeaders.js");





const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(value)) return;

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders((0,_helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"])(header), valueOrRewrite);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(header) && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(entry)) {
          throw TypeError('Object iterator must return a key-value pair');
        }

        obj[key = entry[0]] = (dest = obj[key]) ?
          (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
      }

      setHeaders(obj, valueOrRewrite)
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this, (value, header) => {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  getSetCookie() {
    return this.get("set-cookie") || [];
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].freezeMethods(AxiosHeaders);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosHeaders);


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InterceptorManager);


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildFullPath)
/* harmony export */ });
/* harmony import */ var _helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/isAbsoluteURL.js */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
/* harmony import */ var _helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/combineURLs.js */ "./node_modules/axios/lib/helpers/combineURLs.js");





/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !(0,_helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__["default"])(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return (0,_helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__["default"])(baseURL, requestedURL);
  }
  return requestedURL;
}


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dispatchRequest)
/* harmony export */ });
/* harmony import */ var _transformData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transformData.js */ "./node_modules/axios/lib/core/transformData.js");
/* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cancel/isCancel.js */ "./node_modules/axios/lib/cancel/isCancel.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../adapters/adapters.js */ "./node_modules/axios/lib/adapters/adapters.js");









/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__["default"](null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(config.headers);

  // Transform request data
  config.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_3__["default"].getAdapter(config.adapter || _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(
      config,
      config.transformResponse,
      response
    );

    response.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!(0,_cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_5__["default"])(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeConfig)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");





const headersToObject = (thing) => thing instanceof _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, prop, caseless) {
    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isPlainObject(target) && _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isPlainObject(source)) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].merge.call({caseless}, target, source);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isPlainObject(source)) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].merge({}, source);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop , caseless) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(b)) {
      return getMergedValue(a, b, prop , caseless);
    } else if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(a)) {
      return getMergedValue(undefined, a, prop , caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
  };

  _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ settle)
/* harmony export */ });
/* harmony import */ var _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");




/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"](
      'Request failed with status code ' + response.status,
      [_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_BAD_REQUEST, _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transformData)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");






/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || _defaults_index_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  const context = response || config;
  const headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(context.headers);
  let data = context.data;

  _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}


/***/ }),

/***/ "./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _transitional_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transitional.js */ "./node_modules/axios/lib/defaults/transitional.js");
/* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/toURLEncodedForm.js */ "./node_modules/axios/lib/helpers/toURLEncodedForm.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/formDataToJSON.js */ "./node_modules/axios/lib/helpers/formDataToJSON.js");










/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: _transitional_js__WEBPACK_IMPORTED_MODULE_1__["default"],

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(data);

    if (isObjectPayload && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify((0,_helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_2__["default"])(data)) : data;
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBuffer(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBuffer(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isStream(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFile(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBlob(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isReadableStream(data)
    ) {
      return data;
    }
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBufferView(data)) {
      return data.buffer;
    }
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return (0,_helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_3__["default"])(data, this.formSerializer).toString();
      }

      if ((isFileList = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return (0,_helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_4__["default"])(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isResponse(data) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isReadableStream(data)) {
      return data;
    }

    if (data && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__["default"].from(e, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__["default"].ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: _platform_index_js__WEBPACK_IMPORTED_MODULE_6__["default"].classes.FormData,
    Blob: _platform_index_js__WEBPACK_IMPORTED_MODULE_6__["default"].classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaults);


/***/ }),

/***/ "./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
});


/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
const VERSION = "1.9.0";

/***/ }),

/***/ "./node_modules/axios/lib/helpers/AxiosTransformStream.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/AxiosTransformStream.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");





const kInternals = Symbol('internals');

class AxiosTransformStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform{
  constructor(options) {
    options = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(source[prop]);
    });

    super({
      readableHighWaterMark: options.chunkSize
    });

    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };

    this.on('newListener', event => {
      if (event === 'progress') {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }

  _read(size) {
    const internals = this[kInternals];

    if (internals.onReadCallback) {
      internals.onReadCallback();
    }

    return super._read(size);
  }

  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;

    const readableHighWaterMark = this.readableHighWaterMark;

    const timeWindow = internals.timeWindow;

    const divider = 1000 / timeWindow;
    const bytesThreshold = (maxRate / divider);
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;

    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;

      internals.isCaptured && this.emit('progress', internals.bytesSeen);

      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    }

    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;

      if (maxRate) {
        const now = Date.now();

        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }

        bytesLeft = bytesThreshold - internals.bytes;
      }

      if (maxRate) {
        if (bytesLeft <= 0) {
          // next time window
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }

        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }

      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }

      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };

    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }

      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosTransformStream);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/AxiosURLSearchParams.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");




/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && (0,_toFormData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosURLSearchParams);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/HttpStatusCode.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/HttpStatusCode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HttpStatusCode);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js":
/*!*********************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ "stream");




class ZlibHeaderTransformStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }

  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;

      // Add Default Compression headers if no zlib headers are present
      if (chunk[0] !== 120) { // Hex: 78
        const header = Buffer.alloc(2);
        header[0] = 120; // Hex: 78
        header[1] = 156; // Hex: 9C 
        this.push(header, encoding);
      }
    }

    this.__transform(chunk, encoding, callback);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ZlibHeaderTransformStream);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bind)
/* harmony export */ });


function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildURL)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/AxiosURLSearchParams.js */ "./node_modules/axios/lib/helpers/AxiosURLSearchParams.js");





/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(options)) {
    options = {
      serialize: options
    };
  } 

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isURLSearchParams(params) ?
      params.toString() :
      new _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__["default"](params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/callbackify.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/callbackify.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");


const callbackify = (fn, reducer) => {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isAsyncFn(fn) ? function (...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (callbackify);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ combineURLs)
/* harmony export */ });


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/composeSignals.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/composeSignals.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? err : new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_1__["default"](err instanceof Error ? err.message : err));
      }
    }

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"](`timeout ${timeout} of ms exceeded`, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ETIMEDOUT))
    }, timeout)

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    }

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].asap(unsubscribe);

    return signal;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (composeSignals);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(path) && cookie.push('path=' + path);

      _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  });



/***/ }),

/***/ "./node_modules/axios/lib/helpers/formDataToJSON.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/formDataToJSON.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(target) ? target.length : name;

    if (isLast) {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFormData(formData) && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(formData.entries)) {
    const obj = {};

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formDataToJSON);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/formDataToStream.js":
/*!************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/formDataToStream.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _readBlob_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./readBlob.js */ "./node_modules/axios/lib/helpers/readBlob.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");






const BOUNDARY_ALPHABET = _platform_index_js__WEBPACK_IMPORTED_MODULE_2__["default"].ALPHABET.ALPHA_DIGIT + '-_';

const textEncoder = typeof TextEncoder === 'function' ? new TextEncoder() : new util__WEBPACK_IMPORTED_MODULE_0__.TextEncoder();

const CRLF = '\r\n';
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const {escapeName} = this.constructor;
    const isStringValue = _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isString(value);

    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${
      !isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''
    }${CRLF}`;

    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`
    }

    this.headers = textEncoder.encode(headers + CRLF);

    this.contentLength = isStringValue ? value.byteLength : value.size;

    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;

    this.name = name;
    this.value = value;
  }

  async *encode(){
    yield this.headers;

    const {value} = this;

    if(_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isTypedArray(value)) {
      yield value;
    } else {
      yield* (0,_readBlob_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value);
    }

    yield CRLF_BYTES;
  }

  static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        '\r' : '%0D',
        '\n' : '%0A',
        '"' : '%22',
      }[match]));
  }
}

const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = 'form-data-boundary',
    size = 25,
    boundary = tag + '-' + _platform_index_js__WEBPACK_IMPORTED_MODULE_2__["default"].generateString(size, BOUNDARY_ALPHABET)
  } = options || {};

  if(!_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isFormData(form)) {
    throw TypeError('FormData instance required');
  }

  if (boundary.length < 1 || boundary.length > 70) {
    throw Error('boundary must be 10-70 characters long')
  }

  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);
  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF);
  let contentLength = footerBytes.byteLength;

  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });

  contentLength += boundaryBytes.byteLength * parts.length;

  contentLength = _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].toFiniteNumber(contentLength);

  const computedHeaders = {
    'Content-Type': `multipart/form-data; boundary=${boundary}`
  }

  if (Number.isFinite(contentLength)) {
    computedHeaders['Content-Length'] = contentLength;
  }

  headersHandler && headersHandler(computedHeaders);

  return stream__WEBPACK_IMPORTED_MODULE_1__.Readable.from((async function *() {
    for(const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }

    yield footerBytes;
  })());
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formDataToStream);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/fromDataURI.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/fromDataURI.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fromDataURI)
/* harmony export */ });
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _parseProtocol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parseProtocol.js */ "./node_modules/axios/lib/helpers/parseProtocol.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");






const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

/**
 * Parse data uri to a Buffer or Blob
 *
 * @param {String} uri
 * @param {?Boolean} asBlob
 * @param {?Object} options
 * @param {?Function} options.Blob
 *
 * @returns {Buffer|Blob}
 */
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || _platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].classes.Blob;
  const protocol = (0,_parseProtocol_js__WEBPACK_IMPORTED_MODULE_1__["default"])(uri);

  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }

  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;

    const match = DATA_URL_PATTERN.exec(uri);

    if (!match) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Invalid URL', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_INVALID_URL);
    }

    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');

    if (asBlob) {
      if (!_Blob) {
        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Blob is not supported', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NOT_SUPPORT);
      }

      return new _Blob([buffer], {type: mime});
    }

    return buffer;
  }

  throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Unsupported protocol ' + protocol, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NOT_SUPPORT);
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAbsoluteURL)
/* harmony export */ });


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAxiosError)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(payload) && (payload.isAxiosError === true);
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
  url = new URL(url, _platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin);

  return (
    origin.protocol === url.protocol &&
    origin.host === url.host &&
    (isMSIE || origin.port === url.port)
  );
})(
  new URL(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin),
  _platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].navigator && /(msie|trident)/i.test(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].navigator.userAgent)
) : () => true);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
});


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseProtocol.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseProtocol)
/* harmony export */ });


function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/progressEventReducer.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/progressEventReducer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asyncDecorator: () => (/* binding */ asyncDecorator),
/* harmony export */   progressEventDecorator: () => (/* binding */ progressEventDecorator),
/* harmony export */   progressEventReducer: () => (/* binding */ progressEventReducer)
/* harmony export */ });
/* harmony import */ var _speedometer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedometer.js */ "./node_modules/axios/lib/helpers/speedometer.js");
/* harmony import */ var _throttle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./throttle.js */ "./node_modules/axios/lib/helpers/throttle.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = (0,_speedometer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(50, 250);

  return (0,_throttle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
}

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
}

const asyncDecorator = (fn) => (...args) => _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].asap(() => fn(...args));


/***/ }),

/***/ "./node_modules/axios/lib/helpers/readBlob.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/readBlob.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const {asyncIterator} = Symbol;

const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream()
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer()
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (readBlob);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/resolveConfig.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/resolveConfig.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isURLSameOrigin.js */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
/* harmony import */ var _cookies_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cookies.js */ "./node_modules/axios/lib/helpers/cookies.js");
/* harmony import */ var _core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/buildFullPath.js */ "./node_modules/axios/lib/core/buildFullPath.js");
/* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _buildURL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buildURL.js */ "./node_modules/axios/lib/helpers/buildURL.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((config) => {
  const newConfig = (0,_core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_0__["default"])({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(headers);

  newConfig.url = (0,_buildURL_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_3__["default"])(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (_utils_js__WEBPACK_IMPORTED_MODULE_4__["default"].isFormData(data)) {
    if (_platform_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].hasStandardBrowserEnv || _platform_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (_platform_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].hasStandardBrowserEnv) {
    withXSRFToken && _utils_js__WEBPACK_IMPORTED_MODULE_4__["default"].isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && (0,_isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_6__["default"])(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && _cookies_js__WEBPACK_IMPORTED_MODULE_7__["default"].read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
});



/***/ }),

/***/ "./node_modules/axios/lib/helpers/speedometer.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/speedometer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (speedometer);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ spread)
/* harmony export */ });


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/throttle.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/throttle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  }

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs)
        }, threshold - passed);
      }
    }
  }

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (throttle);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toFormData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toFormData.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/node/classes/FormData.js */ "./node_modules/axios/lib/platform/node/classes/FormData.js");




// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored


/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isPlainObject(thing) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(arr) && !arr.some(isVisitable);
}

const predicates = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"], {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (_platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__["default"] || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isSpecCompliantForm(formData);

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBlob(value)) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Blob is not supported. Use a Buffer instead.');
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBuffer(value) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) && isFlatArray(value)) ||
        ((_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFileList(value) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '[]')) && (arr = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(value, function each(el, key) {
      const result = !(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(el) || el === null) && visitor.call(
        formData, el, _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toFormData);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toURLEncodedForm.js":
/*!************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toURLEncodedForm.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toURLEncodedForm)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");






function toURLEncodedForm(data, options) {
  return (0,_toFormData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, new _platform_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (_platform_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].isNode && _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/trackStream.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/trackStream.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readBytes: () => (/* binding */ readBytes),
/* harmony export */   streamChunk: () => (/* binding */ streamChunk),
/* harmony export */   trackStream: () => (/* binding */ trackStream)
/* harmony export */ });

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
}

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
}

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
}

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  }

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env/data.js */ "./node_modules/axios/lib/env/data.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");





const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + _env_data_js__WEBPACK_IMPORTED_MODULE_0__.VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"](
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  }
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('options must be an object', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('option ' + opt + ' must be ' + result, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('Unknown option ' + opt, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION);
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  assertOptions,
  validators
});


/***/ }),

/***/ "./node_modules/axios/lib/platform/common/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/platform/common/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasBrowserEnv: () => (/* binding */ hasBrowserEnv),
/* harmony export */   hasStandardBrowserEnv: () => (/* binding */ hasStandardBrowserEnv),
/* harmony export */   hasStandardBrowserWebWorkerEnv: () => (/* binding */ hasStandardBrowserWebWorkerEnv),
/* harmony export */   navigator: () => (/* binding */ _navigator),
/* harmony export */   origin: () => (/* binding */ origin)
/* harmony export */ });
const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';




/***/ }),

/***/ "./node_modules/axios/lib/platform/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/platform/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node/index.js */ "./node_modules/axios/lib/platform/node/index.js");
/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/utils.js */ "./node_modules/axios/lib/platform/common/utils.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  ..._common_utils_js__WEBPACK_IMPORTED_MODULE_0__,
  ..._node_index_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});


/***/ }),

/***/ "./node_modules/axios/lib/platform/node/classes/FormData.js":
/*!******************************************************************!*\
  !*** ./node_modules/axios/lib/platform/node/classes/FormData.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! form-data */ "./node_modules/form-data/lib/form_data.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (form_data__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./node_modules/axios/lib/platform/node/classes/URLSearchParams.js":
/*!*************************************************************************!*\
  !*** ./node_modules/axios/lib/platform/node/classes/URLSearchParams.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "url");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (url__WEBPACK_IMPORTED_MODULE_0__.URLSearchParams);


/***/ }),

/***/ "./node_modules/axios/lib/platform/node/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/platform/node/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");
/* harmony import */ var _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/URLSearchParams.js */ "./node_modules/axios/lib/platform/node/classes/URLSearchParams.js");
/* harmony import */ var _classes_FormData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/FormData.js */ "./node_modules/axios/lib/platform/node/classes/FormData.js");




const ALPHA = 'abcdefghijklmnopqrstuvwxyz'

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  const randomValues = new Uint32Array(size);
  crypto__WEBPACK_IMPORTED_MODULE_0__.randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }

  return str;
}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  isNode: true,
  classes: {
    URLSearchParams: _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__["default"],
    FormData: _classes_FormData_js__WEBPACK_IMPORTED_MODULE_2__["default"],
    Blob: typeof Blob !== 'undefined' && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: [ 'http', 'https', 'file', 'data' ]
});


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/bind.js */ "./node_modules/axios/lib/helpers/bind.js");




// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;
const {iterator, toStringTag} = Symbol;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
}

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = (0,_helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__["default"])(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];

  const _iterator = generator.call(obj);

  let result;

  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  }

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
}

const noop = () => {}

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
}

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  }

  return visit(obj, 0);
}

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************


const isIterable = (thing) => thing != null && isFunction(thing[iterator]);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
});


/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/actualApply.js":
/*!*************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/actualApply.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

var $apply = __webpack_require__(/*! ./functionApply */ "./node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__(/*! ./functionCall */ "./node_modules/call-bind-apply-helpers/functionCall.js");
var $reflectApply = __webpack_require__(/*! ./reflectApply */ "./node_modules/call-bind-apply-helpers/reflectApply.js");

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/functionApply.js":
/*!***************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/functionApply.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/functionCall.js":
/*!**************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/functionCall.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");

var $call = __webpack_require__(/*! ./functionCall */ "./node_modules/call-bind-apply-helpers/functionCall.js");
var $actualApply = __webpack_require__(/*! ./actualApply */ "./node_modules/call-bind-apply-helpers/actualApply.js");

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/reflectApply.js":
/*!**************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/reflectApply.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),

/***/ "./node_modules/combined-stream/lib/combined_stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/combined-stream/lib/combined_stream.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! util */ "util");
var Stream = (__webpack_require__(/*! stream */ "stream").Stream);
var DelayedStream = __webpack_require__(/*! delayed-stream */ "./node_modules/delayed-stream/lib/delayed_stream.js");

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	// eslint-disable-next-line no-return-assign
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		const split = (typeof namespaces === 'string' ? namespaces : '')
			.trim()
			.replace(' ', ',')
			.split(',')
			.filter(Boolean);

		for (const ns of split) {
			if (ns[0] === '-') {
				createDebug.skips.push(ns.slice(1));
			} else {
				createDebug.names.push(ns);
			}
		}
	}

	/**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */
	function matchesTemplate(search, template) {
		let searchIndex = 0;
		let templateIndex = 0;
		let starIndex = -1;
		let matchIndex = 0;

		while (searchIndex < search.length) {
			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
				// Match character or proceed with wildcard
				if (template[templateIndex] === '*') {
					starIndex = templateIndex;
					matchIndex = searchIndex;
					templateIndex++; // Skip the '*'
				} else {
					searchIndex++;
					templateIndex++;
				}
			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
				// Backtrack to the last '*' and try to match more characters
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else {
				return false; // No match
			}
		}

		// Handle trailing '*' in template
		while (templateIndex < template.length && template[templateIndex] === '*') {
			templateIndex++;
		}

		return templateIndex === template.length;
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names,
			...createDebug.skips.map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		for (const skip of createDebug.skips) {
			if (matchesTemplate(name, skip)) {
				return false;
			}
		}

		for (const ns of createDebug.names) {
			if (matchesTemplate(name, ns)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/debug/src/index.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/debug/src/browser.js");
} else {
	module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/debug/src/node.js":
/*!****************************************!*\
  !*** ./node_modules/debug/src/node.js ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(/*! tty */ "tty");
const util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(/*! supports-color */ "./node_modules/supports-color/index.js");

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ "./node_modules/delayed-stream/lib/delayed_stream.js":
/*!***********************************************************!*\
  !*** ./node_modules/delayed-stream/lib/delayed_stream.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(/*! stream */ "stream").Stream);
var util = __webpack_require__(/*! util */ "util");

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),

/***/ "./node_modules/dunder-proto/get.js":
/*!******************************************!*\
  !*** ./node_modules/dunder-proto/get.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind-apply-helpers */ "./node_modules/call-bind-apply-helpers/index.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),

/***/ "./node_modules/es-define-property/index.js":
/*!**************************************************!*\
  !*** ./node_modules/es-define-property/index.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ "./node_modules/es-errors/eval.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/eval.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ "./node_modules/es-errors/index.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ "./node_modules/es-errors/range.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/range.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ "./node_modules/es-errors/ref.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/ref.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ "./node_modules/es-errors/syntax.js":
/*!******************************************!*\
  !*** ./node_modules/es-errors/syntax.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ "./node_modules/es-errors/type.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/type.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ "./node_modules/es-errors/uri.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/uri.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ "./node_modules/es-object-atoms/index.js":
/*!***********************************************!*\
  !*** ./node_modules/es-object-atoms/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),

/***/ "./node_modules/es-set-tostringtag/index.js":
/*!**************************************************!*\
  !*** ./node_modules/es-set-tostringtag/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/hasown/index.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");

var toStringTag = hasToStringTag ? Symbol.toStringTag : null;

/** @type {import('.')} */
module.exports = function setToStringTag(object, value) {
	var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
	var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
	if (
		(typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean')
		|| (typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean')
	) {
		throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
	}
	if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
		if ($defineProperty) {
			$defineProperty(object, toStringTag, {
				configurable: !nonConfigurable,
				enumerable: false,
				value: value,
				writable: false
			});
		} else {
			object[toStringTag] = value; // eslint-disable-line no-param-reassign
		}
	}
};


/***/ }),

/***/ "./node_modules/follow-redirects/debug.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/debug.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var debug;

module.exports = function () {
  if (!debug) {
    try {
      /* eslint global-require: off */
      debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/index.js")("follow-redirects");
    }
    catch (error) { /* */ }
    if (typeof debug !== "function") {
      debug = function () { /* */ };
    }
  }
  debug.apply(null, arguments);
};


/***/ }),

/***/ "./node_modules/follow-redirects/index.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var url = __webpack_require__(/*! url */ "url");
var URL = url.URL;
var http = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var Writable = (__webpack_require__(/*! stream */ "stream").Writable);
var assert = __webpack_require__(/*! assert */ "assert");
var debug = __webpack_require__(/*! ./debug */ "./node_modules/follow-redirects/debug.js");

// Preventive platform detection
// istanbul ignore next
(function detectUnsupportedEnvironment() {
  var looksLikeNode = typeof process !== "undefined";
  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var looksLikeV8 = isFunction(Error.captureStackTrace);
  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
    console.warn("The follow-redirects package should be excluded from browser builds.");
  }
}());

// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
  assert(new URL(""));
}
catch (error) {
  useNativeURL = error.code === "ERR_INVALID_URL";
}

// URL fields to preserve in copy operations
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash",
];

// Create handlers that pass events from native requests
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = Object.create(null);
events.forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    try {
      self._processResponse(response);
    }
    catch (cause) {
      self.emit("error", cause instanceof RedirectionError ?
        cause : new RedirectionError({ cause: cause }));
    }
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

RedirectableRequest.prototype.abort = function () {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};

RedirectableRequest.prototype.destroy = function (error) {
  destroyRequest(this._currentRequest, error);
  destroy.call(this, error);
  return this;
};

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  }
  else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  var self = this;

  // Destroys the socket on timeout
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }

  // Sets up a timer to trigger a timeout event
  function startTimer(socket) {
    if (self._timeout) {
      clearTimeout(self._timeout);
    }
    self._timeout = setTimeout(function () {
      self.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }

  // Stops a timeout from triggering
  function clearTimer() {
    // Clear the timeout
    if (self._timeout) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }

    // Clean up all attached listeners
    self.removeListener("abort", clearTimer);
    self.removeListener("error", clearTimer);
    self.removeListener("response", clearTimer);
    self.removeListener("close", clearTimer);
    if (callback) {
      self.removeListener("timeout", callback);
    }
    if (!self.socket) {
      self._currentRequest.removeListener("socket", startTimer);
    }
  }

  // Attach callback if passed
  if (callback) {
    this.on("timeout", callback);
  }

  // Start the timer if or when the socket is opened
  if (this.socket) {
    startTimer(this.socket);
  }
  else {
    this._currentRequest.once("socket", startTimer);
  }

  // Clean up on events
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);

  return this;
};

// Proxy all other public ClientRequest methods
[
  "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request and set up its event handlers
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  request._redirectable = this;
  for (var event of events) {
    request.on(event, eventHandlers[event]);
  }

  // RFC7230§5.3.1: When making a request directly to an origin server, […]
  // a client MUST send only the absolute path […] as the request-target.
  this._currentUrl = /^\//.test(this._options.path) ?
    url.format(this._options) :
    // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path;

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      // istanbul ignore else
      if (request === self._currentRequest) {
        // Report any write errors
        // istanbul ignore if
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          // istanbul ignore else
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.

  // If the response is not a redirect; return it as-is
  var location = response.headers.location;
  if (!location || this._options.followRedirects === false ||
      statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
    return;
  }

  // The response is a redirect, so abort the current request
  destroyRequest(this._currentRequest);
  // Discard the remainder of the response to avoid waiting for data
  response.destroy();

  // RFC7231§6.4: A client SHOULD detect and intervene
  // in cyclical redirections (i.e., "infinite" redirection loops).
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }

  // Store the request headers if applicable
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host"),
    }, this._options.headers);
  }

  // RFC7231§6.4: Automatic redirection needs to done with
  // care for methods not known to be safe, […]
  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
  // the request method from POST to GET for the subsequent request.
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
      // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    // Drop a possible entity and headers related to it
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }

  // Drop the Host header, as the redirect might lead to a different host
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

  // If the redirect is relative, carry over the host of the last request
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
    url.format(Object.assign(currentUrlParts, { host: currentHost }));

  // Create the redirected request
  var redirectUrl = resolveUrl(location, currentUrl);
  debug("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);

  // Drop confidential headers when redirecting to a less secure protocol
  // or to a different domain that is not a superdomain
  if (redirectUrl.protocol !== currentUrlParts.protocol &&
     redirectUrl.protocol !== "https:" ||
     redirectUrl.host !== currentHost &&
     !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }

  // Evaluate the beforeRedirect callback
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode: statusCode,
    };
    var requestDetails = {
      url: currentUrl,
      method: method,
      headers: requestHeaders,
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }

  // Perform the redirected request
  this._performRequest();
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    function request(input, options, callback) {
      // Parse parameters, ensuring that input is an object
      if (isURL(input)) {
        input = spreadUrlObject(input);
      }
      else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      }
      else {
        callback = options;
        options = validateUrl(input);
        input = { protocol: protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }

    // Executes a GET request, following redirects
    function get(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }

    // Expose the properties on the wrapped protocol
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true },
    });
  });
  return exports;
}

function noop() { /* empty */ }

function parseUrl(input) {
  var parsed;
  // istanbul ignore else
  if (useNativeURL) {
    parsed = new URL(input);
  }
  else {
    // Ensure the URL is valid and absolute
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}

function resolveUrl(relative, base) {
  // istanbul ignore next
  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}

function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}

function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }

  // Fix IPv6 hostname
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  // Ensure port is a number
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  // Concatenate path
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

  return spread;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return (lastValue === null || typeof lastValue === "undefined") ?
    undefined : String(lastValue).trim();
}

function createErrorType(code, message, baseClass) {
  // Create constructor
  function CustomError(properties) {
    // istanbul ignore else
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    }
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }

  // Attach constructor and set default properties
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false,
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false,
    },
  });
  return CustomError;
}

function destroyRequest(request, error) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop);
  request.destroy(error);
}

function isSubdomain(subdomain, domain) {
  assert(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}

function isString(value) {
  return typeof value === "string" || value instanceof String;
}

function isFunction(value) {
  return typeof value === "function";
}

function isBuffer(value) {
  return typeof value === "object" && ("length" in value);
}

function isURL(value) {
  return URL && value instanceof URL;
}

// Exports
module.exports = wrap({ http: http, https: https });
module.exports.wrap = wrap;


/***/ }),

/***/ "./node_modules/form-data/lib/form_data.js":
/*!*************************************************!*\
  !*** ./node_modules/form-data/lib/form_data.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CombinedStream = __webpack_require__(/*! combined-stream */ "./node_modules/combined-stream/lib/combined_stream.js");
var util = __webpack_require__(/*! util */ "util");
var path = __webpack_require__(/*! path */ "path");
var http = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var parseUrl = (__webpack_require__(/*! url */ "url").parse);
var fs = __webpack_require__(/*! fs */ "fs");
var Stream = (__webpack_require__(/*! stream */ "stream").Stream);
var mime = __webpack_require__(/*! mime-types */ "./node_modules/mime-types/index.js");
var asynckit = __webpack_require__(/*! asynckit */ "./node_modules/asynckit/index.js");
var setToStringTag = __webpack_require__(/*! es-set-tostringtag */ "./node_modules/es-set-tostringtag/index.js");
var populate = __webpack_require__(/*! ./populate.js */ "./node_modules/form-data/lib/populate.js");

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (Array.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response or not a stream
  if (!value || ( !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) && !(value instanceof Stream))) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {
  if (Object.prototype.hasOwnProperty.call(value, 'fd')) {

    // take read range into a account
    // `end` = Infinity –> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (Object.prototype.hasOwnProperty.call(value, 'httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, prop)) {
      header = headers[prop];

      // skip nullish headers.
      if (header == null) {
        continue;
      }

      // convert all headers to arrays.
      if (!Array.isArray(header)) {
        header = [header];
      }

      // add non-empty headers.
      if (header.length) {
        contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
      }
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc(0);
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err && err !== 'Unknown stream') {
      this._error(err);
      return;
    }

    // add content length
    if (length) {
      request.setHeader('Content-Length', length);
    }

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};
setToStringTag(FormData, 'FormData');


/***/ }),

/***/ "./node_modules/form-data/lib/populate.js":
/*!************************************************!*\
  !*** ./node_modules/form-data/lib/populate.js ***!
  \************************************************/
/***/ ((module) => {

// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/es-object-atoms/index.js");

var $Error = __webpack_require__(/*! es-errors */ "./node_modules/es-errors/index.js");
var $EvalError = __webpack_require__(/*! es-errors/eval */ "./node_modules/es-errors/eval.js");
var $RangeError = __webpack_require__(/*! es-errors/range */ "./node_modules/es-errors/range.js");
var $ReferenceError = __webpack_require__(/*! es-errors/ref */ "./node_modules/es-errors/ref.js");
var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $URIError = __webpack_require__(/*! es-errors/uri */ "./node_modules/es-errors/uri.js");

var abs = __webpack_require__(/*! math-intrinsics/abs */ "./node_modules/math-intrinsics/abs.js");
var floor = __webpack_require__(/*! math-intrinsics/floor */ "./node_modules/math-intrinsics/floor.js");
var max = __webpack_require__(/*! math-intrinsics/max */ "./node_modules/math-intrinsics/max.js");
var min = __webpack_require__(/*! math-intrinsics/min */ "./node_modules/math-intrinsics/min.js");
var pow = __webpack_require__(/*! math-intrinsics/pow */ "./node_modules/math-intrinsics/pow.js");
var round = __webpack_require__(/*! math-intrinsics/round */ "./node_modules/math-intrinsics/round.js");
var sign = __webpack_require__(/*! math-intrinsics/sign */ "./node_modules/math-intrinsics/sign.js");

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");
var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var getProto = __webpack_require__(/*! get-proto */ "./node_modules/get-proto/index.js");
var $ObjectGPO = __webpack_require__(/*! get-proto/Object.getPrototypeOf */ "./node_modules/get-proto/Object.getPrototypeOf.js");
var $ReflectGPO = __webpack_require__(/*! get-proto/Reflect.getPrototypeOf */ "./node_modules/get-proto/Reflect.getPrototypeOf.js");

var $apply = __webpack_require__(/*! call-bind-apply-helpers/functionApply */ "./node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__(/*! call-bind-apply-helpers/functionCall */ "./node_modules/call-bind-apply-helpers/functionCall.js");

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/hasown/index.js");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/get-proto/Object.getPrototypeOf.js":
/*!*********************************************************!*\
  !*** ./node_modules/get-proto/Object.getPrototypeOf.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/es-object-atoms/index.js");

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),

/***/ "./node_modules/get-proto/Reflect.getPrototypeOf.js":
/*!**********************************************************!*\
  !*** ./node_modules/get-proto/Reflect.getPrototypeOf.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),

/***/ "./node_modules/get-proto/index.js":
/*!*****************************************!*\
  !*** ./node_modules/get-proto/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(/*! ./Reflect.getPrototypeOf */ "./node_modules/get-proto/Reflect.getPrototypeOf.js");
var originalGetProto = __webpack_require__(/*! ./Object.getPrototypeOf */ "./node_modules/get-proto/Object.getPrototypeOf.js");

var getDunderProto = __webpack_require__(/*! dunder-proto/get */ "./node_modules/dunder-proto/get.js");

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),

/***/ "./node_modules/gopd/gOPD.js":
/*!***********************************!*\
  !*** ./node_modules/gopd/gOPD.js ***!
  \***********************************/
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(/*! ./gOPD */ "./node_modules/gopd/gOPD.js");

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/has-flag/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-flag/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ "./node_modules/hasown/index.js":
/*!**************************************!*\
  !*** ./node_modules/hasown/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ "./node_modules/math-intrinsics/abs.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/abs.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),

/***/ "./node_modules/math-intrinsics/floor.js":
/*!***********************************************!*\
  !*** ./node_modules/math-intrinsics/floor.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),

/***/ "./node_modules/math-intrinsics/isNaN.js":
/*!***********************************************!*\
  !*** ./node_modules/math-intrinsics/isNaN.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),

/***/ "./node_modules/math-intrinsics/max.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/max.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),

/***/ "./node_modules/math-intrinsics/min.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/min.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),

/***/ "./node_modules/math-intrinsics/pow.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/pow.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),

/***/ "./node_modules/math-intrinsics/round.js":
/*!***********************************************!*\
  !*** ./node_modules/math-intrinsics/round.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),

/***/ "./node_modules/math-intrinsics/sign.js":
/*!**********************************************!*\
  !*** ./node_modules/math-intrinsics/sign.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(/*! ./isNaN */ "./node_modules/math-intrinsics/isNaN.js");

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),

/***/ "./node_modules/mime-db/db.json":
/*!**************************************!*\
  !*** ./node_modules/mime-db/db.json ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),

/***/ "./node_modules/mime-db/index.js":
/*!***************************************!*\
  !*** ./node_modules/mime-db/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(/*! ./db.json */ "./node_modules/mime-db/db.json")


/***/ }),

/***/ "./node_modules/mime-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/mime-types/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(/*! mime-db */ "./node_modules/mime-db/index.js")
var extname = (__webpack_require__(/*! path */ "path").extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/proxy-from-env/index.js":
/*!**********************************************!*\
  !*** ./node_modules/proxy-from-env/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var parseUrl = (__webpack_require__(/*! url */ "url").parse);

var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443,
};

var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length &&
    this.indexOf(s, this.length - s.length) !== -1;
};

/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */
function getProxyForUrl(url) {
  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
    return '';  // Don't proxy URLs without a valid scheme or host.
  }

  proto = proto.split(':', 1)[0];
  // Stripping ports in this way instead of using parsedUrl.hostname to make
  // sure that the brackets around IPv6 addresses are kept.
  hostname = hostname.replace(/:\d*$/, '');
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return '';  // Don't proxy URLs that match NO_PROXY.
  }

  var proxy =
    getEnv('npm_config_' + proto + '_proxy') ||
    getEnv(proto + '_proxy') ||
    getEnv('npm_config_proxy') ||
    getEnv('all_proxy');
  if (proxy && proxy.indexOf('://') === -1) {
    // Missing scheme in proxy, default to the requested URL's scheme.
    proxy = proto + '://' + proxy;
  }
  return proxy;
}

/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */
function shouldProxy(hostname, port) {
  var NO_PROXY =
    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
  if (!NO_PROXY) {
    return true;  // Always proxy if NO_PROXY is not set.
  }
  if (NO_PROXY === '*') {
    return false;  // Never proxy if wildcard is set.
  }

  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;  // Skip zero-length hosts.
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;  // Skip if ports don't match.
    }

    if (!/^[.*]/.test(parsedProxyHostname)) {
      // No wildcards, so stop proxying if there is an exact match.
      return hostname !== parsedProxyHostname;
    }

    if (parsedProxyHostname.charAt(0) === '*') {
      // Remove leading wildcard.
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    // Stop proxying if the hostname ends with the no_proxy host.
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}

/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}

exports.getProxyForUrl = getProxyForUrl;


/***/ }),

/***/ "./node_modules/supports-color/index.js":
/*!**********************************************!*\
  !*** ./node_modules/supports-color/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const tty = __webpack_require__(/*! tty */ "tty");
const hasFlag = __webpack_require__(/*! has-flag */ "./node_modules/has-flag/index.js");

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const FastBuffer = Buffer[Symbol.species];

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) {
    return new FastBuffer(target.buffer, target.byteOffset, offset);
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

module.exports = {
  concat,
  mask: _mask,
  toArrayBuffer,
  toBuffer,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = __webpack_require__(/*! bufferutil */ "bufferutil");

    module.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    module.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


const BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
const hasBlob = typeof Blob !== 'undefined';

if (hasBlob) BINARY_TYPES.push('blob');

module.exports = {
  BINARY_TYPES,
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  hasBlob,
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute] &&
        listener[kListener] === handler &&
        !listener[kForOnEventAttribute]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}


/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const zlib = __webpack_require__(/*! zlib */ "zlib");

const bufferUtil = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const Limiter = __webpack_require__(/*! ./limiter */ "./node_modules/ws/lib/limiter.js");
const { kStatusCode } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const FastBuffer = Buffer[Symbol.species];
const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) {
        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
      }

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);

  //
  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the
  // fact that in Node.js versions prior to 13.10.0, the callback for
  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing
  // `zlib.reset()` ensures that either the callback is invoked or an error is
  // emitted.
  //
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;

  if (this[kError]) {
    this[kCallback](this[kError]);
    return;
  }

  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Writable } = __webpack_require__(/*! stream */ "stream");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

const FastBuffer = Buffer[Symbol.species];

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._allowSynchronousEvents =
      options.allowSynchronousEvents !== undefined
        ? options.allowSynchronousEvents
        : true;
    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n,
        buf.length - n
      );

      return new FastBuffer(buf.buffer, buf.byteOffset, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n,
          buf.length - n
        );
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);

    if (!this._errored) cb();
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      const error = this.createError(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );

      cb(error);
      return;
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      const error = this.createError(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );

      cb(error);
      return;
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (!this._fragmented) {
        const error = this.createError(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        const error = this.createError(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );

        cb(error);
        return;
      }

      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (
        this._payloadLength > 0x7d ||
        (this._opcode === 0x08 && this._payloadLength === 1)
      ) {
        const error = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );

        cb(error);
        return;
      }
    } else {
      const error = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );

      cb(error);
      return;
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );

        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );

      cb(error);
      return;
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );

      cb(error);
      return;
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }

  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );

        cb(error);
        return;
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) {
      this.controlMessage(data, cb);
      return;
    }

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    this.dataMessage(cb);
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            'Max payload size exceeded',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
          );

          cb(error);
          return;
        }

        this._fragments.push(buf);
      }

      this.dataMessage(cb);
      if (this._state === GET_INFO) this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }

    const messageLength = this._messageLength;
    const fragments = this._fragments;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];

    if (this._opcode === 2) {
      let data;

      if (this._binaryType === 'nodebuffer') {
        data = concat(fragments, messageLength);
      } else if (this._binaryType === 'arraybuffer') {
        data = toArrayBuffer(concat(fragments, messageLength));
      } else if (this._binaryType === 'blob') {
        data = new Blob(fragments);
      } else {
        data = fragments;
      }

      if (this._allowSynchronousEvents) {
        this.emit('message', data, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', data, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat(fragments, messageLength);

      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error = this.createError(
          Error,
          'invalid UTF-8 sequence',
          true,
          1007,
          'WS_ERR_INVALID_UTF8'
        );

        cb(error);
        return;
      }

      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit('message', buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 0x08) {
      if (data.length === 0) {
        this._loop = false;
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          const error = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );

          cb(error);
          return;
        }

        const buf = new FastBuffer(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );

          cb(error);
          return;
        }

        this._loop = false;
        this.emit('conclude', code, buf);
        this.end();
      }

      this._state = GET_INFO;
      return;
    }

    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      setImmediate(() => {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }

  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;

    const err = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );

    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  }
}

module.exports = Receiver;


/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */



const { Duplex } = __webpack_require__(/*! stream */ "stream");
const { randomFillSync } = __webpack_require__(/*! crypto */ "crypto");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");
const { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);
const RANDOM_POOL_SIZE = 8 * 1024;
let randomPool;
let randomPoolPointer = RANDOM_POOL_SIZE;

const DEFAULT = 0;
const DEFLATING = 1;
const GET_BLOB_DATA = 2;

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._queue = [];
    this._state = DEFAULT;
    this.onerror = NOOP;
    this[kWebSocket] = undefined;
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        if (randomPoolPointer === RANDOM_POOL_SIZE) {
          /* istanbul ignore else  */
          if (randomPool === undefined) {
            //
            // This is lazily initialized because server-sent frames must not
            // be masked so it may never be used.
            //
            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
          }

          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
          randomPoolPointer = 0;
        }

        mask[0] = randomPool[randomPoolPointer++];
        mask[1] = randomPool[randomPoolPointer++];
        mask[2] = randomPool[randomPoolPointer++];
        mask[3] = randomPool[randomPoolPointer++];
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    const opts = {
      [kByteLength]: byteLength,
      fin: options.fin,
      generateMask: this._generateMask,
      mask: options.mask,
      maskBuffer: this._maskBuffer,
      opcode,
      readOnly,
      rsv1
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
      } else {
        this.getBlobData(data, this._compress, opts, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
    } else {
      this.dispatch(data, this._compress, opts, cb);
    }
  }

  /**
   * Gets the contents of a blob as binary data.
   *
   * @param {Blob} blob The blob
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     the data
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  getBlobData(blob, compress, options, cb) {
    this._bufferedBytes += options[kByteLength];
    this._state = GET_BLOB_DATA;

    blob
      .arrayBuffer()
      .then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error(
            'The socket was closed while the blob was being read'
          );

          //
          // `callCallbacks` is called in the next tick to ensure that errors
          // that might be thrown in the callbacks behave like errors thrown
          // outside the promise chain.
          //
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }

        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);

        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      })
      .catch((err) => {
        //
        // `onError` is called in the next tick for the same reason that
        // `callCallbacks` above is.
        //
        process.nextTick(onError, this, err, cb);
      });
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._state = DEFLATING;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        callCallbacks(this, err, cb);
        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._state = DEFAULT;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (this._state === DEFAULT && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {(Buffer | String)[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;

/**
 * Calls queued callbacks with an error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error to call the callbacks with
 * @param {Function} [cb] The first callback
 * @private
 */
function callCallbacks(sender, err, cb) {
  if (typeof cb === 'function') cb(err);

  for (let i = 0; i < sender._queue.length; i++) {
    const params = sender._queue[i];
    const callback = params[params.length - 1];

    if (typeof callback === 'function') callback(err);
  }
}

/**
 * Handles a `Sender` error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error
 * @param {Function} [cb] The first pending callback
 * @private
 */
function onError(sender, err, cb) {
  callCallbacks(sender, err, cb);
  sender.onerror(err);
}


/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^WebSocket$" }] */


const WebSocket = __webpack_require__(/*! ./websocket */ "./node_modules/ws/lib/websocket.js");
const { Duplex } = __webpack_require__(/*! stream */ "stream");

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ "./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isUtf8 } = __webpack_require__(/*! buffer */ "buffer");

const { hasBlob } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

/**
 * Determines whether a value is a `Blob`.
 *
 * @param {*} value The value to be tested
 * @return {Boolean} `true` if `value` is a `Blob`, else `false`
 * @private
 */
function isBlob(value) {
  return (
    hasBlob &&
    typeof value === 'object' &&
    typeof value.arrayBuffer === 'function' &&
    typeof value.type === 'string' &&
    typeof value.stream === 'function' &&
    (value[Symbol.toStringTag] === 'Blob' ||
      value[Symbol.toStringTag] === 'File')
  );
}

module.exports = {
  isBlob,
  isValidStatusCode,
  isValidUTF8: _isValidUTF8,
  tokenChars
};

if (isUtf8) {
  module.exports.isValidUTF8 = function (buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ "utf-8-validate");

    module.exports.isValidUTF8 = function (buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(/*! events */ "events");
const http = __webpack_require__(/*! http */ "http");
const { Duplex } = __webpack_require__(/*! stream */ "stream");
const { createHash } = __webpack_require__(/*! crypto */ "crypto");

const extension = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const subprotocol = __webpack_require__(/*! ./subprotocol */ "./node_modules/ws/lib/subprotocol.js");
const WebSocket = __webpack_require__(/*! ./websocket */ "./node_modules/ws/lib/websocket.js");
const { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      allowSynchronousEvents: true,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const upgrade = req.headers.upgrade;
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (key === undefined || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null, undefined, this.options);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message);
  }
}


/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(/*! events */ "events");
const https = __webpack_require__(/*! https */ "https");
const http = __webpack_require__(/*! http */ "http");
const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { randomBytes, createHash } = __webpack_require__(/*! crypto */ "crypto");
const { Duplex, Readable } = __webpack_require__(/*! stream */ "stream");
const { URL } = __webpack_require__(/*! url */ "url");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const Receiver = __webpack_require__(/*! ./receiver */ "./node_modules/ws/lib/receiver.js");
const Sender = __webpack_require__(/*! ./sender */ "./node_modules/ws/lib/sender.js");
const { isBlob } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const {
  EventTarget: { addEventListener, removeEventListener }
} = __webpack_require__(/*! ./event-target */ "./node_modules/ws/lib/event-target.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const { toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._errorEmitted = false;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._isServer = true;
    }
  }

  /**
   * For historical reasons, the custom "nodebuffer" type is used by the default
   * instead of "blob".
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    const sender = new Sender(socket, this._extensions, options.generateMask);

    this._receiver = receiver;
    this._sender = sender;
    this._socket = socket;

    receiver[kWebSocket] = this;
    sender[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    sender.onerror = senderOnError;

    //
    // These methods may not be available if `socket` is just a `Duplex`.
    //
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    setCloseTimer(this);
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  websocket._autoPong = opts.autoPong;

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }

  if (parsedUrl.protocol === 'http:') {
    parsedUrl.protocol = 'ws:';
  } else if (parsedUrl.protocol === 'https:') {
    parsedUrl.protocol = 'wss:';
  }

  websocket._url = parsedUrl.href;

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", ' +
      '"http:", "https:", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection =
    opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
          ? false
          : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const upgrade = res.headers.upgrade;

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      abortHandshake(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  if (opts.finishRequest) {
    opts.finishRequest(req, websocket);
  } else {
    req.end();
  }
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  //
  // The following assignment is practically useless and is done only for
  // consistency.
  //
  websocket._errorEmitted = true;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = isBlob(data) ? data.size : toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The `Sender` error event handler.
 *
 * @param {Error} The error
 * @private
 */
function senderOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket.readyState === WebSocket.CLOSED) return;
  if (websocket.readyState === WebSocket.OPEN) {
    websocket._readyState = WebSocket.CLOSING;
    setCloseTimer(websocket);
  }

  //
  // `socket.end()` is used instead of `socket.destroy()` to allow the other
  // peer to finish sending queued data. There is no need to set a timer here
  // because `CLOSING` means that it is already set or not needed.
  //
  this._socket.end();

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * Set a timer to destroy the underlying raw socket of a WebSocket.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @private
 */
function setCloseTimer(websocket) {
  websocket._closeTimer = setTimeout(
    websocket._socket.destroy.bind(websocket._socket),
    closeTimeout
  );
}

/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ "./node_modules/ws/wrapper.mjs":
/*!*************************************!*\
  !*** ./node_modules/ws/wrapper.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ "./node_modules/ws/lib/stream.js");
/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ "./node_modules/ws/lib/receiver.js");
/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ "./node_modules/ws/lib/sender.js");
/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ "./node_modules/ws/lib/websocket.js");
/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ "./node_modules/ws/lib/websocket-server.js");







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);


/***/ }),

/***/ "./src/core/commands/commandManager.ts":
/*!*********************************************!*\
  !*** ./src/core/commands/commandManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CommandManager: () => (/* binding */ CommandManager)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _slashCommandManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slashCommandManager */ "./src/core/commands/slashCommandManager.ts");


/**
 * Manages all commands for the extension
 */
class CommandManager {
    _context;
    _chatViewProvider;
    _llmService;
    _memoryService;
    _modelManager;
    _rulesService;
    _vaultService;
    _jiraService;
    _slashCommandManager;
    constructor(_context, _chatViewProvider, _llmService, _memoryService, _modelManager, _rulesService, // Rules 서비스
    _vaultService, // Vault 서비스
    _jiraService // Jira 서비스
    ) {
        this._context = _context;
        this._chatViewProvider = _chatViewProvider;
        this._llmService = _llmService;
        this._memoryService = _memoryService;
        this._modelManager = _modelManager;
        this._rulesService = _rulesService;
        this._vaultService = _vaultService;
        this._jiraService = _jiraService;
        // Initialize slash command manager with LLMService for smart help and services
        const services = {
            llmService: this._llmService,
            memoryService: this._memoryService,
            modelManager: this._modelManager,
            rulesService: this._rulesService,
            vaultService: this._vaultService,
            jiraService: this._jiraService
        };
        this._slashCommandManager = new _slashCommandManager__WEBPACK_IMPORTED_MODULE_1__.SlashCommandManager(this._context, this._llmService, services);
    }
    /**
     * Gets the slash command manager instance
     */
    get slashCommandManager() {
        return this._slashCommandManager;
    }
    /**
     * Registers all commands for the extension
     */
    registerCommands() {
        // Chat commands
        this._registerCommand('ape.openChat', this._openChat.bind(this));
        this._registerCommand('ape.clearChat', this._clearChat.bind(this));
        this._registerCommand('ape.sendMessage', this._sendMessage.bind(this));
        // Model commands
        this._registerCommand('ape.selectModel', this.selectModel.bind(this));
        this._registerCommand('ape.switchModel', this.switchModel.bind(this));
        // Code commands
        this._registerCommand('ape.analyzeCode', this._analyzeCode.bind(this));
        // Slash commands
        this._registerCommand('ape.executeSlashCommand', this._executeSlashCommand.bind(this));
    }
    /**
     * Registers a single command
     */
    _registerCommand(commandId, handler) {
        const disposable = vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand(commandId, handler);
        this._context.subscriptions.push(disposable);
    }
    /**
     * Opens the chat view
     */
    async _openChat() {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.view.extension.ape-sidebar');
    }
    /**
     * Clears the chat history
     */
    async _clearChat() {
        await this._chatViewProvider.clearChat();
    }
    /**
     * Sends a message to the chat
     */
    async _sendMessage(content) {
        if (!content) {
            // If no content provided, prompt the user
            const message = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: 'Enter message to send to APE',
                placeHolder: 'Type your message here...'
            });
            if (message) {
                await this._chatViewProvider.sendMessage(message);
            }
        }
        else {
            await this._chatViewProvider.sendMessage(content);
        }
    }
    /**
     * Opens model selection dialog
     */
    async selectModel() {
        const models = this._modelManager.getAvailableModels();
        const activeModel = this._modelManager.getActiveModel();
        // Create friendly display names for models
        const selectedModel = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(models.map(model => ({
            label: this._modelManager.getModelDisplayName(model),
            description: model === activeModel ? '(active)' : '',
            detail: this._modelManager.getModelDescription(model),
            model: model // Keep original model ID
        })), {
            placeHolder: 'Select a model to use',
            title: 'APE Model Selection'
        });
        if (selectedModel) {
            await this.switchModel(selectedModel.model);
        }
    }
    /**
     * Switches to a specific model
     */
    async switchModel(modelName) {
        try {
            // Use the ModelManager to switch models
            const success = await this._modelManager.setActiveModel(modelName);
            if (success) {
                // Update the UI to reflect the model change
                this._chatViewProvider.updateModelIndicator();
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`${this._modelManager.getModelDisplayName(modelName)} 모델로 전환했습니다`);
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`모델 전환 실패: 유효하지 않은 모델 또는 전환 중 오류 발생`);
            }
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`모델 전환 실패: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Gets user-friendly display name for a model - Deprecated, use ModelManager.getModelDisplayName instead
     * @param modelId The model ID
     * @returns User-friendly display name
     * @deprecated This method is kept for backward compatibility. Use ModelManager.getModelDisplayName instead
     */
    _getModelDisplayName(modelId) {
        return this._modelManager.getModelDisplayName(modelId);
    }
    /**
     * Executes a slash command
     */
    async _executeSlashCommand(commandText) {
        const executed = await this._slashCommandManager.executeCommand(commandText);
        if (!executed) {
            // If not a slash command, treat as regular message
            await this._sendMessage(commandText);
        }
    }
    /**
     * Gets description for a model - Deprecated, use ModelManager.getModelDescription instead
     * @param model The model ID
     * @returns Model description
     * @deprecated This method is kept for backward compatibility. Use ModelManager.getModelDescription instead
     */
    _getModelDescription(model) {
        return this._modelManager.getModelDescription(model);
    }
    /**
     * Analyzes selected code with APE
     */
    async _analyzeCode() {
        const editor = vscode__WEBPACK_IMPORTED_MODULE_0__.window.activeTextEditor;
        if (!editor) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('No active editor');
            return;
        }
        const selection = editor.selection;
        if (selection.isEmpty) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('Please select code to analyze');
            return;
        }
        const selectedText = editor.document.getText(selection);
        const filePath = editor.document.fileName;
        const fileExtension = filePath.split('.').pop() || '';
        const fileName = filePath.split('/').pop() || '';
        // Create analysis prompt with improved message for APE analysis
        const prompt = `Please analyze this ${fileExtension} code from ${fileName}:\n\n\`\`\`${fileExtension}\n${selectedText}\n\`\`\`\n\nProvide a detailed APE analysis including:\n1. Code functionality\n2. Potential issues or improvements\n3. Best practices recommendations`;
        // Show notification that analysis is starting
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('Analyzing selected code with APE...');
        // Open chat and send the prompt
        await this._openChat();
        await this._sendMessage(prompt);
    }
}


/***/ }),

/***/ "./src/core/commands/defaultCommands.ts":
/*!**********************************************!*\
  !*** ./src/core/commands/defaultCommands.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDefaultCommands: () => (/* binding */ createDefaultCommands)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _git_commands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../git/commands */ "./src/core/git/commands.ts");
/* harmony import */ var _vaultCommands__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vaultCommands */ "./src/core/commands/vaultCommands.ts");
/* harmony import */ var _rulesCommands__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rulesCommands */ "./src/core/commands/rulesCommands.ts");
/* harmony import */ var _jiraCommands__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./jiraCommands */ "./src/core/commands/jiraCommands.ts");
/**
 * 기본 슬래시 커맨드 정의
 */






/**
 * 기본 슬래시 커맨드 목록 생성
 */
function createDefaultCommands(services) {
    const commands = [];
    // VAULT 명령어 추가 (VAULT 서비스가 있는 경우)
    if (services?.vaultService) {
        const vaultCommands = (0,_vaultCommands__WEBPACK_IMPORTED_MODULE_3__.createVaultCommands)(services.vaultService);
        commands.push(...vaultCommands);
    }
    // Rules 명령어 추가 (Rules 서비스가 있는 경우)
    if (services?.rulesService) {
        const rulesCommands = (0,_rulesCommands__WEBPACK_IMPORTED_MODULE_4__.createRulesCommands)(services.rulesService);
        commands.push(...rulesCommands);
    }
    // Jira 명령어 추가 (Jira 서비스가 있는 경우)
    if (services?.jiraService) {
        const jiraCommands = (0,_jiraCommands__WEBPACK_IMPORTED_MODULE_5__.createJiraCommands)(services.jiraService);
        commands.push(...jiraCommands);
    }
    // Todo 관련 코드 삭제됨
    // 도움말 명령어
    commands.push({
        name: 'help',
        aliases: ['?', 'commands', '도움말', '도움', '명령어', '알려줘', 'search', '검색'],
        description: '사용 가능한 명령어 목록과 도움말을 표시합니다',
        examples: ['/help', '/help git', '/help search 커밋 방법', '/도움말', '/도움말 검색 파일 열기'],
        category: 'general',
        priority: 1,
        execute: async (context) => {
            // 도움말 표시 명령은 SlashCommandManager에서 처리
            const firstArg = context.args[0]?.toLowerCase();
            if (firstArg === 'search' || firstArg === '검색' || firstArg === 'find' || firstArg === '찾기') {
                // 검색 모드: 자연어 검색으로 처리
                const searchQuery = context.args.slice(1).join(' ');
                if (searchQuery) {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp', `search ${searchQuery}`);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('검색어를 입력해주세요');
                }
            }
            else if (firstArg === 'faq' || firstArg === '자주묻는질문') {
                // FAQ 모드
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp', 'faq');
            }
            else if (firstArg === 'guide' || firstArg === 'guides' || firstArg === '가이드' || firstArg === '가이드목록') {
                // 가이드 목록 모드
                if (context.args.length > 1) {
                    // 특정 가이드 선택
                    const guideId = context.args[1];
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp', `guide ${guideId}`);
                }
                else {
                    // 가이드 목록
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp', 'guides');
                }
            }
            else {
                // 기본 도움말 또는 카테고리/명령어 상세 도움말
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp', firstArg);
            }
        },
        provideCompletions: (partialArgs) => {
            const parts = partialArgs.split(' ');
            // 첫 번째 인자 자동완성
            if (parts.length <= 1) {
                const options = ['general', 'git', 'code', 'utility', 'advanced', 'search', 'find', 'faq', 'guide', 'guides', '검색', '찾기', '자주묻는질문', '가이드'];
                return options.filter(option => option.toLowerCase().startsWith(parts[0].toLowerCase()));
            }
            // 두 번째 인자 자동완성 (가이드인 경우)
            if ((parts[0] === 'guide' || parts[0] === 'guides' || parts[0] === '가이드') && parts.length === 2) {
                const guideOptions = ['auto-commit', 'git-integration', 'slash-commands', 'plugins'];
                return guideOptions.filter(option => option.toLowerCase().startsWith(parts[1].toLowerCase()));
            }
            return [];
        }
    });
    // 채팅 내역 지우기
    commands.push({
        name: 'clear',
        aliases: ['cls', 'clean', '지우기', '초기화', '클리어'],
        description: '채팅 내역을 지웁니다',
        category: 'general',
        priority: 2,
        execute: async () => {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.clearChat');
        }
    });
    // 모델 변경
    commands.push({
        name: 'model',
        aliases: ['use', '모델', '모델변경', '모델선택'],
        description: '사용할 LLM 모델을 변경합니다',
        examples: ['/model list', '/model use LLAMA4-MAVERICK', '/모델 목록'],
        category: 'advanced',
        priority: 10,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand || subCommand === 'list' || subCommand === '목록') {
                // 모델 목록 표시
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.selectModel');
            }
            else if (subCommand === 'use' || subCommand === 'switch' || subCommand === '사용' || subCommand === '변경') {
                // 특정 모델로 변경
                const modelName = context.args[1];
                if (modelName) {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.switchModel', modelName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('모델 이름을 지정해주세요');
                }
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('알 수 없는 하위 명령어입니다');
            }
        },
        provideCompletions: (partialArgs) => {
            // 고정된 모델 목록 사용
            const models = [
                'openai/gpt-4.1-mini',
                'anthropic/claude-3-haiku-20240307',
                'anthropic/claude-3-sonnet-20240229',
                'perplexity/sonar-small-online',
                'mistralai/mistral-large-latest',
                'google/gemma-7b-it'
            ];
            const subCommands = ['list', 'use', 'switch', '목록', '사용', '변경'];
            const parts = partialArgs.split(' ');
            // 첫 번째 인자 자동완성
            if (parts.length <= 1) {
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(partialArgs.toLowerCase()));
            }
            // 두 번째 인자 자동완성 (모델 이름)
            if (parts[0] === 'use' || parts[0] === 'switch' || parts[0] === '사용' || parts[0] === '변경') {
                const modelQuery = parts[1] || '';
                return models.filter((model) => model.toLowerCase().startsWith(modelQuery.toLowerCase()));
            }
            return [];
        }
    });
    // 코드 분석
    commands.push({
        name: 'analyze',
        aliases: ['code', '분석', '코드', '코드분석'],
        description: '현재 선택된 코드를 APE로 분석합니다',
        examples: ['/analyze', '/code', '/분석'],
        category: 'code',
        priority: 5,
        execute: async () => {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.analyzeCode');
        }
    });
    // Git 명령어 추가
    const gitCommands = (0,_git_commands__WEBPACK_IMPORTED_MODULE_2__.createGitCommands)();
    commands.push(...gitCommands);
    // 설정
    commands.push({
        name: 'settings',
        aliases: ['config', 'preferences', '설정', '환경설정', '프리퍼런스'],
        description: 'APE 설정을 변경합니다',
        category: 'utility',
        priority: 15,
        execute: async () => {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', 'ape');
        }
    });
    // 파일 열기
    commands.push({
        name: 'open',
        aliases: ['file', '열기', '파일', '파일열기'],
        description: '파일을 엽니다',
        examples: ['/open package.json', '/open src/index.ts', '/파일열기 package.json'],
        category: 'utility',
        priority: 20,
        execute: async (context) => {
            const filePath = context.args.join(' ');
            if (!filePath) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('열 파일 경로를 지정해주세요');
                return;
            }
            try {
                const document = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument(filePath);
                await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showTextDocument(document);
            }
            catch {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`파일을 열 수 없습니다: ${filePath}`);
            }
        }
    });
    // 채팅 관리 기능
    commands.push({
        name: 'chat',
        aliases: ['대화', '채팅', 'c'],
        description: '채팅 내역을 저장하고 관리합니다',
        examples: ['/chat save', '/chat list', '/chat show ID', '/대화 저장', '/채팅 목록'],
        category: 'utility',
        priority: 25,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand || subCommand === 'help' || subCommand === '도움말') {
                // 도움말 표시
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: `## 채팅 관리 명령어 사용법

다음 하위 명령어를 사용할 수 있습니다:

- \`/chat save\`: 현재 채팅 내용을 저장합니다.
- \`/chat list\`: 저장된 모든 채팅 목록을 표시합니다.
- \`/chat show [ID]\`: 특정 채팅 내역을 표시합니다.

예시: \`/chat save\`, \`/chat list\`, \`/chat show chat_12345\``
                });
                return;
            }
            if (subCommand === 'save' || subCommand === '저장') {
                // 대화 내역 저장 기능
                try {
                    // 메모리 서비스 가져오기
                    const memoryService = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape-team.ape-extension')?.exports?.memoryService;
                    if (!memoryService) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('메모리 서비스를 찾을 수 없습니다');
                        return;
                    }
                    // VAULT 서비스 가져오기
                    const vaultService = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape-team.ape-extension')?.exports?.vaultService;
                    if (!vaultService) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('VAULT 서비스를 찾을 수 없습니다');
                        return;
                    }
                    // LLM 서비스 가져오기
                    const llmService = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape-team.ape-extension')?.exports?.llmService;
                    // 현재 메시지 목록 가져오기
                    const messagesResult = await memoryService.getMessages();
                    if (!messagesResult.success || !messagesResult.data) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('대화 내역을 가져올 수 없습니다');
                        return;
                    }
                    const messages = messagesResult.data;
                    // 대화 내역 마크다운 형식으로 변환
                    let markdown = '';
                    // 현재 시간 추가
                    const now = new Date();
                    const dateStr = now.toISOString().split('T')[0];
                    const timeStr = now.toTimeString().split(' ')[0];
                    const timestamp = now.toISOString();
                    markdown += `## ${dateStr} ${timeStr}\n\n`;
                    // 메시지 역순으로 변환 (최신 메시지가 위에 오도록)
                    for (let i = messages.length - 1; i >= 0; i--) {
                        const message = messages[i];
                        // 시스템 메시지나 웰컴 메시지는 건너뛰기
                        if (message.role === 'system' && message.content.includes('welcome-container')) {
                            continue;
                        }
                        // 사용자나 어시스턴트 메시지만 포함
                        if (message.role === 'user' || message.role === 'assistant') {
                            const role = message.role === 'user' ? '사용자' : 'Claude';
                            // HTML 태그 제거 (간단한 방식으로)
                            const contentStr = message.content.replace(/<[^>]*>/g, '');
                            markdown += `**${role}**: ${contentStr}\n\n`;
                            // 구분선 추가 (마지막 메시지 제외)
                            if (i > 0) {
                                markdown += '---\n\n';
                            }
                        }
                    }
                    // 채팅 내역 제목 생성 (LLM 서비스 사용)
                    let chatTitle = `채팅 내역 ${dateStr} ${timeStr}`;
                    if (llmService && messages.length > 0) {
                        try {
                            // 첫 번째 사용자 메시지 찾기
                            const firstUserMessage = messages.find((m) => m.role === 'user');
                            if (firstUserMessage) {
                                // LLM에 요약 요청
                                const summaryPrompt = `다음 메시지의 내용을 20자 이내의 한국어 제목으로 요약해주세요: "${firstUserMessage.content.replace(/<[^>]*>/g, '').slice(0, 200)}${firstUserMessage.content.length > 200 ? '...' : ''}"`;
                                const summaryResult = await llmService.getSingleCompletion(summaryPrompt);
                                if (summaryResult && summaryResult.trim()) {
                                    // 요약 결과에서 따옴표나 공백 제거
                                    chatTitle = summaryResult.trim().replace(/^["']|["']$/g, '');
                                }
                            }
                        }
                        catch (error) {
                            console.error('채팅 제목 생성 오류:', error);
                            // 오류 발생 시 기본 제목 사용 (이미 설정됨)
                        }
                    }
                    // UUID 생성
                    const uuid = `chat_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
                    // 워크스페이스 루트 경로 가져오기
                    const workspaceFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0];
                    if (!workspaceFolder) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('워크스페이스 폴더를 찾을 수 없습니다');
                        return;
                    }
                    // Vault 내 채팅 내역 경로 확인 및 생성
                    const chatHistoryDir = path__WEBPACK_IMPORTED_MODULE_1__.join(workspaceFolder.uri.fsPath, 'vault', 'chat-history');
                    const chatHistoryUri = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.file(chatHistoryDir);
                    try {
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(chatHistoryUri);
                    }
                    catch {
                        // 디렉토리가 없으면 생성
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.createDirectory(chatHistoryUri);
                    }
                    // 채팅 내역 파일 경로 (UUID 사용)
                    const chatHistoryPath = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(chatHistoryUri, `${uuid}.md`);
                    // 메타데이터 파일 경로
                    const metadataPath = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(chatHistoryUri, `${uuid}.meta.json`);
                    // 메타데이터 생성
                    const metadata = {
                        id: uuid,
                        title: chatTitle,
                        createdAt: timestamp,
                        updatedAt: timestamp,
                        messageCount: messages.length
                    };
                    // 파일 저장 (채팅 내역)
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.writeFile(chatHistoryPath, Buffer.from(markdown, 'utf8'));
                    // 파일 저장 (메타데이터)
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.writeFile(metadataPath, Buffer.from(JSON.stringify(metadata, null, 2), 'utf8'));
                    // 트리 뷰 새로고침
                    try {
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.refreshTreeView');
                    }
                    catch (error) {
                        console.error('트리 뷰 새로고침 오류:', error);
                    }
                    // 결과를 채팅창에 표시
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: `대화 내역이 **${chatTitle}**으로 저장되었습니다. 총 ${messages.length}개의 메시지가 기록되었습니다.

채팅 내역은 트리 뷰에서 확인하거나 \`/chat list\` 명령어로 확인할 수 있습니다.`
                    });
                }
                catch (error) {
                    console.error('대화 내역 저장 오류:', error);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`대화 내역 저장 중 오류가 발생했습니다: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            else if (subCommand === 'list' || subCommand === 'ls' || subCommand === '목록') {
                // 저장된 모든 채팅 내역 목록 표시
                try {
                    // 워크스페이스 루트 경로 가져오기
                    const workspaceFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0];
                    if (!workspaceFolder) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('워크스페이스 폴더를 찾을 수 없습니다');
                        return;
                    }
                    // 채팅 내역 폴더 경로
                    const chatHistoryDir = path__WEBPACK_IMPORTED_MODULE_1__.join(workspaceFolder.uri.fsPath, 'vault', 'chat-history');
                    const chatHistoryUri = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.file(chatHistoryDir);
                    // 폴더 존재 확인
                    try {
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(chatHistoryUri);
                    }
                    catch {
                        // 폴더가 없는 경우
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                            role: 'assistant',
                            content: '저장된 대화 내역이 없습니다. `/chat save` 명령어를 사용하여 먼저 대화 내역을 저장해주세요.'
                        });
                        return;
                    }
                    // 저장된 모든 채팅 내역 목록 표시
                    await showChatList(chatHistoryUri);
                }
                catch (error) {
                    console.error('대화 내역 목록 표시 오류:', error);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`대화 내역 목록 표시 중 오류가 발생했습니다: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            else if (subCommand === 'show' || subCommand === 'view' || subCommand === '보기') {
                try {
                    // 워크스페이스 루트 경로 가져오기
                    const workspaceFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0];
                    if (!workspaceFolder) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('워크스페이스 폴더를 찾을 수 없습니다');
                        return;
                    }
                    // 채팅 내역 폴더 경로
                    const chatHistoryDir = path__WEBPACK_IMPORTED_MODULE_1__.join(workspaceFolder.uri.fsPath, 'vault', 'chat-history');
                    const chatHistoryUri = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.file(chatHistoryDir);
                    // 폴더 존재 확인
                    try {
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(chatHistoryUri);
                    }
                    catch {
                        // 폴더가 없는 경우
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                            role: 'assistant',
                            content: '저장된 대화 내역이 없습니다. `/chat save` 명령어를 사용하여 먼저 대화 내역을 저장해주세요.'
                        });
                        return;
                    }
                    // 채팅 ID 지정 여부
                    const chatId = context.args[1];
                    if (chatId) {
                        // 특정 채팅 내역 표시
                        await showSpecificChat(chatId, chatHistoryUri);
                    }
                    else {
                        // 저장된 모든 채팅 내역 목록 표시
                        await showChatList(chatHistoryUri);
                    }
                }
                catch (error) {
                    console.error('대화 내역 표시 오류:', error);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`대화 내역 표시 중 오류가 발생했습니다: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`알 수 없는 채팅 명령어입니다: ${subCommand}. 사용 가능한 명령어: save, list, show`);
            }
        },
        provideCompletions: (partialArgs) => {
            const subCommands = ['save', 'list', 'show', 'help', '저장', '목록', '보기', '도움말'];
            const parts = partialArgs.split(' ');
            // 첫 번째 인자 자동완성 (서브커맨드)
            if (parts.length <= 1) {
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(parts[0]?.toLowerCase() || ''));
            }
            return [];
        }
    });
    /**
     * 특정 채팅 내역 표시
     * @param chatId 채팅 ID
     * @param chatHistoryUri 채팅 내역 폴더 URI
     */
    async function showSpecificChat(chatId, chatHistoryUri) {
        // 메타데이터 파일 경로
        const metadataPath = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(chatHistoryUri, `${chatId}.meta.json`);
        // 채팅 내역 파일 경로
        const chatHistoryPath = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(chatHistoryUri, `${chatId}.md`);
        // 파일 존재 확인
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(metadataPath);
            await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(chatHistoryPath);
        }
        catch {
            // 파일이 없는 경우
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `ID가 '${chatId}'인 채팅 내역을 찾을 수 없습니다.`
            });
            return;
        }
        // 메타데이터 읽기
        const metadataData = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(metadataPath);
        const metadata = JSON.parse(Buffer.from(metadataData).toString('utf8'));
        // 채팅 내역 읽기
        const fileData = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(chatHistoryPath);
        const content = Buffer.from(fileData).toString('utf8');
        // 결과를 채팅창에 표시
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## ${metadata.title}\n\n\`\`\`markdown\n${content}\n\`\`\``
        });
    }
    /**
     * 저장된 채팅 내역 목록 표시
     * @param chatHistoryUri 채팅 내역 폴더 URI
     */
    async function showChatList(chatHistoryUri) {
        // 메타데이터 파일 목록 가져오기
        const files = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readDirectory(chatHistoryUri);
        const metaFiles = files.filter(([name]) => name.endsWith('.meta.json'));
        if (metaFiles.length === 0) {
            // 저장된 채팅 내역이 없는 경우
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: '저장된 대화 내역이 없습니다. `/save-chat` 명령어를 사용하여 먼저 대화 내역을 저장해주세요.'
            });
            return;
        }
        // 메타데이터 읽기
        const chatList = [];
        for (const [fileName] of metaFiles) {
            const metadataPath = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(chatHistoryUri, fileName);
            const metadataData = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(metadataPath);
            const metadata = JSON.parse(Buffer.from(metadataData).toString('utf8'));
            // 날짜 포맷팅
            const createdDate = new Date(metadata.createdAt);
            const dateStr = createdDate.toLocaleDateString();
            const timeStr = createdDate.toLocaleTimeString();
            chatList.push({
                id: metadata.id,
                title: metadata.title,
                createdAt: `${dateStr} ${timeStr}`,
                messageCount: metadata.messageCount
            });
        }
        // 최신순 정렬
        chatList.sort((a, b) => b.id.localeCompare(a.id));
        // 마크다운 테이블 생성
        let output = '## 저장된 채팅 내역 목록\n\n';
        output += '| 제목 | 저장 시간 | 메시지 수 | 명령어 |\n';
        output += '|------|-------|----------|--------|\n';
        for (const chat of chatList) {
            output += `| ${chat.title} | ${chat.createdAt} | ${chat.messageCount}개 | \`/show ${chat.id}\` |\n`;
        }
        output += '\n특정 채팅 내역을 보려면 위 명령어를 사용하세요.';
        // 결과를 채팅창에 표시
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: output
        });
    }
    return commands;
}


/***/ }),

/***/ "./src/core/commands/helpRenderer.ts":
/*!*******************************************!*\
  !*** ./src/core/commands/helpRenderer.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateCommandDetailHtml: () => (/* binding */ generateCommandDetailHtml),
/* harmony export */   generateFaqHtml: () => (/* binding */ generateFaqHtml),
/* harmony export */   generateGuideHtml: () => (/* binding */ generateGuideHtml),
/* harmony export */   generateGuidesListHtml: () => (/* binding */ generateGuidesListHtml),
/* harmony export */   generateHelpHtml: () => (/* binding */ generateHelpHtml),
/* harmony export */   generateSmartHelpHtml: () => (/* binding */ generateSmartHelpHtml),
/* harmony export */   generateToolsHelpHtml: () => (/* binding */ generateToolsHelpHtml),
/* harmony export */   getCommandData: () => (/* binding */ getCommandData),
/* harmony export */   getCommandsByCategory: () => (/* binding */ getCommandsByCategory),
/* harmony export */   loadHelpData: () => (/* binding */ loadHelpData),
/* harmony export */   setExtensionContext: () => (/* binding */ setExtensionContext)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _data_helpSystemPrompt__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/helpSystemPrompt */ "./src/data/helpSystemPrompt.ts");
/**
 * 도움말 렌더러
 *
 * 도움말 데이터를 웹뷰에 표시하기 위한 HTML로 변환합니다.
 */



// vscode 확장 인스턴스 캐시
// 현재 사용되지 않지만 향후 사용 가능성이 있어 주석으로 유지
// let _extensionContext: vscode.ExtensionContext | undefined;
/**
 * 확장 컨텍스트 설정
 */
function setExtensionContext() {
    // 지금은 사용되지 않지만 향후 확장성을 위해 유지
    // 매개변수도 제거
}
/**
 * 카테고리별 미니멀 아이콘 가져오기
 * @param category 카테고리 ID
 * @returns 미니멀 아이콘
 */
/* 현재 사용되지 않는 함수이지만 향후 사용 가능성이 있어 주석으로 유지
function getCategorySimpleIcon(category: string): string {
  switch (category) {
    case 'general':
      return '●';  // 일반 명령어 - 심플한 원형
    case 'git':
      return '◆';  // Git 명령어 - 다이아몬드
    case 'code':
      return '▢';  // 코드 관련 - 사각형
    case 'utility':
      return '◈';  // 유틸리티 - 특수 문자
    case 'advanced':
      return '◎';  // 고급 설정 - 이중 원형
    default:
      return '○';  // 기본값 - 빈 원형
  }
}
*/
/**
 * Codicon CSS 파일에 대한 URI 가져오기
 */
function getCodiconCssUri() {
    const extension = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape-team.ape-extension');
    if (!extension) {
        throw new Error('APE 확장을 찾을 수 없습니다');
    }
    return vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(extension.extensionUri, 'media', 'codicon', 'codicon.css');
}

// 도움말 데이터 캐시
let helpDataCache = null;
/**
 * 도움말 데이터 로드
 * @returns 도움말 데이터 객체
 */
async function loadHelpData() {
    if (helpDataCache) {
        return helpDataCache;
    }
    try {
        const extensionPath = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape-team.ape-extension')?.extensionPath;
        if (!extensionPath) {
            throw new Error('확장 프로그램 경로를 찾을 수 없습니다.');
        }
        const helpFilePath = path__WEBPACK_IMPORTED_MODULE_1__.join(extensionPath, 'src', 'data', 'help.json');
        const helpDataStr = fs__WEBPACK_IMPORTED_MODULE_2__.readFileSync(helpFilePath, 'utf8');
        helpDataCache = JSON.parse(helpDataStr);
        return helpDataCache;
    }
    catch (error) {
        console.error('도움말 데이터 로드 오류:', error);
        throw new Error('도움말 데이터를 로드할 수 없습니다.');
    }
}
/**
 * 특정 명령어 데이터 가져오기
 * @param commandName 명령어 이름
 * @returns 명령어 데이터 객체
 */
async function getCommandData(commandName) {
    try {
        const helpData = await loadHelpData();
        // 모든 카테고리 검색
        for (const category of helpData.categories) {
            // 카테고리 내 명령어 검색
            for (const command of category.commands) {
                // 명령어 이름 또는 별칭 매칭
                if (command.name === commandName || (command.aliases && command.aliases.includes(commandName))) {
                    return {
                        ...command,
                        category: category.id,
                        categoryName: category.name
                    };
                }
            }
        }
        return null;
    }
    catch (error) {
        console.error('명령어 데이터 검색 오류:', error);
        return null;
    }
}
/**
 * 카테고리별 명령어 목록 가져오기
 * @param categoryId 카테고리 ID (옵션)
 * @returns 카테고리별 명령어 목록
 */
async function getCommandsByCategory(categoryId) {
    try {
        const helpData = await loadHelpData();
        // 특정 카테고리 요청 시
        if (categoryId) {
            const category = helpData.categories.find((c) => c.id === categoryId);
            return category ? [category] : [];
        }
        // 모든 카테고리 반환
        return helpData.categories;
    }
    catch (error) {
        console.error('카테고리별 명령어 목록 가져오기 오류:', error);
        return [];
    }
}
/**
 * 도움말 HTML 생성 (기본 카테고리 목록)
 * @param categoryId 카테고리 ID (옵션)
 * @returns HTML 문자열
 */
async function generateHelpHtml(categoryId) {
    try {
        const categories = await getCommandsByCategory(categoryId);
        let content = `
      <h1>APE 도움말</h1>
      <p>사용 가능한 명령어 목록입니다. 각 명령어에 대한 자세한 정보를 보려면 명령어를 클릭하세요.</p>
      
      <div class="quick-actions">
        <h2>자주 사용하는 명령어</h2>
        <div class="quick-buttons">
          <button class="quick-button git" onclick="sendCommandToVSCode('git status')">
            <span class="codicon codicon-git-commit"></span>Git 상태
          </button>
          <button class="quick-button code" onclick="sendCommandToVSCode('analyze')">
            <span class="codicon codicon-code"></span>코드 분석
          </button>
          <button class="quick-button utility" onclick="sendCommandToVSCode('clear')">
            <span class="codicon codicon-clear-all"></span>채팅 지우기
          </button>
          <button class="quick-button model" onclick="sendCommandToVSCode('model list')">
            <span class="codicon codicon-settings-gear"></span>모델 선택
          </button>
        </div>
      </div>
    `;
        // 카테고리별 명령어 목록
        for (const category of categories) {
            content += `
        <div class="help-category">
          <h2>${category.name}</h2>
          <p>${category.description || ''}</p>
          <div class="command-grid">
      `;
            // 카테고리 내 명령어
            for (const command of category.commands) {
                // 명령어 아이콘 선택
                const iconName = getCategoryIcon(category.id);
                // 명령어 요약 카드
                content += `
          <div class="command-card" onclick="sendCommandToVSCode('${command.name}')">
            <div class="command-name">
              <span class="command-icon codicon codicon-${iconName}"></span>
              <span class="command-text">/${command.name}</span>
            </div>
            <div class="command-description">${command.description}</div>
            ${command.examples && command.examples.length > 0 ?
                    `<div class="command-examples">예시: ${command.examples[0]}</div>` : ''}
            ${command.aliases && command.aliases.length > 0 ?
                    `<div class="command-aliases">별칭: ${command.aliases.map((a) => `/${a}`).join(', ')}</div>` : ''}
          </div>
        `;
            }
            content += `
          </div>
        </div>
      `;
        }
        // 전체 HTML 래핑
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('도움말 HTML 생성 오류:', error);
        return getHelpPageHtml(`
      <h1>도움말 로드 오류</h1>
      <p>도움말 데이터를 로드하는 중 오류가 발생했습니다: ${error}</p>
    `);
    }
}
/**
 * 명령어 상세 정보 HTML 생성
 * @param commandName 명령어 이름
 * @returns HTML 문자열
 */
async function generateCommandDetailHtml(commandName) {
    try {
        const commandData = await getCommandData(commandName);
        if (!commandData) {
            return getHelpPageHtml(`
        <h1>명령어를 찾을 수 없음</h1>
        <p>'${commandName}' 명령어를 찾을 수 없습니다.</p>
        <p><a href="#" onclick="sendCommandToVSCode('help')">모든 명령어 보기</a></p>
      `);
        }
        let content = `
      <div class="command-detail">
        <h1>/${commandData.name}</h1>
        <div class="command-description">${commandData.description}</div>
        
        <h2>상세 정보</h2>
        <p>${commandData.longDescription || commandData.description}</p>
        
        <h2>사용법</h2>
        <div class="command-usage">
          <code>${commandData.usage || `/${commandData.name}`}</code>
        </div>
    `;
        // 예시
        if (commandData.examples && commandData.examples.length > 0) {
            content += `
        <h2>예시</h2>
        <ul class="command-examples-list">
          ${commandData.examples.map((example) => `<li><code>${example}</code></li>`).join('')}
        </ul>
      `;
        }
        // 별칭
        if (commandData.aliases && commandData.aliases.length > 0) {
            content += `
        <h2>별칭</h2>
        <div class="command-aliases">
          ${commandData.aliases.map((alias) => `<code>/${alias}</code>`).join(', ')}
        </div>
      `;
        }
        // 관련 명령어
        if (commandData.related && commandData.related.length > 0) {
            content += `
        <h2>관련 명령어</h2>
        <div class="related-commands">
          ${commandData.related.map((cmd) => `<a href="#" class="related-command" onclick="sendCommandToVSCode('${cmd}')">${cmd}</a>`).join(', ')}
        </div>
      `;
        }
        content += `
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">← 모든 명령어 보기</a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('명령어 상세 정보 HTML 생성 오류:', error);
        return getHelpPageHtml(`
      <h1>명령어 정보 로드 오류</h1>
      <p>명령어 정보를 로드하는 중 오류가 발생했습니다: ${error}</p>
    `);
    }
}
/**
 * FAQ HTML 생성
 * @returns HTML 문자열
 */
async function generateFaqHtml() {
    try {
        const helpData = await loadHelpData();
        const faqs = helpData.faq || [];
        let content = `
      <h1>APE 자주 묻는 질문 (FAQ)</h1>
      <div class="faq-list">
    `;
        for (const faq of faqs) {
            content += `
        <div class="faq-item">
          <div class="faq-question">${faq.question}</div>
          <div class="faq-answer">${faq.answer}</div>
        </div>
      `;
        }
        content += `
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">← 도움말로 돌아가기</a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('FAQ HTML 생성 오류:', error);
        return getHelpPageHtml(`
      <h1>FAQ 로드 오류</h1>
      <p>FAQ 데이터를 로드하는 중 오류가 발생했습니다: ${error}</p>
    `);
    }
}
/**
 * 가이드 문서 HTML 생성
 * @param guideId 가이드 ID
 * @returns HTML 문자열
 */
async function generateGuideHtml(guideId) {
    try {
        const helpData = await loadHelpData();
        const guides = helpData.guides || [];
        const guide = guides.find((g) => g.id === guideId);
        if (!guide) {
            return getHelpPageHtml(`
        <h1>가이드를 찾을 수 없음</h1>
        <p>'${guideId}' 가이드를 찾을 수 없습니다.</p>
        <p><a href="#" onclick="sendCommandToVSCode('help guides')">모든 가이드 보기</a></p>
      `);
        }
        // 마크다운 형식 그대로 표시
        const content = `
      <div class="guide-content markdown-body">
        ${guide.content}
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help guides')">← 모든 가이드 보기</a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('가이드 HTML 생성 오류:', error);
        return getHelpPageHtml(`
      <h1>가이드 로드 오류</h1>
      <p>가이드 데이터를 로드하는 중 오류가 발생했습니다: ${error}</p>
    `);
    }
}
/**
 * 모든 가이드 목록 HTML 생성
 * @returns HTML 문자열
 */
async function generateGuidesListHtml() {
    try {
        const helpData = await loadHelpData();
        const guides = helpData.guides || [];
        let content = `
      <h1>APE 가이드 문서</h1>
      <p>사용 가능한 가이드 문서 목록입니다. 각 가이드에 대한 자세한 정보를 보려면 제목을 클릭하세요.</p>
      <div class="guides-list">
    `;
        for (const guide of guides) {
            content += `
        <div class="guide-item">
          <h2 class="guide-title">
            <a href="#" onclick="sendCommandToVSCode('help guide ${guide.id}')">${guide.title}</a>
          </h2>
          <div class="guide-description">
            ${guide.content.split('\n')[0].replace(/^#+\s+.*$/, '')}
          </div>
        </div>
      `;
        }
        content += `
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">← 도움말로 돌아가기</a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('가이드 목록 HTML 생성 오류:', error);
        return getHelpPageHtml(`
      <h1>가이드 목록 로드 오류</h1>
      <p>가이드 목록을 로드하는 중 오류가 발생했습니다: ${error}</p>
    `);
    }
}
/**
 * LLM을 사용한 스마트 도움말 생성
 * @param query 사용자 질문
 * @param llmService LLM 서비스 인스턴스
 * @returns HTML 문자열
 */
async function generateSmartHelpHtml(query, llmService) {
    try {
        const helpData = await loadHelpData();
        // LLM 프롬프트 생성
        const prompt = (0,_data_helpSystemPrompt__WEBPACK_IMPORTED_MODULE_3__.generateHelpSystemPrompt)(helpData, query);
        // LLM에 질문 전송
        const result = await llmService.getCompletion(prompt);
        if (!result.success || !result.data) {
            throw new Error(result.error?.message || 'LLM 응답을 받을 수 없습니다.');
        }
        // 마크다운 응답을 HTML로 변환
        const markdownResponse = result.data;
        const content = `
      <div class="smart-help">
        <h1>APE 도움말 - ${escapeHtml(query)}</h1>
        <div class="markdown-body">
          ${markdownToHtml(markdownResponse)}
        </div>
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">← 도움말로 돌아가기</a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('스마트 도움말 생성 오류:', error);
        return getHelpPageHtml(`
      <h1>도움말 응답 오류</h1>
      <p>도움말을 생성하는 중 오류가 발생했습니다: ${error}</p>
      <p><a href="#" onclick="sendCommandToVSCode('help')">도움말로 돌아가기</a></p>
    `);
    }
}
/**
 * 도움말 페이지 HTML 래핑
 * @param content 내용 HTML
 * @returns 완성된 HTML 문자열
 */
function getHelpPageHtml(content) {
    return `
    <!DOCTYPE html>
    <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>APE 도움말</title>
      <link rel="stylesheet" href="${getCodiconCssUri().toString()}" />
      <style>
        :root {
          /* 기본 색상 변수 */
          --bg-color: var(--vscode-editor-background, #ffffff);
          --text-color: var(--vscode-editor-foreground, #333333);
          --link-color: var(--vscode-textLink-foreground, #3794ff);
          --heading-color: var(--vscode-editor-foreground, #333333);
          --border-color: var(--vscode-panel-border, #e7e7e7);
          --accent-color: var(--vscode-button-background, #0e639c);
          --accent-hover-color: var(--vscode-button-hoverBackground, #1177bb);
          --card-bg-color: var(--vscode-editor-inactiveSelectionBackground, #f5f5f5);
          --code-bg-color: var(--vscode-textBlockQuote-background, #f1f1f1);

          /* 구찌 & 에르메스 럭셔리 테마 색상 */
          --gucci-green: #006837;
          --gucci-green-light: #007f45;
          --gucci-green-dark: #004d27;
          --hermes-orange: #ff6600;
          --hermes-orange-light: #ff8533;
          --hermes-orange-dark: #cc5200;
          --luxury-gold: #d4af37;
          --luxury-silver: #c0c0c0;
          --luxury-bg-dark: #1a1a1a;
          --luxury-bg-light: #f5f5f5;

          /* 섬세한 박스 그림자 */
          --luxury-shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.06);
          --luxury-shadow-md: 0 6px 16px rgba(0, 0, 0, 0.1);
          --luxury-shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);
          --luxury-glow: 0 0 20px rgba(0, 104, 55, 0.08);

          /* 우아한 전환 효과 */
          --luxury-transition: 400ms cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
          line-height: 1.6;
          color: var(--text-color);
          background-color: var(--bg-color);
          margin: 0;
          padding: 20px;
          max-width: 1000px;
          margin: 0 auto;
          letter-spacing: -0.01em;
        }

        h1, h2, h3, h4, h5, h6 {
          color: var(--heading-color);
          margin-top: 24px;
          margin-bottom: 16px;
          font-weight: 600;
          line-height: 1.25;
          letter-spacing: -0.02em;
        }

        h1 {
          font-size: 2em;
          padding-bottom: 0.3em;
          border-bottom: 1px solid var(--gucci-green);
          position: relative;
        }

        h1::after {
          content: '';
          position: absolute;
          bottom: -1px;
          left: 0;
          width: 80px;
          height: 3px;
          background-color: var(--hermes-orange);
        }

        h2 {
          font-size: 1.5em;
          padding-bottom: 0.3em;
          color: var(--gucci-green);
        }

        a {
          color: var(--hermes-orange);
          text-decoration: none;
          transition: color var(--luxury-transition), transform var(--luxury-transition);
          display: inline-block;
        }

        a:hover {
          color: var(--hermes-orange-light);
          transform: translateY(-1px);
        }

        p {
          margin-top: 0;
          margin-bottom: 16px;
        }

        code {
          font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, Courier, monospace;
          padding: 0.2em 0.4em;
          margin: 0;
          font-size: 85%;
          background-color: var(--code-bg-color);
          border-radius: 3px;
        }

        pre {
          background-color: var(--code-bg-color);
          border-radius: 3px;
          padding: 16px;
          overflow: auto;
        }

        pre code {
          background-color: transparent;
          padding: 0;
          margin: 0;
          font-size: 100%;
          word-break: normal;
          white-space: pre;
        }

        ul, ol {
          margin-top: 0;
          margin-bottom: 16px;
          padding-left: 2em;
        }

        li {
          margin-top: 0.25em;
        }

        .help-category {
          margin-bottom: 40px;
        }

        .command-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
          gap: 16px;
          margin-bottom: 30px;
        }

        .command-card {
          background-color: var(--card-bg-color);
          border-radius: 8px;
          padding: 20px;
          cursor: pointer;
          transition: all var(--luxury-transition);
          border: 1px solid transparent;
          box-shadow: var(--luxury-shadow-sm);
          position: relative;
          overflow: hidden;
        }

        .command-card:hover {
          transform: translateY(-3px);
          box-shadow: var(--luxury-shadow-md);
          border-color: var(--gucci-green-light);
        }

        .command-card::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 4px;
          height: 100%;
          background-color: var(--gucci-green);
          opacity: 0;
          transition: opacity var(--luxury-transition);
        }

        .command-card:hover::before {
          opacity: 1;
        }

        .command-card::after {
          content: '';
          position: absolute;
          bottom: 0;
          right: 0;
          width: 30px;
          height: 1px;
          background-color: var(--hermes-orange);
          transition: width var(--luxury-transition);
        }

        .command-card:hover::after {
          width: 60px;
        }

        .clickable-command {
          cursor: pointer;
          transition: all var(--luxury-transition);
          padding: 2px 6px;
          border-radius: 3px;
        }

        .clickable-command:hover {
          color: var(--hermes-orange);
          background-color: rgba(255, 102, 0, 0.1);
        }

        .command-name {
          font-weight: bold;
          margin-bottom: 12px;
          color: var(--gucci-green);
          font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, Courier, monospace;
          font-size: 1.1em;
          display: flex;
          align-items: center;
          letter-spacing: 0.02em;
        }

        .command-description {
          margin-bottom: 12px;
          color: var(--text-color);
          line-height: 1.5;
        }

        .command-examples {
          font-size: 0.85em;
          color: var(--vscode-descriptionForeground, #747474);
          font-style: italic;
          padding: 4px 0;
          border-left: 2px solid rgba(0, 104, 55, 0.2);
          padding-left: 8px;
          margin-top: 8px;
        }

        .command-aliases {
          font-size: 0.85em;
          color: var(--vscode-descriptionForeground, #747474);
          background-color: rgba(0, 104, 55, 0.08);
          border-radius: 4px;
          padding: 3px 8px;
          display: inline-block;
          margin-top: 6px;
          transition: background-color var(--luxury-transition);
        }

        .command-card:hover .command-aliases {
          background-color: rgba(0, 104, 55, 0.15);
        }

        .command-icon {
          font-size: 1.1em;
          margin-right: 8px;
          position: relative;
          top: 1px;
          color: var(--gucci-green-dark);
          transition: transform var(--luxury-transition);
        }

        .command-card:hover .command-icon {
          transform: scale(1.1);
        }

        .command-text {
          font-weight: bold;
          position: relative;
        }

        .command-usage {
          margin-bottom: 18px;
          background-color: rgba(0, 104, 55, 0.05);
          padding: 8px 12px;
          border-radius: 6px;
          border-left: 3px solid var(--gucci-green);
        }

        .command-aliases, .related-commands {
          margin-bottom: 18px;
        }

        .related-command {
          margin-right: 10px;
          background-color: rgba(255, 102, 0, 0.08);
          padding: 4px 10px;
          border-radius: 4px;
          transition: all var(--luxury-transition);
          display: inline-block;
        }

        .related-command:hover {
          background-color: rgba(255, 102, 0, 0.15);
          transform: translateY(-2px);
          text-decoration: none;
        }

        .back-link {
          margin-top: 30px;
          padding-top: 20px;
          border-top: 1px solid var(--border-color);
        }

        .back-link a {
          display: inline-flex;
          align-items: center;
          color: var(--gucci-green);
          font-weight: 500;
          padding: 6px 14px;
          border-radius: 4px;
          background-color: rgba(0, 104, 55, 0.05);
          transition: all var(--luxury-transition);
        }

        .back-link a:hover {
          background-color: rgba(0, 104, 55, 0.1);
          transform: translateY(-2px);
          box-shadow: var(--luxury-shadow-sm);
          text-decoration: none;
        }

        .back-link a::before {
          content: '←';
          margin-right: 8px;
          font-size: 1.1em;
          transition: transform var(--luxury-transition);
        }

        .back-link a:hover::before {
          transform: translateX(-3px);
        }

        .faq-list {
          margin-top: 30px;
        }

        .faq-item {
          margin-bottom: 28px;
          border-bottom: 1px solid rgba(0, 104, 55, 0.1);
          padding-bottom: 20px;
          transition: transform var(--luxury-transition);
        }

        .faq-item:hover {
          transform: translateY(-2px);
        }

        .faq-question {
          font-weight: 600;
          font-size: 1.2em;
          margin-bottom: 10px;
          color: var(--gucci-green);
          position: relative;
          padding-left: 16px;
        }

        .faq-question::before {
          content: '';
          position: absolute;
          left: 0;
          top: 50%;
          transform: translateY(-50%);
          width: 6px;
          height: 6px;
          background-color: var(--hermes-orange);
          border-radius: 50%;
        }

        .faq-answer {
          padding-left: 16px;
        }

        .guides-list {
          margin-top: 30px;
        }

        .guide-item {
          margin-bottom: 28px;
          border-bottom: 1px solid rgba(0, 104, 55, 0.1);
          padding-bottom: 20px;
          transition: all var(--luxury-transition);
        }

        .guide-item:hover {
          border-bottom-color: var(--gucci-green-light);
          transform: translateY(-2px);
        }

        .guide-title {
          margin-bottom: 10px;
          color: var(--gucci-green);
        }

        .guide-title a {
          text-decoration: none;
          color: var(--gucci-green);
          transition: color var(--luxury-transition);
          font-weight: 600;
          display: inline-block;
          padding-bottom: 2px;
          border-bottom: 1px solid transparent;
        }

        .guide-title a:hover {
          color: var(--gucci-green-light);
          border-bottom-color: var(--hermes-orange-light);
        }

        .guide-description {
          margin-bottom: 10px;
          color: var(--text-color);
        }

        .markdown-body {
          line-height: 1.6;
        }

        .markdown-body img {
          max-width: 100%;
          box-sizing: content-box;
          border-radius: 6px;
          box-shadow: var(--luxury-shadow-sm);
        }

        .markdown-body blockquote {
          padding: 0.5em 1em;
          color: var(--vscode-editor-foreground, #6a737d);
          border-left: 3px solid var(--gucci-green-light);
          margin: 0 0 16px 0;
          background-color: rgba(0, 104, 55, 0.05);
          border-radius: 0 4px 4px 0;
        }

        .markdown-body table {
          display: block;
          width: 100%;
          overflow: auto;
          border-collapse: collapse;
          margin-bottom: 16px;
          border-radius: 6px;
          overflow: hidden;
          box-shadow: var(--luxury-shadow-sm);
        }

        .markdown-body table th,
        .markdown-body table td {
          padding: 8px 16px;
          border: 1px solid var(--vscode-panel-border, #dfe2e5);
        }

        .markdown-body table th {
          background-color: rgba(0, 104, 55, 0.1);
          font-weight: 600;
        }

        .markdown-body table tr {
          background-color: var(--bg-color);
          border-top: 1px solid var(--vscode-panel-border, #c6cbd1);
          transition: background-color var(--luxury-transition);
        }

        .markdown-body table tr:hover {
          background-color: rgba(0, 104, 55, 0.03);
        }

        .markdown-body table tr:nth-child(2n) {
          background-color: var(--vscode-editor-inactiveSelectionBackground, #f6f8fa);
        }

        .markdown-body table tr:nth-child(2n):hover {
          background-color: rgba(0, 104, 55, 0.05);
        }

        /* 퀵 액션 스타일 */
        .quick-actions {
          margin: 30px 0 40px;
          background-color: rgba(0, 104, 55, 0.04);
          border-radius: 10px;
          padding: 24px;
          border: 1px solid rgba(0, 104, 55, 0.1);
          position: relative;
          box-shadow: var(--luxury-shadow-sm);
          transition: box-shadow var(--luxury-transition), transform var(--luxury-transition);
        }

        .quick-actions:hover {
          box-shadow: var(--luxury-shadow-md);
          transform: translateY(-2px);
        }

        .quick-actions::after {
          content: '';
          position: absolute;
          top: 0;
          right: 0;
          width: 40px;
          height: 3px;
          background-color: var(--hermes-orange);
          border-radius: 0 10px 0 10px;
        }

        .quick-actions h2 {
          margin-top: 0;
          font-size: 1.4em;
          color: var(--gucci-green);
          margin-bottom: 20px;
          letter-spacing: -0.01em;
        }

        .quick-buttons {
          display: flex;
          flex-wrap: wrap;
          gap: 14px;
        }

        .quick-button {
          display: flex;
          align-items: center;
          padding: 10px 18px;
          border-radius: 6px;
          cursor: pointer;
          font-weight: 500;
          border: none;
          min-width: 130px;
          font-size: 0.95em;
          transition: all var(--luxury-transition);
          color: white;
          letter-spacing: 0.01em;
          box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .quick-button:hover {
          transform: translateY(-3px);
          box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .quick-button .codicon {
          margin-right: 10px;
          font-size: 1.2em;
          transition: transform var(--luxury-transition);
        }

        .quick-button:hover .codicon {
          transform: scale(1.1);
        }

        .quick-button.git {
          background: linear-gradient(135deg, var(--gucci-green) 0%, var(--gucci-green-dark) 100%);
          border: 1px solid rgba(0, 104, 55, 0.3);
        }

        .quick-button.code {
          background: linear-gradient(135deg, var(--hermes-orange) 0%, var(--hermes-orange-dark) 100%);
          border: 1px solid rgba(255, 102, 0, 0.3);
        }

        .quick-button.utility {
          background: linear-gradient(135deg, var(--gucci-green-light) 0%, var(--gucci-green) 100%);
          border: 1px solid rgba(0, 104, 55, 0.3);
        }

        .quick-button.model {
          background: linear-gradient(135deg, var(--hermes-orange-light) 0%, var(--hermes-orange) 100%);
          border: 1px solid rgba(255, 102, 0, 0.3);
        }
      </style>
    </head>
    <body>
      <div class="help-content">
        ${content}
      </div>
      
      <script>
        // VS Code API와 통신
        const vscode = acquireVsCodeApi();
        
        // 명령어 VS Code로 전송
        function sendCommandToVSCode(command) {
          vscode.postMessage({
            type: 'command',
            command: command
          });
        }
        
        // 채팅창에 명령어 입력
        function insertCommandToChatInput(command) {
          vscode.postMessage({
            type: 'insertCommand',
            command: command
          });
        }
        
        // 명령어 카드 클릭 시 명령어 입력
        document.addEventListener('click', (event) => {
          const target = event.target;
          
          // 명령어 카드 클릭 처리
          const commandCard = target.closest('.command-card');
          if (commandCard) {
            const cmdName = commandCard.querySelector('.command-name')?.textContent;
            if (cmdName) {
              insertCommandToChatInput(cmdName);
            }
          }
          
          // A 태그 이벤트 처리
          if (target.tagName === 'A' && target.getAttribute('href') === '#') {
            event.preventDefault();
            // 이벤트 처리는 각 요소의 onclick에서 처리
          }
        });
        
        // 코드 블록 내 명령어 클릭 처리
        document.querySelectorAll('code').forEach(codeElement => {
          if (codeElement.textContent.startsWith('/')) {
            codeElement.classList.add('clickable-command');
            codeElement.addEventListener('click', () => {
              insertCommandToChatInput(codeElement.textContent);
            });
          }
        });
      </script>
    </body>
    </html>
  `;
}
/**
 * HTML 이스케이프
 * @param unsafe 이스케이프할 문자열
 * @returns 이스케이프된 문자열
 */
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}
/**
 * 카테고리별 Codicon 아이콘 이름 가져오기
 * @param category 카테고리 ID
 * @returns Codicon 아이콘 이름
 */
function getCategoryIcon(category) {
    switch (category) {
        case 'general':
            return 'info';
        case 'git':
            return 'git-commit';
        case 'code':
            return 'code';
        case 'utility':
            return 'tools';
        case 'advanced':
            return 'settings-gear';
        default:
            return 'symbol-event';
    }
}
/**
 * 도구별 미니멀 아이콘 가져오기
 * @param toolName 도구 이름
 * @returns 미니멀 아이콘
 */
function getToolEmoji(toolName) {
    switch (toolName) {
        case 'Bash':
            return '▶'; // 터미널 실행
        case 'Batch':
            return '⧉'; // 병렬 실행
        case 'Glob':
            return '◎'; // 검색 조회
        case 'Grep':
            return '⌕'; // 내용 검색
        case 'LS':
            return '⊞'; // 디렉토리 목록
        case 'Read':
            return '◯'; // 파일 읽기
        case 'Edit':
            return '✎'; // 편집
        case 'MultiEdit':
            return '⧠'; // 다중 편집
        case 'Write':
            return '⊕'; // 새 파일 생성
        case 'TodoRead':
            return '☰'; // 할일 목록
        case 'TodoWrite':
            return '✓'; // 할일 완료
        case 'WebFetch':
            return '⇥'; // 웹 가져오기
        case 'WebSearch':
            return '⌕'; // 웹 검색
        case 'Task':
            return '◈'; // 작업 실행
        default:
            return '◇'; // 기본 도구
    }
}
/**
 * 마크다운을 HTML로 변환 (간단 구현)
 */
function markdownToHtml(markdown) {
    return markdown
        // 헤더 변환
        .replace(/^# (.+)$/gm, '<h1>$1</h1>')
        .replace(/^## (.+)$/gm, '<h2>$1</h2>')
        .replace(/^### (.+)$/gm, '<h3>$1</h3>')
        .replace(/^#### (.+)$/gm, '<h4>$1</h4>')
        .replace(/^##### (.+)$/gm, '<h5>$1</h5>')
        .replace(/^###### (.+)$/gm, '<h6>$1</h6>')
        // 코드 블록 변환
        .replace(/```([a-z]*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>')
        // 인라인 코드 변환
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        // 볼드 텍스트 변환
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/__([^_]+)__/g, '<strong>$1</strong>')
        // 이탤릭 텍스트 변환
        .replace(/\*([^*]+)\*/g, '<em>$1</em>')
        .replace(/_([^_]+)_/g, '<em>$1</em>')
        // 목록 변환
        .replace(/^- (.+)$/gm, '<li>$1</li>')
        .replace(/^([0-9]+)\. (.+)$/gm, '<li>$2</li>')
        .replace(/(<li>.*<\/li>\n)+/g, '<ul>$&</ul>')
        // 링크 변환
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
        // 줄바꿈 변환
        .replace(/\n\n/g, '</p><p>')
        .replace(/\n/g, '<br>')
        // 단락 감싸기
        .replace(/^(.+?)(?=<\/p>|<h[1-6]|<ul>|$)/s, '<p>$1</p>');
}
/**
 * Agent 도구 목록 HTML 생성
 * @returns HTML 문자열
 */
async function generateToolsHelpHtml() {
    try {
        // 도구 페이지 스타일
        const toolsPageStyle = `
      .tools-page {
        max-width: 900px;
        margin: 0 auto;
        padding: 10px 0;
      }
      
      .tools-page h1 {
        text-align: center;
        margin-bottom: 30px;
        color: var(--vscode-editor-foreground);
        font-size: 32px;
      }
      
      .tools-page p {
        text-align: center;
        margin-bottom: 40px;
        line-height: 1.6;
        color: var(--text-color);
        opacity: 0.8;
      }
      
      .tools-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 24px;
        margin-bottom: 40px;
      }
      
      .tool-card {
        background-color: var(--bg-color);
        border-radius: var(--modern-radius);
        padding: 24px;
        box-shadow: var(--modern-card-shadow);
        transition: var(--modern-transition);
        border: 1px solid rgba(0, 0, 0, 0.05);
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      
      .tool-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(90deg, var(--modern-accent), #7C4DFF);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .tool-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
      }
      
      .tool-card:hover::before {
        opacity: 1;
      }
      
      .tool-header {
        display: flex;
        align-items: center;
        margin-bottom: 16px;
      }
      
      .tool-icon {
        margin-right: 12px;
        font-size: 24px;
        color: var(--modern-accent);
        background-color: var(--modern-accent-light);
        width: 40px;
        height: 40px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: var(--modern-transition);
      }
      
      .tool-card:hover .tool-icon {
        transform: scale(1.1);
        background-color: var(--modern-accent);
        color: white;
      }
      
      .tool-icon-svg {
        width: 24px;
        height: 24px;
        filter: var(--vscode-editor-foreground-filter, none);
      }
      
      .tool-name {
        font-size: 18px;
        font-weight: 600;
        color: var(--heading-color);
      }
      
      .tool-description {
        font-size: 14px;
        color: var(--text-color);
        opacity: 0.8;
        line-height: 1.6;
        margin-bottom: 16px;
      }
      
      .tool-examples {
        background-color: var(--card-bg-color);
        border-radius: 8px;
        padding: 10px;
      }
      
      .tool-examples-title {
        font-size: 13px;
        font-weight: 600;
        color: var(--heading-color);
        margin-bottom: 8px;
      }
      
      .tool-examples-list {
        font-size: 12px;
        color: var(--text-color);
        opacity: 0.8;
        line-height: 1.5;
      }
      
      .tool-examples-list li {
        margin-bottom: 4px;
      }
      
      /* 다크 모드 조정 */
      .vscode-dark .tool-card {
        background-color: var(--bg-color);
        border-color: rgba(255, 255, 255, 0.1);
      }
      
      .vscode-dark .tool-examples {
        background-color: rgba(30, 30, 30, 0.6);
      }
      
      /* 반응형 */
      @media (max-width: 768px) {
        .tools-grid {
          grid-template-columns: 1fr;
        }
      }
    `;
        // 도구 데이터 목록
        const tools = [
            {
                name: 'Bash',
                description: '쉘 명령을 실행하여 파일 시스템을 조작하고 시스템 작업을 수행합니다.',
                icon: 'terminal',
                examples: ['디렉터리 내용 나열', '파일 이동 및 복사', '시스템 정보 조회']
            },
            {
                name: 'Batch',
                description: '여러 도구 호출을 병렬로 실행하여 작업 속도를 향상시킵니다.',
                icon: 'layers',
                examples: ['여러 파일 동시 읽기', '복수 Bash 명령 실행', '병렬 검색 수행']
            },
            {
                name: 'Glob',
                description: '패턴 매칭을 사용하여 파일 시스템에서 파일을 검색합니다.',
                icon: 'filter',
                examples: ['.js 파일 찾기', '특정 디렉터리 내 파일 검색', '제외 패턴 사용']
            },
            {
                name: 'Grep',
                description: '파일 내용에서 정규식 패턴을 검색합니다.',
                icon: 'search',
                examples: ['함수 정의 찾기', '오류 메시지 검색', '코드 패턴 식별']
            },
            {
                name: 'LS',
                description: '디렉터리 내용을 나열하여 파일과 폴더를 표시합니다.',
                icon: 'folder-opened',
                examples: ['디렉터리 구조 확인', '숨겨진 파일 표시', '파일 메타데이터 확인']
            },
            {
                name: 'Read',
                description: '파일 내용을 읽어 텍스트로 표시합니다.',
                icon: 'preview',
                examples: ['소스 코드 읽기', '구성 파일 검사', '로그 파일 분석']
            },
            {
                name: 'Edit',
                description: '파일 내용을 수정하고 변경 사항을 저장합니다.',
                icon: 'edit',
                examples: ['코드 버그 수정', '구성 설정 업데이트', '문서 수정']
            },
            {
                name: 'MultiEdit',
                description: '여러 편집 작업을 단일 파일에 원자적으로 적용합니다.',
                icon: 'multiple-edit',
                examples: ['여러 코드 섹션 수정', '클래스/함수 이름 변경', '여러 버그 한 번에 수정']
            },
            {
                name: 'Write',
                description: '새 파일을 생성하거나 기존 파일을 덮어씁니다.',
                icon: 'new-file',
                examples: ['새 소스 파일 생성', '구성 파일 작성', '로그 파일 생성']
            },
            {
                name: 'WebFetch',
                description: '웹 URL에서 콘텐츠를 가져와 분석합니다.',
                icon: 'globe',
                examples: ['API 문서 읽기', '웹 페이지 콘텐츠 분석', '외부 데이터 가져오기']
            },
            {
                name: 'WebSearch',
                description: '인터넷에서 최신 정보를 검색합니다.',
                icon: 'web-search',
                examples: ['기술 문서 찾기', '오류 솔루션 검색', '라이브러리 사용법 검색']
            },
            {
                name: 'TodoRead',
                description: '세션의 현재 할 일 목록을 읽습니다.',
                icon: 'list-selection',
                examples: ['작업 진행 상황 확인', '남은 작업 파악', '작업 우선순위 확인']
            },
            {
                name: 'TodoWrite',
                description: '할 일 목록을 업데이트하고 작업 상태를 관리합니다.',
                icon: 'checklist',
                examples: ['새 작업 추가', '작업 상태 업데이트', '완료된 작업 표시']
            },
            {
                name: 'Task',
                description: '하위 에이전트를 실행하여 독립적인 작업을 수행합니다.',
                icon: 'agent',
                examples: ['코드베이스 검색', '복잡한의 작업 위임', '배경 분석 수행']
            }
        ];
        // HTML 생성
        let content = `
      <div class="tools-page">
        <h1>APE 지원 도구</h1>
        <p>APE에서 사용할 수 있는 다양한 Agent 도구 목록입니다. 이러한 도구를 활용하여 코드 작성, 검색, 분석 등 다양한 작업을 수행할 수 있습니다.</p>
        
        <div class="tools-grid">
    `;
        // 각 도구별 카드 생성
        for (const tool of tools) {
            // 미니멀 아이콘 사용
            const iconEmoji = getToolEmoji(tool.name);
            const iconHtml = `<div class="tool-icon minimal-icon">${iconEmoji}</div>`;
            content += `
        <div class="tool-card">
          <div class="tool-header">
            ${iconHtml}
            <div class="tool-name">${tool.name}</div>
          </div>
          <div class="tool-description">${tool.description}</div>
          
          <div class="tool-examples">
            <div class="tool-examples-title">주요 사용 사례</div>
            <ul class="tool-examples-list">
              ${tool.examples.map(ex => `<li>${ex}</li>`).join('')}
            </ul>
          </div>
        </div>
      `;
        }
        content += `
        </div>
        
        <div class="back-link">
          <a href="#" onclick="sendCommandToVSCode('help')">← 도움말로 돌아가기</a>
        </div>
      </div>
    `;
        // 전체 HTML 생성
        return getHelpPageHtml(toolsPageStyle + content);
    }
    catch (error) {
        console.error('Agent 도구 HTML 생성 오류:', error);
        return getHelpPageHtml(`
      <h1>도구 목록 로드 오류</h1>
      <p>도구 목록을 로드하는 중 오류가 발생했습니다: ${error}</p>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">← 도움말로 돌아가기</a>
      </div>
    `);
    }
}


/***/ }),

/***/ "./src/core/commands/jiraCommands.ts":
/*!*******************************************!*\
  !*** ./src/core/commands/jiraCommands.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createJiraCommands: () => (/* binding */ createJiraCommands)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _services_jiraService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/jiraService */ "./src/core/services/jiraService.ts");
/**
 * Jira 관련 슬래시 명령어 정의
 */


/**
 * Jira 명령어 생성
 */
function createJiraCommands(jiraService) {
    const commands = [];
    // Jira 메인 명령어
    commands.push({
        name: 'jira',
        aliases: ['j', '지라', '이슈'],
        description: 'Jira 이슈 관련 작업을 수행합니다',
        examples: ['/jira search', '/jira create', '/jira summary', '/jira status', '/지라 검색'],
        category: 'utility',
        priority: 8,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand) {
                // 하위 명령어 없이 사용시 도움말 표시
                const helpMessage = `
## Jira 명령어 도움말

Jira 관련 작업을 수행하기 위한 명령어입니다. 다음과 같은 하위 명령어를 사용할 수 있습니다:

- **/jira create** - 새 Jira 이슈를 생성합니다
- **/jira search** - Jira 이슈를 검색합니다
- **/jira summary** - 프로젝트 요약 정보를 표시합니다
- **/jira status** - Jira 이슈의 상태를 변경합니다

사용 예시: \`/jira search APE-\`, \`/jira create\`, \`/jira summary APE\`, \`/jira status APE-123 in-progress\`
        `;
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: helpMessage
                });
                return;
            }
            // 하위 명령어 처리
            switch (subCommand) {
                case 'create':
                case '생성':
                case '만들기':
                    await handleJiraCreate(jiraService);
                    break;
                case 'search':
                case '검색':
                case '찾기':
                    await handleJiraSearch(jiraService, context);
                    break;
                case 'summary':
                case '요약':
                case '통계':
                    await handleJiraSummary(jiraService, context);
                    break;
                case 'status':
                case '상태':
                case '변경':
                case 'update':
                    await handleJiraStatus(jiraService, context);
                    break;
                default:
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`알 수 없는 Jira 하위 명령어: ${subCommand}`);
                    break;
            }
        },
        provideCompletions: (partialArgs) => {
            const parts = partialArgs.split(' ');
            // 첫 번째 인자 자동완성 (하위 명령어)
            if (parts.length <= 1) {
                const subCommands = ['create', 'search', 'summary', 'status', '생성', '검색', '요약', '상태', '변경'];
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(parts[0]?.toLowerCase() || ''));
            }
            // 하위 명령어에 따른 자동완성
            const subCommand = parts[0].toLowerCase();
            if (subCommand === 'search' || subCommand === '검색') {
                // 검색어 자동완성은 제공하지 않음
                return [];
            }
            else if (subCommand === 'summary' || subCommand === '요약') {
                // 프로젝트 키 자동완성은 제공하지 않음 (무수히 많을 수 있음)
                return [];
            }
            else if (subCommand === 'status' || subCommand === '상태' || subCommand === '변경') {
                // 이슈 키 자동완성은 제공하지 않음
                if (parts.length === 3) {
                    // 상태 값 자동완성
                    const statusValues = ['todo', 'in-progress', 'in-review', 'done', 'blocked'];
                    return statusValues.filter(status => status.startsWith(parts[2].toLowerCase()));
                }
            }
            return [];
        }
    });
    return commands;
}
/**
 * Jira 이슈 상태 변경 처리
 */
async function handleJiraStatus(jiraService, context) {
    if (!jiraService) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Jira 서비스를 사용할 수 없습니다');
        return;
    }
    try {
        // 상태 변경에 필요한 파라미터 확인 (이슈 키와 새 상태)
        const statusArgs = context?.args.slice(1) || [];
        if (statusArgs.length < 1) {
            // 이슈 키 입력 받기
            const issueKey = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: 'Jira 이슈 키를 입력하세요',
                placeHolder: '예: APE-123, PROJ-456 등'
            });
            if (!issueKey)
                return; // 취소됨
            // 상태값 선택하기
            const status = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick([
                { label: '할일', value: 'todo' },
                { label: '진행중', value: 'in-progress' },
                { label: '검토중', value: 'in-review' },
                { label: '완료', value: 'done' },
                { label: '차단됨', value: 'blocked' }
            ], { placeHolder: '변경할 상태를 선택하세요' });
            if (!status)
                return; // 취소됨
            // 상태 변경 실행
            return await executeStatusChange(jiraService, issueKey, status.value);
        }
        else {
            const issueKey = statusArgs[0];
            let status;
            if (statusArgs.length < 2) {
                // 상태값 선택하기
                const selectedStatus = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick([
                    { label: '할일', value: 'todo' },
                    { label: '진행중', value: 'in-progress' },
                    { label: '검토중', value: 'in-review' },
                    { label: '완료', value: 'done' },
                    { label: '차단됨', value: 'blocked' }
                ], { placeHolder: '변경할 상태를 선택하세요' });
                if (!selectedStatus)
                    return; // 취소됨
                status = selectedStatus.value;
            }
            else {
                status = statusArgs[1].toLowerCase();
            }
            // 상태 변경 실행
            return await executeStatusChange(jiraService, issueKey, status);
        }
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Jira 이슈 상태 변경 오류: ${error instanceof Error ? error.message : String(error)}`);
        // 채팅에 오류 표시
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira 이슈 상태 변경 오류\n\n이슈 상태 변경 중 오류가 발생했습니다: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}
/**
 * 상태 변경 실행 함수
 */
async function executeStatusChange(jiraService, issueKey, statusStr) {
    // 상태값 검증 및 변환
    let status;
    // 상태 문자열을 JiraIssueStatus 열거형으로 변환
    switch (statusStr.toLowerCase()) {
        case 'todo':
        case 'to-do':
        case 'to_do':
        case '할일':
        case '대기':
            status = _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.ToDo;
            break;
        case 'in-progress':
        case 'in_progress':
        case 'inprogress':
        case '진행중':
        case '진행':
            status = _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.InProgress;
            break;
        case 'in-review':
        case 'in_review':
        case 'inreview':
        case '검토중':
        case '리뷰':
            status = _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.InReview;
            break;
        case 'done':
        case 'complete':
        case 'completed':
        case '완료':
        case '종료':
            status = _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.Done;
            break;
        case 'blocked':
        case 'block':
        case '차단':
        case '차단됨':
            status = _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.Blocked;
            break;
        default:
            throw new Error(`지원되지 않는 상태값입니다: ${statusStr}. 지원되는 상태값: todo, in-progress, in-review, done, blocked`);
    }
    // 현재 이슈 정보 조회
    const issueResult = await jiraService.getIssue(issueKey);
    if (!issueResult.success || !issueResult.data) {
        throw new Error(`이슈를 찾을 수 없습니다: ${issueKey}`);
    }
    const issue = issueResult.data;
    const currentStatus = issue.status;
    // 이미 동일한 상태면 변경하지 않음
    if (currentStatus === status) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira 이슈 상태 정보\n\n이슈 **${issueKey}** (${issue.summary})는 이미 **${getStatusDisplayName(status)}** 상태입니다.`
        });
        return;
    }
    // 상태 변경 실행
    const result = await jiraService.updateIssueStatus(issueKey, status);
    if (result.success) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Jira 이슈 상태가 변경되었습니다: ${issueKey}`);
        // 채팅에 결과 표시
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira 이슈 상태 변경 완료\n\n이슈 **${issueKey}** (${issue.summary})의 상태가 **${getStatusDisplayName(currentStatus)}**에서 **${getStatusDisplayName(status)}**(으)로 변경되었습니다.`
        });
    }
    else {
        throw new Error(result.error?.message || '이슈 상태 변경에 실패했습니다');
    }
}
/**
 * 상태 표시명 가져오기
 */
function getStatusDisplayName(status) {
    switch (status) {
        case _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.ToDo:
            return '할일';
        case _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.InProgress:
            return '진행중';
        case _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.InReview:
            return '검토중';
        case _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.Done:
            return '완료';
        case _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.Blocked:
            return '차단됨';
        default:
            return '알 수 없음';
    }
}
/**
 * Jira 이슈 생성 처리
 */
async function handleJiraCreate(jiraService) {
    if (!jiraService) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Jira 서비스를 사용할 수 없습니다');
        return;
    }
    try {
        // 프로젝트 키 입력 받기
        const projectKey = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: 'Jira 프로젝트 키를 입력하세요',
            placeHolder: '예: APE, DEV, TEST 등'
        });
        if (!projectKey)
            return; // 취소됨
        // 이슈 유형 입력 받기
        const issueType = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(['Task', 'Bug', 'Story', 'Epic'], { placeHolder: '이슈 유형을 선택하세요' });
        if (!issueType)
            return; // 취소됨
        // 이슈 제목 입력 받기
        const summary = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: '이슈 제목을 입력하세요',
            placeHolder: '이슈 제목'
        });
        if (!summary)
            return; // 취소됨
        // 이슈 설명 입력 받기
        const description = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: '이슈 설명을 입력하세요 (선택사항)',
            placeHolder: '이슈 설명'
        });
        // 이슈 생성
        const result = await jiraService.createIssue({
            projectKey,
            issueType,
            summary,
            description: description || ''
        });
        if (result.success && result.data) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Jira 이슈가 생성되었습니다: ${result.data.key}`);
            // 채팅에 결과 표시
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `## Jira 이슈 생성 완료\n\n이슈 **${result.data.key}**가 성공적으로 생성되었습니다.\n\n- **제목**: ${summary}\n- **유형**: ${issueType}\n- **프로젝트**: ${projectKey}`
            });
        }
        else {
            throw new Error(result.error?.message || '이슈 생성에 실패했습니다');
        }
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Jira 이슈 생성 오류: ${error instanceof Error ? error.message : String(error)}`);
        // 채팅에 오류 표시
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira 이슈 생성 오류\n\n이슈 생성 중 오류가 발생했습니다: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}
/**
 * Jira 이슈 검색 처리
 */
async function handleJiraSearch(jiraService, context) {
    if (!jiraService) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Jira 서비스를 사용할 수 없습니다');
        return;
    }
    try {
        // 검색 조건 구성
        const searchArgs = context?.args.slice(1) || [];
        const searchText = searchArgs.join(' ');
        // 검색 텍스트가 없으면 입력 받기
        let finalSearchText = searchText;
        if (!finalSearchText) {
            finalSearchText = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: 'Jira 검색어를 입력하세요',
                placeHolder: '프로젝트 키, 이슈 키, 텍스트 등 (예: APE-123, Bug, 로그인)'
            });
            if (!finalSearchText)
                return; // 취소됨
        }
        // 검색 조건 파싱 (간단 구현)
        const searchCriteria = {};
        // 프로젝트 키 패턴 확인
        const projectKeyMatch = finalSearchText.match(/^([A-Z0-9]+-\d+|[A-Z0-9]+)$/);
        if (projectKeyMatch) {
            if (projectKeyMatch[0].includes('-')) {
                // 특정 이슈 검색
                const result = await jiraService.getIssue(projectKeyMatch[0]);
                if (result.success && result.data) {
                    // 채팅에 결과 표시
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: `## Jira 이슈 검색 결과\n\n### ${result.data.key}: ${result.data.summary}\n\n**상태**: ${result.data.status}\n**담당자**: ${result.data.assignee?.displayName || '없음'}\n**보고자**: ${result.data.reporter?.displayName || '없음'}\n\n${result.data.description || '설명 없음'}`
                    });
                    return;
                }
            }
            else {
                // 프로젝트 내 이슈 검색
                searchCriteria.projectKey = projectKeyMatch[0];
            }
        }
        else {
            // 텍스트 검색
            searchCriteria.text = finalSearchText;
        }
        // 최대 결과 수 제한
        searchCriteria.maxResults = 10;
        // 검색 실행
        const result = await jiraService.searchIssues(searchCriteria);
        if (result.success && result.data) {
            if (result.data.issues.length === 0) {
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: `## Jira 이슈 검색 결과\n\n검색어 \`${finalSearchText}\`에 해당하는 이슈를 찾을 수 없습니다.`
                });
                return;
            }
            // 결과 포맷팅
            let content = `## Jira 이슈 검색 결과\n\n검색어: \`${finalSearchText}\`\n\n총 **${result.data.total}**개 이슈 중 **${result.data.issues.length}**개 표시\n\n`;
            // 이슈 목록 표시
            result.data.issues.forEach(issue => {
                content += `### ${issue.key}: ${issue.summary}\n\n`;
                content += `**상태**: ${issue.status} | **담당자**: ${issue.assignee?.displayName || '없음'}\n\n`;
            });
            // 더 많은 결과가 있는 경우 안내
            if (result.data.hasMore) {
                content += `\n> 더 많은 결과가 있습니다. 검색어를 구체적으로 지정하거나 Jira 웹 인터페이스에서 확인하세요.`;
            }
            // 채팅에 결과 표시
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content
            });
        }
        else {
            throw new Error(result.error?.message || '이슈 검색에 실패했습니다');
        }
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Jira 이슈 검색 오류: ${error instanceof Error ? error.message : String(error)}`);
        // 채팅에 오류 표시
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira 이슈 검색 오류\n\n이슈 검색 중 오류가 발생했습니다: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}
/**
 * Jira 프로젝트 요약 처리
 */
async function handleJiraSummary(jiraService, context) {
    if (!jiraService) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Jira 서비스를 사용할 수 없습니다');
        return;
    }
    try {
        // 프로젝트 키 구성
        const summaryArgs = context?.args.slice(1) || [];
        const projectKey = summaryArgs.join(' ');
        // 프로젝트 키가 없으면 입력 받기
        let finalProjectKey = projectKey;
        if (!finalProjectKey) {
            finalProjectKey = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: 'Jira 프로젝트 키를 입력하세요',
                placeHolder: '예: APE, DEV, TEST 등'
            });
            if (!finalProjectKey)
                return; // 취소됨
        }
        // 요약 실행
        const result = await jiraService.getProjectSummary(finalProjectKey);
        if (result.success && result.data) {
            const summary = result.data;
            // 상태별 이슈 분포 포맷팅
            let statusDistribution = '';
            for (const [status, count] of Object.entries(summary.issuesByStatus)) {
                statusDistribution += `- **${status}**: ${count}개\n`;
            }
            // 담당자별 이슈 분포 포맷팅
            let assigneeDistribution = '';
            for (const [assignee, count] of Object.entries(summary.issuesByAssignee)) {
                assigneeDistribution += `- **${assignee || '미할당'}**: ${count}개\n`;
            }
            // 우선순위별 이슈 분포 포맷팅
            let priorityDistribution = '';
            for (const [priority, count] of Object.entries(summary.issuesByPriority)) {
                priorityDistribution += `- **${priority || '미지정'}**: ${count}개\n`;
            }
            // 최근 이슈 목록 포맷팅
            let recentIssues = '';
            summary.recentIssues.forEach(issue => {
                recentIssues += `- **${issue.key}**: ${issue.summary} (${issue.status})\n`;
            });
            // 미해결 상태의 오래된 이슈 포맷팅
            let oldestUnresolvedIssues = '';
            summary.oldestUnresolvedIssues.forEach(issue => {
                oldestUnresolvedIssues += `- **${issue.key}**: ${issue.summary} (${issue.status}, 생성: ${issue.created?.split('T')[0] || '날짜 미상'})\n`;
            });
            // 결과 내용 구성
            let content = `## Jira 프로젝트 요약: ${finalProjectKey}\n\n`;
            if (summary.projectStats) {
                content += `### 프로젝트 통계\n\n`;
                content += `- **총 이슈 수**: ${summary.projectStats.totalIssues}개\n`;
                content += `- **열린 이슈 수**: ${summary.projectStats.openIssues}개\n`;
                content += `- **완료율**: ${summary.projectStats.percentComplete.toFixed(1)}%\n\n`;
            }
            content += `### 상태별 이슈 분포\n\n${statusDistribution}\n`;
            content += `### 담당자별 이슈 분포\n\n${assigneeDistribution}\n`;
            content += `### 우선순위별 이슈 분포\n\n${priorityDistribution}\n`;
            if (recentIssues) {
                content += `### 최근 이슈\n\n${recentIssues}\n`;
            }
            if (oldestUnresolvedIssues) {
                content += `### 미해결 상태의 오래된 이슈\n\n${oldestUnresolvedIssues}\n`;
            }
            if (summary.averageResolutionTime !== undefined) {
                content += `### 성능 지표\n\n`;
                content += `- **평균 해결 시간**: ${Math.round(summary.averageResolutionTime / 24)}일\n`;
            }
            // 채팅에 결과 표시
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content
            });
        }
        else {
            throw new Error(result.error?.message || '프로젝트 요약 정보를 가져오는 데 실패했습니다');
        }
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Jira 프로젝트 요약 오류: ${error instanceof Error ? error.message : String(error)}`);
        // 채팅에 오류 표시
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira 프로젝트 요약 오류\n\n프로젝트 요약 정보를 가져오는 중 오류가 발생했습니다: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}


/***/ }),

/***/ "./src/core/commands/rulesCommands.ts":
/*!********************************************!*\
  !*** ./src/core/commands/rulesCommands.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRulesCommands: () => (/* binding */ createRulesCommands)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Rules 슬래시 커맨드 정의
 */

/**
 * Rules 슬래시 커맨드 목록 생성
 */
function createRulesCommands(rulesService) {
    if (!rulesService) {
        return [];
    }
    const commands = [];
    // rules 명령어: Rules 관리 기능 제공
    commands.push({
        name: 'rules',
        aliases: ['rule', 'ape-rules', '룰', '규칙', '규칙관리'],
        description: 'APE Rules를 관리합니다 (목록, 활성화, 비활성화, 생성, 삭제)',
        examples: [
            '/rules list',
            '/rules active',
            '/rules inactive',
            '/rules activate 규칙이름',
            '/rules deactivate 규칙이름',
            '/rules create 규칙이름',
            '/rules delete 규칙이름',
            '/rules open 규칙이름',
            '/rules info'
        ],
        category: 'advanced',
        priority: 15,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand || subCommand === 'list' || subCommand === '목록') {
                // Rules 목록 표시
                await listRules(rulesService);
            }
            else if (subCommand === 'active' || subCommand === '활성' || subCommand === '활성화목록') {
                // 활성화된 Rules 목록 표시
                await listActiveRules(rulesService);
            }
            else if (subCommand === 'inactive' || subCommand === '비활성' || subCommand === '비활성화목록') {
                // 비활성화된 Rules 목록 표시
                await listInactiveRules(rulesService);
            }
            else if (subCommand === 'activate' || subCommand === '활성화') {
                // Rule 활성화
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await activateRule(rulesService, ruleName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('활성화할 Rule 이름을 지정해주세요');
                }
            }
            else if (subCommand === 'deactivate' || subCommand === '비활성화') {
                // Rule 비활성화
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await deactivateRule(rulesService, ruleName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('비활성화할 Rule 이름을 지정해주세요');
                }
            }
            else if (subCommand === 'create' || subCommand === '생성' || subCommand === '만들기') {
                // Rule 생성
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await createRule(rulesService, ruleName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('새 Rule 이름을 지정해주세요');
                }
            }
            else if (subCommand === 'delete' || subCommand === '삭제') {
                // Rule 삭제
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await deleteRule(rulesService, ruleName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('삭제할 Rule 이름을 지정해주세요');
                }
            }
            else if (subCommand === 'open' || subCommand === '열기') {
                // Rule 파일 열기
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await openRuleFile(rulesService, ruleName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('열 Rule 이름을 지정해주세요');
                }
            }
            else if (subCommand === 'info' || subCommand === '정보') {
                // Rules 정보 표시
                await showRulesInfo(rulesService);
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`알 수 없는 Rules 하위 명령어입니다: ${subCommand}`);
            }
        },
        provideCompletions: (partialArgs) => {
            const subCommands = [
                'list', 'active', 'inactive', 'activate', 'deactivate', 'create', 'delete', 'open', 'info',
                '목록', '활성', '비활성', '활성화', '비활성화', '생성', '만들기', '삭제', '열기', '정보'
            ];
            const parts = partialArgs.split(' ');
            // 첫 번째 인자 자동완성 (하위 명령어)
            if (parts.length <= 1) {
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(parts[0]?.toLowerCase() || ''));
            }
            // 두 번째 인자 자동완성 (Rule 이름)
            if (parts.length === 2 && ['activate', 'deactivate', 'delete', 'open', '활성화', '비활성화', '삭제', '열기'].includes(parts[0])) {
                // 현재는 비어있는 배열 반환
                // 모든 활성화된/비활성화된 Rule 목록을 가져오는 방법은 아직 구현되지 않음
                return [];
            }
            return [];
        }
    });
    // r 명령어: rules의 별칭
    commands.push({
        name: 'r',
        description: 'rules 명령어의 축약형 (APE Rules 관리)',
        category: 'advanced',
        aliases: [],
        priority: 0,
        execute: async (context) => {
            // rules 명령어로 리다이렉트
            const rulesCommand = commands.find(cmd => cmd.name === 'rules');
            if (rulesCommand && rulesCommand.execute) {
                await rulesCommand.execute(context);
            }
        },
        provideCompletions: (partialArgs) => {
            // rules 명령어의 자동완성 재사용
            const rulesCommand = commands.find(cmd => cmd.name === 'rules');
            if (rulesCommand && rulesCommand.provideCompletions) {
                return rulesCommand.provideCompletions(partialArgs);
            }
            return [];
        }
    });
    return commands;
}
/**
 * Rules 목록 표시
 */
async function listRules(rulesService) {
    try {
        const rules = rulesService.getAllRules();
        if (rules.length === 0) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: '등록된 Rule이 없습니다. `/rules create 이름`으로 새 Rule을 생성하세요.'
            });
            return;
        }
        let content = '## APE Rules 목록\n\n';
        // 활성화된 Rules 먼저 표시
        const activeRules = rules.filter(rule => rule.status === 'active');
        const inactiveRules = rules.filter(rule => rule.status === 'inactive');
        if (activeRules.length > 0) {
            content += '### 🟢 활성화된 Rules\n\n';
            activeRules.forEach(rule => {
                content += `- **${rule.name}** - \`${rule.id}.md\`\n`;
            });
            content += '\n';
        }
        if (inactiveRules.length > 0) {
            content += '### ⚪ 비활성화된 Rules\n\n';
            inactiveRules.forEach(rule => {
                content += `- **${rule.name}** - \`${rule.id}.md\`\n`;
            });
            content += '\n';
        }
        content += '\n**Rules 관리 명령어**:\n';
        content += '- `/rules activate 규칙이름` - Rule 활성화\n';
        content += '- `/rules deactivate 규칙이름` - Rule 비활성화\n';
        content += '- `/rules create 규칙이름` - 새 Rule 생성\n';
        content += '- `/rules delete 규칙이름` - Rule 삭제\n';
        content += '- `/rules open 규칙이름` - Rule 파일 열기\n';
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rules 목록 조회 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * 활성화된 Rules 목록 표시
 */
async function listActiveRules(rulesService) {
    try {
        const activeRules = rulesService.getActiveRules();
        if (activeRules.length === 0) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: '현재 활성화된 Rule이 없습니다. `/rules activate 이름`으로 Rule을 활성화하세요.'
            });
            return;
        }
        let content = '## 🟢 활성화된 APE Rules\n\n';
        activeRules.forEach(rule => {
            // 첫 100자 내용만 표시
            const previewContent = rule.content.length > 100
                ? rule.content.substring(0, 100) + '...'
                : rule.content;
            content += `### ${rule.name}\n\n`;
            content += `- **ID**: \`${rule.id}\`\n`;
            content += `- **파일**: \`${rule.filePath.split('/').pop()}\`\n`;
            content += `- **내용 미리보기**:\n\n\`\`\`\n${previewContent}\n\`\`\`\n\n`;
        });
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`활성화된 Rules 목록 조회 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * 비활성화된 Rules 목록 표시
 */
async function listInactiveRules(rulesService) {
    try {
        const allRules = rulesService.getAllRules();
        const activeRules = rulesService.getActiveRules();
        const inactiveRules = allRules.filter(rule => !activeRules.some(activeRule => activeRule.id === rule.id));
        if (inactiveRules.length === 0) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: '현재 비활성화된 Rule이 없습니다. 모든 Rules가 활성화 상태입니다.'
            });
            return;
        }
        let content = '## ⚪ 비활성화된 APE Rules\n\n';
        inactiveRules.forEach(rule => {
            // 첫 100자 내용만 표시
            const previewContent = rule.content.length > 100
                ? rule.content.substring(0, 100) + '...'
                : rule.content;
            content += `### ${rule.name}\n\n`;
            content += `- **ID**: \`${rule.id}\`\n`;
            content += `- **파일**: \`${rule.filePath.split('/').pop()}\`\n`;
            content += `- **내용 미리보기**:\n\n\`\`\`\n${previewContent}\n\`\`\`\n\n`;
        });
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`비활성화된 Rules 목록 조회 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule 활성화
 */
async function activateRule(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        // 이름 또는 ID로 Rule 찾기
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}' 이름 또는 ID를 가진 Rule을 찾을 수 없습니다. '/rules list'로 사용 가능한 Rules를 확인하세요.`
            });
            return;
        }
        // 이미 활성화된 경우
        if (rule.status === 'active') {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${rule.name}' Rule은 이미 활성화되어 있습니다.`
            });
            return;
        }
        // Rule 활성화
        await rulesService.activateRule(rule.id);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Rule이 활성화되었습니다. 이제 LLM 시스템 프롬프트에 적용됩니다.`
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule 활성화 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule 비활성화
 */
async function deactivateRule(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        // 이름 또는 ID로 Rule 찾기
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}' 이름 또는 ID를 가진 Rule을 찾을 수 없습니다. '/rules list'로 사용 가능한 Rules를 확인하세요.`
            });
            return;
        }
        // 이미 비활성화된 경우
        if (rule.status === 'inactive') {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${rule.name}' Rule은 이미 비활성화되어 있습니다.`
            });
            return;
        }
        // Rule 비활성화
        await rulesService.deactivateRule(rule.id);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Rule이 비활성화되었습니다. 더 이상 LLM 시스템 프롬프트에 적용되지 않습니다.`
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule 비활성화 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * 새 Rule 생성
 */
async function createRule(rulesService, ruleName) {
    try {
        // Rule 내용 템플릿
        const ruleContent = `# ${ruleName}\n\n여기에 LLM에 적용할 규칙 내용을 작성하세요.\n\n규칙은 마크다운 형식으로 작성됩니다.\n\n## 예시\n\n1. 항상 코드에 주석을 추가해주세요.\n2. 응답은 간결하게 유지해주세요.\n3. 에러 처리를 항상 포함해주세요.`;
        // Rule 생성
        const rule = await rulesService.createRule(ruleName, ruleContent, false);
        // Rule 파일 열기
        await rulesService.openRuleFile(rule.id);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Rule이 생성되었습니다. 파일을 수정한 후 저장하고, '/rules activate ${rule.name}'로 활성화할 수 있습니다.`
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule 생성 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule 삭제
 */
async function deleteRule(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        // 이름 또는 ID로 Rule 찾기
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}' 이름 또는 ID를 가진 Rule을 찾을 수 없습니다. '/rules list'로 사용 가능한 Rules를 확인하세요.`
            });
            return;
        }
        // 삭제 확인 (프롬프트 대화상자 사용)
        const confirmation = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage(`'${rule.name}' Rule을 삭제하시겠습니까?`, { modal: true }, '삭제', '취소');
        if (confirmation !== '삭제') {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${rule.name}' Rule 삭제가 취소되었습니다.`
            });
            return;
        }
        // Rule 삭제
        await rulesService.deleteRule(rule.id);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Rule이 삭제되었습니다.`
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule 삭제 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule 파일 열기
 */
async function openRuleFile(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        // 이름 또는 ID로 Rule 찾기
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}' 이름 또는 ID를 가진 Rule을 찾을 수 없습니다. '/rules list'로 사용 가능한 Rules를 확인하세요.`
            });
            return;
        }
        // Rule 파일 열기
        await rulesService.openRuleFile(rule.id);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Rule 파일이 열렸습니다.`
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule 파일 열기 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rules 정보 표시
 */
async function showRulesInfo(rulesService) {
    try {
        const rules = rulesService.getAllRules();
        const activeRules = rulesService.getActiveRules();
        let content = '## APE Rules 정보\n\n';
        content += `- **총 Rules 수**: ${rules.length}개\n`;
        content += `- **활성화된 Rules**: ${activeRules.length}개\n`;
        content += `- **비활성화된 Rules**: ${rules.length - activeRules.length}개\n\n`;
        content += '### Rules 시스템에 대하여\n\n';
        content += 'APE Rules는 LLM에 적용되는 규칙을 관리하는 시스템입니다. 각 Rule은 마크다운 형식의 파일로 저장되며, 활성화된 Rules는 LLM 시스템 프롬프트에 자동으로 추가됩니다.\n\n';
        content += '### 주요 기능\n\n';
        content += '- **목록 보기**: `/rules list` - 모든 Rules 목록 표시\n';
        content += '- **활성화된 Rules**: `/rules active` - 활성화된 Rules 목록 표시\n';
        content += '- **비활성화된 Rules**: `/rules inactive` - 비활성화된 Rules 목록 표시\n';
        content += '- **Rule 활성화**: `/rules activate 이름` - 지정한 Rule 활성화\n';
        content += '- **Rule 비활성화**: `/rules deactivate 이름` - 지정한 Rule 비활성화\n';
        content += '- **Rule 생성**: `/rules create 이름` - 새 Rule 생성\n';
        content += '- **Rule 삭제**: `/rules delete 이름` - 지정한 Rule 삭제\n';
        content += '- **Rule 파일 열기**: `/rules open 이름` - 지정한 Rule 파일 열기\n';
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rules 정보 표시 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
    }
}


/***/ }),

/***/ "./src/core/commands/slashCommandManager.ts":
/*!**************************************************!*\
  !*** ./src/core/commands/slashCommandManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SlashCommandManager: () => (/* binding */ SlashCommandManager)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _defaultCommands__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaultCommands */ "./src/core/commands/defaultCommands.ts");
/* harmony import */ var _helpRenderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpRenderer */ "./src/core/commands/helpRenderer.ts");
/**
 * 슬래시 커맨드 매니저
 *
 * 채팅 인터페이스에서 슬래시(/)로 시작하는 명령어를 처리하는 시스템
 */





/**
 * 슬래시 커맨드 매니저 클래스
 */
class SlashCommandManager {
    context;
    llmService;
    services;
    // 등록된 명령어 목록
    commands = new Map();
    // 명령어 별칭 맵
    aliasMap = new Map();
    // 한국어 명령어 맵 (한국어 명령어 -> 영어 명령어 이름)
    koreanCommandMap = new Map();
    // 의도 기반 매핑 (통합된 intentMap)
    intentMap = {};
    // 이벤트 이미터
    _onDidSuggestCommands = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    /**
     * 명령어 제안 이벤트
     */
    onDidSuggestCommands = this._onDidSuggestCommands.event;
    /**
     * 생성자
     */
    constructor(context, llmService, services) {
        this.context = context;
        this.llmService = llmService;
        this.services = services;
        // 확장 컨텍스트 설정 (도움말 렌더러에 전달)
        (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.setExtensionContext)();
        // 기본 명령어 등록
        this.registerDefaultCommands();
        // 명령어 등록
        this.registerVSCodeCommands();
    }
    /**
     * 기본 명령어 등록
     */
    registerDefaultCommands() {
        (0,_defaultCommands__WEBPACK_IMPORTED_MODULE_3__.createDefaultCommands)(this.services).forEach(command => {
            this.registerCommand(command);
        });
    }
    /**
     * VS Code 명령어 등록
     */
    registerVSCodeCommands() {
        // 도움말 명령어 등록
        const showHelpCommand = vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.showCommandHelp', (category) => {
            this.showCommandHelp(category);
        });
        // 'executeSlashCommand'는 CommandManager에서 이미 등록되므로 여기서는 제거
        // 중복 등록으로 인한 충돌 방지
        // Git 상태 표시 명령어
        const showGitStatus = vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.git.showStatus', () => {
            this.showGitStatus();
        });
        // 명령어 등록 해제
        this.context.subscriptions.push(showHelpCommand, showGitStatus);
    }
    /**
     * 명령어 등록
     */
    registerCommand(command) {
        // 기본 명령어 등록
        this.commands.set(command.name, command);
        // 별칭 등록
        if (command.aliases) {
            command.aliases.forEach(alias => {
                this.aliasMap.set(alias, command.name);
            });
        }
        // BilingualCommand인 경우 한국어 지원 등록
        if (this.isBilingualCommand(command)) {
            this.registerBilingualCommand(command);
        }
    }
    /**
     * 이중 언어 명령어 등록
     * BilingualCommand 인터페이스로 정의된 명령어에 대한 한국어 지원을 등록합니다.
     */
    registerBilingualCommand(command) {
        // 한국어 기본 명령어 등록 (있는 경우)
        if (command.koreanName) {
            this.koreanCommandMap.set(command.koreanName, command.name);
            // 의도 맵에도 추가
            this.intentMap[command.koreanName] = command.name;
        }
        // 한국어 별칭 등록
        if (command.koreanAliases) {
            command.koreanAliases.forEach(alias => {
                this.koreanCommandMap.set(alias, command.name);
                // 의도 맵에도 추가
                this.intentMap[alias] = command.name;
            });
        }
        // 의도 매핑 등록 (있는 경우)
        if (command.intentMap) {
            // 명령어가 제공하는 의도 맵 병합
            Object.entries(command.intentMap).forEach(([intent, cmd]) => {
                this.intentMap[intent] = cmd;
            });
        }
    }
    /**
     * 명령어가 BilingualCommand 인터페이스를 구현하는지 확인
     */
    isBilingualCommand(command) {
        return ('koreanName' in command ||
            'koreanAliases' in command ||
            'koreanDescription' in command ||
            'koreanExamples' in command ||
            'intentMap' in command);
    }
    /**
     * 모든 명령어 가져오기
     */
    getAllCommands() {
        return Array.from(this.commands.values());
    }
    /**
     * 특정 명령어 가져오기
     */
    getCommand(name) {
        // 직접 명령어 이름으로 찾기
        if (this.commands.has(name)) {
            return this.commands.get(name);
        }
        // 별칭으로 찾기
        const originalName = this.aliasMap.get(name);
        if (originalName) {
            return this.commands.get(originalName);
        }
        return undefined;
    }
    /**
     * 유사 명령어 찾기
     *
     * 레벤슈타인 거리 알고리즘을 사용하여 입력된 명령어와 가장 유사한 명령어를 찾습니다.
     * @param name 입력된 명령어 이름
     * @param maxDistance 최대 허용 거리 (기본값: 2)
     * @returns 가장 유사한 명령어 목록 (거리 오름차순)
     */
    findSimilarCommands(name, maxDistance = 2) {
        const result = [];
        // 모든 명령어 및 별칭과 비교
        for (const command of this.getAllCommands()) {
            // 메인 명령어 비교
            const distance = this.levenshteinDistance(name, command.name);
            if (distance <= maxDistance) {
                result.push({ command, distance });
            }
            // 별칭 비교
            if (command.aliases) {
                for (const alias of command.aliases) {
                    const aliasDistance = this.levenshteinDistance(name, alias);
                    if (aliasDistance <= maxDistance && aliasDistance < distance) {
                        // 별칭이 더 유사하면 기존 항목 대체
                        const existing = result.findIndex(r => r.command === command);
                        if (existing >= 0) {
                            result[existing].distance = aliasDistance;
                        }
                        else {
                            result.push({ command, distance: aliasDistance });
                        }
                    }
                }
            }
        }
        // 거리 기준 정렬 (가장 유사한 것부터)
        return result.sort((a, b) => a.distance - b.distance);
    }
    /**
     * 레벤슈타인 거리 계산
     *
     * 두 문자열 간의 편집 거리를 계산합니다. 값이 작을수록 문자열이 유사합니다.
     * @param a 첫 번째 문자열
     * @param b 두 번째 문자열
     * @returns 편집 거리
     */
    levenshteinDistance(a, b) {
        // 공백 제거 및 소문자 변환
        a = a.toLowerCase().trim();
        b = b.toLowerCase().trim();
        if (a === b)
            return 0;
        if (a.length === 0)
            return b.length;
        if (b.length === 0)
            return a.length;
        // 매트릭스 생성
        const matrix = Array(a.length + 1).fill(null).map(() => Array(b.length + 1).fill(null));
        // 첫 행과 열 초기화
        for (let i = 0; i <= a.length; i++) {
            matrix[i][0] = i;
        }
        for (let j = 0; j <= b.length; j++) {
            matrix[0][j] = j;
        }
        // 행렬 채우기
        for (let i = 1; i <= a.length; i++) {
            for (let j = 1; j <= b.length; j++) {
                const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // 삭제
                matrix[i][j - 1] + 1, // 삽입
                matrix[i - 1][j - 1] + cost // 대체
                );
            }
        }
        return matrix[a.length][b.length];
    }
    /**
     * 한글 의도 기반 명령어 매칭 (개선된 버전)
     *
     * 한글로 된 자연어 입력을 의도에 맞는 명령어로 매핑합니다.
     * 자연어 이해 기능으로 사용자 의도에 맞는 명령어를 찾아냅니다.
     * @param input 사용자 입력 (슬래시 포함)
     * @returns 매칭된 명령어 또는 undefined
     */
    matchCommandByIntent(input) {
        // 의도 문구와 명령어 이름 매핑
        const intentMap = {
            // 도움말 관련
            '뭐해야해': 'help', // 뭐 해야 할지 모르겠음 → 도움말
            '뭐부터해야해': 'help', // 무엇부터 해야할지 → 도움말 
            '도와줘': 'help', // 도와줘 → 도움말
            '명령어': 'help', // 명령어 확인 → 도움말
            '어떻게': 'help', // 어떻게 사용하지 → 도움말
            '사용법': 'help', // 사용법 → 도움말
            '기능': 'help', // 기능 → 도움말
            '메뉴': 'help', // 메뉴 → 도움말
            '도움': 'help', // 도움 → 도움말
            '안내': 'help', // 안내 → 도움말
            '사용방법': 'help', // 사용 방법 → 도움말
            '기능목록': 'help', // 기능 목록 → 도움말
            '설명서': 'help', // 설명서 → 도움말
            '가이드': 'help', // 가이드 → 도움말
            '튜토리얼': 'help', // 튜토리얼 → 도움말
            '도움말': 'help', // 도움말 → 도움말
            '어떻게사용': 'help', // 어떻게 사용 → 도움말
            '사용방식': 'help', // 사용 방식 → 도움말
            '시작하기': 'help', // 시작하기 → 도움말
            '힌트': 'help', // 힌트 → 도움말
            '도움주세요': 'help', // 도움 주세요 → 도움말 (신규)
            '사용법알려줘': 'help', // 사용법 알려줘 → 도움말 (신규)
            '어떻게쓰는거야': 'help', // 어떻게 쓰는거야 → 도움말 (신규)
            '어떻게작동해': 'help', // 어떻게 작동해 → 도움말 (신규)
            '사용설명': 'help', // 사용 설명 → 도움말 (신규)
            // 메모리 관련
            '기억해': 'memory', // 기억해 → 메모리 저장
            '저장해': 'memory', // 저장해 → 메모리 저장
            '메모': 'memory', // 메모 → 메모리 저장
            '노트': 'memory', // 노트 → 메모리 저장
            '기록': 'memory', // 기록 → 메모리 저장
            '메모리': 'memory', // 메모리 → 메모리 저장
            '내용저장': 'memory', // 내용 저장 → 메모리 저장
            '기록저장': 'memory', // 기록 저장 → 메모리 저장
            '적어둬': 'memory', // 적어둬 → 메모리 저장
            '메모장': 'memory', // 메모장 → 메모리 저장
            '저장소': 'memory', // 저장소 → 메모리 저장
            '북마크': 'memory', // 북마크 → 메모리 저장
            '메모해줘': 'memory', // 메모해줘 → 메모리 저장
            '기억': 'memory', // 기억 → 메모리 저장
            '저장': 'memory', // 저장 → 메모리 저장
            '메모저장': 'memory', // 메모 저장 → 메모리 저장
            // VAULT 관련 (볼트 시스템)
            '볼트': 'vault', // 볼트 → vault
            '금고': 'vault', // 금고 → vault
            '컨텍스트': 'vault', // 컨텍스트 → vault
            '문맥': 'vault', // 문맥 → vault
            '자료저장소': 'vault', // 자료저장소 → vault
            '자료보관': 'vault', // 자료보관 → vault
            '볼트저장': 'vault save', // 볼트저장 → vault save
            '볼트목록': 'vault list', // 볼트목록 → vault list
            '볼트조회': 'vault list', // 볼트조회 → vault list
            '볼트내용': 'vault show', // 볼트내용 → vault show
            '컨텍스트저장': 'vault save', // 컨텍스트저장 → vault save
            '볼트검색': 'vault search', // 볼트검색 → vault search
            '볼트찾기': 'vault search', // 볼트찾기 → vault search
            '컨텍스트찾기': 'vault search', // 컨텍스트찾기 → vault search
            '볼트생성': 'vault create', // 볼트생성 → vault create
            '볼트만들기': 'vault create', // 볼트만들기 → vault create
            '컨텍스트생성': 'vault create', // 컨텍스트생성 → vault create
            '볼트삭제': 'vault delete', // 볼트삭제 → vault delete
            '볼트지우기': 'vault delete', // 볼트지우기 → vault delete
            '컨텍스트삭제': 'vault delete', // 컨텍스트삭제 → vault delete
            '볼트사용': 'vault use', // 볼트사용 → vault use
            '볼트가져오기': 'vault use', // 볼트가져오기 → vault use
            '컨텍스트사용': 'vault use', // 컨텍스트사용 → vault use
            // Git 관련
            '깃상태': 'git status', // 깃 상태 → git status
            '깃': 'git status', // 깃 → git status
            '깃커밋': 'git commit', // 깃 커밋 → git commit
            '커밋': 'git commit', // 커밋 → git commit
            '푸시': 'git push', // 푸시 → git push
            '풀': 'git pull', // 풀 → git pull
            '충돌': 'git solve', // 충돌 → git solve
            '자동커밋': 'git auto', // 자동커밋 → git auto
            '변경사항': 'git status', // 변경사항 → git status
            '깃상황': 'git status', // 깃 상황 → git status
            '깃저장': 'git commit', // 깃 저장 → git commit
            '깃푸시': 'git push', // 깃 푸시 → git push
            '깃풀': 'git pull', // 깃 풀 → git pull
            '깃충돌': 'git solve', // 깃 충돌 → git solve
            '깃원격': 'git push', // 깃 원격 → git push
            '깃합치기': 'git merge', // 깃 합치기 → git merge
            '깃브랜치': 'git branch', // 깃 브랜치 → git branch
            '깃전환': 'git checkout', // 깃 전환 → git checkout
            '깃이력': 'git log', // 깃 이력 → git log
            '깃로그': 'git log', // 깃 로그 → git log
            '깃버전': 'git log', // 깃 버전 → git log
            '깃스테이지': 'git add', // 깃 스테이지 → git add
            '깃추가': 'git add', // 깃 추가 → git add
            '깃상태알려줘': 'git status', // 깃 상태 알려줘 → git status (신규)
            '깃상태확인': 'git status', // 깃 상태 확인 → git status (신규)
            '변경확인': 'git status', // 변경 확인 → git status (신규)
            '코드커밋': 'git commit', // 코드 커밋 → git commit (신규)
            '변경저장': 'git commit', // 변경 저장 → git commit (신규)
            '코드저장': 'git commit', // 코드 저장 → git commit (신규)
            '브랜치확인': 'git branch', // 브랜치 확인 → git branch (신규)
            '브랜치목록': 'git branch', // 브랜치 목록 → git branch (신규)
            '머지충돌': 'git solve', // 머지 충돌 → git solve (신규)
            '원격저장소업데이트': 'git push', // 원격 저장소 업데이트 → git push (신규)
            // 파일 관련
            '파일열어': 'open', // 파일 열기 → open
            '열기': 'open', // 열기 → open
            '파일': 'open', // 파일 → open
            '코드열어': 'open', // 코드 열기 → open
            '파일오픈': 'open', // 파일 오픈 → open
            '파일보기': 'open', // 파일 보기 → open
            '소스열기': 'open', // 소스 열기 → open
            '문서열기': 'open', // 문서 열기 → open
            '코드파일': 'open', // 코드 파일 → open
            '열어줘': 'open', // 열어줘 → open
            '파일내용': 'open', // 파일 내용 → open
            '파일내용보기': 'open', // 파일 내용 보기 → open
            '코드파일열기': 'open', // 코드 파일 열기 → open
            '파일경로': 'open', // 파일 경로 → open
            '경로열기': 'open', // 경로 열기 → open
            '이파일열어줘': 'open', // 이 파일 열어줘 → open (신규)
            '소스코드열기': 'open', // 소스코드 열기 → open (신규)
            '코드내용보기': 'open', // 코드 내용 보기 → open (신규)
            '파일열어볼래': 'open', // 파일 열어볼래 → open (신규)
            '파일보여줘': 'open', // 파일 보여줘 → open (신규)
            '문서보여줘': 'open', // 문서 보여줘 → open (신규)
            '소스보여줘': 'open', // 소스 보여줘 → open (신규)
            // 실행 관련
            '실행해': 'execute', // 실행해 → execute
            '실행': 'execute', // 실행 → execute
            '돌려': 'execute', // 돌려 → execute
            '코드실행': 'execute', // 코드 실행 → execute
            '구동': 'execute', // 구동 → execute
            '실행시켜': 'execute', // 실행시켜 → execute
            '돌려봐': 'execute', // 돌려봐 → execute
            '실행해봐': 'execute', // 실행해봐 → execute
            '실행해줘': 'execute', // 실행해줘 → execute
            '코드돌려': 'execute', // 코드 돌려 → execute
            '코드구동': 'execute', // 코드 구동 → execute
            '스크립트실행': 'execute', // 스크립트 실행 → execute
            '명령실행': 'execute', // 명령 실행 → execute
            '명령어실행': 'execute', // 명령어 실행 → execute
            // 분석 관련
            '분석해': 'analyze', // 분석해 → analyze
            '분석': 'analyze', // 분석 → analyze
            '코드분석': 'analyze', // 코드분석 → analyze
            '검토': 'analyze', // 검토 → analyze
            '리뷰': 'analyze', // 리뷰 → analyze
            '코드리뷰': 'analyze', // 코드리뷰 → analyze
            '코드검토': 'analyze', // 코드 검토 → analyze
            '분석하기': 'analyze', // 분석하기 → analyze
            '살펴봐': 'analyze', // 살펴봐 → analyze
            '파악해': 'analyze', // 파악해 → analyze
            '이해': 'analyze', // 이해 → analyze
            '코드이해': 'analyze', // 코드 이해 → analyze
            '코드파악': 'analyze', // 코드 파악 → analyze
            '분석해봐': 'analyze', // 분석해봐 → analyze
            '분석해줘': 'analyze', // 분석해줘 → analyze
            '검토해줘': 'analyze', // 검토해줘 → analyze
            '리뷰해줘': 'analyze', // 리뷰해줘 → analyze
            '코드진단': 'analyze', // 코드 진단 → analyze
            '진단': 'analyze', // 진단 → analyze
            '코드리뷰해줘': 'analyze', // 코드 리뷰해줘 → analyze (신규)
            '코드개선': 'analyze', // 코드 개선 → analyze (신규)
            '코드품질': 'analyze', // 코드 품질 → analyze (신규)
            '코드평가': 'analyze', // 코드 평가 → analyze (신규)
            '코드분석해줘': 'analyze', // 코드 분석해줘 → analyze (신규)
            '이코드어때': 'analyze', // 이 코드 어때 → analyze (신규)
            '코드문제': 'analyze', // 코드 문제 → analyze (신규)
            '버그분석': 'analyze', // 버그 분석 → analyze (신규)
            '코드최적화': 'analyze', // 코드 최적화 → analyze (신규)
            '성능분석': 'analyze', // 성능 분석 → analyze (신규)
            // 설정 및 모델 관련
            '모델바꿔': 'model', // 모델 변경 → model
            '모델': 'model', // 모델 → model
            '설정해': 'settings', // 설정 변경 → settings
            '설정': 'settings', // 설정 → settings
            '환경설정': 'settings', // 환경설정 → settings
            '옵션': 'settings', // 옵션 → settings
            '모델변경': 'model', // 모델 변경 → model
            '모델목록': 'model list', // 모델 목록 → model list
            '설정변경': 'settings', // 설정 변경 → settings
            '모델선택': 'model', // 모델 선택 → model
            '에이아이변경': 'model', // AI 변경 → model
            '모델교체': 'model', // 모델 교체 → model
            '모델전환': 'model', // 모델 전환 → model
            '설정보기': 'settings', // 설정 보기 → settings
            '옵션변경': 'settings', // 옵션 변경 → settings
            '옵션보기': 'settings', // 옵션 보기 → settings
            '설정메뉴': 'settings', // 설정 메뉴 → settings
            '환경': 'settings', // 환경 → settings
            '모델종류': 'model list', // 모델 종류 → model list
            '모델타입': 'model list', // 모델 타입 → model list
            '모델확인': 'model', // 모델 확인 → model
            // 검색 관련
            '검색해': 'search', // 검색해 → search
            '검색': 'search', // 검색 → search
            '찾아': 'search', // 찾아 → search
            '찾기': 'search', // 찾기 → search
            '찾아줘': 'search', // 찾아줘 → search
            '코드검색': 'search', // 코드 검색 → search
            '검색하기': 'search', // 검색하기 → search
            '내용찾기': 'search', // 내용 찾기 → search
            '검색해줘': 'search', // 검색해줘 → search
            '코드찾기': 'search', // 코드 찾기 → search
            '파일검색': 'search', // 파일 검색 → search
            '파일찾기': 'search', // 파일 찾기 → search
            '키워드검색': 'search', // 키워드 검색 → search
            '텍스트검색': 'search', // 텍스트 검색 → search
            '문자검색': 'search', // 문자 검색 → search
            '검색어': 'search', // 검색어 → search
            '문자열검색': 'search', // 문자열 검색 → search
            '찾아보기': 'search', // 찾아보기 → search
            // 상태 및 기타
            '지금뭐해': 'status', // 지금 뭐해 → status
            '상태': 'status', // 상태 → status
            '초기화': 'clear', // 초기화 → clear
            '지워': 'clear', // 지워 → clear
            '새로고침': 'clear', // 새로고침 → clear
            '시스템상태': 'status', // 시스템 상태 → status
            '현재상태': 'status', // 현재 상태 → status
            '뭐하고있어': 'status', // 뭐하고 있어 → status
            '채팅지우기': 'clear', // 채팅 지우기 → clear
            '내용지우기': 'clear', // 내용 지우기 → clear
            '다시시작': 'clear', // 다시 시작 → clear
            '상태확인': 'status', // 상태 확인 → status
            '시스템확인': 'status', // 시스템 확인 → status
            '상태보기': 'status', // 상태 보기 → status
            '작업현황': 'status', // 작업 현황 → status
            '진행현황': 'status', // 진행 현황 → status
            '지금상태': 'status', // 지금 상태 → status
            '비우기': 'clear', // 비우기 → clear
            '삭제': 'clear', // 삭제 → clear
            '내용삭제': 'clear', // 내용 삭제 → clear
            '전체삭제': 'clear', // 전체 삭제 → clear
            '재시작': 'clear', // 재시작 → clear
            '처음부터': 'clear', // 처음부터 → clear
            // JIRA 관련
            '지라': 'jira', // 지라 → jira
            '지라이슈': 'jira issue', // 지라 이슈 → jira issue
            '이슈': 'jira issue', // 이슈 → jira issue
            '지라검색': 'jira search', // 지라 검색 → jira search
            '지라목록': 'jira list', // 지라 목록 → jira list
            '지라상태': 'jira status', // 지라 상태 → jira status
            '지라업데이트': 'jira update', // 지라 업데이트 → jira update
            '지라생성': 'jira create', // 지라 생성 → jira create
            '이슈생성': 'jira create', // 이슈 생성 → jira create
            '지라정보': 'jira info', // 지라 정보 → jira info
            // Todo 관련
            '할일': 'todo', // 할일 → todo
            '투두': 'todo', // 투두 → todo
            '태스크': 'todo', // 태스크 → todo
            '작업': 'todo', // 작업 → todo
            '할일추가': 'todo add', // 할일 추가 → todo add
            '할일목록': 'todo list', // 할일 목록 → todo list
            '투두목록': 'todo list', // 투두 목록 → todo list
            '태스크목록': 'todo list', // 태스크 목록 → todo list
            '작업목록': 'todo list', // 작업 목록 → todo list
            '할일관리': 'todo', // 할일 관리 → todo
            '투두관리': 'todo', // 투두 관리 → todo
            '태스크관리': 'todo', // 태스크 관리 → todo
            '작업관리': 'todo', // 작업 관리 → todo
            '할일추가하기': 'todo add', // 할일 추가하기 → todo add (신규)
            '할일등록': 'todo add', // 할일 등록 → todo add (신규)
            '태스크등록': 'todo add', // 태스크 등록 → todo add (신규)
            '작업등록': 'todo add', // 작업 등록 → todo add (신규)
            '할일삭제': 'todo delete', // 할일 삭제 → todo delete (신규)
            '태스크삭제': 'todo delete', // 태스크 삭제 → todo delete (신규)
            '작업삭제': 'todo delete', // 작업 삭제 → todo delete (신규)
            '작업상태': 'todo status', // 작업 상태 → todo status (신규)
            '할일상태': 'todo status', // 할일 상태 → todo status (신규)
            '태스크상태': 'todo status', // 태스크 상태 → todo status (신규)
            '할일완료': 'todo status', // 할일 완료 → todo status (신규)
            '작업완료': 'todo status', // 작업 완료 → todo status (신규)
            '태스크완료': 'todo status', // 태스크 완료 → todo status (신규)
            '작업우선순위': 'todo priority', // 작업 우선순위 → todo priority (신규)
            '할일우선순위': 'todo priority', // 할일 우선순위 → todo priority (신규)
            '태스크우선순위': 'todo priority', // 태스크 우선순위 → todo priority (신규)
            // 채팅 저장/보기
            '대화저장': 'stack', // 대화 저장 → stack
            '채팅저장': 'stack', // 채팅 저장 → stack
            '대화기록': 'stack', // 대화 기록 → stack
            '채팅기록': 'stack', // 채팅 기록 → stack
            '대화내역': 'show', // 대화 내역 → show
            '채팅내역': 'show', // 채팅 내역 → show
            '대화목록': 'show', // 대화 목록 → show
            '채팅목록': 'show', // 채팅 목록 → show
            '대화보기': 'show', // 대화 보기 → show
            '채팅보기': 'show', // 채팅 보기 → show
            '기록보기': 'show', // 기록 보기 → show
        };
        // 입력 정규화 (슬래시 제거 및 소문자 변환)
        const normalizedInput = input.substring(1).trim().toLowerCase();
        // 1. 정확한 의도 매칭 먼저 시도
        for (const [intent, commandName] of Object.entries(intentMap)) {
            if (normalizedInput === intent) {
                return this.getCommand(commandName.split(' ')[0]);
            }
        }
        // 2. 부분 매칭 시도 (입력에 특정 의도 단어가 포함된 경우)
        for (const [intent, commandName] of Object.entries(intentMap)) {
            if (normalizedInput.includes(intent)) {
                return this.getCommand(commandName.split(' ')[0]);
            }
        }
        // 3. 공백을 제거한 매칭 시도 (예: "뭐 해야 해" → "뭐해야해")
        const normalizedWithoutSpaces = normalizedInput.replace(/\s+/g, '');
        for (const [intent, commandName] of Object.entries(intentMap)) {
            if (normalizedWithoutSpaces === intent || normalizedWithoutSpaces.includes(intent)) {
                return this.getCommand(commandName.split(' ')[0]);
            }
        }
        // 4. 유사 매칭 - 자음/모음 기반 유사도 계산 (한글만 적용)
        if (/[\uAC00-\uD7AF]/.test(normalizedInput)) {
            // 향상된 유사도 계산 함수
            const calculateSimilarity = (a, b) => {
                // 완전 일치하는 경우
                if (a === b)
                    return 1.0;
                if (a.length === 0 || b.length === 0)
                    return 0.0;
                // 음절 단위로 분리
                const charsA = Array.from(a);
                const charsB = Array.from(b);
                // 한글 초성 매칭 가중치 추가
                // 초성 추출 함수
                const getInitialConsonant = (char) => {
                    if (!/^[가-힣]$/.test(char))
                        return char;
                    const code = char.charCodeAt(0) - 0xAC00;
                    const consonantIndex = Math.floor(code / 28 / 21);
                    const consonants = [
                        'ㄱ', 'ㄲ', 'ㄴ', 'ㄷ', 'ㄸ', 'ㄹ', 'ㅁ', 'ㅂ', 'ㅃ', 'ㅅ',
                        'ㅆ', 'ㅇ', 'ㅈ', 'ㅉ', 'ㅊ', 'ㅋ', 'ㅌ', 'ㅍ', 'ㅎ'
                    ];
                    return consonants[consonantIndex];
                };
                // 초성 추출
                const initialA = charsA.map(getInitialConsonant).join('');
                const initialB = charsB.map(getInitialConsonant).join('');
                // 초성 일치 점수 (가중치: 0.3)
                const initialScore = initialA === initialB ? 0.3 : 0;
                // 각 문자열의 n-gram 생성 (1-gram, 2-gram)
                const generateNgrams = (str, n) => {
                    const ngrams = [];
                    for (let i = 0; i <= str.length - n; i++) {
                        ngrams.push(str.substring(i, i + n));
                    }
                    return ngrams;
                };
                // 1-gram (음절) 유사도 (가중치: 0.3)
                const chars1A = new Set(charsA);
                const chars1B = new Set(charsB);
                const charIntersection = new Set([...chars1A].filter(x => chars1B.has(x)));
                const charUnion = new Set([...chars1A, ...chars1B]);
                const charScore = charIntersection.size / charUnion.size * 0.3;
                // 2-gram (음절 쌍) 유사도 (가중치: 0.4)
                const bigrams2A = new Set(generateNgrams(a, 2));
                const bigrams2B = new Set(generateNgrams(b, 2));
                const bigramIntersection = new Set([...bigrams2A].filter(x => bigrams2B.has(x)));
                const bigramUnion = new Set([...bigrams2A, ...bigrams2B]);
                const bigramScore = bigrams2A.size > 0 && bigrams2B.size > 0 ?
                    bigramIntersection.size / bigramUnion.size * 0.4 : 0;
                // 길이 유사도 - 길이가 비슷할수록 높은 점수 (가중치: 0.2)
                const lengthScore = 1 - (Math.abs(a.length - b.length) / Math.max(a.length, b.length, 1)) * 0.2;
                // 접두사 가중치 - 시작 부분이 같으면 가중치 부여
                const prefixBonus = a.startsWith(b.charAt(0)) || b.startsWith(a.charAt(0)) ? 0.1 : 0;
                // 전체 유사도 점수
                return Math.min(1.0, initialScore + charScore + bigramScore + lengthScore + prefixBonus);
            };
            const similarityThreshold = 0.45; // 유사도 임계값 (약간 낮춤)
            let bestMatch = null;
            for (const [intent, commandName] of Object.entries(intentMap)) {
                const similarity = calculateSimilarity(normalizedInput, intent);
                if (similarity >= similarityThreshold && (!bestMatch || similarity > bestMatch.similarity)) {
                    bestMatch = { intent, command: commandName, similarity };
                }
            }
            if (bestMatch) {
                console.log(`한글 유사도 매칭 (개선): "${normalizedInput}" → "${bestMatch.intent}" (${bestMatch.similarity.toFixed(2)})`);
                return this.getCommand(bestMatch.command.split(' ')[0]);
            }
        }
        return undefined;
    }
    /**
     * 명령어 실행
     */
    async executeCommand(input) {
        // 슬래시로 시작하는지 확인
        if (!input.startsWith('/') && !input.startsWith('@')) {
            return false;
        }
        // 명령어와 인자 분리
        const trimmedInput = input.trim();
        const parts = trimmedInput.split(' ');
        // @ 명령어 처리 (특수 접두사)
        if (trimmedInput.startsWith('@')) {
            const specialCommand = parts[0].substring(1); // @ 제거
            // 지원되지 않는 @ 명령어
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`'@${specialCommand}'는 현재 지원되지 않는 명령어입니다.`);
            return false;
        }
        // 일반 슬래시 명령어 처리
        const commandName = parts[0].substring(1); // 슬래시 제거
        const args = parts.slice(1);
        // 1. 직접 명령어 매칭 시도
        let command = this.getCommand(commandName);
        // 2. 한글 텍스트가 있는 경우 의도 기반 매칭 시도
        if (!command && /[\uAC00-\uD7AF]/.test(commandName)) {
            command = this.matchCommandByIntent(trimmedInput);
        }
        // 3. 명령어를 찾지 못한 경우
        if (!command) {
            // 유사 명령어 찾기
            const similarCommands = this.findSimilarCommands(commandName);
            if (similarCommands.length > 0 && similarCommands[0].distance <= 1) {
                // 매우 유사한 명령어가 있는 경우 (오타로 간주)
                const closestCommand = similarCommands[0].command;
                const result = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`명령어 '/${commandName}'를 찾을 수 없습니다. '/${closestCommand.name}'를 실행하시겠습니까?`, '실행', '취소');
                if (result === '실행') {
                    // 사용자가 수정된 명령어 실행에 동의함
                    try {
                        await closestCommand.execute({
                            extensionContext: this.context,
                            args,
                            originalInput: `/${closestCommand.name} ${args.join(' ')}`.trim()
                        });
                        return true;
                    }
                    catch (error) {
                        console.error(`Error executing command /${closestCommand.name}:`, error);
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`명령어 실행 오류: /${closestCommand.name}`);
                        return true; // 명령어는 처리됨 (오류 발생)
                    }
                }
                else {
                    // 사용자가 취소함 - LLM 추천 또는 오류 메시지 표시
                    if (this.llmService) {
                        await this.handleUnknownCommandWithSuggestions(commandName, trimmedInput, similarCommands);
                        return true; // 명령어는 처리됨 (대체 처리)
                    }
                    else {
                        this.showSimilarCommandSuggestions(commandName, similarCommands);
                        return false;
                    }
                }
            }
            else {
                // 유사한 명령어가 없거나 충분히 유사하지 않은 경우
                if (this.llmService) {
                    await this.handleUnknownCommandWithSuggestions(commandName, trimmedInput, similarCommands);
                    return true; // 명령어는 처리됨 (대체 처리)
                }
                else {
                    if (similarCommands.length > 0) {
                        this.showSimilarCommandSuggestions(commandName, similarCommands);
                    }
                    else {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`알 수 없는 명령어: /${commandName}`);
                    }
                    return false;
                }
            }
        }
        // 명령어 실행
        try {
            await command.execute({
                extensionContext: this.context,
                args,
                originalInput: trimmedInput
            });
            return true;
        }
        catch (error) {
            console.error(`Error executing command /${commandName}:`, error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`명령어 실행 오류: /${commandName}`);
            return true; // 명령어는 처리됨 (오류 발생)
        }
    }
    /**
     * 유사 명령어 추천 메시지 표시
     */
    showSimilarCommandSuggestions(commandName, similarCommands) {
        if (similarCommands.length === 0) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`알 수 없는 명령어: /${commandName}`);
            return;
        }
        // 최대 3개까지만 표시
        const suggestionsLimit = Math.min(3, similarCommands.length);
        const suggestions = similarCommands.slice(0, suggestionsLimit);
        // 메시지 구성
        const message = `명령어 '/${commandName}'를 찾을 수 없습니다. 이것을 의미했나요?`;
        // 버튼 생성
        const buttons = suggestions.map(s => `/${s.command.name}`);
        // 메시지 표시
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(message, ...buttons)
            .then(selected => {
            if (selected) {
                // 선택한 명령어 실행
                this.executeCommand(selected);
            }
        });
    }
    /**
     * 알 수 없는 명령어 처리 - LLM을 통한 해석 및 추천
     * @param commandName 알 수 없는 명령어 이름
     * @param originalInput 원본 입력
     */
    async handleUnknownCommand(commandName, originalInput) {
        try {
            // 1. 도움말 데이터 로드
            const helpData = await this.loadHelpData();
            // 2. 가이드 데이터 로드
            const guideData = await this.loadGuideData();
            // 3. LLM 프롬프트 생성
            const prompt = this.generateUnknownCommandPrompt(commandName, originalInput, helpData, guideData);
            // 4. LLM 응답 요청
            const result = await this.llmService.getCompletion(prompt);
            if (!result.success || !result.data) {
                throw new Error(result.error?.message || 'LLM 응답을 받을 수 없습니다.');
            }
            // 5. LLM 응답 처리 및 UI에 표시 (WebView 패널 사용)
            await this.showLlmResponsePanel('명령어 도움말', result.data);
        }
        catch (error) {
            console.error('알 수 없는 명령어 처리 오류:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`'/${commandName}' 명령어 해석 중 오류가 발생했습니다. 기본 도움말을 참조하세요.`);
            // 오류 발생 시 기본 도움말 표시
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp');
        }
    }
    /**
     * 알 수 없는 명령어 처리 - 유사 명령어 정보를 포함한 LLM 추천
     * @param commandName 알 수 없는 명령어 이름
     * @param originalInput 원본 입력
     * @param similarCommands 유사 명령어 목록
     */
    async handleUnknownCommandWithSuggestions(commandName, originalInput, similarCommands) {
        try {
            // 1. 도움말 데이터 로드
            const helpData = await this.loadHelpData();
            // 2. 가이드 데이터 로드
            const guideData = await this.loadGuideData();
            // 3. LLM 프롬프트 생성 (유사 명령어 정보 포함)
            const prompt = this.generateUnknownCommandPromptWithSuggestions(commandName, originalInput, helpData, guideData, similarCommands);
            // 4. LLM 응답 요청
            const result = await this.llmService.getCompletion(prompt);
            if (!result.success || !result.data) {
                throw new Error(result.error?.message || 'LLM 응답을 받을 수 없습니다.');
            }
            // 5. LLM 응답 처리 및 UI에 표시 (WebView 패널 사용)
            await this.showLlmResponsePanel('명령어 도움말', result.data);
        }
        catch (error) {
            console.error('알 수 없는 명령어 처리 오류:', error);
            // 오류 발생 시 기본 유사 명령어 추천 사용
            this.showSimilarCommandSuggestions(commandName, similarCommands);
            // 필요시 기본 도움말도 표시 가능
            // await vscode.commands.executeCommand('ape.showCommandHelp');
        }
    }
    /**
     * 도움말 데이터 로드
     */
    async loadHelpData() {
        try {
            const extensionPath = this.context.extensionPath;
            const helpFilePath = path__WEBPACK_IMPORTED_MODULE_1__.join(extensionPath, 'src', 'data', 'help.json');
            const helpDataStr = fs__WEBPACK_IMPORTED_MODULE_2__.readFileSync(helpFilePath, 'utf8');
            return JSON.parse(helpDataStr);
        }
        catch (error) {
            console.error('도움말 데이터 로드 오류:', error);
            return {};
        }
    }
    /**
     * 가이드 데이터 로드
     */
    async loadGuideData() {
        try {
            const extensionPath = this.context.extensionPath;
            const guideFilePath = path__WEBPACK_IMPORTED_MODULE_1__.join(extensionPath, 'src', 'data', 'guide.json');
            const guideDataStr = fs__WEBPACK_IMPORTED_MODULE_2__.readFileSync(guideFilePath, 'utf8');
            return JSON.parse(guideDataStr);
        }
        catch (error) {
            console.error('가이드 데이터 로드 오류:', error);
            return {};
        }
    }
    /**
     * 알 수 없는 명령어 처리를 위한 LLM 프롬프트 생성
     */
    generateUnknownCommandPrompt(commandName, originalInput, helpData, guideData) {
        return `
# APE 명령어 해석 및 추천 시스템

당신은 APE(Agentic Pipeline Extension)의 도움말 시스템입니다. 사용자가 입력한 알 수 없는 명령어를 해석하고 관련된 유효한 명령어나 질문을 추천해야 합니다.

## 사용자 입력

사용자가 입력한 알 수 없는 명령어: \`${originalInput}\`

## 도움말 데이터

${JSON.stringify(helpData, null, 2)}

## 가이드 데이터

${JSON.stringify(guideData, null, 2)}

## 응답 지침

1. 사용자 입력을 분석하여 의도를 파악하세요. 특히 한글로 입력된 자연어 질문이나 명령에 주의하세요.
2. 입력과 유사하거나 관련된 유효한 명령어를 추천하세요. 
3. 한글 입력의 경우 "뭐해야해", "뭐부터해야해" 같은 자연어 질문으로 이해하고 적절한 워크플로우를 제안하세요.
4. 현재 상황에 적합한 컨텍스트 질문도 추천하세요 (예: "Git 형상이 세팅됐나요?", "Jira 작업이 필요한가요?" 등).
5. 응답은 다음 형식으로 작성하세요:

---
### 명령어 해석

[입력한 명령어에 대한 해석 및 추측 - 한글 입력의 경우 사용자 의도를 자세히 분석]

### 추천 명령어

- **[명령어1]**: [설명]
- **[명령어2]**: [설명]
- **[명령어3]**: [설명]

### 추천 질문

- [질문1]
- [질문2]
- [질문3]

---

응답을 시작하세요.
`;
    }
    /**
     * 유사 명령어 정보를 포함한 알 수 없는 명령어 처리 프롬프트 생성
     */
    generateUnknownCommandPromptWithSuggestions(commandName, originalInput, helpData, guideData, similarCommands) {
        // 유사 명령어 정보 추출
        const similarCommandsInfo = similarCommands.map(sc => ({
            name: sc.command.name,
            description: sc.command.description,
            category: sc.command.category,
            aliases: sc.command.aliases || [],
            examples: sc.command.examples || [],
            distance: sc.distance
        }));
        return `
# APE 명령어 해석 및 추천 시스템 (향상된 버전)

당신은 APE(Agentic Pipeline Extension)의 도움말 시스템입니다. 사용자가 입력한 알 수 없는 명령어를 해석하고 관련된 유효한 명령어나 질문을 추천해야 합니다.

## 사용자 입력

사용자가 입력한 알 수 없는 명령어: \`${originalInput}\`

## 도움말 데이터

${JSON.stringify(helpData, null, 2)}

## 가이드 데이터

${JSON.stringify(guideData, null, 2)}

## 유사 명령어 (레벤슈타인 거리 기반)

${JSON.stringify(similarCommandsInfo, null, 2)}

## 응답 지침

1. 사용자 입력을 분석하여 의도를 파악하세요. 특히 한글로 입력된 자연어 질문이나 명령에 주의하세요.
2. 제공된 유사 명령어를 참고하여 사용자가 실제로 원했을 가능성이 높은 명령어를 추천하세요.
3. 사용자 입력과 유사한 명령어가 있다면 오타일 가능성을 언급하세요. (예: "/gti status"는 "/git status"의 오타로 보입니다)
4. 한글 입력의 경우 "뭐해야해", "뭐부터해야해" 같은 자연어 질문으로 이해하고 적절한 워크플로우를 제안하세요.
5. 특히 레벤슈타인 거리가 가장 작은 명령어를 우선적으로 추천하되, 맥락상 맞지 않는 경우는 제외하세요.
6. 현재 상황에 적합한 컨텍스트 질문도 추천하세요.
7. 응답은 친절하고 도움이 되는 톤으로 작성하세요.
8. 응답은 다음 형식으로 작성하세요:

---
### 명령어 해석

[입력한 명령어에 대한 해석 및 추측 - 한글 입력의 경우 사용자 의도를 자세히 분석]

### 추천 명령어

- **[명령어1]**: [설명] [오타 가능성 또는 추천 이유 언급]
- **[명령어2]**: [설명]
- **[명령어3]**: [설명]

### 추천 질문

- [질문1]
- [질문2]
- [질문3]

---

응답을 시작하세요.
`;
    }
    /**
     * LLM 응답을 WebView 패널로 표시
     */
    async showLlmResponsePanel(title, content) {
        // WebView 패널 생성
        const panel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createWebviewPanel('apeLlmResponse', title, vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.One, {
            enableScripts: true,
            localResourceRoots: [vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this.context.extensionUri, 'media')]
        });
        // LLM 응답에서 명령어 추출 (한글 명령어 포함)
        const commandRegex = /\*\*\/([\p{L}\p{N}-]+)(?:\s+[\p{L}\p{N}-]+)*\*\*/gu;
        const extractedCommands = [];
        let match;
        while ((match = commandRegex.exec(content)) !== null) {
            extractedCommands.push(`/${match[1]}`);
        }
        // 질문 추출
        const questionRegex = /- ([^-\n]+)/g;
        const extractedQuestions = [];
        match = null;
        while ((match = questionRegex.exec(content)) !== null) {
            const question = match[1].trim();
            if (question && !question.startsWith('/')) {
                extractedQuestions.push(question);
            }
        }
        // 패널에 HTML 설정
        panel.webview.html = this.getLlmResponseHtml(content, extractedCommands, extractedQuestions);
        // 메시지 핸들러 설정
        panel.webview.onDidReceiveMessage(async (message) => {
            if (message.type === 'executeCommand') {
                // 명령어 실행
                await this.executeCommand(message.command);
            }
            else if (message.type === 'insertToChat') {
                // 채팅 입력창에 텍스트 삽입 (이벤트 발생)
                vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.insertToChatInput', message.text);
            }
        });
    }
    /**
     * LLM 응답 HTML 생성
     */
    getLlmResponseHtml(content, commands, questions) {
        // 마크다운을 HTML로 변환
        const markdownContent = content
            // 제목 변환
            .replace(/^### (.*$)/gm, '<h3>$1</h3>')
            .replace(/^## (.*$)/gm, '<h2>$1</h2>')
            .replace(/^# (.*$)/gm, '<h1>$1</h1>')
            // 볼드 및 코드 변환
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/`(.*?)`/g, '<code>$1</code>')
            // 목록 변환
            .replace(/^- (.*$)/gm, '<li>$1</li>')
            .replace(/(<li>.*<\/li>\n)+/g, '<ul>$&</ul>');
        // 명령어 및 질문 버튼 HTML 생성
        let commandsHtml = '';
        if (commands.length > 0) {
            commandsHtml = `
        <div class="command-buttons">
          <h3>명령어 바로 실행</h3>
          <div class="button-container">
            ${commands.map(cmd => `
              <button class="command-button" onclick="executeCommand('${cmd}')">${cmd}</button>
            `).join('')}
          </div>
        </div>
      `;
        }
        let questionsHtml = '';
        if (questions.length > 0) {
            questionsHtml = `
        <div class="question-buttons">
          <h3>질문 추천</h3>
          <div class="button-container">
            ${questions.map(q => `
              <button class="question-button" onclick="insertToChat('${q.replace(/'/g, "\\'")}')">${q}</button>
            `).join('')}
          </div>
        </div>
      `;
        }
        return `
      <!DOCTYPE html>
      <html lang="ko">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>APE 명령어 도움말</title>
        <style>
          :root {
            --bg-color: var(--vscode-editor-background, #1e1e1e);
            --text-color: var(--vscode-editor-foreground, #d4d4d4);
            --link-color: var(--vscode-textLink-foreground, #3794ff);
            --button-bg: var(--vscode-button-background, #0e639c);
            --button-fg: var(--vscode-button-foreground, white);
            --button-hover-bg: var(--vscode-button-hoverBackground, #1177bb);
            --code-bg: var(--vscode-textBlockQuote-background, #2a2d2e);
          }
          
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
          }
          
          h1, h2, h3 {
            margin-top: 20px;
            margin-bottom: 10px;
          }
          
          ul {
            margin-bottom: 20px;
          }
          
          code {
            background-color: var(--code-bg);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
          }
          
          .content {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
          }
          
          .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
          }
          
          .command-button, .question-button {
            background-color: var(--button-bg);
            color: var(--button-fg);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
          }
          
          .command-button:hover, .question-button:hover {
            background-color: var(--button-hover-bg);
          }
          
          .question-button {
            background-color: var(--vscode-badge-background, #4d4d4d);
          }
          
          .question-button:hover {
            background-color: var(--vscode-list-hoverBackground, #2a2d2e);
          }
        </style>
      </head>
      <body>
        <div class="content">
          ${markdownContent}
        </div>
        
        ${commandsHtml}
        ${questionsHtml}
        
        <script>
          const vscode = acquireVsCodeApi();
          
          function executeCommand(command) {
            vscode.postMessage({
              type: 'executeCommand',
              command: command
            });
          }
          
          function insertToChat(text) {
            vscode.postMessage({
              type: 'insertToChat',
              text: text
            });
          }
        </script>
      </body>
      </html>
    `;
    }
    /**
     * 명령어 제안 항목 가져오기
     */
    getCommandSuggestions(input = '') {
        // 입력한 텍스트 처리
        const trimmedInput = input.trim();
        const isSlashCommand = trimmedInput.startsWith('/');
        // 슬래시가 없으면 빈 배열 반환
        if (!isSlashCommand && trimmedInput !== '') {
            return [];
        }
        // 슬래시 이후 텍스트 추출
        const searchText = isSlashCommand ? trimmedInput.substring(1).toLowerCase() : '';
        // 명령어 필터링
        return this.filterCommands(searchText);
    }
    /**
     * 명령어 필터링
     */
    filterCommands(searchText) {
        const suggestions = [];
        for (const command of this.getAllCommands()) {
            // 검색어 필터링
            if (searchText && !command.name.toLowerCase().includes(searchText)) {
                // 별칭 검색
                const hasMatchingAlias = command.aliases?.some(alias => alias.toLowerCase().includes(searchText));
                // 매칭되는 별칭이 없으면 건너뛰기
                if (!hasMatchingAlias) {
                    continue;
                }
            }
            // 제안 항목 생성
            suggestions.push({
                label: `/${command.name}`,
                description: command.description,
                detail: command.examples ? `예시: ${command.examples.join(', ')}` : undefined,
                category: command.category,
                insertText: `/${command.name} `,
                iconPath: this.getIconForCategory(command.category)
            });
        }
        // 우선순위 및 이름으로 정렬
        return suggestions.sort((a, b) => {
            // 우선 카테고리로 정렬
            const commandA = this.getCommand(a.label.substring(1));
            const commandB = this.getCommand(b.label.substring(1));
            // 우선순위 비교
            const priorityA = commandA?.priority || 100;
            const priorityB = commandB?.priority || 100;
            if (priorityA !== priorityB) {
                return priorityA - priorityB;
            }
            // 이름으로 정렬
            return a.label.localeCompare(b.label);
        });
    }
    /**
     * 카테고리별 아이콘 가져오기
     */
    getIconForCategory(category) {
        // 이모지 아이콘 대신 ThemeIcon 사용
        switch (category) {
            case 'general':
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('info');
            case 'git':
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('git-commit');
            case 'code':
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('code');
            case 'utility':
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('tools');
            case 'advanced':
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('settings-gear');
            default:
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('symbol-event');
        }
    }
    /**
     * 명령어 자동완성 제공
     */
    provideCompletions(input) {
        // 입력한 텍스트 처리
        const trimmedInput = input.trim();
        if (!trimmedInput.startsWith('/')) {
            return [];
        }
        const parts = trimmedInput.split(' ');
        const commandName = parts[0].substring(1); // 슬래시 제거
        const partialArg = parts.length > 1 ? parts[parts.length - 1] : '';
        // 명령어 찾기
        const command = this.getCommand(commandName);
        if (!command || !command.provideCompletions) {
            return [];
        }
        // 명령어별 자동완성 호출
        return command.provideCompletions(partialArg);
    }
    /**
     * 명령어 제안 업데이트
     *
     * 채팅 입력 필드 값이 변경될 때 호출됩니다.
     */
    updateSuggestions(input) {
        const suggestions = this.getCommandSuggestions(input);
        this._onDidSuggestCommands.fire(suggestions);
    }
    /**
     * 명령어 도움말 표시
     *
     * 새로운 JSON 기반 도움말 시스템 사용
     */
    async showCommandHelp(arg) {
        // 도움말 패널 생성
        const helpPanel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createWebviewPanel('apeCommandHelp', 'APE 도움말', vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.One, {
            enableScripts: true, // 스크립트 활성화 (도움말 내비게이션 위함)
            localResourceRoots: [vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this.context.extensionUri, 'media')]
        });
        // 메시지 핸들러 설정
        helpPanel.webview.onDidReceiveMessage(async (message) => {
            if (message.type === 'command') {
                // 도움말 내에서 명령어 실행
                if (message.command.startsWith('help ')) {
                    // 도움말 내부 링크 처리
                    const helpArg = message.command.substring(5);
                    await this.processHelpCommand(helpPanel, helpArg);
                }
                else {
                    // 다른 명령어는 슬래시 명령어로 실행
                    await this.executeCommand(`/${message.command}`);
                }
            }
            else if (message.type === 'expandTreeView') {
                // 트리 뷰 확장 요청
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.focusTreeView');
            }
        });
        // 초기 도움말 내용 표시
        if (!arg) {
            // 카테고리 또는 명령어 미지정 시 기본 도움말 표시
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)();
        }
        else if (arg.startsWith('guide ')) {
            // 가이드 문서 표시
            const guideId = arg.substring(6);
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateGuideHtml)(guideId);
        }
        else if (arg === 'guides' || arg === 'guide') {
            // 가이드 목록 표시
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateGuidesListHtml)();
        }
        else if (arg === 'faq') {
            // FAQ 표시
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateFaqHtml)();
        }
        else if (arg === 'tools') {
            // Agent 도구 목록 표시
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateToolsHelpHtml)();
        }
        else if (this.getCommand(arg)) {
            // 명령어 상세 정보 표시
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateCommandDetailHtml)(arg);
        }
        else if (arg.startsWith('search ')) {
            // 도움말 검색 기능
            const query = arg.substring(7);
            if (this.llmService) {
                // LLM 서비스가 있는 경우 스마트 도움말 사용
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateSmartHelpHtml)(query, this.llmService);
            }
            else {
                // LLM 서비스가 없는 경우 기본 도움말 표시와 메시지
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)();
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage('스마트 도움말 검색을 위한 LLM 서비스를 사용할 수 없습니다.');
            }
        }
        else {
            // 카테고리 지정 시 해당 카테고리 도움말 표시
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)(arg);
        }
    }
    /**
     * 도움말 명령어 처리
     *
     * 도움말 패널 내에서 명령어 실행 시 처리
     */
    async processHelpCommand(helpPanel, arg) {
        // 도움말 내부 링크 클릭 처리
        if (!arg) {
            // 인자 없는 경우 기본 도움말 표시
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)();
        }
        else if (arg.startsWith('guide ')) {
            // 가이드 문서 표시
            const guideId = arg.substring(6);
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateGuideHtml)(guideId);
        }
        else if (arg === 'guides' || arg === 'guide') {
            // 가이드 목록 표시
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateGuidesListHtml)();
        }
        else if (arg === 'faq') {
            // FAQ 표시
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateFaqHtml)();
        }
        else if (arg === 'tools') {
            // Agent 도구 목록 표시
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateToolsHelpHtml)();
        }
        else if (arg.startsWith('search ')) {
            // 도움말 검색 기능
            const query = arg.substring(7);
            if (this.llmService) {
                // LLM 서비스가 있는 경우 스마트 도움말 사용
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateSmartHelpHtml)(query, this.llmService);
            }
            else {
                // LLM 서비스가 없는 경우 기본 도움말 표시와 메시지
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)();
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage('스마트 도움말 검색을 위한 LLM 서비스를 사용할 수 없습니다.');
            }
        }
        else {
            // 명령어 이름으로 처리
            const command = this.getCommand(arg);
            if (command) {
                // 명령어 상세 정보 표시
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateCommandDetailHtml)(arg);
            }
            else {
                // 카테고리로 처리
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)(arg);
            }
        }
    }
    /**
     * 카테고리 제목 가져오기
     */
    getCategoryTitle(category) {
        switch (category) {
            case 'general':
                return '일반 명령어';
            case 'git':
                return 'Git 관련 명령어';
            case 'code':
                return '코드 관련 명령어';
            case 'utility':
                return '유틸리티 명령어';
            case 'advanced':
                return '고급 명령어';
            default:
                return category;
        }
    }
    /**
     * 도움말 패널 HTML 생성
     */
    getHelpPanelHtml(content) {
        return `
      <!DOCTYPE html>
      <html lang="ko">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>슬래시 명령어 도움말</title>
        <style>
          body {
            font-family: var(--vscode-font-family, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif);
            padding: 0 20px;
            color: var(--vscode-foreground);
            font-size: var(--vscode-font-size);
            background-color: var(--vscode-editor-background);
          }
          h1 {
            border-bottom: 1px solid var(--vscode-panel-border);
            padding-bottom: 10px;
            color: var(--vscode-symbolIcon-classForeground);
          }
          h2 {
            margin-top: 20px;
            color: var(--vscode-symbolIcon-constantForeground);
            border-left: 3px solid var(--vscode-activityBarBadge-background);
            padding-left: 10px;
          }
          code {
            font-family: var(--vscode-editor-font-family, monospace);
            background-color: var(--vscode-textBlockQuote-background);
            padding: 2px 4px;
            border-radius: 3px;
          }
          .command-name {
            font-weight: bold;
            color: var(--vscode-symbolIcon-functionForeground);
          }
        </style>
      </head>
      <body>
        ${this.markdownToHtml(content)}
      </body>
      </html>
    `;
    }
    /**
     * 마크다운을 HTML로 변환 (간단 구현)
     */
    markdownToHtml(markdown) {
        return markdown
            // 헤더 변환
            .replace(/^# (.+)$/gm, '<h1>$1</h1>')
            .replace(/^## (.+)$/gm, '<h2>$1</h2>')
            .replace(/^### (.+)$/gm, '<h3>$1</h3>')
            // 볼드 텍스트 변환
            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
            // 명령어 강조 (한글, 영문 모두 지원)
            .replace(/\/([\p{L}\p{N}-]+)/gu, '<code>/$1</code>')
            // 목록 변환
            .replace(/^- (.+)$/gm, '<li>$1</li>')
            .replace(/(<li>.*<\/li>\n)+/g, '<ul>$&</ul>')
            // 줄바꿈 변환
            .replace(/\n\n/g, '</p><p>')
            .replace(/\n/g, '<br>')
            // 단락 감싸기
            .replace(/^(.+?)(?=<\/p>|<h[1-6]|<ul>|$)/s, '<p>$1</p>');
    }
    /**
     * Git 상태 표시
     */
    async showGitStatus() {
        try {
            // Git 확장 API 가져오기
            const gitExtension = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('vscode.git')?.exports;
            if (!gitExtension) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Git 확장이 활성화되지 않았습니다.');
                return;
            }
            const git = gitExtension.getAPI(1);
            if (!git) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Git API를 가져올 수 없습니다.');
                return;
            }
            // 현재 저장소 가져오기
            const repositories = git.repositories;
            if (repositories.length === 0) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('Git 저장소가 없습니다.');
                return;
            }
            // 현재 저장소 상태 표시
            const repo = repositories[0];
            const state = repo.state;
            // 상태 메시지 생성
            const changes = state.workingTreeChanges.length;
            const staged = state.indexChanges.length;
            const untracked = state.untrackedChanges.length;
            const statusMessage = `# Git 상태 요약\n\n` +
                `- 브랜치: **${state.HEAD?.name || 'detached HEAD'}**\n` +
                `- 변경: **${changes}**개 파일\n` +
                `- 스테이징: **${staged}**개 파일\n` +
                `- 추적되지 않음: **${untracked}**개 파일\n\n` +
                `## 변경된 파일\n\n` +
                state.workingTreeChanges.map((c) => `- ${c.uri.fsPath.split('/').pop()} (${this.getChangeTypeLabel(c.status)})`).join('\n');
            // 도움말 패널로 표시
            const statusPanel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createWebviewPanel('apeGitStatus', 'Git 상태', vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.One, {
                enableScripts: false,
                localResourceRoots: []
            });
            statusPanel.webview.html = this.getHelpPanelHtml(statusMessage);
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Git 상태 확인 오류: ${error}`);
        }
    }
    /**
     * 변경 유형 라벨 가져오기
     */
    getChangeTypeLabel(status) {
        // Git 변경 타입 매핑
        switch (status) {
            case 0: return '추가됨'; // Added
            case 1: return '수정됨'; // Modified
            case 2: return '삭제됨'; // Deleted
            case 3: return '이름 변경됨'; // Renamed
            case 4: return '복사됨'; // Copied
            default: return '알 수 없음';
        }
    }
}


/***/ }),

/***/ "./src/core/commands/vaultCommands.ts":
/*!********************************************!*\
  !*** ./src/core/commands/vaultCommands.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createVaultCommands: () => (/* binding */ createVaultCommands)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _services_vaultService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/vaultService */ "./src/core/services/vaultService.ts");
/**
 * VAULT 관련 슬래시 커맨드 정의
 */


/**
 * VAULT 명령어 생성
 * @param vaultService VAULT 서비스 인스턴스
 */
function createVaultCommands(vaultService) {
    const commands = [];
    // VAULT 메인 명령어
    commands.push({
        name: 'vault',
        aliases: ['컨텍스트', '볼트', 'ctx', 'context'],
        description: 'VAULT 컨텍스트 및 아이템을 관리합니다',
        examples: ['/vault list', '/vault show system-context', '/vault use system-item-1', '/vault create personal 내 작업 메모'],
        category: 'utility',
        priority: 5,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand || subCommand === 'list' || subCommand === '목록') {
                // 컨텍스트 목록 표시
                await showContextList(vaultService);
            }
            else if (subCommand === 'show' || subCommand === '보기' || subCommand === 'view') {
                // 컨텍스트 또는 아이템 상세 보기
                const id = context.args[1];
                if (!id) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('표시할 컨텍스트 또는 아이템 ID를 지정해주세요');
                    return;
                }
                await showContextOrItem(vaultService, id);
            }
            else if (subCommand === 'use' || subCommand === '사용') {
                // 아이템 사용 (채팅창에 내용 삽입)
                const itemId = context.args[1];
                if (!itemId) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('사용할 아이템 ID를 지정해주세요');
                    return;
                }
                await useVaultItem(vaultService, itemId);
            }
            else if (subCommand === 'create' || subCommand === '생성' || subCommand === 'new' || subCommand === '새로만들기') {
                // 새 컨텍스트 또는 아이템 생성
                const type = context.args[1]?.toLowerCase();
                const name = context.args.slice(2).join(' ');
                if (!type || !name) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('컨텍스트 유형과 이름을 지정해주세요');
                    return;
                }
                await createContextOrItem(vaultService, type, name);
            }
            else if (subCommand === 'delete' || subCommand === '삭제' || subCommand === 'remove') {
                // 컨텍스트 또는 아이템 삭제
                const id = context.args[1];
                if (!id) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('삭제할 컨텍스트 또는 아이템 ID를 지정해주세요');
                    return;
                }
                await deleteContextOrItem(vaultService, id);
            }
            else if (subCommand === 'search' || subCommand === '검색') {
                // 아이템 검색
                const query = context.args.slice(1).join(' ');
                if (!query) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('검색어를 입력해주세요');
                    return;
                }
                await searchVaultItems(vaultService, query);
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`알 수 없는 VAULT 하위 명령어입니다: ${subCommand}`);
            }
        },
        provideCompletions: (partialArgs) => {
            const parts = partialArgs.split(' ');
            // 첫 번째 인자 자동완성 (하위 명령어)
            if (parts.length <= 1) {
                const options = ['list', 'show', 'use', 'create', 'delete', 'search', '목록', '보기', '사용', '생성', '삭제', '검색'];
                return options.filter(option => option.toLowerCase().startsWith(parts[0].toLowerCase() || ''));
            }
            // 두 번째 인자 자동완성
            if (parts.length === 2) {
                const subCommand = parts[0].toLowerCase();
                if (subCommand === 'create' || subCommand === '생성' || subCommand === 'new' || subCommand === '새로만들기') {
                    // 컨텍스트 유형 제안
                    const typeOptions = ['system', 'project', 'personal', 'shared', 'template', '시스템', '프로젝트', '개인', '공유', '템플릿'];
                    return typeOptions.filter(option => option.toLowerCase().startsWith(parts[1].toLowerCase() || ''));
                }
                else if (subCommand === 'show' || subCommand === '보기' || subCommand === 'view' ||
                    subCommand === 'use' || subCommand === '사용' ||
                    subCommand === 'delete' || subCommand === '삭제' || subCommand === 'remove') {
                    // 컨텍스트/아이템 ID 제안 - 실제로는 vaultService에서 가져와야 함
                    // 모의 데이터 사용
                    const idOptions = ['system-context', 'project-context', 'personal-context', 'shared-context', 'template-context',
                        'system-item-1', 'system-item-2', 'project-item-1', 'project-item-2', 'personal-item-1'];
                    return idOptions.filter(option => option.toLowerCase().startsWith(parts[1].toLowerCase() || ''));
                }
            }
            return [];
        }
    });
    return commands;
}
/**
 * 컨텍스트 목록 표시
 */
async function showContextList(vaultService, context) {
    try {
        const allContexts = vaultService.getAllContexts();
        if (allContexts.length === 0) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: 'VAULT에 저장된 컨텍스트가 없습니다.'
            });
            return;
        }
        let content = '## VAULT 컨텍스트 목록\n\n';
        // 컨텍스트 타입별 그룹화
        const groupedContexts = {
            'system': [],
            'project': [],
            'personal': [],
            'shared': [],
            'template': []
        };
        allContexts.forEach((ctx) => {
            groupedContexts[ctx.type].push(ctx);
        });
        // 타입별로 표시
        for (const [type, contexts] of Object.entries(groupedContexts)) {
            if (contexts.length > 0) {
                // 타입명 한글로 변환
                let typeKorean = '';
                switch (type) {
                    case 'system':
                        typeKorean = '시스템';
                        break;
                    case 'project':
                        typeKorean = '프로젝트';
                        break;
                    case 'personal':
                        typeKorean = '개인';
                        break;
                    case 'shared':
                        typeKorean = '공유';
                        break;
                    case 'template':
                        typeKorean = '템플릿';
                        break;
                    default: typeKorean = type;
                }
                content += `### ${typeKorean} 컨텍스트\n\n`;
                contexts.forEach(context => {
                    content += `- **${context.name}** (ID: \`${context.id}\`): ${context.items.length}개 항목`;
                    if (context.description) {
                        content += ` - ${context.description}`;
                    }
                    content += '\n';
                    // 해당 컨텍스트의 아이템들 표시
                    if (context.items.length > 0) {
                        content += '  - 아이템 목록:\n';
                        context.items.forEach((item) => {
                            content += `    - ${item.name} (ID: \`${item.id}\`)`;
                            if (item.description) {
                                content += ` - ${item.description}`;
                            }
                            content += '\n';
                        });
                    }
                    content += '\n';
                });
            }
        }
        // 컨텍스트를 사용하는 방법 안내
        content += '\n### 사용 방법\n\n';
        content += '- 컨텍스트 상세 정보 보기: `/vault show [컨텍스트ID]`\n';
        content += '- 아이템 내용 보기: `/vault show [아이템ID]`\n';
        content += '- 아이템 사용하기: `/vault use [아이템ID]`\n';
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        console.error('컨텍스트 목록 표시 오류:', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('컨텍스트 목록을 가져오는 중 오류가 발생했습니다');
    }
}
/**
 * 컨텍스트 또는 아이템 상세 보기
 */
async function showContextOrItem(vaultService, id) {
    try {
        // 먼저 컨텍스트 검색
        const context = vaultService.getContextById(id);
        if (context) {
            // 컨텍스트 정보 표시
            let content = `## 컨텍스트: ${context.name}\n\n`;
            content += `- **ID**: \`${context.id}\`\n`;
            content += `- **유형**: ${getContextTypeKorean(context.type)}\n`;
            if (context.description) {
                content += `- **설명**: ${context.description}\n`;
            }
            content += `- **생성일**: ${formatDate(context.createdAt)}\n`;
            content += `- **수정일**: ${formatDate(context.updatedAt)}\n`;
            content += `- **항목 수**: ${context.items.length}개\n\n`;
            if (context.items.length > 0) {
                content += '### 포함된 아이템\n\n';
                context.items.forEach((item) => {
                    content += `- **${item.name}** (ID: \`${item.id}\`)`;
                    if (item.description) {
                        content += ` - ${item.description}`;
                    }
                    content += '\n';
                });
            }
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content
            });
            return;
        }
        // 아이템 검색
        const allContexts = vaultService.getAllContexts();
        for (const context of allContexts) {
            const item = context.items.find((item) => item.id === id);
            if (item) {
                // 아이템 정보 표시
                let content = `## 아이템: ${item.name}\n\n`;
                content += `- **ID**: \`${item.id}\`\n`;
                content += `- **컨텍스트**: ${context.name} (${getContextTypeKorean(context.type)})\n`;
                if (item.description) {
                    content += `- **설명**: ${item.description}\n`;
                }
                content += `- **생성일**: ${formatDate(item.createdAt)}\n`;
                content += `- **수정일**: ${formatDate(item.updatedAt)}\n`;
                if (item.tags && item.tags.length > 0) {
                    content += `- **태그**: ${item.tags.join(', ')}\n`;
                }
                content += '\n### 내용\n\n';
                content += '```\n' + item.content + '\n```\n\n';
                content += '이 아이템을 사용하려면 `/vault use ' + item.id + '` 명령어를 실행하세요.';
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content
                });
                return;
            }
        }
        // 컨텍스트나 아이템을 찾지 못한 경우
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `ID가 \`${id}\`인 컨텍스트나 아이템을 찾을 수 없습니다.`
        });
    }
    catch (error) {
        console.error('컨텍스트/아이템 표시 오류:', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('컨텍스트 또는 아이템 정보를 가져오는 중 오류가 발생했습니다');
    }
}
/**
 * 아이템 사용 (채팅창에 내용 삽입)
 */
async function useVaultItem(vaultService, itemId) {
    try {
        // 아이템 검색
        const allContexts = vaultService.getAllContexts();
        for (const context of allContexts) {
            const item = context.items.find((item) => item.id === itemId);
            if (item) {
                // 아이템 내용을 LLM에게 제공
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendUserMessage', {
                    content: item.content
                });
                return;
            }
        }
        // 아이템을 찾지 못한 경우
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `ID가 \`${itemId}\`인 아이템을 찾을 수 없습니다.`
        });
    }
    catch (error) {
        console.error('아이템 사용 오류:', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('아이템을 사용하는 중 오류가 발생했습니다');
    }
}
/**
 * 새 컨텍스트 또는 아이템 생성
 */
async function createContextOrItem(vaultService, typeStr, name) {
    try {
        // 컨텍스트 유형 결정
        let contextType;
        switch (typeStr.toLowerCase()) {
            case 'system':
            case '시스템':
                contextType = _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.System;
                break;
            case 'project':
            case '프로젝트':
                contextType = _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Project;
                break;
            case 'personal':
            case '개인':
                contextType = _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Personal;
                break;
            case 'shared':
            case '공유':
                contextType = _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Shared;
                break;
            case 'template':
            case '템플릿':
                contextType = _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Template;
                break;
            default:
                // 컨텍스트 ID인지 확인 (아이템 생성 모드)
                const context = vaultService.getContextById(typeStr);
                if (context) {
                    // 아이템 생성 모드
                    await createItem(vaultService, context, name);
                    return;
                }
                // 유효하지 않은 유형
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('유효하지 않은 컨텍스트 유형이나 ID입니다');
                return;
        }
        // 컨텍스트 생성
        await createContext(vaultService, contextType, name);
    }
    catch (error) {
        console.error('컨텍스트/아이템 생성 오류:', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('컨텍스트 또는 아이템을 생성하는 중 오류가 발생했습니다');
    }
}
/**
 * 새 컨텍스트 생성
 */
async function createContext(vaultService, type, name) {
    try {
        // 설명 입력 받기
        const description = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: '컨텍스트 설명을 입력하세요 (선택사항)',
            placeHolder: '컨텍스트에 대한 설명'
        });
        // 컨텍스트 생성
        const newContext = await vaultService.createContext(name, type, description);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `${getContextTypeKorean(type)} 컨텍스트 "${name}"가 생성되었습니다. (ID: \`${newContext.id}\`)`
        });
    }
    catch (error) {
        console.error('컨텍스트 생성 오류:', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('컨텍스트를 생성하는 중 오류가 발생했습니다');
    }
}
/**
 * 새 아이템 생성
 */
async function createItem(vaultService, context, name) {
    try {
        // 설명 입력 받기
        const description = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: '아이템 설명을 입력하세요 (선택사항)',
            placeHolder: '아이템에 대한 설명'
        });
        // 태그 입력 받기
        const tagsInput = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: '태그를 입력하세요 (쉼표로 구분, 선택사항)',
            placeHolder: 'tag1, tag2, tag3'
        });
        const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()) : undefined;
        // 내용 입력 받기 (에디터 열기)
        const document = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument({
            content: '',
            language: 'markdown'
        });
        const editor = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showTextDocument(document);
        // 사용자가 내용 편집을 완료할 때까지 대기
        const content = await new Promise(resolve => {
            const disposable = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidCloseTextDocument(closedDoc => {
                if (closedDoc === document) {
                    resolve(document.getText());
                    disposable.dispose();
                }
            });
        });
        if (!content.trim()) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('아이템 내용이 비어 있습니다. 아이템 생성이 취소되었습니다.');
            return;
        }
        // 아이템 생성
        const newItem = await vaultService.createItem(context.id, {
            name,
            description,
            content,
            tags,
            contextType: context.type
        });
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `"${context.name}" 컨텍스트에 "${name}" 아이템이 생성되었습니다. (ID: \`${newItem.id}\`)`
        });
    }
    catch (error) {
        console.error('아이템 생성 오류:', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('아이템을 생성하는 중 오류가 발생했습니다');
    }
}
/**
 * 컨텍스트 또는 아이템 삭제
 */
async function deleteContextOrItem(vaultService, id) {
    try {
        // 컨텍스트인지 확인
        const context = vaultService.getContextById(id);
        if (context) {
            // 컨텍스트 삭제 확인
            const confirmed = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage(`"${context.name}" 컨텍스트를 삭제하시겠습니까? 이 작업은 되돌릴 수 없으며, 포함된 모든 아이템이 함께 삭제됩니다.`, { modal: true }, '삭제');
            if (confirmed !== '삭제') {
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: '컨텍스트 삭제가 취소되었습니다.'
                });
                return;
            }
            // 컨텍스트 삭제
            await vaultService.deleteContext(id);
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `"${context.name}" 컨텍스트가 삭제되었습니다.`
            });
            return;
        }
        // 아이템 검색
        const allContexts = vaultService.getAllContexts();
        for (const ctx of allContexts) {
            const itemIndex = ctx.items.findIndex((item) => item.id === id);
            if (itemIndex !== -1) {
                const item = ctx.items[itemIndex];
                // 아이템 삭제 확인
                const confirmed = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage(`"${item.name}" 아이템을 삭제하시겠습니까? 이 작업은 되돌릴 수 없습니다.`, { modal: true }, '삭제');
                if (confirmed !== '삭제') {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: '아이템 삭제가 취소되었습니다.'
                    });
                    return;
                }
                // 아이템 삭제
                await vaultService.deleteItem(ctx.id, id);
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: `"${item.name}" 아이템이 삭제되었습니다.`
                });
                return;
            }
        }
        // 컨텍스트나 아이템을 찾지 못한 경우
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `ID가 \`${id}\`인 컨텍스트나 아이템을 찾을 수 없습니다.`
        });
    }
    catch (error) {
        console.error('컨텍스트/아이템 삭제 오류:', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('컨텍스트 또는 아이템을 삭제하는 중 오류가 발생했습니다');
    }
}
/**
 * 아이템 검색
 */
async function searchVaultItems(vaultService, query) {
    try {
        // 아이템 검색
        const items = vaultService.searchItems(query);
        if (items.length === 0) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `"${query}" 검색어와 일치하는 아이템이 없습니다.`
            });
            return;
        }
        // 결과 표시
        let content = `## "${query}" 검색 결과\n\n`;
        content += `총 ${items.length}개의 아이템이 검색되었습니다.\n\n`;
        // 아이템 그룹화 (컨텍스트별)
        const groupedItems = {};
        items.forEach((item) => {
            if (!groupedItems[item.contextId || 'unknown']) {
                groupedItems[item.contextId || 'unknown'] = [];
            }
            groupedItems[item.contextId || 'unknown'].push(item);
        });
        // 컨텍스트별로 표시
        for (const [contextId, ctxItems] of Object.entries(groupedItems)) {
            const context = vaultService.getContextById(contextId);
            if (context) {
                content += `### ${context.name} (${getContextTypeKorean(context.type)})\n\n`;
                ctxItems.forEach((item) => {
                    content += `- **${item.name}** (ID: \`${item.id}\`)`;
                    if (item.description) {
                        content += ` - ${item.description}`;
                    }
                    content += '\n';
                    if (item.tags && item.tags.length > 0) {
                        content += `  - 태그: ${item.tags.join(', ')}\n`;
                    }
                    // 내용 일부 표시 (최대 100자)
                    const previewContent = item.content.length > 100
                        ? item.content.substring(0, 100) + '...'
                        : item.content;
                    content += `  - 내용 미리보기: ${previewContent.replace(/\n/g, ' ')}\n\n`;
                });
            }
        }
        content += '자세히 보려면 `/vault show [아이템ID]` 명령어를 사용하세요.';
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        console.error('아이템 검색 오류:', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('아이템을 검색하는 중 오류가 발생했습니다');
    }
}
/**
 * 컨텍스트 유형의 한글 이름 가져오기
 */
function getContextTypeKorean(type) {
    switch (type) {
        case _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.System: return '시스템';
        case _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Project: return '프로젝트';
        case _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Personal: return '개인';
        case _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Shared: return '공유';
        case _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Template: return '템플릿';
        default: return String(type);
    }
}
/**
 * 날짜 포맷팅
 */
function formatDate(date) {
    const d = typeof date === 'string' ? new Date(date) : date;
    return d.toLocaleDateString() + ' ' + d.toLocaleTimeString();
}


/***/ }),

/***/ "./src/core/completion/inlineCompletionProvider.ts":
/*!*********************************************************!*\
  !*** ./src/core/completion/inlineCompletionProvider.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InlineCompletionProvider: () => (/* binding */ InlineCompletionProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/**
 * 인라인 완성 제공자
 *
 * VS Code 입력 중에 인라인 제안 및 고스트 텍스트를 제공하는 컴포넌트
 */


/**
 * 인라인 완성 제공자 클래스
 */
class InlineCompletionProvider {
    llmService;
    context;
    completionCache = new Map();
    cacheTimeout = 5 * 60 * 1000; // 5분
    requestQueue = new Map();
    completionConfig = {
        enabled: true,
        triggerLength: 3,
        debounceDelay: 300,
        maxLineContext: 10
    };
    // 디바운스 타이머
    debounceTimer = null;
    /**
     * 생성자
     */
    constructor(llmService, context) {
        this.llmService = llmService;
        this.context = context;
        // 설정 로드
        this.loadConfiguration();
        // 설정 변경 감지
        vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.completion')) {
                this.loadConfiguration();
            }
        });
    }
    /**
     * 설정 로드
     */
    loadConfiguration() {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.completion');
        this.completionConfig = {
            enabled: config.get('inlineEnabled', true),
            triggerLength: config.get('triggerLength', 3),
            debounceDelay: config.get('debounceDelay', 300),
            maxLineContext: config.get('maxLineContext', 10)
        };
    }
    /**
     * 인라인 완성 제공
     */
    async provideInlineCompletionItems(document, position, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _context, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _token) {
        // 비활성화된 경우
        if (!this.completionConfig.enabled) {
            return null;
        }
        // 현재 줄 가져오기
        const lineText = document.lineAt(position.line).text;
        const linePrefix = lineText.substring(0, position.character);
        // 트리거 확인 (문자 수 검사)
        if (linePrefix.trim().length < this.completionConfig.triggerLength) {
            return null;
        }
        // 특정 파일 형식 필터링 (주석 또는 문서)
        if (this.shouldSkipCompletion(document, position)) {
            return null;
        }
        // 캐시 키 생성
        const cacheKey = `${document.fileName}:${position.line}:${position.character}:${lineText}`;
        // 캐시된 결과가 있는 경우 재사용
        const cachedResult = this.completionCache.get(cacheKey);
        if (cachedResult && Date.now() - cachedResult.timestamp < this.cacheTimeout) {
            return cachedResult.completions;
        }
        // 이미 요청 중인 경우 해당 요청의 결과 대기
        if (this.requestQueue.has(cacheKey)) {
            try {
                return await this.requestQueue.get(cacheKey);
            }
            catch (error) {
                console.error('대기 중인 인라인 완성 요청 오류:', error);
                return null;
            }
        }
        // 디바운스 적용
        if (this.debounceTimer) {
            clearTimeout(this.debounceTimer);
        }
        const completionPromise = new Promise((resolve) => {
            this.debounceTimer = setTimeout(async () => {
                try {
                    // 컨텍스트 수집
                    const context = await this.getCompletionContext(document, position);
                    // LLM을 통한 인라인 완성 요청
                    const completions = await this.requestInlineCompletions(context.precedingText, context.followingText, document.languageId);
                    // 결과 캐싱
                    this.completionCache.set(cacheKey, {
                        completions,
                        timestamp: Date.now()
                    });
                    // 요청 큐에서 제거
                    this.requestQueue.delete(cacheKey);
                    resolve(completions);
                }
                catch (error) {
                    console.error('인라인 완성 요청 오류:', error);
                    this.requestQueue.delete(cacheKey);
                    resolve([]);
                }
            }, this.completionConfig.debounceDelay);
        });
        // 요청 큐에 추가
        this.requestQueue.set(cacheKey, completionPromise);
        return completionPromise;
    }
    /**
     * 완성을 건너뛸지 결정
     */
    shouldSkipCompletion(document, position) {
        // 코드 블록이나 다른 특수 컨텍스트 감지
        const lineText = document.lineAt(position.line).text;
        // 마크다운 코드 블록 또는 주석 내에서는 건너뛰기
        const isMdCodeBlock = document.languageId === 'markdown' &&
            (lineText.trim().startsWith('```') ||
                document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(Math.max(0, position.line - 3), 0), position)).includes('```'));
        // 주석 감지
        const isInComment = this.isPositionInComment(document, position);
        return isMdCodeBlock || isInComment;
    }
    /**
     * 현재 위치가 주석 내에 있는지 확인
     */
    isPositionInComment(document, position) {
        const lineText = document.lineAt(position.line).text;
        // 언어별 주석 구문 검사
        switch (document.languageId) {
            case 'typescript':
            case 'javascript':
            case 'typescriptreact':
            case 'javascriptreact':
            case 'csharp':
            case 'java':
            case 'cpp':
            case 'c': {
                // 한 줄 주석 확인
                if (lineText.substring(0, position.character).includes('//')) {
                    return true;
                }
                // 여러 줄 주석 확인 (간단한 구현)
                const prevText = document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(0, 0), position));
                const commentStarts = (prevText.match(/\/\*/g) || []).length;
                const commentEnds = (prevText.match(/\*\//g) || []).length;
                return commentStarts > commentEnds;
            }
            case 'python':
                // Python 주석
                return lineText.substring(0, position.character).includes('#');
            case 'html':
            case 'xml': {
                // HTML/XML 주석
                const htmlPrev = document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(0, 0), position));
                const htmlCommentStarts = (htmlPrev.match(/<!--/g) || []).length;
                const htmlCommentEnds = (htmlPrev.match(/-->/g) || []).length;
                return htmlCommentStarts > htmlCommentEnds;
            }
        }
        return false;
    }
    /**
     * 완성 컨텍스트 수집
     */
    async getCompletionContext(document, position) {
        // 이전 텍스트 (현재 라인 포함)
        const startLine = Math.max(0, position.line - this.completionConfig.maxLineContext);
        const precedingText = document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(startLine, 0), position));
        // 이후 텍스트 (현재 라인의 나머지 부분 + 다음 몇 줄)
        const endLine = Math.min(document.lineCount - 1, position.line + 5);
        const followingText = document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(position, new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(endLine, document.lineAt(endLine).text.length)));
        return { precedingText, followingText };
    }
    /**
     * LLM을 통한 인라인 완성 요청
     */
    async requestInlineCompletions(precedingText, followingText, languageId) {
        try {
            // 프롬프트 생성
            const prompt = `
현재 사용자가 코드를 작성하고 있습니다. 언어는 ${languageId}입니다.
사용자의 입력을 기반으로 다음에 올 코드를 정확하게 예측해서 제안해주세요.
문맥을 고려하여 가장 적절한 자연스러운 다음 코드 줄이나 구문을 작성해주세요.
인라인 제안이므로 간결하고 정확해야 합니다.

현재까지 작성된 코드:
\`\`\`${languageId}
${precedingText}
\`\`\`

현재 위치 이후의 코드 (컨텍스트):
\`\`\`${languageId}
${followingText}
\`\`\`

다음에 올 코드 예측 (최대 3개):
`;
            // LLM 요청
            const messages = [
                {
                    id: `msg_inline_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            const result = await this.llmService.sendRequest(messages);
            if (result.success && result.data) {
                // 응답 파싱하여 InlineCompletionItem 배열로 변환
                return this.parseInlineCompletionResponse(result.data.content || '');
            }
            else {
                throw new Error('LLM 요청 실패');
            }
        }
        catch (error) {
            console.error('LLM 인라인 완성 요청 오류:', error);
            return [];
        }
    }
    /**
     * LLM 응답을 InlineCompletionItem으로 파싱
     */
    parseInlineCompletionResponse(responseContent) {
        const completions = [];
        try {
            // 코드 블록 추출
            const codeBlockRegex = /```(?:\w+)?\n([\s\S]*?)```/g;
            const codeBlocks = [];
            let match;
            while ((match = codeBlockRegex.exec(responseContent)) !== null) {
                codeBlocks.push(match[1]);
            }
            if (codeBlocks.length > 0) {
                // 코드 블록에서 추출
                for (const block of codeBlocks) {
                    const lines = block.split('\n').filter(line => line.trim() !== '');
                    lines.forEach(line => {
                        if (line.trim()) {
                            completions.push({
                                insertText: line.trim(),
                                range: undefined
                            });
                        }
                    });
                }
            }
            else {
                // 코드 블록이 없는 경우 일반 텍스트로 처리
                const lines = responseContent.split('\n')
                    .filter(line => line.trim() !== '')
                    .filter(line => !line.startsWith('#') && !line.startsWith('-') && !line.startsWith('*'));
                lines.forEach(line => {
                    const cleanedLine = line.replace(/^\d+\.\s+/, '').trim();
                    if (cleanedLine) {
                        completions.push({
                            insertText: cleanedLine,
                            range: undefined
                        });
                    }
                });
            }
        }
        catch (error) {
            console.error('인라인 완성 응답 파싱 오류:', error);
        }
        // 중복 제거
        const uniqueCompletions = this.removeDuplicates(completions);
        return uniqueCompletions.slice(0, 3); // 최대 3개 반환
    }
    /**
     * 중복 제거
     */
    removeDuplicates(completions) {
        const seen = new Set();
        return completions.filter(item => {
            if (item.insertText && !seen.has(item.insertText.toString())) {
                seen.add(item.insertText.toString());
                return true;
            }
            return false;
        });
    }
}


/***/ }),

/***/ "./src/core/completion/tabCompletionProvider.ts":
/*!******************************************************!*\
  !*** ./src/core/completion/tabCompletionProvider.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TabCompletionProvider: () => (/* binding */ TabCompletionProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/**
 * Tab Completion Provider
 *
 * 탭 자동 완성 기능을 제공하는 모듈
 */


/**
 * 탭 자동 완성 제공자
 */
class TabCompletionProvider {
    llmService;
    cachedCompletions = new Map();
    cacheTimeout = 30 * 60 * 1000; // 30분
    suggestionCache = new Map();
    contextAwareCommands = new Map();
    /**
     * 생성자
     */
    constructor(llmService) {
        this.llmService = llmService;
        // 컨텍스트 인식 명령어 초기화
        this.initializeContextAwareCommands();
    }
    /**
     * 컨텍스트 인식 명령어 초기화
     */
    initializeContextAwareCommands() {
        // Git 관련 컨텍스트
        this.contextAwareCommands.set('git', [
            'commit',
            'push',
            'pull',
            'status',
            'solve',
            'branch',
            'auto',
            'consolidate'
        ]);
        // Jira 관련 컨텍스트
        this.contextAwareCommands.set('jira', [
            'create',
            'list',
            'update',
            'comment',
            'assign'
        ]);
        // 코드 관련 컨텍스트
        this.contextAwareCommands.set('code', [
            'analyze',
            'review',
            'optimize',
            'refactor',
            'format'
        ]);
        // SWDP 관련 컨텍스트
        this.contextAwareCommands.set('swdp', [
            'build',
            'deploy',
            'status',
            'verify',
            'list'
        ]);
    }
    /**
     * 자동 완성 제안
     */
    async provideCompletionItems(document, position, token, context) {
        // 트리거 문자가 TAB인 경우에만 처리
        if (context.triggerKind !== vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionTriggerKind.TriggerCharacter &&
            context.triggerKind !== vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionTriggerKind.Invoke) {
            return [];
        }
        // 현재 줄 가져오기
        const lineText = document.lineAt(position.line).text;
        const linePrefix = lineText.substring(0, position.character);
        // 명령어 또는 코드 완성이 필요한지 확인
        if (this.isCommandCompletion(linePrefix)) {
            return this.provideCommandCompletions(linePrefix);
        }
        else {
            // 코드 자동 완성
            return this.provideCodeCompletions(document, position, linePrefix);
        }
    }
    /**
     * 명령어 자동 완성인지 확인
     */
    isCommandCompletion(linePrefix) {
        // 행이 '/'로 시작하는지 확인
        return linePrefix.trim().startsWith('/');
    }
    /**
     * 명령어 자동 완성 제공
     */
    provideCommandCompletions(linePrefix) {
        const commands = [
            { name: 'git', description: 'Git 관련 명령어' },
            { name: 'commit', description: '변경 사항 커밋' },
            { name: 'push', description: '원격 저장소에 푸시' },
            { name: 'pull', description: '원격 저장소에서 풀' },
            { name: 'status', description: 'Git 상태 확인' },
            { name: 'jira', description: 'JIRA 관련 명령어' },
            { name: 'issue', description: 'JIRA 이슈 조회/생성' },
            { name: 'ticket', description: 'JIRA 티켓 관리' },
            { name: 'help', description: '도움말 표시' },
            { name: 'todo', description: '할 일 지정' },
            { name: 'code', description: '코드 분석 및 작업' },
            { name: 'analyze', description: '코드 분석' },
            { name: 'settings', description: '설정 열기' },
            { name: 'theme', description: '테마 변경' },
            { name: 'model', description: 'LLM 모델 설정' },
            { name: 'clear', description: '채팅 내역 지우기' },
            { name: 'swdp', description: 'SWDP 관련 명령어' }
        ];
        // 현재 입력된 명령어 파싱
        const commandParts = linePrefix.trim().substring(1).split(/\s+/);
        const currentCommand = commandParts[0];
        // 현재 작업 컨텍스트 파악
        const activeContext = this.getActiveContext();
        // 하위 명령어 필터링
        if (commandParts.length > 1 && !commandParts[1].startsWith('-')) {
            // 상위 명령어에 따른 하위 명령어 제공
            if (this.contextAwareCommands.has(currentCommand)) {
                const subCommands = this.contextAwareCommands.get(currentCommand) || [];
                return subCommands.map(subCmd => this.createCompletionItem(subCmd, `${currentCommand} ${subCmd} 명령어`, `/${currentCommand} ${subCmd}`));
            }
            // 기본 서브커맨드 제공
            switch (currentCommand) {
                case 'git':
                    return [
                        this.createCompletionItem('commit', '변경 사항 커밋', '/git commit'),
                        this.createCompletionItem('push', '원격 저장소에 푸시', '/git push'),
                        this.createCompletionItem('pull', '원격 저장소에서 풀', '/git pull'),
                        this.createCompletionItem('status', '현재 Git 상태 확인', '/git status'),
                        this.createCompletionItem('solve', '충돌 자동 해결', '/git solve'),
                        this.createCompletionItem('branch', '브랜치 생성/목록/전환', '/git branch'),
                        this.createCompletionItem('auto', '자동 커밋 토글', '/git auto'),
                        this.createCompletionItem('consolidate', '임시 커밋 통합', '/git consolidate')
                    ];
                case 'jira':
                    return [
                        this.createCompletionItem('create', '새 이슈 생성', '/jira create'),
                        this.createCompletionItem('list', '이슈 목록 조회', '/jira list'),
                        this.createCompletionItem('assign', '이슈 할당', '/jira assign'),
                        this.createCompletionItem('update', '이슈 업데이트', '/jira update'),
                        this.createCompletionItem('comment', '이슈에 코멘트 추가', '/jira comment')
                    ];
                case 'code':
                    return [
                        this.createCompletionItem('analyze', '코드 분석', '/code analyze'),
                        this.createCompletionItem('review', '코드 리뷰', '/code review'),
                        this.createCompletionItem('optimize', '코드 최적화', '/code optimize'),
                        this.createCompletionItem('refactor', '코드 리팩토링', '/code refactor'),
                        this.createCompletionItem('format', '코드 서식 정리', '/code format')
                    ];
                case 'swdp':
                    return [
                        this.createCompletionItem('build', '빌드 실행', '/swdp build'),
                        this.createCompletionItem('deploy', '배포 실행', '/swdp deploy'),
                        this.createCompletionItem('status', '상태 확인', '/swdp status'),
                        this.createCompletionItem('verify', '검증 실행', '/swdp verify'),
                        this.createCompletionItem('list', '목록 표시', '/swdp list')
                    ];
                case 'todo':
                    return [
                        this.createCompletionItem('add', '할 일 추가', '/todo add'),
                        this.createCompletionItem('list', '할 일 목록', '/todo list'),
                        this.createCompletionItem('done', '할 일 완료', '/todo done'),
                        this.createCompletionItem('delete', '할 일 삭제', '/todo delete'),
                        this.createCompletionItem('prioritize', '우선순위 변경', '/todo prioritize')
                    ];
            }
        }
        // 현재 컨텍스트에 따라 추천되는 명령어 필터링
        let filteredCommands = [...commands];
        if (activeContext) {
            // 에디터에서 텍스트 선택된 경우: code 관련 명령어 우선
            const codeRelatedCommands = ['code', 'analyze', 'review', 'optimize', 'refactor'];
            if (activeContext.hasTextSelection) {
                filteredCommands = [
                    ...filteredCommands.filter(cmd => codeRelatedCommands.includes(cmd.name)),
                    ...filteredCommands.filter(cmd => !codeRelatedCommands.includes(cmd.name))
                ];
            }
            // Git 관련 컨텍스트: git 관련 명령어 우선
            const gitRelatedCommands = ['git', 'commit', 'push', 'pull', 'status'];
            if (activeContext.isGitRepo) {
                filteredCommands = [
                    ...filteredCommands.filter(cmd => gitRelatedCommands.includes(cmd.name)),
                    ...filteredCommands.filter(cmd => !gitRelatedCommands.includes(cmd.name))
                ];
            }
        }
        // 기본 최상위 명령어 제공
        return filteredCommands.map(cmd => this.createCompletionItem(cmd.name, cmd.description, '/' + cmd.name));
    }
    /**
     * 현재 컨텍스트 파악
     */
    getActiveContext() {
        try {
            const editor = vscode__WEBPACK_IMPORTED_MODULE_0__.window.activeTextEditor;
            return {
                hasTextSelection: !!(editor && !editor.selection.isEmpty),
                isGitRepo: this.isGitRepository()
            };
        }
        catch (error) {
            console.error('컨텍스트 파악 오류:', error);
            return null;
        }
    }
    /**
     * Git 저장소인지 확인
     */
    isGitRepository() {
        try {
            // 현재 작업 디렉토리
            const workspaceFolders = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                return false;
            }
            // 간단히 true 반환 (모의 구현)
            // 실제로는 .git 폴더 존재 여부를 확인해야 하지만, 여기서는 모의 구현만 제공
            return true;
        }
        catch (error) {
            console.error('Git 저장소 확인 오류:', error);
            return false;
        }
    }
    /**
     * 코드 자동 완성 제공
     */
    async provideCodeCompletions(document, position, linePrefix) {
        // 캐시 키 생성 (파일 경로 + 현재 위치)
        const cacheKey = `${document.fileName}:${position.line}:${position.character}`;
        // 캐시된 결과가 있는 경우 재사용
        const cachedResult = this.suggestionCache.get(cacheKey);
        if (cachedResult && Date.now() - cachedResult.timestamp < this.cacheTimeout) {
            return cachedResult.suggestions;
        }
        try {
            // 컨텍스트 수집
            // 전체 파일 내용과 커서 위치 계산(미사용)
            // // const fileContent = document.getText();
            // // const cursorOffset = document.offsetAt(position);
            // 이전 줄과 현재 줄 추출
            const precedingLines = document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(Math.max(0, position.line - 10), 0), position));
            // 파일 유형 확인
            const fileType = document.fileName.split('.').pop() || '';
            // LLM에 코드 완성 요청
            const suggestions = await this.requestCodeCompletions(precedingLines, linePrefix, fileType);
            // 결과 캐싱
            this.suggestionCache.set(cacheKey, {
                suggestions,
                timestamp: Date.now()
            });
            return suggestions;
        }
        catch (error) {
            console.error('코드 완성 오류:', error);
            return [];
        }
    }
    /**
     * LLM을 통한 코드 완성 요청
     */
    async requestCodeCompletions(context, currentLine, fileType) {
        try {
            // 프롬프트 생성
            const prompt = `
다음 코드의 다음 줄을 완성해주세요. 파일 타입은 ${fileType}입니다.
탭 자동 완성을 위한 여러 가지 가능한 코드 완성을 제안해주세요.
각 제안은 새로운 줄에 시작하며, 완전한 코드 조각이어야 합니다.
최대 5개의 다른 완성을 제안해주세요.

코드 컨텍스트:
\`\`\`${fileType}
${context}
\`\`\`

현재 줄 (커서 위치는 | 로 표시):
\`\`\`
${currentLine}|
\`\`\`

가능한 완성:`;
            // LLM 요청
            const messages = [
                {
                    id: `msg_completion_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            const result = await this.llmService.sendRequest(messages);
            if (result.success && result.data) {
                // 응답 파싱하여 CompletionItem 배열로 변환
                return this.parseCompletionResponse(result.data.content || '', currentLine);
            }
            else {
                throw new Error('LLM 요청 실패');
            }
        }
        catch (error) {
            console.error('LLM 코드 완성 요청 오류:', error);
            return [];
        }
    }
    /**
     * LLM 응답을 CompletionItem으로 파싱
     */
    parseCompletionResponse(responseContent, currentLine) {
        const completions = [];
        try {
            // 코드 블록에서 제안 추출
            const codeBlockMatch = responseContent.match(/```(?:.*?)?\n([\s\S]*?)```/);
            const suggestions = codeBlockMatch
                ? codeBlockMatch[1].split('\n').filter(line => line.trim() !== '')
                : responseContent.split('\n').filter(line => line.trim() !== '');
            // 각 제안에 대해 CompletionItem 생성
            suggestions.forEach((suggestion, index) => {
                // 번호 또는 불릿 포인트 제거
                suggestion = suggestion.replace(/^\d+\.\s+|^-\s+/, '').trim();
                if (suggestion) {
                    // 현재 줄과 겹치는 부분 제거
                    const overlap = this.findOverlap(currentLine, suggestion);
                    const insertText = overlap > 0 ? suggestion.substring(overlap) : suggestion;
                    if (insertText.trim()) {
                        const item = new vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionItem(suggestion, vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionItemKind.Snippet);
                        item.insertText = insertText;
                        item.sortText = String(index).padStart(5, '0');
                        item.detail = '탭 자동 완성';
                        completions.push(item);
                    }
                }
            });
        }
        catch (error) {
            console.error('응답 파싱 오류:', error);
        }
        return completions;
    }
    /**
     * 현재 줄과 제안 사이의 겹치는 부분 찾기
     */
    findOverlap(currentLine, suggestion) {
        let overlap = 0;
        // 현재 줄의 끝에서부터 제안의 시작과 일치하는지 확인
        for (let i = 1; i <= currentLine.length; i++) {
            const suffix = currentLine.substring(currentLine.length - i);
            if (suggestion.startsWith(suffix)) {
                overlap = suffix.length;
            }
        }
        return overlap;
    }
    /**
     * CompletionItem 생성 헬퍼 함수
     */
    createCompletionItem(label, detail, insertText) {
        const item = new vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionItem(label, vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionItemKind.Keyword);
        item.detail = detail;
        item.insertText = insertText;
        item.command = {
            command: 'editor.action.triggerSuggest',
            title: 'Re-trigger completions...'
        };
        return item;
    }
}


/***/ }),

/***/ "./src/core/git/autoCommitService.ts":
/*!*******************************************!*\
  !*** ./src/core/git/autoCommitService.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutoCommitService: () => (/* binding */ AutoCommitService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);
/**
 * Auto Commit Service
 *
 * 자동 커밋, 커밋 메시지 생성, 충돌 해결 기능을 제공하는 서비스
 */




const execAsync = (0,util__WEBPACK_IMPORTED_MODULE_3__.promisify)(child_process__WEBPACK_IMPORTED_MODULE_2__.exec);
/**
 * 자동 커밋 서비스 클래스
 */
class AutoCommitService {
    context;
    llmService;
    bitbucketService;
    workspaceRoot;
    statusBarItem;
    commitInProgress = false;
    disposables = [];
    gitWatcher;
    /**
     * 생성자
     */
    constructor(context, llmService, bitbucketService) {
        this.context = context;
        this.llmService = llmService;
        this.bitbucketService = bitbucketService;
        // 워크스페이스 루트 설정
        this.workspaceRoot = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0]?.uri.fsPath;
        // 상태 표시줄 아이템 생성
        this.statusBarItem = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createStatusBarItem(vscode__WEBPACK_IMPORTED_MODULE_0__.StatusBarAlignment.Left, 100);
        this.statusBarItem.text = "$(git-commit) 자동 커밋 준비됨";
        this.statusBarItem.tooltip = "APE 자동 커밋 서비스";
        this.statusBarItem.command = "ape.git.toggleAutoCommit";
        this.statusBarItem.show();
        // 명령어 등록
        this.registerCommands();
        // Git 변경 감지 설정
        this.setupGitWatcher();
    }
    /**
     * 명령어 등록
     */
    registerCommands() {
        // 자동 커밋 토글
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.git.toggleAutoCommit', () => this.toggleAutoCommit()));
        // 수동 커밋
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.git.commit', () => this.createCommit()));
        // 임시 커밋 통합
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.git.consolidateTemporaryCommits', () => this.consolidateTemporaryCommits()));
    }
    /**
     * Git 변경 감지 설정
     */
    setupGitWatcher() {
        if (!this.workspaceRoot) {
            return;
        }
        try {
            // .git/index 파일 변경 감지
            const gitIndexPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.workspaceRoot, '.git', 'index');
            this.gitWatcher = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.createFileSystemWatcher(gitIndexPath);
            // 파일 변경 시 상태 업데이트
            this.gitWatcher.onDidChange(() => {
                this.updateStatusBar();
            });
            this.disposables.push(this.gitWatcher);
            // 초기 상태 업데이트
            this.updateStatusBar();
            // 에디터 저장 이벤트 감지
            vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidSaveTextDocument(() => {
                // 자동 커밋이 활성화되었을 때 파일 저장 시 변경 사항 감지
                void this.handleFileSaved();
            }, this, this.disposables);
        }
        catch (error) {
            // Git 저장소가 아닌 경우 무시
            console.log('Git 저장소가 아닙니다:', error);
        }
    }
    /**
     * 상태 표시줄 업데이트
     */
    async updateStatusBar() {
        if (!this.workspaceRoot) {
            this.statusBarItem.hide();
            return;
        }
        try {
            // Git 상태 확인
            const { stdout } = await execAsync('git status --porcelain', { cwd: this.workspaceRoot });
            if (stdout.trim() === '') {
                // 변경 사항 없음
                this.statusBarItem.text = "$(git-commit) 자동 커밋 준비됨";
                this.statusBarItem.tooltip = "변경 사항이 없습니다";
            }
            else {
                // 변경된 파일 수 계산
                const changedFiles = stdout.split('\n').filter(line => line.trim() !== '').length;
                this.statusBarItem.text = `$(git-commit) 자동 커밋 (${changedFiles})`;
                this.statusBarItem.tooltip = `${changedFiles}개 파일이 변경되었습니다`;
            }
            this.statusBarItem.show();
        }
        catch {
            // Git 저장소가 아닌 경우
            this.statusBarItem.text = "$(git-commit) Git 저장소 아님";
            this.statusBarItem.tooltip = "현재 폴더는 Git 저장소가 아닙니다";
            this.statusBarItem.show();
        }
    }
    /**
     * 자동 커밋 토글
     */
    toggleAutoCommit() {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git');
        const current = config.get('autoCommit', false);
        // 설정 토글
        config.update('autoCommit', !current, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Workspace).then(() => {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`자동 커밋이 ${!current ? '활성화' : '비활성화'}되었습니다`);
            // 상태 표시줄 업데이트
            if (!current) {
                this.statusBarItem.text = "$(git-commit) 자동 커밋 활성화됨";
                this.statusBarItem.backgroundColor = new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeColor('statusBarItem.warningBackground');
            }
            else {
                this.statusBarItem.text = "$(git-commit) 자동 커밋 준비됨";
                this.statusBarItem.backgroundColor = undefined;
            }
        });
    }
    /**
     * 파일 저장 처리
     */
    async handleFileSaved() {
        if (this.commitInProgress) {
            return;
        }
        // 자동 커밋 설정 확인
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git');
        const autoCommitEnabled = config.get('autoCommit', false);
        if (!autoCommitEnabled) {
            return;
        }
        // 일정 시간 후 커밋 (연속 저장 방지)
        setTimeout(async () => {
            try {
                // 변경 사항 확인
                const { stdout } = await execAsync('git status --porcelain', { cwd: this.workspaceRoot });
                if (stdout.trim() !== '') {
                    // 변경 사항이 있으면 커밋
                    await this.createCommit();
                }
            }
            catch (error) {
                console.error('자동 커밋 오류:', error);
            }
        }, 2000); // 2초 지연
    }
    /**
     * 커밋 생성
     */
    async createCommit() {
        if (!this.workspaceRoot || this.commitInProgress) {
            return;
        }
        this.commitInProgress = true;
        try {
            // Git 상태 확인
            const { stdout: statusOutput } = await execAsync('git status --porcelain', { cwd: this.workspaceRoot });
            if (statusOutput.trim() === '') {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('커밋할 변경 사항이 없습니다');
                this.commitInProgress = false;
                return;
            }
            // 변경된 파일 목록
            const changedFiles = statusOutput
                .split('\n')
                .filter(line => line.trim() !== '')
                .map(line => {
                const status = line.substring(0, 2).trim();
                const file = line.substring(3).trim();
                return { status, file };
            });
            // 변경 내용 확인
            const { stdout: diffOutput } = await execAsync('git diff --staged', { cwd: this.workspaceRoot });
            const unstaged = await execAsync('git diff', { cwd: this.workspaceRoot });
            try {
                // 자동 커밋 메시지 생성
                let commitMessage = await this.generateCommitMessage(changedFiles, diffOutput + unstaged.stdout);
                // 자동 커밋의 경우 프리픽스 추가
                const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git');
                const autoCommitEnabled = config.get('autoCommit', false);
                if (autoCommitEnabled) {
                    // 자동 커밋인 경우 [APE][Temporary] 프리픽스 추가
                    commitMessage = `[APE][Temporary] ${commitMessage}`;
                }
                // 변경 사항 스테이징
                await execAsync('git add .', { cwd: this.workspaceRoot });
                // 커밋 생성
                await execAsync(`git commit -m "${commitMessage}"`, { cwd: this.workspaceRoot });
                // 성공 메시지
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`커밋 성공: ${commitMessage}`);
                // 상태 업데이트
                this.updateStatusBar();
            }
            catch (error) {
                // 커밋 메시지 생성 실패 처리
                const errorMessage = error.message || '알 수 없는 오류';
                // BitBucket 오류나 Jira 오류 등 외부 API 오류일 경우 구체적인 메시지 전달
                if (errorMessage.includes('BitBucket') || errorMessage.includes('Jira')) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`서비스 연결 실패: ${errorMessage}. 설정을 확인하세요.`);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`커밋 실패: ${errorMessage}`);
                }
                // API 설정 안내
                const openSettings = '설정 열기';
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('아틀라시안 API 설정이 올바르지 않거나 누락되었습니다. 설정에서 확인해보세요.', openSettings).then(selection => {
                    if (selection === openSettings) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', 'ape.bitbucket');
                    }
                });
            }
        }
        catch (error) {
            // Git 명령 실행 자체의 오류 (status 조회, diff 실패 등)
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Git 명령 실패: ${error.message}`);
        }
        finally {
            this.commitInProgress = false;
        }
    }
    /**
     * 자동 커밋 메시지 생성
     */
    async generateCommitMessage(changedFiles, diff) {
        try {
            // 설정에서 LLM 사용 여부 확인
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git');
            const useLLM = config.get('useLLMForCommitMessages', false);
            // LLM 사용 시 고급 커밋 메시지 생성
            if (useLLM && diff.length > 0) {
                try {
                    return await this.generateLLMCommitMessage(changedFiles, diff);
                }
                catch (error) {
                    console.error('LLM 커밋 메시지 생성 실패:', error);
                    // LLM 생성 실패 시 기본 메시지 생성 로직으로 폴백
                }
            }
            // 간단한 커밋 메시지 헤더 생성 로직
            let messagePrefix = '';
            // 변경 유형에 따른 접두사 결정
            const newFiles = changedFiles.filter(file => file.status.includes('A') || file.status.includes('?'));
            const modifiedFiles = changedFiles.filter(file => file.status.includes('M'));
            const deletedFiles = changedFiles.filter(file => file.status.includes('D'));
            if (newFiles.length > 0 && modifiedFiles.length === 0 && deletedFiles.length === 0) {
                messagePrefix = 'Add';
            }
            else if (modifiedFiles.length > 0 && newFiles.length === 0 && deletedFiles.length === 0) {
                messagePrefix = 'Update';
            }
            else if (deletedFiles.length > 0 && newFiles.length === 0 && modifiedFiles.length === 0) {
                messagePrefix = 'Remove';
            }
            else if (deletedFiles.length > 0 || newFiles.length > 0) {
                messagePrefix = 'Refactor';
            }
            else {
                messagePrefix = 'Fix';
            }
            // 변경된 파일 경로에서 주요 구성 요소 추출
            const fileComponents = [];
            for (const file of changedFiles) {
                const ext = path__WEBPACK_IMPORTED_MODULE_1__.extname(file.file);
                const dir = path__WEBPACK_IMPORTED_MODULE_1__.dirname(file.file);
                // 확장자 및 디렉토리 정보 수집
                if (ext && !fileComponents.includes(ext.substring(1))) {
                    fileComponents.push(ext.substring(1));
                }
                // 주요 디렉토리 경로 추출
                const mainDir = dir.split('/')[0];
                if (mainDir && mainDir !== '.' && !fileComponents.includes(mainDir)) {
                    fileComponents.push(mainDir);
                }
            }
            // 변경된 파일 목록 요약
            let fileList = '';
            if (changedFiles.length <= 3) {
                fileList = changedFiles.map(f => path__WEBPACK_IMPORTED_MODULE_1__.basename(f.file)).join(', ');
            }
            else {
                fileList = `${changedFiles.length} files`;
            }
            // 기본 커밋 메시지 생성
            const component = fileComponents.length > 0 ? fileComponents.join(', ') : 'code';
            const baseMessage = `${messagePrefix} ${component}: `;
            return `${baseMessage}${fileList}`;
        }
        catch (error) {
            console.error('커밋 메시지 생성 오류:', error);
            throw new Error(`커밋 메시지 생성 실패: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * LLM을 사용한 고급 커밋 메시지 생성
     * @throws Error 커밋 메시지 생성 실패 시 오류를 던짐
     */
    async generateLLMCommitMessage(changedFiles, diff) {
        // 커밋 메시지 예제 가져오기
        let commitExamples = '';
        try {
            // BitBucket 서비스가 주입되었는지 확인
            if (this.bitbucketService) {
                try {
                    // BitBucket API를 사용하여 사용자 이름 가져오기
                    const userName = await this.bitbucketService.getGitUsername();
                    if (userName) {
                        // BitBucket API를 사용하여 사용자의 최근 커밋 이력 검색
                        const commits = await this.bitbucketService.getCommitHistory(userName, 20);
                        if (commits && commits.length > 0) {
                            // 커밋 이력을 포맷팅하여 예제로 사용
                            const formattedHistory = commits.map(commit => `${commit.displayId} - ${commit.message}`).join('\n');
                            // 사용자의 최근 커밋 메시지를 예제로 사용
                            commitExamples = `Here are some example commit messages to follow the style:\n${formattedHistory}\n\n`;
                        }
                    }
                }
                catch (error) {
                    console.error('BitBucket 서비스 오류:', error);
                    // BitBucket 서비스 오류 시 로컬 Git 명령어를 사용하여 폴백
                    await this.fallbackToLocalGitHistory();
                }
            }
            else {
                // BitBucket 서비스가 주입되지 않은 경우 로컬 Git 명령어 사용
                await this.fallbackToLocalGitHistory();
            }
        }
        catch (error) {
            console.error('커밋 이력 검색 오류:', error);
            // 모든 방법이 실패하면 기본 예제 사용
            const defaultExamples = [
                "feat(ui): add slash command suggestions to chat interface",
                "fix(core): resolve memory leak in service initialization",
                "docs(api): update API documentation with examples",
                "refactor(git): improve auto-commit change detection",
                "style(ui): update chat interface styling",
                "test(llm): add integration tests for LLM service",
                "perf(stream): optimize streaming response handling",
                "chore(deps): update dependencies to latest versions"
            ];
            commitExamples = `Here are some example commit messages to follow the style:\n${defaultExamples.join('\n')}\n\n`;
        }
        // diff가 너무 길면 잘라내기
        const maxDiffLength = 5000; // 최대 5000자
        const truncatedDiff = diff.length > maxDiffLength ?
            diff.substring(0, maxDiffLength) + '\n... (truncated)' : diff;
        // 파일 목록 생성
        const fileChangeList = changedFiles.map(file => {
            return `${file.status} ${file.file}`;
        }).join('\n');
        // Conventional Commits 형식 안내
        const prompt = `Please generate a concise and meaningful Git commit message for the following changes. 
Use the Conventional Commits format: <type>(<scope>): <description>

Types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert

${commitExamples}
Changed files:
${fileChangeList}

Diff:
${truncatedDiff}

Generate ONLY the commit message without any explanation. Keep it under 72 characters if possible.`;
        try {
            // LLM에 요청 보내기
            const result = await this.llmService.getCompletion(prompt);
            if (result.success && result.data) {
                // 공백 제거 및 정리
                const message = result.data.trim();
                // 결과가 짧고 의미있을 경우 사용
                if (message.length > 0 && message.length < 200) {
                    return message;
                }
            }
            // LLM 결과가 적절하지 않을 경우 오류 발생
            throw new Error('LLM 생성 결과가 적절하지 않습니다');
        }
        catch (error) {
            // LLM 서비스 오류 로깅
            console.error('LLM 커밋 메시지 생성 오류:', error);
            // 오류 전파 - 호출자에서 기본 메시지 생성 로직으로 폴백
            throw new Error(`LLM 커밋 메시지 생성 실패: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * 로컬 Git 명령어를 사용하여 커밋 이력 가져오기 (BitBucket 폴백)
     * @private
     */
    async fallbackToLocalGitHistory() {
        try {
            const { stdout: userName } = await execAsync('git config --get user.name', { cwd: this.workspaceRoot });
            if (userName.trim()) {
                // 사용자 이름으로 커밋 이력 검색
                const { stdout: commitHistory } = await execAsync(`git log --author="${userName.trim()}" -n 20 --pretty=format:"%h - %s"`, { cwd: this.workspaceRoot });
                if (commitHistory.trim()) {
                    // 사용자의 최근 커밋 메시지를 예제로 사용
                    return `Here are some example commit messages to follow the style:\n${commitHistory.trim()}\n\n`;
                }
            }
            // 로컬 Git 명령어도 실패하면 빈 문자열 반환
            return '';
        }
        catch (error) {
            console.error('로컬 Git 이력 검색 오류:', error);
            return '';
        }
    }
    /**
     * 임시 커밋 통합
     *
     * [APE][Temporary] 프리픽스가 붙은 모든 임시 커밋을 찾아서
     * 이들을 통합하여 하나의 정상적인 커밋으로 만듭니다.
     */
    async consolidateTemporaryCommits() {
        if (!this.workspaceRoot) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Git 저장소가 없습니다.');
            return;
        }
        try {
            // 진행 중 안내
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.withProgress({
                location: vscode__WEBPACK_IMPORTED_MODULE_0__.ProgressLocation.Notification,
                title: "임시 커밋 통합 중...",
                cancellable: false
            }, async (progress) => {
                progress.report({ message: "임시 커밋 찾는 중..." });
                // [APE][Temporary] 프리픽스가 붙은 커밋 찾기
                const { stdout: logOutput } = await execAsync('git log --pretty=format:"%H %s" -n 30', { cwd: this.workspaceRoot });
                // 임시 커밋 목록 추출
                const allCommits = logOutput.split('\n')
                    .map(line => {
                    const space = line.indexOf(' ');
                    return {
                        hash: line.substring(0, space),
                        message: line.substring(space + 1),
                        isTemporary: line.substring(space + 1).includes('[APE][Temporary]')
                    };
                });
                // 연속된 임시 커밋 그룹 찾기
                const temporaryGroups = [];
                let currentGroup = [];
                // 가장 최근 커밋부터 검사하여 연속된 임시 커밋 그룹 찾기
                for (const commit of allCommits) {
                    if (commit.isTemporary) {
                        currentGroup.push(commit);
                    }
                    else {
                        // 일반 커밋을 만나면 지금까지의 그룹을 저장하고 새 그룹 시작
                        if (currentGroup.length > 0) {
                            temporaryGroups.push([...currentGroup]);
                            currentGroup = [];
                        }
                    }
                }
                // 마지막 그룹이 남아있으면 추가
                if (currentGroup.length > 0) {
                    temporaryGroups.push(currentGroup);
                }
                // 임시 커밋이 없는 경우
                if (temporaryGroups.length === 0 || temporaryGroups[0].length === 0) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('통합할 임시 커밋이 없습니다.');
                    return;
                }
                // 가장 최근의 연속된 임시 커밋 그룹 선택 (첫 번째 그룹)
                const commits = temporaryGroups[0];
                // 임시 커밋 이전 해시 찾기
                const oldestTempCommitHash = commits[commits.length - 1].hash;
                // 임시 커밋 이전 커밋 찾기
                const { stdout: parentHash } = await execAsync(`git rev-parse ${oldestTempCommitHash}^`, { cwd: this.workspaceRoot });
                // 통합할 커밋 수 확인
                const commitCount = commits.length;
                // 메시지 생성
                progress.report({ message: "변경 내용 취합 중..." });
                // 변경 사항 취합을 위한 설명 작성
                let commitDescription = '';
                try {
                    // 변경 내용 diff 가져오기
                    const { stdout: diffOutput } = await execAsync(`git diff ${parentHash.trim()} HEAD`, { cwd: this.workspaceRoot });
                    // 임시 커밋 메시지 모음
                    const messages = commits.map(c => c.message.replace('[APE][Temporary] ', '')).join('\n');
                    // 설명 생성 (LLM 사용)
                    progress.report({ message: "커밋 설명 생성 중..." });
                    // LLM 사용 설정 확인
                    const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git');
                    const useLLM = config.get('useLLMForCommitMessages', false);
                    if (useLLM) {
                        // LLM으로 통합 커밋 메시지 생성
                        const prompt = `다음은 여러 임시 커밋을 통합하기 위한 정보입니다.

임시 커밋 메시지들:
${messages}

변경 내용 요약 (diff):
${diffOutput.length > 5000 ? diffOutput.substring(0, 5000) + '\n... (잘림)' : diffOutput}

위 임시 커밋들을 통합하는 하나의 정식 커밋 메시지를 작성해주세요.
Conventional Commits 형식을 사용하세요: <type>(<scope>): <description>
타입: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert
설명만 제공하고 다른 설명은 하지 마세요. 가능하면 72자 미만으로 작성하세요.`;
                        const result = await this.llmService.getCompletion(prompt);
                        if (result.success && result.data) {
                            commitDescription = result.data.trim();
                        }
                    }
                    // LLM 실패 또는 비활성화된 경우 기본 메시지 생성
                    if (!commitDescription) {
                        commitDescription = `chore(git): consolidate ${commitCount} temporary commits`;
                    }
                }
                catch (error) {
                    console.error('커밋 설명 생성 오류:', error);
                    commitDescription = `chore(git): consolidate ${commitCount} temporary commits`;
                }
                // 사용자에게 최종 확인 요청
                progress.report({ message: "통합 준비 완료..." });
                const result = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`${commitCount}개의 임시 커밋을 통합하시겠습니까?`, { modal: true }, '통합하기', '취소');
                if (result !== '통합하기') {
                    return;
                }
                // git reset --soft로 변경 사항 유지하며 커밋 취소
                progress.report({ message: "임시 커밋 리셋 중..." });
                await execAsync(`git reset --soft ${parentHash.trim()}`, { cwd: this.workspaceRoot });
                // 통합 커밋 생성
                progress.report({ message: "통합 커밋 생성 중..." });
                await execAsync(`git commit -m "${commitDescription.replace(/"/g, '\\"')}"`, { cwd: this.workspaceRoot });
                // 성공 메시지
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`${commitCount}개의 임시 커밋이 성공적으로 통합되었습니다.`);
                // 상태 업데이트
                this.updateStatusBar();
            });
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`임시 커밋 통합 오류: ${error.message}`);
        }
    }
    /**
     * 리소스 해제
     */
    dispose() {
        this.statusBarItem.dispose();
        for (const disposable of this.disposables) {
            disposable.dispose();
        }
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/git/bitbucketService.ts":
/*!******************************************!*\
  !*** ./src/core/git/bitbucketService.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BitbucketErrorType: () => (/* binding */ BitbucketErrorType),
/* harmony export */   BitbucketService: () => (/* binding */ BitbucketService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ "./node_modules/axios/lib/axios.js");
/* harmony import */ var _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/serviceConfig */ "./src/core/services/serviceConfig.ts");
/**
 * BitBucket 서비스
 *
 * BitBucket API를 사용하여 Git 저장소 정보를 조회하고 관리하는 서비스입니다.
 * 내부망 BitBucket 서버와 통신하며, 실제 서버를 사용할 수 없는 경우 Mock 데이터를 사용합니다.
 */



/**
 * BitBucket 서비스 오류 유형
 */
var BitbucketErrorType;
(function (BitbucketErrorType) {
    BitbucketErrorType["ConnectionFailed"] = "connection_failed";
    BitbucketErrorType["AuthenticationFailed"] = "authentication_failed";
    BitbucketErrorType["PermissionDenied"] = "permission_denied";
    BitbucketErrorType["ResourceNotFound"] = "resource_not_found";
    BitbucketErrorType["ServerError"] = "server_error";
    BitbucketErrorType["Unknown"] = "unknown";
})(BitbucketErrorType || (BitbucketErrorType = {}));
/**
 * BitBucket 서비스 클래스
 */
class BitbucketService {
    context;
    serviceConfigManager;
    baseUrl = '';
    projectKey = '';
    repoSlug = '';
    username = '';
    password = '';
    token = '';
    authType = _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic;
    useMock = true;
    disposables = [];
    _lastError = null;
    /**
     * BitBucket 서비스 생성자
     * @param context VSCode 확장 컨텍스트
     * @param serviceConfigManager 서비스 설정 관리자 (선택적)
     */
    constructor(context, serviceConfigManager) {
        this.context = context;
        this.serviceConfigManager = serviceConfigManager;
        // 설정 로드
        this.loadConfiguration();
        // 설정 변경 감지
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.bitbucket')) {
                this.loadConfiguration();
            }
        }));
    }
    /**
     * 설정 다시 로드
     */
    loadConfiguration() {
        if (this.serviceConfigManager) {
            // 서비스 설정 관리자를 사용하여 설정 로드
            const config = this.serviceConfigManager.getServiceConfig(_services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Bitbucket);
            this.baseUrl = config.url;
            this.authType = config.authType;
            this.username = config.username || '';
            this.password = config.password || '';
            this.token = config.token || '';
            this.useMock = config.useMock;
            // 추가 파라미터에서 프로젝트 키와 저장소 슬러그 가져오기
            const additionalParams = config.additionalParams || {};
            this.projectKey = additionalParams.projectKey || '';
            this.repoSlug = additionalParams.repositorySlug || '';
        }
        else {
            // 직접 VSCode 설정에서 로드
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.bitbucket');
            this.baseUrl = config.get('url', '');
            this.projectKey = config.get('projectKey', '');
            this.repoSlug = config.get('repositorySlug', '');
            this.username = config.get('username', '');
            this.password = config.get('password', '');
            this.token = config.get('token', '');
            this.authType = config.get('authType', _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic);
            this.useMock = config.get('useMock', false);
        }
        // 필수 설정이 없으면 모의 모드 강제 활성화
        if (!this.baseUrl || (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) ||
            (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token)) {
            this.useMock = true;
        }
    }
    /**
     * 마지막 오류 가져오기
     */
    get lastError() {
        return this._lastError;
    }
    /**
     * 특정 사용자의 최근 커밋 이력 가져오기
     * @param authorName 작성자 이름 (비어 있으면 모든 커밋 가져옴)
     * @param limit 가져올 커밋 수 (기본값: 20)
     * @returns 커밋 목록
     * @throws Error 연결 실패 또는 서버 오류 시 오류를 던짐
     */
    async getCommitHistory(authorName, limit = 20) {
        try {
            // 마지막 오류 초기화
            this._lastError = null;
            // 모의 모드인 경우 모의 데이터 반환
            if (this.useMock) {
                return this.getMockCommitHistory(authorName, limit);
            }
            // 필수 설정 확인
            if (!this.baseUrl) {
                throw new Error('BitBucket 서버 URL이 설정되지 않았습니다. 설정을 확인하세요.');
            }
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('BitBucket 인증 정보가 설정되지 않았습니다. 사용자 이름과 비밀번호를 확인하세요.');
            }
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('BitBucket 인증 토큰이 설정되지 않았습니다. 토큰 설정을 확인하세요.');
            }
            if (!this.projectKey || !this.repoSlug) {
                throw new Error('BitBucket 프로젝트 키 또는 저장소 슬러그가 설정되지 않았습니다. 설정을 확인하세요.');
            }
            // BitBucket REST API 엔드포인트
            const url = `${this.baseUrl}/rest/api/1.0/projects/${this.projectKey}/repos/${this.repoSlug}/commits`;
            // 쿼리 파라미터
            const params = {
                limit: limit
            };
            // 작성자 필터링
            if (authorName) {
                // BitBucket Server API는 'until' 파라미터를 사용하여 커밋 범위를 지정할 수 있음
                params.until = 'HEAD';
                // 'since'는 선택적으로 사용 (필요하면 추가)
            }
            // API 요청 설정
            const config = {};
            // 인증 유형에 따른 설정
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // 쿼리 파라미터 설정
            config.params = params;
            // API 요청 실행
            const response = await axios__WEBPACK_IMPORTED_MODULE_2__["default"].get(url, config);
            // 응답 데이터 파싱
            const commits = response.data.values.filter((commit) => {
                // 작성자 필터링 (서버에서 지원하지 않는 경우 클라이언트측에서 필터링)
                return !authorName || commit.author.name === authorName;
            }).map((commit) => ({
                id: commit.id,
                displayId: commit.displayId,
                message: commit.message,
                author: {
                    name: commit.author.name,
                    emailAddress: commit.author.emailAddress
                },
                authorTimestamp: commit.authorTimestamp
            }));
            return commits;
        }
        catch (error) {
            // 오류 처리 및 분류
            this.handleError(error);
            // 오류 로그
            console.error('BitBucket 커밋 이력 가져오기 실패:', error);
            // 마지막 오류 객체를 통해 예외 생성
            if (this._lastError) {
                throw new Error(`BitBucket 오류 (${this._lastError.type}): ${this._lastError.message}`);
            }
            else {
                throw error; // 원본 오류 전파
            }
        }
    }
    /**
     * 오류 처리 및 분류
     * @param error 발생한 오류
     * @private
     */
    handleError(error) {
        if (axios__WEBPACK_IMPORTED_MODULE_2__["default"].isAxiosError(error)) {
            const axiosError = error;
            if (!axiosError.response) {
                // 네트워크 오류
                this.setError(BitbucketErrorType.ConnectionFailed, `BitBucket 서버 연결 실패: ${error.message}. 서버 URL을 확인하세요: ${this.baseUrl}`);
            }
            else {
                // HTTP 상태 코드에 따른 오류 분류
                const status = axiosError.response.status;
                if (status === 401 || status === 403) {
                    this.setError(BitbucketErrorType.AuthenticationFailed, `BitBucket 인증 실패: ${error.message}. 사용자 이름과 비밀번호를 확인하세요.`);
                }
                else if (status === 404) {
                    this.setError(BitbucketErrorType.ResourceNotFound, `BitBucket 리소스를 찾을 수 없습니다: ${error.message}. 프로젝트 키와 저장소 슬러그를 확인하세요.`);
                }
                else if (status >= 500) {
                    this.setError(BitbucketErrorType.ServerError, `BitBucket 서버 오류: ${error.message}. 서버 상태를 확인하세요.`);
                }
                else {
                    this.setError(BitbucketErrorType.Unknown, `BitBucket 오류: ${error.message}`);
                }
            }
        }
        else {
            // 일반 오류
            this.setError(BitbucketErrorType.Unknown, `BitBucket 오류: ${error.message}`);
        }
    }
    /**
     * 오류 설정
     * @param type 오류 유형
     * @param message 오류 메시지
     * @param details 추가 세부 정보
     * @private
     */
    setError(type, message, details) {
        this._lastError = {
            type,
            message,
            details
        };
        // 콘솔에 오류 기록
        console.error(`BitBucket 오류 (${type}):`, message, details || '');
    }
    /**
     * 사용자의 Git 사용자 이름 가져오기 (BitBucket 계정 이름과 다를 수 있음)
     * @returns Git 사용자 이름
     * @throws Error 연결 실패 또는 서버 오류 시 오류를 던짐
     */
    async getGitUsername() {
        try {
            // 마지막 오류 초기화
            this._lastError = null;
            // 모의 모드인 경우 모의 데이터 반환
            if (this.useMock) {
                return 'TestUser';
            }
            // 필수 설정 확인
            if (!this.baseUrl) {
                throw new Error('BitBucket 서버 URL이 설정되지 않았습니다. 설정을 확인하세요.');
            }
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('BitBucket 인증 정보가 설정되지 않았습니다. 사용자 이름과 비밀번호를 확인하세요.');
            }
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('BitBucket 인증 토큰이 설정되지 않았습니다. 토큰 설정을 확인하세요.');
            }
            // BitBucket REST API를 통해 현재 사용자 정보 가져오기
            const url = `${this.baseUrl}/rest/api/1.0/users/~`;
            // API 요청 설정
            const config = {};
            // 인증 유형에 따른 설정
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API 요청 실행
            const response = await axios__WEBPACK_IMPORTED_MODULE_2__["default"].get(url, config);
            return response.data.displayName || response.data.name || this.username;
        }
        catch (error) {
            // 오류 처리 및 분류
            this.handleError(error);
            // 오류 로그
            console.error('BitBucket 사용자 정보 가져오기 실패:', error);
            // 마지막 오류 객체를 통해 예외 생성
            if (this._lastError) {
                throw new Error(`BitBucket 오류 (${this._lastError.type}): ${this._lastError.message}`);
            }
            else {
                throw error; // 원본 오류 전파
            }
        }
    }
    /**
     * 모의 커밋 이력 생성
     * @param authorName 작성자 이름
     * @param limit 가져올 커밋 수
     * @returns 모의 커밋 목록
     */
    getMockCommitHistory(authorName, limit = 20) {
        // 모의 커밋 데이터
        const mockCommits = [
            {
                id: 'abcdef1234567890abcdef1234567890abcdef12',
                displayId: 'abcdef1',
                message: 'feat(ui): add slash command suggestions to chat interface',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 1
            },
            {
                id: 'bcdef1234567890abcdef1234567890abcdef123',
                displayId: 'bcdef12',
                message: 'fix(core): resolve memory leak in service initialization',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 2
            },
            {
                id: 'cdef1234567890abcdef1234567890abcdef1234',
                displayId: 'cdef123',
                message: 'docs(api): update API documentation with examples',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 3
            },
            {
                id: 'def1234567890abcdef1234567890abcdef12345',
                displayId: 'def1234',
                message: 'refactor(git): improve auto-commit change detection',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 4
            },
            {
                id: 'ef1234567890abcdef1234567890abcdef123456',
                displayId: 'ef12345',
                message: 'style(ui): update chat interface styling',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 5
            },
            {
                id: 'f1234567890abcdef1234567890abcdef1234567',
                displayId: 'f123456',
                message: 'test(llm): add integration tests for LLM service',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 6
            },
            {
                id: '1234567890abcdef1234567890abcdef12345678',
                displayId: '1234567',
                message: 'perf(stream): optimize streaming response handling',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 7
            },
            {
                id: '234567890abcdef1234567890abcdef123456789',
                displayId: '2345678',
                message: 'chore(deps): update dependencies to latest versions',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 8
            },
            {
                id: '34567890abcdef1234567890abcdef1234567890',
                displayId: '3456789',
                message: 'feat(commands): add support for keyboard shortcuts',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 9
            },
            {
                id: '4567890abcdef1234567890abcdef12345678901',
                displayId: '4567890',
                message: 'fix(ui): correct positioning of dropdown menu',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 10
            },
            {
                id: '567890abcdef1234567890abcdef123456789012',
                displayId: '567890a',
                message: 'docs(readme): update installation instructions',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 11
            },
            {
                id: '67890abcdef1234567890abcdef1234567890123',
                displayId: '67890ab',
                message: 'refactor(core): simplify service initialization logic',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 12
            },
            {
                id: '7890abcdef1234567890abcdef12345678901234',
                displayId: '7890abc',
                message: 'style(icons): update icon set for better visibility',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 13
            },
            {
                id: '890abcdef1234567890abcdef123456789012345',
                displayId: '890abcd',
                message: 'test(core): improve test coverage for core services',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 14
            },
            {
                id: '90abcdef1234567890abcdef1234567890123456',
                displayId: '90abcde',
                message: 'perf(memory): optimize memory usage in large operations',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 15
            },
            {
                id: '0abcdef1234567890abcdef12345678901234567',
                displayId: '0abcdef',
                message: 'chore(build): update build configuration',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 16
            },
            {
                id: 'abcdef1234567890abcdef123456789012345678',
                displayId: 'abcdef1',
                message: 'feat(git): enhance commit message generation',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 17
            },
            {
                id: 'bcdef1234567890abcdef1234567890123456789',
                displayId: 'bcdef12',
                message: 'fix(auth): resolve authentication token refresh issue',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 18
            },
            {
                id: 'cdef1234567890abcdef12345678901234567890',
                displayId: 'cdef123',
                message: 'docs(api): add examples for new API endpoints',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 19
            },
            {
                id: 'def1234567890abcdef123456789012345678901',
                displayId: 'def1234',
                message: 'refactor(ui): reorganize component hierarchy',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 20
            }
        ];
        // 작성자로 필터링
        const filteredCommits = authorName
            ? mockCommits.filter(commit => commit.author.name === authorName)
            : mockCommits;
        // 최대 개수 제한
        return filteredCommits.slice(0, limit);
    }
    /**
     * 리소스 해제
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/git/commands.ts":
/*!**********************************!*\
  !*** ./src/core/git/commands.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createGitCommands: () => (/* binding */ createGitCommands)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Git 명령어 모듈
 *
 * Git 관련 명령어들을 정의합니다.
 */

/**
 * Git 명령어 목록 생성
 */
function createGitCommands() {
    const commands = [];
    // Git 명령어 정의
    commands.push({
        name: 'git',
        aliases: ['g', '깃', '깃작업'],
        description: 'Git 작업을 수행합니다',
        examples: ['/git status', '/git commit', '/git auto', '/git consolidate', '/깃 상태', '/깃 통합'],
        category: 'git',
        priority: 3,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand || subCommand === 'status' || subCommand === '상태') {
                // Git 상태 확인
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.git.showStatus');
            }
            else if (subCommand === 'commit' || subCommand === '커밋' || subCommand === '저장') {
                // Git 커밋
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.git.commit');
            }
            else if (subCommand === 'auto' || subCommand === '자동' || subCommand === '자동커밋') {
                // 자동 커밋 토글 또는 명시적 상태 설정
                const secondArg = context.args[1]?.toLowerCase();
                if (secondArg === 'on' || secondArg === '켜기' || secondArg === 'true') {
                    // 자동 커밋 켜기
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git')
                        .update('autoCommit', true, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Workspace);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('자동 커밋이 켜졌습니다');
                }
                else if (secondArg === 'off' || secondArg === '끄기' || secondArg === 'false') {
                    // 자동 커밋 끄기
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git')
                        .update('autoCommit', false, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Workspace);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('자동 커밋이 꺼졌습니다');
                }
                else {
                    // 토글 (인자 없는 경우)
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.git.toggleAutoCommit');
                }
            }
            else if (subCommand === 'consolidate' || subCommand === 'squash' || subCommand === '통합' || subCommand === '임시통합' || subCommand === '통합커밋') {
                // 임시 커밋 통합
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.git.consolidateTemporaryCommits');
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('알 수 없는 Git 하위 명령어입니다');
            }
        },
        provideCompletions: (partialArgs) => {
            const subCommands = ['status', 'commit', 'auto', 'consolidate', 'squash',
                '상태', '커밋', '저장', '자동', '자동커밋', '통합', '임시통합', '통합커밋'];
            // 첫 번째 인자 자동완성
            if (!partialArgs.includes(' ')) {
                return subCommands.filter(cmd => cmd.startsWith(partialArgs.toLowerCase()));
            }
            return [];
        }
    });
    return commands;
}


/***/ }),

/***/ "./src/core/git/conflictSolver.ts":
/*!****************************************!*\
  !*** ./src/core/git/conflictSolver.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConflictSolver: () => (/* binding */ ConflictSolver),
/* harmony export */   ConflictStrategy: () => (/* binding */ ConflictStrategy)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/**
 * Git Conflict Solver
 *
 * Git 충돌을 자동으로 해결하는 고급 모듈
 */






const execAsync = (0,util__WEBPACK_IMPORTED_MODULE_3__.promisify)(child_process__WEBPACK_IMPORTED_MODULE_4__.exec);
/**
 * 충돌 해결 전략 유형
 */
var ConflictStrategy;
(function (ConflictStrategy) {
    ConflictStrategy["AUTO"] = "auto";
    ConflictStrategy["OURS"] = "ours";
    ConflictStrategy["THEIRS"] = "theirs";
    ConflictStrategy["MERGE"] = "merge";
    ConflictStrategy["LLM"] = "llm"; // LLM 기반 지능형 병합
})(ConflictStrategy || (ConflictStrategy = {}));
/**
 * Git 충돌 해결기
 */
class ConflictSolver {
    llmService;
    workspaceRoot;
    /**
     * 생성자
     */
    constructor(llmService) {
        this.llmService = llmService;
        // 워크스페이스 루트 설정
        this.workspaceRoot = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0]?.uri.fsPath;
    }
    /**
     * 현재 저장소의 충돌 파일 목록 가져오기
     */
    async getConflictingFiles() {
        if (!this.workspaceRoot) {
            return [];
        }
        try {
            // Git 충돌 파일 목록 가져오기
            const { stdout } = await execAsync('git diff --name-only --diff-filter=U', {
                cwd: this.workspaceRoot
            });
            return stdout.trim().split('\n').filter(file => file.trim() !== '');
        }
        catch (error) {
            console.error('충돌 파일 조회 오류:', error);
            return [];
        }
    }
    /**
     * 지정된 전략으로 모든 충돌 해결
     */
    async resolveAllConflicts(strategy = ConflictStrategy.AUTO) {
        const conflictFiles = await this.getConflictingFiles();
        if (conflictFiles.length === 0) {
            return 0;
        }
        let resolvedCount = 0;
        // 진행 상황 UI
        const progressOptions = {
            location: vscode__WEBPACK_IMPORTED_MODULE_0__.ProgressLocation.Notification,
            title: '충돌 해결 중...',
            cancellable: true
        };
        await vscode__WEBPACK_IMPORTED_MODULE_0__.window.withProgress(progressOptions, async (progress, token) => {
            let i = 0;
            for (const file of conflictFiles) {
                if (token.isCancellationRequested) {
                    break;
                }
                progress.report({
                    message: `${file} (${i + 1}/${conflictFiles.length})`,
                    increment: 100 / conflictFiles.length
                });
                const resolveSuccess = await this.resolveConflictsInFile(path__WEBPACK_IMPORTED_MODULE_1__.join(this.workspaceRoot, file), strategy);
                if (resolveSuccess) {
                    resolvedCount++;
                }
                i++;
            }
            return resolvedCount;
        });
        return resolvedCount;
    }
    /**
     * 단일 파일의 충돌 해결
     */
    async resolveConflictsInFile(filePath, strategy = ConflictStrategy.AUTO) {
        try {
            // 파일 내용 읽기
            const content = fs__WEBPACK_IMPORTED_MODULE_2__.readFileSync(filePath, 'utf-8');
            // 충돌 정보 파싱
            const conflictInfo = this.parseConflicts(filePath, content);
            if (conflictInfo.conflicts.length === 0) {
                return false;
            }
            // 파일 확장자 확인
            const fileExt = path__WEBPACK_IMPORTED_MODULE_1__.extname(filePath).substring(1);
            // 충돌 해결
            const resolvedContent = await this.resolveContent(content, conflictInfo, strategy, fileExt);
            // 해결된 내용 저장
            fs__WEBPACK_IMPORTED_MODULE_2__.writeFileSync(filePath, resolvedContent, 'utf-8');
            // Git에 추가
            if (this.workspaceRoot) {
                await execAsync(`git add "${filePath}"`, { cwd: this.workspaceRoot });
            }
            return true;
        }
        catch (error) {
            console.error(`파일 충돌 해결 오류 (${filePath}):`, error);
            return false;
        }
    }
    /**
     * 충돌 정보 파싱
     */
    parseConflicts(filePath, content) {
        const result = {
            filePath,
            conflicts: []
        };
        // 충돌 패턴
        const conflictPattern = /<<<<<<< HEAD\r?\n([\s\S]*?)\r?\n=======\r?\n([\s\S]*?)\r?\n>>>>>>> (.*?)(\r?\n|$)/g;
        // 라인 수 계산은 별도로 필요할 때 구현
        let match;
        while ((match = conflictPattern.exec(content)) !== null) {
            const fullMatch = match[0];
            const ours = match[1];
            const theirs = match[2];
            const branch = match[3];
            // 시작 및 종료 라인 번호 계산
            const startPos = content.substring(0, match.index).split(/\r?\n/).length - 1;
            const endPos = startPos + fullMatch.split(/\r?\n/).length - 1;
            result.conflicts.push({
                ours,
                theirs,
                marker: fullMatch,
                branch,
                startLine: startPos,
                endLine: endPos
            });
        }
        return result;
    }
    /**
     * 충돌 내용 해결
     */
    async resolveContent(content, conflictInfo, strategy, fileType) {
        let resolvedContent = content;
        // 각 충돌 부분에 대해 처리
        for (const conflict of conflictInfo.conflicts) {
            // 실제 전략이 AUTO인 경우 파일 유형과 충돌 내용에 따라 최적 전략 선택
            const actualStrategy = strategy === ConflictStrategy.AUTO
                ? this.determineStrategy(conflict, fileType)
                : strategy;
            // 전략에 따른 충돌 해결
            const mergeResult = await this.applyStrategy(conflict, actualStrategy, fileType);
            if (mergeResult.success && mergeResult.resolvedContent) {
                // 충돌 마커를 해결된 내용으로 교체
                resolvedContent = resolvedContent.replace(conflict.marker, mergeResult.resolvedContent);
            }
        }
        return resolvedContent;
    }
    /**
     * 충돌에 가장 적합한 전략 결정
     */
    determineStrategy(conflict, fileType) {
        // 두 변경 사항이 동일한 경우
        if (conflict.ours.trim() === conflict.theirs.trim()) {
            return ConflictStrategy.OURS;
        }
        // 한쪽이 다른 쪽을 포함하는 경우
        if (conflict.ours.includes(conflict.theirs)) {
            return ConflictStrategy.OURS;
        }
        if (conflict.theirs.includes(conflict.ours)) {
            return ConflictStrategy.THEIRS;
        }
        // 양쪽 변경사항의 규모 비교
        const oursLines = conflict.ours.split(/\r?\n/).length;
        const theirsLines = conflict.theirs.split(/\r?\n/).length;
        // 크기 차이가 크면 큰 쪽 선택
        if (oursLines > theirsLines * 2) {
            return ConflictStrategy.OURS;
        }
        if (theirsLines > oursLines * 2) {
            return ConflictStrategy.THEIRS;
        }
        // 코드 파일인 경우 지능형 병합 시도
        if (['js', 'ts', 'jsx', 'tsx', 'py', 'java', 'c', 'cpp', 'cs', 'go', 'rb', 'php'].includes(fileType)) {
            return ConflictStrategy.LLM;
        }
        // 기타 파일의 경우 단순 병합
        return ConflictStrategy.MERGE;
    }
    /**
     * 충돌 해결 전략 적용
     */
    async applyStrategy(conflict, strategy, fileType) {
        switch (strategy) {
            case ConflictStrategy.OURS:
                return {
                    success: true,
                    resolvedContent: conflict.ours
                };
            case ConflictStrategy.THEIRS:
                return {
                    success: true,
                    resolvedContent: conflict.theirs
                };
            case ConflictStrategy.MERGE:
                return this.mergeChanges(conflict);
            case ConflictStrategy.LLM:
                return await this.llmBasedMerge(conflict, fileType);
            default:
                return {
                    success: false,
                    message: '지원되지 않는 전략'
                };
        }
    }
    /**
     * 기본 병합 전략
     */
    mergeChanges(conflict) {
        // 줄 단위 병합 수행
        const oursLines = conflict.ours.split(/\r?\n/);
        const theirsLines = conflict.theirs.split(/\r?\n/);
        // 공통 줄 찾기
        const commonLines = oursLines.filter(line => theirsLines.includes(line));
        // 두 변경사항의 고유 줄 추출
        const uniqueOurs = oursLines.filter(line => !theirsLines.includes(line));
        const uniqueTheirs = theirsLines.filter(line => !oursLines.includes(line));
        // 중복 없이 모든 줄 결합
        const combinedLines = [...commonLines, ...uniqueOurs, ...uniqueTheirs];
        return {
            success: true,
            resolvedContent: combinedLines.join('\n')
        };
    }
    /**
     * LLM 기반 지능형 병합
     */
    async llmBasedMerge(conflict, fileType) {
        try {
            // LLM 서비스에 프롬프트 생성
            const prompt = `
두 코드 변경사항을 병합해야 합니다. 파일 타입은 ${fileType}입니다.
충돌이 발생한 코드 부분에 대해 최선의 병합 결과를 생성해주세요.
코드의 의미와 기능을 유지하면서 두 변경사항을 통합해야 합니다.

현재 브랜치 코드:
\`\`\`${fileType}
${conflict.ours}
\`\`\`

다른 브랜치 (${conflict.branch}) 코드:
\`\`\`${fileType}
${conflict.theirs}
\`\`\`

병합 결과를 직접 제공해주세요. 병합 마커나 설명 없이 코드만 결과로 반환해주세요.`;
            // LLM에 요청
            const messages = [
                {
                    id: `msg_conflict_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_5__.MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            const response = await this.llmService.sendRequest(messages);
            if (response.success && response.data) {
                // 코드 블록에서 코드 추출
                const codeBlockRegex = /```(?:[a-z]*\n)?([\s\S]*?)```/;
                const content = response.data.content || '';
                const contentMatch = content.match(codeBlockRegex);
                const resolvedContent = contentMatch
                    ? contentMatch[1].trim()
                    : content.trim();
                return {
                    success: true,
                    resolvedContent
                };
            }
            else {
                throw new Error('LLM 서비스 응답 실패');
            }
        }
        catch (error) {
            console.error('LLM 기반 병합 오류:', error);
            // LLM 오류 시 기본 병합 전략으로 대체
            return this.mergeChanges(conflict);
        }
    }
}


/***/ }),

/***/ "./src/core/llm/llmService.ts":
/*!************************************!*\
  !*** ./src/core/llm/llmService.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConnectionType: () => (/* binding */ ConnectionType),
/* harmony export */   LLMService: () => (/* binding */ LLMService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios */ "./node_modules/axios/lib/axios.js");
/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ws */ "./node_modules/ws/wrapper.mjs");
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/* harmony import */ var _vaultIntegration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vaultIntegration */ "./src/core/llm/vaultIntegration.ts");
/* harmony import */ var _rulesIntegration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rulesIntegration */ "./src/core/llm/rulesIntegration.ts");






// Define constants for WebSocket states
const WS_OPEN = 1;
/**
 * UUID 생성 함수 - 분산 환경에서의 추적성 향상
 */
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
/**
 * 세밀한 진단을 위한 로깅 유틸리티 - 기존 코드에 영향 없이 추가됨
 */
class LogUtil {
    // 로그 수준 설정으로 진단 깊이 조절 가능
    static LOG_LEVEL = {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3
    };
    static CURRENT_LOG_LEVEL = LogUtil.LOG_LEVEL.INFO;
    static logCounter = 0;
    static getLogId() {
        return `log_${Date.now()}_${++LogUtil.logCounter}`;
    }
    // 순환 참조 객체 안전하게 JSON으로 변환
    static getCircularReplacer() {
        const seen = new WeakSet();
        return (key, value) => {
            // undefined 값은 건너뜀
            if (value === undefined)
                return '[undefined]';
            // 원시 타입이나 null이면 그대로 반환
            if (typeof value !== 'object' || value === null)
                return value;
            // 순환 참조 감지
            if (seen.has(value)) {
                return '[Circular Reference]';
            }
            // Error 객체 특수 처리
            if (value instanceof Error) {
                return {
                    name: value.name,
                    message: value.message,
                    stack: value.stack
                };
            }
            // 객체 추적에 추가 (비원시 타입만)
            seen.add(value);
            return value;
        };
    }
    // 진단 가능한 구조화 정보 출력 (순환 참조 안전처리)
    static formatObject(obj, depth = 2) {
        try {
            return JSON.stringify(obj, this.getCircularReplacer(), 2);
        }
        catch (error) {
            console.error('로깅 중 오류 발생:', error);
            return '[로깅 불가 객체]';
        }
    }
    // 향상된 시각적 패턴으로 API 요청 추적
    static logRequest(endpoint, headers, body) {
        const logId = LogUtil.getLogId();
        if (LogUtil.CURRENT_LOG_LEVEL <= LogUtil.LOG_LEVEL.DEBUG) {
            console.log(`
╔════════════════════════════════════════════════════════════
║ API 요청 [ID:${logId}] (${new Date().toISOString()})
╠════════════════════════════════════════════════════════════
║ 엔드포인트: ${endpoint}
║ 
║ 요청 헤더:
${LogUtil.formatObject(headers).split('\n').map((line) => `║ ${line}`).join('\n')}
║
║ 요청 본문:
${LogUtil.formatObject(body).split('\n').map((line) => `║ ${line}`).join('\n')}
╚════════════════════════════════════════════════════════════
      `);
        }
    }
    // 응답 데이터 구조적 분석 도구
    static logResponse(responseData) {
        const logId = LogUtil.getLogId();
        if (LogUtil.CURRENT_LOG_LEVEL <= LogUtil.LOG_LEVEL.DEBUG) {
            console.log(`
╔════════════════════════════════════════════════════════════
║ API 응답 [ID:${logId}] (${new Date().toISOString()})
╠════════════════════════════════════════════════════════════
║ 응답 본문:
${LogUtil.formatObject(responseData).split('\n').map((line) => `║ ${line}`).join('\n')}
╚════════════════════════════════════════════════════════════
      `);
        }
    }
    // 복합적 오류 컨텍스트 캡처
    static logError(operation, error) {
        const logId = LogUtil.getLogId();
        if (LogUtil.CURRENT_LOG_LEVEL <= LogUtil.LOG_LEVEL.ERROR) {
            // 순환 구조 문제를 방지하기 위해 안전한 오류 출력
            let errorDetails = '';
            try {
                // 기본 오류 정보 추출
                errorDetails = `
║ 작업 컨텍스트: ${operation}
║ 에러 코드: ${error?.code || 'N/A'}
║ 상태 코드: ${error?.response?.status || 'N/A'}
║ 에러 메시지: ${error?.message || '알 수 없는 오류'}`;
                // 응답 데이터가 있으면 안전하게 추가
                if (error?.response?.data) {
                    try {
                        const safeResponseData = typeof error.response.data === 'object' ?
                            JSON.stringify(error.response.data, this.getCircularReplacer()) :
                            String(error.response.data);
                        errorDetails += `\n║ 응답 데이터: ${safeResponseData}`;
                    }
                    catch (formatError) {
                        errorDetails += '\n║ 응답 데이터: [순환 참조 또는 직렬화 불가 객체]';
                    }
                }
                else {
                    errorDetails += '\n║ 응답 데이터: N/A';
                }
                // 스택 트레이스 안전하게 추가
                errorDetails += '\n║ \n║ 스택 트레이스:';
                if (error?.stack) {
                    errorDetails += `\n${error.stack.split('\n').map((line) => `║ ${line}`).join('\n')}`;
                }
                else {
                    try {
                        const safeErrorString = JSON.stringify(error, this.getCircularReplacer());
                        errorDetails += `\n${safeErrorString.split('\n').map((line) => `║ ${line}`).join('\n')}`;
                    }
                    catch (stringifyError) {
                        errorDetails += '\n║ [순환 참조로 인해 스택 트레이스를 표시할 수 없음]';
                    }
                }
            }
            catch (loggingError) {
                // 최악의 경우에도 기본 오류 정보는 제공
                errorDetails = `
║ 작업 컨텍스트: ${operation}
║ 기본 에러 정보: 순환 참조로 인해 자세한 정보를 표시할 수 없습니다
║ 에러 메시지: ${error?.message || '알 수 없는 오류'}`;
            }
            // 최종 오류 출력
            console.error(`
╔════════════════════════════════════════════════════════════
║ ⚠️ 시스템 오류 [ID:${logId}] (${new Date().toISOString()})
╠════════════════════════════════════════════════════════════${errorDetails}
╚════════════════════════════════════════════════════════════
      `);
        }
    }
    // 스트리밍 데이터 흐름 추적
    static logStreamChunk(chunk, parsed) {
        // Skip logging empty chunks or when only structural content exists
        const isEmpty = !chunk ||
            (typeof chunk === 'string' && !chunk.trim()) ||
            (parsed && Object.keys(parsed).length === 0);
        if (isEmpty) {
            return;
        }
        // Check if content is empty (to reduce logging noise)
        const hasContent = parsed &&
            (parsed.content || parsed.text || parsed.delta?.content ||
                parsed.choices?.[0]?.delta?.content || parsed.choices?.[0]?.message?.content);
        // Only log if DEBUG level is enabled and content exists
        const logId = LogUtil.getLogId();
        if (LogUtil.CURRENT_LOG_LEVEL <= LogUtil.LOG_LEVEL.DEBUG && hasContent) {
            console.log(`
╔════════════════════════════════════════════════════════════
║ 스트림 데이터 청크 [ID:${logId}] (${new Date().toISOString()})
╠════════════════════════════════════════════════════════════
║ 원본 데이터:
${(typeof chunk === 'string' ? chunk : LogUtil.formatObject(chunk)).split('\n').map((line) => `║ ${line}`).join('\n')}
║
║ 구조화 데이터:
${LogUtil.formatObject(parsed).split('\n').map((line) => `║ ${line}`).join('\n')}
╚════════════════════════════════════════════════════════════
      `);
        }
    }
    // 시스템 상태 및 주요 이벤트 추적
    static logInfo(message, data) {
        const logId = LogUtil.getLogId();
        if (LogUtil.CURRENT_LOG_LEVEL <= LogUtil.LOG_LEVEL.INFO) {
            try {
                const safeData = data ? LogUtil.formatObject(data) : '';
                console.log(`
╔════════════════════════════════════════════════════════════
║ 시스템 이벤트 [ID:${logId}] (${new Date().toISOString()})
╠════════════════════════════════════════════════════════════
║ ${message}
${data ? `║ 
${safeData.split('\n').map((line) => `║ ${line}`).join('\n')}` : ''}
╚════════════════════════════════════════════════════════════
        `);
            }
            catch (error) {
                // 로깅 실패 시에도 최소한의 정보는 출력
                console.log(`
╔════════════════════════════════════════════════════════════
║ 시스템 이벤트 [ID:${logId}] (${new Date().toISOString()})
╠════════════════════════════════════════════════════════════
║ ${message}
║ [로깅 불가 데이터: 순환 참조 또는 직렬화 오류]
╚════════════════════════════════════════════════════════════
        `);
            }
        }
    }
}
/**
 * LLM connection type
 */
var ConnectionType;
(function (ConnectionType) {
    ConnectionType["HTTP"] = "http";
    ConnectionType["WebSocket"] = "websocket";
})(ConnectionType || (ConnectionType = {}));
/**
 * Service for interacting with LLM APIs
 */
class LLMService {
    _context;
    _modelManager;
    _endpoint;
    _connectionType;
    _wsConnection = null;
    _cancelTokenSource = null;
    _configListener;
    _modelChangeListener;
    /**
     * Creates a new LLMService instance
     * @param _context The VSCode extension context
     * @param _modelManager The model manager service
     */
    _vaultService = null;
    _rulesService = null;
    /**
     * 생성자
     * @param _context VSCode 확장 컨텍스트
     * @param _modelManager 모델 관리자
     */
    constructor(_context, _modelManager) {
        this._context = _context;
        this._modelManager = _modelManager;
        // Initialize properties
        this._endpoint = '';
        this._connectionType = ConnectionType.HTTP;
        LogUtil.logInfo('LLMService 초기화 시작...');
        // Load configuration
        this._loadConfiguration();
        // Listen for configuration changes
        this._configListener = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration('ape.llm') &&
                !event.affectsConfiguration('ape.llm.defaultModel')) { // Only handle non-model configs
                LogUtil.logInfo('LLM 설정 변경 감지:', event);
                this._loadConfiguration();
            }
        });
        // Listen for model changes from ModelManager
        this._modelChangeListener = this._modelManager.onDidChangeModel(event => {
            LogUtil.logInfo(`모델 변경 감지: ${event.oldModel} -> ${event.newModel}`);
            // No need to update internal state as we'll always use modelManager.getActiveModel()
        });
        LogUtil.logInfo('LLMService 초기화 완료, 기본 모델:', this.getActiveModel());
    }
    /**
     * VAULT 서비스 설정
     * @param vaultService VAULT 서비스 인스턴스
     */
    setVaultService(vaultService) {
        this._vaultService = vaultService;
        LogUtil.logInfo('VAULT 서비스 설정됨');
    }
    /**
     * Rules 서비스 설정
     * @param rulesService Rules 서비스 인스턴스
     */
    setRulesService(rulesService) {
        this._rulesService = rulesService;
        LogUtil.logInfo('Rules 서비스 설정됨');
    }
    /**
     * Reloads configuration from VSCode settings
     */
    _apiKey = '';
    _loadConfiguration() {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.llm');
        const newEndpoint = config.get('endpoint', 'https://openrouter.ai/api/v1/chat/completions');
        const newApiKey = config.get('apiKey', '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');
        // Only update endpoint and API key if changed
        if (this._endpoint !== newEndpoint) {
            this._endpoint = newEndpoint;
            LogUtil.logInfo('엔드포인트 설정 변경됨', { endpoint: this._endpoint });
        }
        if (this._apiKey !== newApiKey) {
            this._apiKey = newApiKey;
            LogUtil.logInfo('API 키 설정 변경됨', { keyLength: this._apiKey.length });
        }
        // Update connection type
        const newConnectionType = this._endpoint && this._endpoint.startsWith('ws')
            ? ConnectionType.WebSocket
            : ConnectionType.HTTP;
        if (this._connectionType !== newConnectionType) {
            this._connectionType = newConnectionType;
            LogUtil.logInfo('연결 타입 변경됨', { connectionType: this._connectionType });
            // Handle WebSocket connection changes
            if (this._connectionType === ConnectionType.WebSocket && this._wsConnection) {
                this._wsConnection.close();
                this._wsConnection = null;
                LogUtil.logInfo('기존 WebSocket 연결 종료됨');
            }
        }
    }
    /**
     * Gets the currently active LLM model
     * @returns The active LLM model
     */
    getActiveModel() {
        return this._modelManager.getActiveModel();
    }
    /**
     * Changes the active LLM model
     * @param model The model to switch to
     */
    async setActiveModel(model) {
        LogUtil.logInfo('모델 변경 요청', { newModel: model });
        return this._modelManager.setActiveModel(model);
    }
    /**
     * Gets all available LLM models
     * @returns Array of available LLM models
     */
    getAvailableModels() {
        return this._modelManager.getAvailableModels();
    }
    /**
     * Gets a user-friendly display name for a model
     * @param modelId The model ID
     * @returns A formatted display name
     */
    getModelDisplayName(modelId) {
        return this._modelManager.getModelDisplayName(modelId);
    }
    /**
     * Sends a request to the LLM and gets a response
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to LLMResult containing the LLM response
     */
    async sendRequest(messages, options) {
        try {
            LogUtil.logInfo('LLM 요청 시작', {
                messageCount: messages.length,
                options: options
            });
            // 모델 지정 (디버깅 목적으로 사용됩니다)
            // options?.model || this.getActiveModel();
            if (this._connectionType === ConnectionType.WebSocket) {
                LogUtil.logInfo('WebSocket 요청 실행', {
                    model: options?.model || this.getActiveModel()
                });
                const response = await this._sendWebSocketRequest(messages, options);
                return { success: true, data: response };
            }
            else {
                LogUtil.logInfo('HTTP 요청 실행', {
                    model: options?.model || this.getActiveModel()
                });
                const response = await this._sendHttpRequest(messages, options);
                return { success: true, data: response };
            }
        }
        catch (error) {
            LogUtil.logError('LLM 요청 중 오류 발생', error);
            return {
                success: false,
                error: error instanceof Error
                    ? error
                    : new Error(`Failed to communicate with LLM service: ${String(error)}`)
            };
        }
    }
    /**
     * Streams a response from the LLM
     * @param messages Messages to send
     * @param streamCallback Callback for streaming chunks and completion
     * @param options Request options
     * @returns Promise that resolves to LLMResult indicating streaming success or failure
     */
    async streamResponse(messages, streamCallback, options) {
        try {
            LogUtil.logInfo('LLM 스트리밍 요청 시작', {
                messageCount: messages.length,
                options: options
            });
            // 모델 지정 (디버깅 목적으로 사용됩니다)
            // options?.model || this.getActiveModel();
            if (this._connectionType === ConnectionType.WebSocket) {
                LogUtil.logInfo('WebSocket 스트리밍 시작', {
                    model: options?.model || this.getActiveModel()
                });
                await this._streamWebSocketResponse(messages, streamCallback, options);
                return { success: true };
            }
            else {
                LogUtil.logInfo('HTTP 스트리밍 시작', {
                    model: options?.model || this.getActiveModel()
                });
                await this._streamHttpResponse(messages, streamCallback, options);
                return { success: true };
            }
        }
        catch (error) {
            LogUtil.logError('LLM 스트리밍 중 오류 발생', error);
            // 에러 발생 시 스트리밍 완료 콜백 호출로 UI가 대기 상태에서 벗어나게 함
            // 에러 메시지를 마지막 청크로 전달하여 사용자에게 표시
            const errorMessage = error instanceof Error
                ? `오류 발생: ${error.message}`
                : `오류 발생: LLM 서비스 연결 실패 (${String(error)})`;
            // 에러 메시지를 전달하고 스트리밍 완료 플래그(true)를 보냄
            streamCallback(errorMessage, true);
            return {
                success: false,
                error: error instanceof Error
                    ? error
                    : new Error(`Failed to stream from LLM service: ${String(error)}`)
            };
        }
    }
    /**
     * Cancels an ongoing streaming response
     * @param streamCallback Optional callback to notify about cancellation
     */
    cancelStream(streamCallback) {
        LogUtil.logInfo('스트림 취소 요청됨');
        if (this._connectionType === ConnectionType.HTTP && this._cancelTokenSource) {
            this._cancelTokenSource.cancel('Operation canceled by user');
            this._cancelTokenSource = null;
            LogUtil.logInfo('HTTP 스트림 취소됨');
            // 취소 알림 메시지 전달 (선택적)
            if (streamCallback) {
                streamCallback('\n\n*요청이 취소되었습니다.*', true);
            }
        }
        else if (this._connectionType === ConnectionType.WebSocket && this._wsConnection) {
            // Send cancel message if supported
            try {
                this._wsConnection.send(JSON.stringify({ type: 'cancel' }));
                LogUtil.logInfo('WebSocket 취소 메시지 전송됨');
                // 취소 알림 메시지 전달 (선택적)
                if (streamCallback) {
                    streamCallback('\n\n*요청이 취소되었습니다.*', true);
                }
            }
            catch (error) {
                LogUtil.logError('WebSocket 취소 메시지 전송 실패', error);
                // 취소 오류 알림 (선택적)
                if (streamCallback) {
                    streamCallback('\n\n*요청 취소 중 오류가 발생했습니다.*', true);
                }
            }
        }
    }
    /**
     * HTTP implementation of sendRequest
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to the LLM response
     */
    async _sendHttpRequest(messages, options) {
        const formattedMessages = this._formatMessagesForAPI(messages, options);
        const requestId = generateUUID();
        // OpenRouter API 요청 형식으로 변환
        const openRouterMessages = formattedMessages.map(msg => ({
            role: msg.role,
            content: msg.content
        }));
        const request = {
            model: options?.model || this.getActiveModel(),
            messages: openRouterMessages,
            temperature: options?.temperature || 0.7,
            max_tokens: options?.maxTokens || 1000,
            stream: false
        };
        // OpenRouter API 요청에 필요한 헤더 추가
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this._apiKey}`,
            'HTTP-Referer': 'APE-Extension',
            'X-Title': 'APE (Agentic Pipeline Engine)'
        };
        LogUtil.logRequest(this._endpoint, headers, request);
        try {
            const response = await axios__WEBPACK_IMPORTED_MODULE_5__["default"].post(this._endpoint, request, { headers });
            LogUtil.logResponse(response.data);
            return this._processHttpResponse(response.data);
        }
        catch (error) {
            LogUtil.logError('HTTP 요청 중 오류 발생', error);
            throw error;
        }
    }
    /**
     * WebSocket implementation of sendRequest
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to the LLM response
     */
    async _sendWebSocketRequest(messages, options) {
        return new Promise((resolve, reject) => {
            this._ensureWebSocketConnection();
            if (!this._wsConnection) {
                const error = new Error('Failed to establish WebSocket connection');
                LogUtil.logError('WebSocket 연결 실패', error);
                reject(error);
                return;
            }
            const formattedMessages = this._formatMessagesForAPI(messages, options);
            const request = {
                messages: formattedMessages,
                model: options?.model || this.getActiveModel(),
                temperature: options?.temperature,
                maxTokens: options?.maxTokens,
                stream: false,
                parameters: options?.modelParameters
            };
            // Generate a unique request ID
            const requestId = generateUUID();
            LogUtil.logInfo('WebSocket 요청 준비 완료', { requestId });
            // Set up one-time message handler for this request
            const messageHandler = (data) => {
                try {
                    const dataStr = data.toString();
                    LogUtil.logInfo('WebSocket 응답 수신', {
                        dataPreview: dataStr.substring(0, 100) + (dataStr.length > 100 ? '...' : '')
                    });
                    const response = JSON.parse(dataStr);
                    // Check if this is the response to our request
                    if (response.requestId === requestId) {
                        // Remove the listener once we get our response
                        if (this._wsConnection) {
                            this._wsConnection.removeListener('message', messageHandler);
                        }
                        if (response.error) {
                            LogUtil.logError('WebSocket 응답 오류', new Error(response.error));
                            reject(new Error(response.error));
                        }
                        else {
                            LogUtil.logInfo('WebSocket 응답 처리 성공');
                            resolve(this._processWebSocketResponse(response));
                        }
                    }
                }
                catch (error) {
                    LogUtil.logError('WebSocket 응답 처리 중 오류', error);
                    reject(error);
                }
            };
            // Add the message handler
            this._wsConnection.on('message', messageHandler);
            // Send the request with the request ID
            try {
                this._wsConnection.send(JSON.stringify({
                    ...request,
                    requestId
                }));
                LogUtil.logInfo('WebSocket 요청 전송 완료', { requestId });
            }
            catch (error) {
                LogUtil.logError('WebSocket 요청 전송 실패', error);
                reject(error);
                return;
            }
            // Set a timeout in case of no response
            const timeoutId = setTimeout(() => {
                if (this._wsConnection) {
                    this._wsConnection.removeListener('message', messageHandler);
                }
                const timeoutError = new Error('Request timed out');
                LogUtil.logError('WebSocket 요청 타임아웃', timeoutError);
                reject(timeoutError);
            }, 30000); // 30 seconds timeout
            // Also set up an error handler
            const errorHandler = (error) => {
                clearTimeout(timeoutId);
                this._wsConnection?.removeListener('message', messageHandler);
                this._wsConnection?.removeListener('error', errorHandler);
                LogUtil.logError('WebSocket 오류 발생', error);
                reject(error);
            };
            this._wsConnection.on('error', errorHandler);
        });
    }
    /**
     * HTTP implementation of streamResponse
     * @param messages Messages to send
     * @param streamCallback Callback for streaming chunks and completion
     * @param options Request options
     */
    async _streamHttpResponse(messages, streamCallback, options) {
        const formattedMessages = this._formatMessagesForAPI(messages, options);
        const requestId = generateUUID();
        // OpenRouter API 요청 형식으로 변환
        const openRouterMessages = formattedMessages.map(msg => ({
            role: msg.role,
            content: msg.content
        }));
        const request = {
            model: options?.model || this.getActiveModel(),
            messages: openRouterMessages,
            temperature: options?.temperature || 0.7,
            max_tokens: options?.maxTokens || 1000,
            stream: true
        };
        // OpenRouter API 요청에 필요한 헤더 추가
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this._apiKey}`,
            'HTTP-Referer': 'APE-Extension',
            'X-Title': 'APE (Agentic Pipeline Engine)'
        };
        // Create a cancellation token
        this._cancelTokenSource = axios__WEBPACK_IMPORTED_MODULE_5__["default"].CancelToken.source();
        LogUtil.logRequest(this._endpoint, headers, request);
        LogUtil.logInfo('HTTP 스트리밍 요청 시작', { requestId });
        try {
            // 누적 텍스트는 디버깅 목적으로 사용될 수 있음
            let chunkCount = 0;
            let accumulatedText = '';
            const response = await axios__WEBPACK_IMPORTED_MODULE_5__["default"].post(this._endpoint, request, {
                responseType: 'stream',
                cancelToken: this._cancelTokenSource.token,
                headers: headers
            });
            LogUtil.logInfo('스트리밍 응답 시작됨', {
                status: response.status,
                statusText: response.statusText
            });
            response.data.on('data', (chunk) => {
                const chunkStr = chunk.toString();
                LogUtil.logInfo(`스트림 데이터 청크 #${++chunkCount} 수신`, {
                    chunkSize: chunkStr.length,
                    chunkPreview: chunkStr.substring(0, 100) + (chunkStr.length > 100 ? '...' : '')
                });
                const lines = chunkStr.split('\n').filter(Boolean);
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.substring('data: '.length);
                        if (data === '[DONE]') {
                            LogUtil.logInfo('스트림 완료 신호 [DONE] 수신');
                            streamCallback('', true); // 스트림 완료 신호
                        }
                        else {
                            try {
                                const parsed = JSON.parse(data);
                                LogUtil.logStreamChunk(data, parsed);
                                if (parsed.choices && parsed.choices.length > 0) {
                                    const content = parsed.choices[0].delta?.content ||
                                        parsed.choices[0].message?.content || '';
                                    if (content) {
                                        accumulatedText += content;
                                        LogUtil.logInfo('스트림 콘텐츠 추출', {
                                            contentLength: content.length,
                                            contentPreview: content.substring(0, 50) + (content.length > 50 ? '...' : ''),
                                            totalAccumulated: accumulatedText.length
                                        });
                                        streamCallback(content, false);
                                    }
                                }
                                else if (parsed.error) {
                                    // 스트리밍 중 API 에러 처리
                                    const errorContent = `\n\n**오류 발생**: ${parsed.error.message || '알 수 없는 오류가 발생했습니다.'}`;
                                    LogUtil.logError('API 스트리밍 오류 응답', new Error(parsed.error.message));
                                    streamCallback(errorContent, true); // 에러 메시지 전달 후 스트림 완료 처리
                                    throw new Error(parsed.error.message || 'API error during streaming');
                                }
                            }
                            catch (err) {
                                LogUtil.logError('스트림 데이터 파싱 오류', err);
                                // JSON 파싱 에러는 스트림을 중단시키지 않음 (단일 청크 손상 처리)
                            }
                        }
                    }
                }
            });
            response.data.on('end', () => {
                this._cancelTokenSource = null;
                LogUtil.logInfo('스트림 종료', {
                    totalChunks: chunkCount,
                    totalAccumulatedLength: accumulatedText.length
                });
                streamCallback('', true); // 스트림 완료 신호
            });
            response.data.on('error', (err) => {
                this._cancelTokenSource = null;
                // 스트림 에러 처리 (TLS 소켓 순환 참조 오류 등)
                let errorMessage = '연결이 중단되었습니다.';
                try {
                    errorMessage = err.message || errorMessage;
                }
                catch (serializationError) {
                    // 순환 참조 객체로 인한 오류 - 기본 메시지 사용
                }
                LogUtil.logError('스트림 에러', {
                    message: errorMessage,
                    name: err.name || 'Unknown Error'
                });
                // 스트림 에러 발생 시 에러 메시지 전달 후 스트림 완료 처리
                const errorContent = `\n\n**스트림 오류 발생**: ${errorMessage}`;
                streamCallback(errorContent, true);
            });
        }
        catch (error) {
            this._cancelTokenSource = null;
            if (axios__WEBPACK_IMPORTED_MODULE_5__["default"].isCancel(error)) {
                // Request was canceled intentionally
                LogUtil.logInfo('스트림 요청이 취소됨');
                streamCallback('\n\n*요청이 취소되었습니다.*', true); // 사용자에게 취소 알림
            }
            else {
                // Real error - 순환 참조 방지 처리
                let errorMessage = '연결 실패';
                try {
                    errorMessage = error instanceof Error ? error.message : String(error);
                }
                catch (serializationError) {
                    // 순환 참조 객체로 인한 오류 - 기본 메시지 사용
                }
                LogUtil.logError('스트림 요청 처리 중 오류 발생', {
                    message: errorMessage,
                    name: error instanceof Error ? error.name : 'Unknown Error'
                });
                const errorContent = `\n\n**API 오류 발생**: ${errorMessage}`;
                streamCallback(errorContent, true); // 에러 메시지 전달 후 스트림 완료 처리
                throw error;
            }
        }
    }
    /**
     * WebSocket implementation of streamResponse
     * @param messages Messages to send
     * @param streamCallback Callback for streaming chunks and completion
     * @param options Request options
     */
    async _streamWebSocketResponse(messages, streamCallback, options) {
        return new Promise((resolve, reject) => {
            this._ensureWebSocketConnection();
            if (!this._wsConnection) {
                // 연결 실패 시 에러 메시지 전달 후 스트림 완료 처리
                const errorMessage = '\n\n**WebSocket 연결 실패**: 서버에 연결할 수 없습니다.';
                LogUtil.logError('WebSocket 연결 실패', new Error('Failed to establish WebSocket connection'));
                streamCallback(errorMessage, true);
                reject(new Error('Failed to establish WebSocket connection'));
                return;
            }
            const formattedMessages = this._formatMessagesForAPI(messages, options);
            const request = {
                messages: formattedMessages,
                model: options?.model || this.getActiveModel(),
                temperature: options?.temperature,
                maxTokens: options?.maxTokens,
                stream: true,
                parameters: options?.modelParameters
            };
            // Generate a unique request ID
            const requestId = generateUUID();
            LogUtil.logInfo('WebSocket 스트리밍 요청 준비 완료', { requestId });
            let chunkCount = 0;
            let accumulatedText = '';
            // Set up message handler for streaming
            const messageHandler = (data) => {
                try {
                    const dataStr = data.toString();
                    const response = JSON.parse(dataStr);
                    // Check if this is a response to our request
                    if (response.requestId === requestId) {
                        if (response.error) {
                            // Error response - 에러 메시지를 사용자에게 표시
                            const errorMessage = `\n\n**WebSocket 오류 발생**: ${response.error}`;
                            LogUtil.logError('WebSocket 스트리밍 오류 응답', new Error(response.error));
                            streamCallback(errorMessage, true); // 에러 메시지 전달 후 스트림 완료 처리
                            if (this._wsConnection) {
                                this._wsConnection.removeListener('message', messageHandler);
                            }
                            reject(new Error(response.error));
                        }
                        else if (response.type === 'chunk') {
                            // Streaming chunk
                            chunkCount++;
                            const content = response.content || '';
                            if (content) {
                                accumulatedText += content;
                                LogUtil.logInfo(`WebSocket 스트림 청크 #${chunkCount}`, {
                                    contentLength: content.length,
                                    contentPreview: content.substring(0, 50) + (content.length > 50 ? '...' : ''),
                                    totalAccumulated: accumulatedText.length
                                });
                            }
                            streamCallback(content, false);
                        }
                        else if (response.type === 'complete') {
                            // Stream complete
                            LogUtil.logInfo('WebSocket 스트리밍 완료', {
                                totalChunks: chunkCount,
                                totalAccumulatedLength: accumulatedText.length
                            });
                            if (this._wsConnection) {
                                this._wsConnection.removeListener('message', messageHandler);
                            }
                            streamCallback('', true); // Signal completion
                            resolve();
                        }
                    }
                }
                catch (error) {
                    // JSON 파싱 에러 등의 예외 처리
                    let errorMessage = '알 수 없는 오류';
                    try {
                        errorMessage = error instanceof Error ? error.message : String(error);
                    }
                    catch (serializationError) {
                        // 순환 참조 객체로 인한 오류 - 기본 메시지 사용
                    }
                    LogUtil.logError('WebSocket 데이터 처리 오류', {
                        message: errorMessage,
                        name: error instanceof Error ? error.name : 'Unknown Error'
                    });
                    const wsErrorMessage = `\n\n**WebSocket 데이터 처리 오류**: ${errorMessage}`;
                    streamCallback(wsErrorMessage, true);
                    if (this._wsConnection) {
                        this._wsConnection.removeListener('message', messageHandler);
                    }
                    reject(error);
                }
            };
            // Add the message handler
            this._wsConnection.on('message', messageHandler);
            // Send the streaming request
            try {
                this._wsConnection.send(JSON.stringify({
                    ...request,
                    requestId
                }));
                LogUtil.logInfo('WebSocket 스트리밍 요청 전송 완료', { requestId });
            }
            catch (error) {
                // 전송 실패 시 에러 처리
                let errorMessage = '알 수 없는 오류';
                try {
                    errorMessage = error instanceof Error ? error.message : String(error);
                }
                catch (serializationError) {
                    // 순환 참조 객체로 인한 오류 - 기본 메시지 사용
                }
                LogUtil.logError('WebSocket 스트리밍 요청 전송 실패', {
                    message: errorMessage,
                    name: error instanceof Error ? error.name : 'Unknown Error'
                });
                const wsErrorMessage = `\n\n**WebSocket 요청 전송 실패**: ${errorMessage}`;
                streamCallback(wsErrorMessage, true);
                reject(error);
                return;
            }
            // Set a timeout for the entire streaming session
            const timeoutId = setTimeout(() => {
                if (this._wsConnection) {
                    this._wsConnection.removeListener('message', messageHandler);
                }
                // 타임아웃 발생 시 에러 메시지 전달
                const timeoutError = new Error('Streaming request timed out');
                LogUtil.logError('WebSocket 스트리밍 요청 타임아웃', timeoutError);
                const timeoutMessage = '\n\n**연결 시간 초과**: 응답을 기다리는 시간이 너무 깁니다.';
                streamCallback(timeoutMessage, true);
                reject(timeoutError);
            }, 300000); // 5 minutes timeout for streaming
            // Also set up an error handler
            const errorHandler = (error) => {
                clearTimeout(timeoutId);
                // WebSocket 에러 발생 시 에러 메시지 전달
                let errorMessage = '연결 중 오류가 발생했습니다.';
                try {
                    errorMessage = error.message || errorMessage;
                }
                catch (serializationError) {
                    // 순환 참조 객체로 인한 오류 - 기본 메시지 사용
                }
                LogUtil.logError('WebSocket 오류 발생', {
                    message: errorMessage,
                    name: error.name || 'Unknown Error'
                });
                const wsErrorMessage = `\n\n**WebSocket 오류 발생**: ${errorMessage}`;
                streamCallback(wsErrorMessage, true);
                this._wsConnection?.removeListener('message', messageHandler);
                this._wsConnection?.removeListener('error', errorHandler);
                reject(error);
            };
            this._wsConnection.on('error', errorHandler);
        });
    }
    /**
     * Ensures a WebSocket connection is established
     */
    _ensureWebSocketConnection() {
        if (this._connectionType !== ConnectionType.WebSocket) {
            LogUtil.logInfo('WebSocket 연결 필요 없음 - HTTP 모드로 동작 중');
            return;
        }
        if (!this._wsConnection || this._wsConnection.readyState !== WS_OPEN) {
            LogUtil.logInfo('새 WebSocket 연결 시도', { endpoint: this._endpoint });
            try {
                // Create a new WebSocket connection
                this._wsConnection = new ws__WEBPACK_IMPORTED_MODULE_1__.WebSocket(this._endpoint);
                // Set up event handlers
                if (this._wsConnection) {
                    this._wsConnection.on('error', (error) => {
                        LogUtil.logError('WebSocket 오류', error);
                        this._wsConnection = null;
                    });
                    this._wsConnection.on('close', () => {
                        LogUtil.logInfo('WebSocket 연결 닫힘');
                        this._wsConnection = null;
                    });
                    // Wait for connection to be established
                    this._wsConnection.on('open', () => {
                        LogUtil.logInfo('WebSocket 연결 성공적으로 설정됨');
                    });
                }
            }
            catch (error) {
                LogUtil.logError('WebSocket 연결 생성 실패', error);
                this._wsConnection = null;
            }
        }
        else {
            LogUtil.logInfo('기존 WebSocket 연결 재사용');
        }
    }
    /**
     * Formats messages for the API
     * @param messages Messages to format
     * @param options Optional request options
     * @returns Formatted messages array
     */
    _formatMessagesForAPI(messages, options) {
        LogUtil.logInfo('API용 메시지 포맷팅 시작', {
            messageCount: messages.length,
            hasSystemPrompt: !!options?.systemPrompt,
            hasContextMessages: options?.contextMessages ? options.contextMessages.length : 0
        });
        let formattedMessages = [...messages];
        // Add system prompt as a system message if provided
        if (options?.systemPrompt) {
            formattedMessages.unshift({
                id: `system_${Date.now()}`,
                role: _types_chat__WEBPACK_IMPORTED_MODULE_2__.MessageRole.System,
                content: options.systemPrompt,
                timestamp: new Date()
            });
            LogUtil.logInfo('시스템 프롬프트 추가됨');
        }
        // Add context messages if provided
        if (options?.contextMessages && options.contextMessages.length > 0) {
            formattedMessages = [...options.contextMessages, ...formattedMessages];
            LogUtil.logInfo(`컨텍스트 메시지 ${options.contextMessages.length}개 추가됨`);
        }
        // Apply VAULT context if available and requested
        if (this._vaultService && options?.vaultOptions) {
            const vaultOptions = options.vaultOptions;
            // vaultOptions가 undefined일 수 없지만 타입 에러를 해결하기 위해 기본 객체 제공
            formattedMessages = (0,_vaultIntegration__WEBPACK_IMPORTED_MODULE_3__.applyVaultContext)(formattedMessages, this._vaultService, vaultOptions || {});
            LogUtil.logInfo('VAULT 컨텍스트 적용됨');
        }
        // Apply Rules if available
        if (this._rulesService) {
            const rulesOptions = options?.rulesOptions;
            formattedMessages = (0,_rulesIntegration__WEBPACK_IMPORTED_MODULE_4__.applyRulesContext)(formattedMessages, this._rulesService, rulesOptions);
            LogUtil.logInfo('Rules 컨텍스트 적용됨');
        }
        // Return formatted messages
        LogUtil.logInfo('메시지 포맷팅 완료', { finalMessageCount: formattedMessages.length });
        return formattedMessages;
    }
    /**
     * Processes an HTTP API response
     * @param responseData Raw response data
     * @returns Processed LLM response
     */
    _processHttpResponse(responseData) {
        // OpenRouter/OpenAI 형식 응답 처리 (choices 배열 사용)
        if (responseData.choices && Array.isArray(responseData.choices)) {
            const content = responseData.choices[0]?.message?.content || '';
            LogUtil.logInfo('OpenAI/OpenRouter 형식 응답 처리', {
                responseId: responseData.id,
                contentLength: content.length
            });
            return {
                message: {
                    id: responseData.id || `msg_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_2__.MessageRole.Assistant,
                    content: content,
                    timestamp: new Date(),
                    metadata: {
                        model: responseData.model || this.getActiveModel()
                    }
                },
                usage: responseData.usage || {
                    promptTokens: 0,
                    completionTokens: 0,
                    totalTokens: 0
                },
                metadata: responseData.metadata || {},
                content: content // 호환성을 위해 추가
            };
        }
        // 기존 응답 형식 처리
        else {
            const messageContent = responseData.content || responseData.message?.content || '';
            LogUtil.logInfo('기존 형식 응답 처리', {
                responseId: responseData.message?.id,
                contentLength: messageContent.length
            });
            return {
                message: {
                    id: responseData.message?.id || `msg_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_2__.MessageRole.Assistant,
                    content: messageContent,
                    timestamp: new Date(),
                    metadata: responseData.message?.metadata || {
                        model: responseData.model || this.getActiveModel()
                    }
                },
                usage: responseData.usage || {
                    promptTokens: 0,
                    completionTokens: 0,
                    totalTokens: 0
                },
                metadata: responseData.metadata || {}
            };
        }
    }
    /**
     * Processes a WebSocket API response
     * @param responseData Raw response data
     * @returns Processed LLM response
     */
    _processWebSocketResponse(responseData) {
        // Process according to the WebSocket response format
        const messageContent = responseData.content || responseData.message?.content || '';
        LogUtil.logInfo('WebSocket 응답 처리', {
            responseId: responseData.message?.id,
            contentLength: messageContent.length
        });
        return {
            message: {
                id: responseData.message?.id || `msg_${Date.now()}`,
                role: _types_chat__WEBPACK_IMPORTED_MODULE_2__.MessageRole.Assistant,
                content: messageContent,
                timestamp: new Date(),
                metadata: responseData.message?.metadata || {
                    model: responseData.model || this.getActiveModel()
                }
            },
            usage: responseData.usage || {
                promptTokens: 0,
                completionTokens: 0,
                totalTokens: 0
            },
            metadata: responseData.metadata || {}
        };
    }
    /**
     * Processes a streaming chunk
     * @param chunk Raw chunk data
     * @returns Processed chunk as a string
     */
    _processStreamChunk(chunk) {
        // Skip processing for empty chunks
        if (!chunk) {
            return '';
        }
        LogUtil.logInfo('스트림 청크 처리 시작');
        // Process based on the API's streaming format
        try {
            if (typeof chunk === 'string') {
                // Skip empty strings
                if (!chunk.trim()) {
                    return '';
                }
                try {
                    // Try to parse as JSON if it's a string
                    const data = JSON.parse(chunk);
                    const content = data.content || data.text || data.chunk || '';
                    // Only log non-empty content
                    if (content) {
                        LogUtil.logInfo('청크 처리 완료 (문자열 형식)', {
                            contentLength: content.length
                        });
                    }
                    return content;
                }
                catch (e) {
                    // If it's not JSON, return as is
                    return chunk;
                }
            }
            else if (typeof chunk === 'object') {
                // Already a parsed object
                const content = chunk.content || chunk.text || chunk.chunk || '';
                // Only log non-empty content
                if (content) {
                    LogUtil.logInfo('청크 처리 완료 (객체 형식)', {
                        contentLength: content.length
                    });
                }
                return content;
            }
        }
        catch (error) {
            // If parsing fails, return as is but log error
            LogUtil.logError('청크 파싱 실패', error);
            return chunk ? chunk.toString() : '';
        }
        // Default case - return empty string for anything else
        return '';
    }
    /**
     * Gets a simple completion from the LLM for a prompt
     * @param prompt The prompt to send to the LLM
     * @param options Optional request options
     * @returns Promise that resolves to LLMResult containing the completion text
     */
    async getCompletion(prompt, options) {
        try {
            LogUtil.logInfo('단순 완성 요청 시작', {
                promptLength: prompt.length,
                promptPreview: prompt.substring(0, 100) + (prompt.length > 100 ? '...' : '')
            });
            // Create a simple message with the prompt
            const messages = [
                {
                    id: `user_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_2__.MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            // Send the request
            const result = await this.sendRequest(messages, options);
            if (result.success && result.data) {
                LogUtil.logInfo('완성 요청 성공', {
                    contentLength: result.data.message.content.length
                });
                return {
                    success: true,
                    data: result.data.message.content
                };
            }
            else {
                LogUtil.logError('완성 요청 실패', result.error || new Error('Failed to get completion'));
                return {
                    success: false,
                    error: result.error || new Error('Failed to get completion')
                };
            }
        }
        catch (error) {
            LogUtil.logError('완성 가져오기 중 오류', error);
            return {
                success: false,
                error: error instanceof Error
                    ? error
                    : new Error(`Failed to get completion: ${String(error)}`)
            };
        }
    }
    /**
     * Disposes resources
     */
    dispose() {
        LogUtil.logInfo('LLMService 리소스 정리 시작');
        // Dispose event listeners
        this._configListener.dispose();
        this._modelChangeListener.dispose();
        // Cancel any ongoing operations
        if (this._cancelTokenSource) {
            this._cancelTokenSource.cancel('Extension deactivated');
            this._cancelTokenSource = null;
            LogUtil.logInfo('진행 중인 HTTP 요청 취소됨');
        }
        // Close WebSocket connection
        if (this._wsConnection) {
            this._wsConnection.close();
            this._wsConnection = null;
            LogUtil.logInfo('WebSocket 연결 닫힘');
        }
        LogUtil.logInfo('LLMService 리소스 정리 완료');
    }
}


/***/ }),

/***/ "./src/core/llm/modelManager.ts":
/*!**************************************!*\
  !*** ./src/core/llm/modelManager.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModelManager: () => (/* binding */ ModelManager)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types_models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/models */ "./src/types/models.ts");


/**
 * 모델 관리 서비스
 * LLM 모델 설정, 검색 및 이벤트 관리를 담당합니다.
 */
class ModelManager {
    _context;
    // 현재 활성 모델
    _activeModel = _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI;
    // 설정 업데이트 중인지 여부를 추적하는 플래그
    _isUpdatingConfig = false;
    // 모델 변경 이벤트
    _onDidChangeModel = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    onDidChangeModel = this._onDidChangeModel.event;
    // 설정 변경 감지를 위한 구독
    _configListener;
    /**
     * 생성자
     * @param _context VSCode 확장 컨텍스트
     */
    constructor(_context) {
        this._context = _context;
        // 초기 설정 로드
        this._loadConfiguration();
        // 설정 변경 이벤트 처리
        this._configListener = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration('ape.llm.defaultModel') && !this._isUpdatingConfig) {
                this._loadConfiguration();
            }
        });
    }
    /**
     * 설정에서 모델 정보 로드
     */
    _loadConfiguration() {
        try {
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.llm');
            const configModel = config.get('defaultModel', _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI);
            // 유효한 모델인지 확인
            if (this._isValidModel(configModel)) {
                // 모델이 변경된 경우에만 이벤트 발생
                if (this._activeModel !== configModel) {
                    const oldModel = this._activeModel;
                    this._activeModel = configModel;
                    // 모델 변경 이벤트 발생
                    this._onDidChangeModel.fire({
                        oldModel,
                        newModel: this._activeModel
                    });
                }
            }
            else {
                console.warn(`유효하지 않은 모델: ${configModel}, 기본 모델 사용: ${_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI}`);
                // 활성 모델이 이미 기본 모델이 아닌 경우에만 업데이트
                if (this._activeModel !== _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI) {
                    const oldModel = this._activeModel;
                    this._activeModel = _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI;
                    // 설정 업데이트 플래그 설정
                    this._isUpdatingConfig = true;
                    // 설정 업데이트
                    Promise.resolve(config.update('defaultModel', _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global))
                        .then(() => {
                        // 모델 변경 이벤트 발생
                        this._onDidChangeModel.fire({
                            oldModel,
                            newModel: _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI
                        });
                        console.log(`기본 모델로 설정 업데이트됨: ${_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI}`);
                    })
                        .then(undefined, (err) => {
                        console.error('모델 설정 업데이트 실패:', err);
                    })
                        .finally(() => {
                        // 설정 업데이트 플래그 해제 (지연 설정)
                        setTimeout(() => {
                            this._isUpdatingConfig = false;
                        }, 100);
                    });
                }
            }
        }
        catch (error) {
            console.error('모델 설정 로드 중 오류:', error);
        }
    }
    /**
     * 모델 ID가 유효한지 확인
     * @param modelId 확인할 모델 ID
     * @returns 유효한 모델인지 여부
     */
    _isValidModel(modelId) {
        // 표준 모델 확인
        const isStandardModel = Object.values(_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId).includes(modelId);
        return isStandardModel;
    }
    /**
     * 현재 활성 모델 가져오기
     * @returns 현재 활성 모델
     */
    getActiveModel() {
        return this._activeModel;
    }
    /**
     * 활성 모델 변경
     * @param model 사용할 새 모델
     * @returns 성공 여부를 나타내는 Promise
     */
    async setActiveModel(model) {
        // 현재 모델과 동일하거나 이미 설정 업데이트 중이면 무시
        if (this._activeModel === model || this._isUpdatingConfig) {
            return false;
        }
        // 유효한 모델인지 확인
        if (!this._isValidModel(model)) {
            console.warn(`유효하지 않은 모델: ${model}, 현재 모델 유지: ${this._activeModel}`);
            return false;
        }
        try {
            // 설정 업데이트 플래그 설정
            this._isUpdatingConfig = true;
            // 이전 모델 저장
            const oldModel = this._activeModel;
            // 활성 모델 업데이트
            this._activeModel = model;
            // 설정에 변경 사항 저장
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.llm');
            await config.update('defaultModel', model, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global);
            // 모델 변경 이벤트 발생
            this._onDidChangeModel.fire({
                oldModel,
                newModel: model
            });
            console.log(`모델이 변경됨: ${oldModel} -> ${model}`);
            return true;
        }
        catch (error) {
            console.error('모델 설정 업데이트 실패:', error);
            return false;
        }
        finally {
            // 설정 업데이트 플래그 해제 (지연 설정)
            setTimeout(() => {
                this._isUpdatingConfig = false;
            }, 100);
        }
    }
    /**
     * 모든 사용 가능한 모델 가져오기
     * @returns 사용 가능한 모델 배열
     */
    getAvailableModels() {
        try {
            // 설정에 정의된 모델 목록 확인
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.llm');
            // inspect 결과가 다양한 형태일 수 있으므로 안전하게 처리
            const inspection = config.inspect('defaultModel');
            const configModels = inspection && typeof inspection === 'object' ?
                inspection.properties?.enum : undefined;
            // 설정에 정의된 모델 배열이 있으면 사용
            if (configModels && Array.isArray(configModels)) {
                // 내부망 모델 참조 제거
                return configModels.filter(model => model !== 'NARRNAS' &&
                    model !== 'LLAMA4-SCOUT' &&
                    model !== 'LLAMA4-MAVERICK');
            }
            // 표준 모델 반환 (내부망 모델 제외)
            return Object.values(_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId);
        }
        catch (error) {
            // 오류 발생 시 기본 모델 목록만 반환
            console.error('사용 가능한 모델 가져오기 오류:', error);
            return Object.values(_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId);
        }
    }
    /**
     * 모델 선택 명령어 등록 - 명령어는 CommandManager를 사용합니다
     * @deprecated 이 메서드는 더 이상 사용되지 않으며, 명령어 등록은 CommandManager에서 담당합니다.
     *
     * 참고: 이 메서드를 호출하면 아무 동작도 하지 않습니다.
     * extension.ts에서는 commandManager.registerCommands()만 호출합니다.
     */
    registerCommands() {
        console.log('경고: ModelManager.registerCommands()는 비활성화되었습니다. CommandManager를 사용하세요.');
        // 아무 동작도 하지 않음
    }
    /**
     * 모델 ID를 표시 이름으로 변환
     * @param modelId 모델 ID
     * @returns 사용자 친화적인 모델 표시 이름
     */
    getModelDisplayName(modelId) {
        // ModelDisplayNames에서 모델 표시 이름 가져오기 시도
        if (Object.values(_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId).includes(modelId)) {
            return _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelDisplayNames[modelId];
        }
        // 기존 하드코딩된 매핑 방식 사용 (이전 버전과의 호환성 유지)
        switch (modelId) {
            case 'openai/gpt-4.1-mini':
                return 'GPT-4.1 Mini';
            case 'anthropic/claude-3-haiku-20240307':
                return 'Claude 3 Haiku';
            case 'anthropic/claude-3-sonnet-20240229':
                return 'Claude 3 Sonnet';
            case 'perplexity/sonar-small-online':
                return 'Perplexity Sonar';
            case 'mistralai/mistral-large-latest':
                return 'Mistral Large';
            case 'google/gemma-7b-it':
                return 'Gemma 7B';
            default: {
                // 'provider/model-name' 형식에서 이름 추출
                const parts = modelId.split('/');
                if (parts.length > 1) {
                    // 더 읽기 쉬운 형식으로 모델 이름 변환
                    const modelName = parts[1].replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                    return modelName;
                }
                return modelId;
            }
        }
    }
    /**
     * 모델에 대한 설명 가져오기
     * @param model 모델 이름
     * @returns 모델 설명
     */
    getModelDescription(model) {
        // ModelDescriptions에서 모델 설명 가져오기 시도
        if (Object.values(_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId).includes(model)) {
            return _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelDescriptions[model];
        }
        // 기존 하드코딩된 매핑 방식 사용 (이전 버전과의 호환성 유지)
        switch (model) {
            case 'openai/gpt-4.1-mini':
                return '균형 잡힌 성능과 속도 (기본 모델)';
            case 'anthropic/claude-3-haiku-20240307':
                return '빠른 응답이 필요한 작업에 최적화';
            case 'anthropic/claude-3-sonnet-20240229':
                return '높은 품질과 효율적인 성능의 균형';
            case 'anthropic/claude-3-opus-20240229':
                return '최고 수준의 추론 및 복잡한 작업 처리';
            case 'google/gemini-pro':
                return 'Google의 고급 멀티모달 모델';
            case 'google/gemma-7b-it':
                return '경량 오픈소스 모델, 낮은 지연 시간';
            default:
                return '';
        }
    }
    /**
     * 리소스 해제
     */
    dispose() {
        // 이벤트 핸들러 해제
        this._onDidChangeModel.dispose();
        // 설정 변경 리스너 해제
        this._configListener.dispose();
    }
}


/***/ }),

/***/ "./src/core/llm/rulesIntegration.ts":
/*!******************************************!*\
  !*** ./src/core/llm/rulesIntegration.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyRulesContext: () => (/* binding */ applyRulesContext)
/* harmony export */ });
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/**
 * Rules 통합 모듈
 *
 * LLM 서비스에 Rules 기능을 통합하는 모듈입니다.
 * LLM 요청 시 Rules 시스템 프롬프트를 적용합니다.
 */

/**
 * Rules 시스템 프롬프트를 메시지에 적용
 * @param messages 메시지 배열
 * @param rulesService Rules 서비스
 * @param options Rules 옵션
 * @returns Rules가 적용된 메시지 배열
 */
function applyRulesContext(messages, rulesService, options) {
    // Rules 옵션이 명시적으로 false가 아니면 Rules 적용
    const includeRules = options?.includeRules !== false;
    if (!includeRules || !rulesService) {
        return messages;
    }
    try {
        // 활성화된 Rules가 있는지 확인
        const activeRules = rulesService.getActiveRules();
        if (activeRules.length === 0) {
            return messages;
        }
        // Rules 시스템 프롬프트 생성
        const rulesPrompt = rulesService.getRulesAsSystemPrompt();
        if (!rulesPrompt) {
            return messages;
        }
        // 기존 시스템 메시지가 있는지 확인
        const systemMessageIndex = messages.findIndex(msg => msg.role === _types_chat__WEBPACK_IMPORTED_MODULE_0__.MessageRole.System);
        if (systemMessageIndex >= 0) {
            // 기존 시스템 메시지가 있으면 Rules 프롬프트를 추가
            const updatedMessages = [...messages];
            const existingSystemMessage = updatedMessages[systemMessageIndex];
            updatedMessages[systemMessageIndex] = {
                ...existingSystemMessage,
                content: `${rulesPrompt}\n\n${existingSystemMessage.content}`
            };
            return updatedMessages;
        }
        else {
            // 시스템 메시지가 없으면 새 시스템 메시지를 추가
            return [
                {
                    id: `system_rules_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_0__.MessageRole.System,
                    content: rulesPrompt,
                    timestamp: new Date()
                },
                ...messages
            ];
        }
    }
    catch (error) {
        console.error('Rules 적용 중 오류 발생:', error);
        return messages;
    }
}


/***/ }),

/***/ "./src/core/llm/vaultIntegration.ts":
/*!******************************************!*\
  !*** ./src/core/llm/vaultIntegration.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyVaultContext: () => (/* binding */ applyVaultContext)
/* harmony export */ });
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/* harmony import */ var _services_vaultService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/vaultService */ "./src/core/services/vaultService.ts");
/**
 * VAULT 서비스와 LLM 서비스 통합 모듈
 *
 * VAULT 컨텍스트를 LLM 요청에 적용하는 기능을 제공합니다.
 */


/**
 * VAULT 컨텍스트를 LLM 요청에 적용
 * @param messages 원본 메시지 배열
 * @param vaultService VAULT 서비스 인스턴스
 * @param options VAULT 컨텍스트 적용 옵션
 * @returns VAULT 컨텍스트가 적용된 메시지 배열
 */
function applyVaultContext(messages, vaultService, options) {
    if (!options) {
        return messages;
    }
    // 조건에 맞는 아이템 검색
    const items = findRelevantVaultItems(vaultService, options);
    if (items.length === 0) {
        return messages;
    }
    // 컨텍스트 메시지 생성
    const contextMessages = createContextMessages(items);
    // 결합 방식에 따라 메시지 배열 업데이트
    return combineMessages(messages, contextMessages, options.combinationMode || 'prepend');
}
/**
 * 조건에 맞는 VAULT 아이템 찾기
 */
function findRelevantVaultItems(vaultService, options) {
    let result = [];
    // 1. 아이템 ID로 직접 조회 (가장 우선순위 높음)
    if (options.itemIds && options.itemIds.length > 0) {
        const allContexts = vaultService.getAllContexts();
        for (const context of allContexts) {
            const matchingItems = context.items.filter(item => options.itemIds.includes(item.id));
            result.push(...matchingItems);
        }
        // 아이템 ID가 지정된 경우 다른 필터는 적용하지 않음
        return result;
    }
    // 2. 컨텍스트 ID로 해당 컨텍스트의 모든 아이템 조회
    if (options.contextIds && options.contextIds.length > 0) {
        for (const contextId of options.contextIds) {
            const context = vaultService.getContextById(contextId);
            if (context) {
                result.push(...context.items);
            }
        }
        // 여기서 바로 반환하지 않고 아래 필터를 추가로 적용
    }
    // 3. 컨텍스트 유형으로 조회 (contextIds가 없는 경우)
    if ((!options.contextIds || options.contextIds.length === 0) &&
        options.contextTypes && options.contextTypes.length > 0) {
        for (const contextType of options.contextTypes) {
            const contexts = vaultService.getContextsByType(contextType);
            for (const context of contexts) {
                result.push(...context.items);
            }
        }
    }
    // 4. 아무 컨텍스트도 지정되지 않은 경우, 검색어나 태그가 있으면 전체 검색
    if ((!options.contextIds || options.contextIds.length === 0) &&
        (!options.contextTypes || options.contextTypes.length === 0) &&
        (options.searchQuery || (options.tags && options.tags.length > 0))) {
        result = vaultService.searchItems(options.searchQuery || '', { tags: options.tags });
    }
    // 추가 필터: 태그로 필터링 (이미 다른 기준으로 필터된 아이템들에 대해)
    if (options.tags && options.tags.length > 0) {
        result = result.filter(item => {
            if (!item.tags)
                return false;
            return options.tags.some(tag => item.tags.includes(tag));
        });
    }
    // 추가 필터: 검색어로 필터링 (이미 다른 기준으로 필터된 아이템들에 대해)
    if (options.searchQuery) {
        const query = options.searchQuery.toLowerCase();
        result = result.filter(item => item.name.toLowerCase().includes(query) ||
            (item.description && item.description.toLowerCase().includes(query)) ||
            item.content.toLowerCase().includes(query) ||
            (item.tags && item.tags.some(tag => tag.toLowerCase().includes(query))));
    }
    return result;
}
/**
 * VAULT 아이템들로부터 컨텍스트 메시지 생성
 */
function createContextMessages(items) {
    const contextMessages = [];
    // 각 아이템마다 메시지 생성
    for (const item of items) {
        // 아이템의 컨텍스트 유형에 따라 적절한 역할 지정
        let role = _types_chat__WEBPACK_IMPORTED_MODULE_0__.MessageRole.System;
        if (item.contextType === _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Personal ||
            item.contextType === _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Project ||
            item.contextType === _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Shared) {
            role = _types_chat__WEBPACK_IMPORTED_MODULE_0__.MessageRole.User;
        }
        contextMessages.push({
            id: `vault_${item.id}_${Date.now()}`,
            role,
            content: formatItemContent(item),
            timestamp: new Date(),
            metadata: {
                isVaultContext: true,
                vaultItemId: item.id,
                vaultContextType: item.contextType,
                vaultTags: item.tags
            }
        });
    }
    return contextMessages;
}
/**
 * VAULT 아이템 콘텐츠 포맷팅
 */
function formatItemContent(item) {
    // 기본적으로 콘텐츠를 그대로 사용
    const content = item.content;
    // 아이템 유형에 따라 특별한 포맷팅 적용
    if (item.contextType === _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.System) {
        // 시스템 프롬프트로 사용
        return content;
    }
    else if (item.contextType === _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Template) {
        // 템플릿은 그대로 사용
        return content;
    }
    else {
        // 다른 유형들은 메타데이터 추가
        const header = `VAULT 컨텍스트: ${item.name}\n`;
        const tags = item.tags?.length ? `태그: ${item.tags.join(', ')}\n` : '';
        return `${header}${tags}${content}`;
    }
}
/**
 * 원본 메시지와 컨텍스트 메시지 결합
 */
function combineMessages(originalMessages, contextMessages, mode) {
    if (mode === 'replace') {
        return contextMessages;
    }
    else if (mode === 'append') {
        return [...originalMessages, ...contextMessages];
    }
    else { // prepend (기본값)
        return [...contextMessages, ...originalMessages];
    }
}


/***/ }),

/***/ "./src/core/memory/memoryService.ts":
/*!******************************************!*\
  !*** ./src/core/memory/memoryService.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MemoryService: () => (/* binding */ MemoryService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs/promises */ "fs/promises");
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");





/**
 * Memory service manages storing and retrieving conversation data
 */
class MemoryService {
    _context;
    _sessions = new Map();
    _currentSessionId = null;
    _storageDir;
    _maxMessages;
    _sessionDuration;
    _configListener;
    /**
     * Creates a new MemoryService instance
     * @param _context The VSCode extension context
     */
    constructor(_context) {
        this._context = _context;
        // Initialize properties
        this._maxMessages = 30;
        this._sessionDuration = 240;
        // Create storage directory
        this._storageDir = path__WEBPACK_IMPORTED_MODULE_1__.join(_context.globalStoragePath, 'memory');
        this._ensureStorageDirectory();
        // Load configuration
        this._loadConfiguration();
        // Initialize with default session
        this._initializeDefaultSession();
        // Listen for configuration changes
        this._configListener = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.memory')) {
                this._loadConfiguration();
            }
        });
    }
    /**
     * Loads configuration from VSCode settings
     */
    _loadConfiguration() {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.memory');
        this._maxMessages = config.get('maxMessages', 30);
        this._sessionDuration = config.get('sessionDuration', 240); // minutes
    }
    /**
     * Creates storage directory if it doesn't exist
     */
    _ensureStorageDirectory() {
        if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(this._storageDir)) {
            (0,fs__WEBPACK_IMPORTED_MODULE_3__.mkdirSync)(this._storageDir, { recursive: true });
        }
    }
    /**
     * Initializes default session
     */
    async _initializeDefaultSession() {
        const defaultSessionId = 'default';
        try {
            // Check if default session exists
            const existingSession = await this._loadSession(defaultSessionId);
            if (existingSession) {
                this._sessions.set(defaultSessionId, existingSession);
            }
            else {
                // Create new default session
                const newSession = {
                    id: defaultSessionId,
                    name: 'Default Session',
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    messages: []
                };
                this._sessions.set(defaultSessionId, newSession);
                await this._saveSession(newSession);
            }
            this._currentSessionId = defaultSessionId;
        }
        catch (error) {
            console.error('Failed to initialize default session:', error);
            // Create an in-memory default session as fallback
            this._sessions.set(defaultSessionId, {
                id: defaultSessionId,
                name: 'Default Session',
                createdAt: new Date(),
                updatedAt: new Date(),
                messages: []
            });
            this._currentSessionId = defaultSessionId;
        }
    }
    /**
     * Gets the current session ID
     * @returns Current session ID or null if no session is active
     */
    getCurrentSessionId() {
        return this._currentSessionId;
    }
    /**
     * Gets the current session
     * @returns Current session or null if no session is active
     */
    getCurrentSession() {
        if (!this._currentSessionId) {
            return null;
        }
        return this._sessions.get(this._currentSessionId) || null;
    }
    /**
     * Gets messages from the current session
     * @returns Promise that resolves to a MemoryResult containing messages
     */
    async getMessages() {
        try {
            if (!this._currentSessionId) {
                return { success: true, data: [] };
            }
            const session = this._sessions.get(this._currentSessionId);
            return {
                success: true,
                data: session ? session.messages : []
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Adds a message to the current session
     * @param message Message to add
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async addMessage(message) {
        try {
            if (!this._currentSessionId) {
                return {
                    success: false,
                    error: new Error('No active session')
                };
            }
            const session = this._sessions.get(this._currentSessionId);
            if (session) {
                // 기존 메시지가 있는지 확인
                const existingIndex = session.messages.findIndex(m => m.id === message.id);
                if (existingIndex >= 0) {
                    // 기존 메시지 업데이트
                    session.messages[existingIndex] = message;
                }
                else {
                    // 새 메시지 추가
                    session.messages.push(message);
                }
                // Limit messages if needed
                if (this._maxMessages > 0 && session.messages.length > this._maxMessages) {
                    // Keep the most recent messages
                    session.messages = session.messages.slice(-this._maxMessages);
                }
                // Update session timestamp
                session.updatedAt = new Date();
                // Save session
                await this._saveSession(session);
                return { success: true };
            }
            else {
                return {
                    success: false,
                    error: new Error('Session not found')
                };
            }
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * 특정 메시지를 업데이트
     * @param message 업데이트할 메시지
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async updateMessage(message) {
        try {
            if (!this._currentSessionId) {
                return {
                    success: false,
                    error: new Error('No active session')
                };
            }
            const session = this._sessions.get(this._currentSessionId);
            if (session) {
                // 기존 메시지 찾기
                const index = session.messages.findIndex(m => m.id === message.id);
                if (index === -1) {
                    return {
                        success: false,
                        error: new Error(`Message with ID ${message.id} not found`)
                    };
                }
                // 메시지 업데이트
                session.messages[index] = message;
                // Update session timestamp
                session.updatedAt = new Date();
                // Save session
                await this._saveSession(session);
                return { success: true };
            }
            else {
                return {
                    success: false,
                    error: new Error('Session not found')
                };
            }
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Saves messages to the current session
     * @param messages Messages to save
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async saveMessages(messages) {
        try {
            if (!this._currentSessionId) {
                return {
                    success: false,
                    error: new Error('No active session')
                };
            }
            const session = this._sessions.get(this._currentSessionId);
            if (session) {
                // Replace messages in the session
                session.messages = messages;
                // Limit messages if needed
                if (this._maxMessages > 0 && session.messages.length > this._maxMessages) {
                    // Keep the most recent messages
                    session.messages = session.messages.slice(-this._maxMessages);
                }
                // Update session timestamp
                session.updatedAt = new Date();
                // Save session
                await this._saveSession(session);
                return { success: true };
            }
            else {
                return {
                    success: false,
                    error: new Error('Session not found')
                };
            }
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Creates a new chat session
     * @param name Session name
     * @param options Optional session options
     * @returns Promise that resolves to a MemoryResult containing the session ID
     */
    async createSession(name, options) {
        try {
            const sessionId = `session_${Date.now()}`;
            const newSession = {
                id: sessionId,
                name,
                createdAt: new Date(),
                updatedAt: new Date(),
                messages: [],
                metadata: options?.metadata
            };
            this._sessions.set(sessionId, newSession);
            await this._saveSession(newSession);
            return {
                success: true,
                data: sessionId
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Switches to a different session
     * @param sessionId Session ID to switch to
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async switchSession(sessionId) {
        try {
            // If session is not loaded, try to load it
            if (!this._sessions.has(sessionId)) {
                const session = await this._loadSession(sessionId);
                if (!session) {
                    return {
                        success: false,
                        error: new Error(`Session ${sessionId} not found`)
                    };
                }
                this._sessions.set(sessionId, session);
            }
            this._currentSessionId = sessionId;
            return {
                success: true,
                data: true
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Gets all available sessions
     * @returns Promise that resolves to a MemoryResult containing session summaries
     */
    async getSessions() {
        try {
            // Load all sessions from storage
            await this._loadAllSessions();
            const sessionSummaries = Array.from(this._sessions.values()).map(session => ({
                id: session.id,
                name: session.name,
                createdAt: session.createdAt,
                updatedAt: session.updatedAt,
                messageCount: session.messages.length,
                summary: session.metadata?.summary || this._summarizeConversation(session.messages)
            }));
            return {
                success: true,
                data: sessionSummaries
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Gets a specific session by ID
     * @param sessionId Session ID to get
     * @returns Promise that resolves to a MemoryResult containing the session
     */
    async getSession(sessionId) {
        try {
            // If session is not loaded, try to load it
            if (!this._sessions.has(sessionId)) {
                const session = await this._loadSession(sessionId);
                if (!session) {
                    return {
                        success: false,
                        error: new Error(`Session ${sessionId} not found`)
                    };
                }
                this._sessions.set(sessionId, session);
            }
            const session = this._sessions.get(sessionId);
            if (!session) {
                return {
                    success: false,
                    error: new Error(`Session ${sessionId} not found`)
                };
            }
            return {
                success: true,
                data: session
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Updates a session's properties (not including messages)
     * @param sessionId Session ID to update
     * @param updates Object containing updates to apply
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async updateSession(sessionId, updates) {
        try {
            const sessionResult = await this.getSession(sessionId);
            if (!sessionResult.success || !sessionResult.data) {
                return {
                    success: false,
                    error: sessionResult.error || new Error(`Session ${sessionId} not found`)
                };
            }
            const session = sessionResult.data;
            // Apply updates
            if (updates.name) {
                session.name = updates.name;
            }
            if (updates.metadata) {
                session.metadata = {
                    ...session.metadata,
                    ...updates.metadata
                };
            }
            // Update timestamp
            session.updatedAt = new Date();
            // Save session
            await this._saveSession(session);
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Deletes a session
     * @param sessionId Session ID to delete
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async deleteSession(sessionId) {
        try {
            // Don't allow deleting the default session
            if (sessionId === 'default') {
                return {
                    success: false,
                    error: new Error('Cannot delete the default session')
                };
            }
            // Remove from memory
            this._sessions.delete(sessionId);
            // If this was the current session, switch to default
            if (this._currentSessionId === sessionId) {
                await this.switchSession('default');
            }
            // Remove from disk
            const sessionFile = path__WEBPACK_IMPORTED_MODULE_1__.join(this._storageDir, `${sessionId}.json`);
            if ((0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(sessionFile)) {
                await fs_promises__WEBPACK_IMPORTED_MODULE_2__.unlink(sessionFile);
            }
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Clears messages from the current session
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async clearMessages() {
        try {
            if (!this._currentSessionId) {
                return {
                    success: false,
                    error: new Error('No active session')
                };
            }
            const session = this._sessions.get(this._currentSessionId);
            if (session) {
                session.messages = [];
                session.updatedAt = new Date();
                await this._saveSession(session);
                return { success: true };
            }
            else {
                return {
                    success: false,
                    error: new Error('Session not found')
                };
            }
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Archives old sessions based on session duration configuration
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async archiveOldSessions() {
        try {
            // Load all sessions from storage
            await this._loadAllSessions();
            const now = new Date();
            const archiveThreshold = new Date(now.getTime() - this._sessionDuration * 60 * 1000);
            let archivedCount = 0;
            for (const [sessionId, session] of this._sessions.entries()) {
                // Skip the default session and current session
                if (sessionId === 'default' || sessionId === this._currentSessionId) {
                    continue;
                }
                // Archive sessions older than the threshold
                if (session.updatedAt < archiveThreshold) {
                    // Create an archive copy
                    const archiveDir = path__WEBPACK_IMPORTED_MODULE_1__.join(this._storageDir, 'archive');
                    if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(archiveDir)) {
                        (0,fs__WEBPACK_IMPORTED_MODULE_3__.mkdirSync)(archiveDir, { recursive: true });
                    }
                    // Generate summary if not already present
                    if (!session.metadata) {
                        session.metadata = {};
                    }
                    if (!session.metadata.summary) {
                        session.metadata.summary = this._summarizeConversation(session.messages);
                    }
                    // Save to archive
                    const archiveFile = path__WEBPACK_IMPORTED_MODULE_1__.join(archiveDir, `${session.id}_${Math.floor(session.updatedAt.getTime() / 1000)}.json`);
                    await fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile(archiveFile, JSON.stringify(session, null, 2), 'utf-8');
                    // Remove from active sessions
                    this._sessions.delete(sessionId);
                    // Remove from disk
                    const sessionFile = path__WEBPACK_IMPORTED_MODULE_1__.join(this._storageDir, `${sessionId}.json`);
                    if ((0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(sessionFile)) {
                        await fs_promises__WEBPACK_IMPORTED_MODULE_2__.unlink(sessionFile);
                    }
                    archivedCount++;
                }
            }
            return {
                success: true,
                data: archivedCount
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Exports a session to a file
     * @param sessionId Session ID to export
     * @param filePath File path to export to
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async exportSession(sessionId, filePath) {
        try {
            const sessionResult = await this.getSession(sessionId);
            if (!sessionResult.success || !sessionResult.data) {
                return {
                    success: false,
                    error: sessionResult.error || new Error(`Session ${sessionId} not found`)
                };
            }
            const session = sessionResult.data;
            // Export to file
            await fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile(filePath, JSON.stringify(session, null, 2), 'utf-8');
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Imports a session from a file
     * @param filePath File path to import from
     * @param setAsCurrent Whether to set the imported session as current
     * @returns Promise that resolves to a MemoryResult containing the session ID
     */
    async importSession(filePath, setAsCurrent = false) {
        try {
            // Read and parse file
            const data = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.readFile(filePath, 'utf-8');
            const sessionData = JSON.parse(data);
            // Validate session data
            if (!sessionData.id || !sessionData.name || !sessionData.createdAt || !sessionData.updatedAt) {
                return {
                    success: false,
                    error: new Error('Invalid session data')
                };
            }
            // Convert date strings to Date objects
            sessionData.createdAt = new Date(sessionData.createdAt);
            sessionData.updatedAt = new Date(sessionData.updatedAt);
            if (sessionData.messages) {
                sessionData.messages.forEach((message) => {
                    message.timestamp = new Date(message.timestamp);
                });
            }
            // Generate a new ID to avoid conflicts
            const originalId = sessionData.id;
            sessionData.id = `imported_${Date.now()}`;
            // Add a note about the import
            if (!sessionData.metadata) {
                sessionData.metadata = {};
            }
            sessionData.metadata.importedFrom = originalId;
            sessionData.metadata.importedAt = new Date();
            // Save the session
            this._sessions.set(sessionData.id, sessionData);
            await this._saveSession(sessionData);
            // Switch to the imported session if requested
            if (setAsCurrent) {
                this._currentSessionId = sessionData.id;
            }
            return {
                success: true,
                data: sessionData.id
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Loads a specific session from storage
     * @param sessionId Session ID to load
     * @returns Promise that resolves to a ChatSession or null
     */
    async _loadSession(sessionId) {
        const sessionFile = path__WEBPACK_IMPORTED_MODULE_1__.join(this._storageDir, `${sessionId}.json`);
        try {
            if ((0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(sessionFile)) {
                const data = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.readFile(sessionFile, 'utf-8');
                const sessionData = JSON.parse(data);
                // Convert date strings back to Date objects
                sessionData.createdAt = new Date(sessionData.createdAt);
                sessionData.updatedAt = new Date(sessionData.updatedAt);
                if (sessionData.messages) {
                    sessionData.messages.forEach((message) => {
                        message.timestamp = new Date(message.timestamp);
                    });
                }
                return sessionData;
            }
        }
        catch (error) {
            console.error(`Error loading session ${sessionId}:`, error);
        }
        return null;
    }
    /**
     * Saves a session to storage
     * @param session Session to save
     * @returns Promise that resolves when the session is saved
     */
    async _saveSession(session) {
        const sessionFile = path__WEBPACK_IMPORTED_MODULE_1__.join(this._storageDir, `${session.id}.json`);
        try {
            const sessionJson = JSON.stringify(session, null, 2);
            await fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile(sessionFile, sessionJson, 'utf-8');
        }
        catch (error) {
            console.error(`Error saving session ${session.id}:`, error);
            throw error;
        }
    }
    /**
     * Loads all sessions from storage
     * @returns Promise that resolves when all sessions are loaded
     */
    async _loadAllSessions() {
        try {
            if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(this._storageDir)) {
                return;
            }
            const files = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.readdir(this._storageDir);
            for (const file of files) {
                if (file.endsWith('.json')) {
                    const sessionId = path__WEBPACK_IMPORTED_MODULE_1__.basename(file, '.json');
                    // Don't reload sessions we already have in memory
                    if (!this._sessions.has(sessionId)) {
                        const session = await this._loadSession(sessionId);
                        if (session) {
                            this._sessions.set(sessionId, session);
                        }
                    }
                }
            }
        }
        catch (error) {
            console.error('Error loading sessions:', error);
            throw error;
        }
    }
    /**
     * Summarizes a conversation for long-term memory
     * @param messages Messages to summarize
     * @returns Summary of the conversation
     */
    _summarizeConversation(messages) {
        if (messages.length === 0) {
            return 'Empty conversation';
        }
        // Find the first user message
        const firstUserMessage = messages.find(m => m.role === _types_chat__WEBPACK_IMPORTED_MODULE_4__.MessageRole.User);
        if (!firstUserMessage) {
            return `Conversation with ${messages.length} messages`;
        }
        // Get first user message content
        const content = firstUserMessage.content;
        const truncatedContent = content.substring(0, 50) + (content.length > 50 ? '...' : '');
        // Count messages by role
        const userMessages = messages.filter(m => m.role === _types_chat__WEBPACK_IMPORTED_MODULE_4__.MessageRole.User).length;
        const assistantMessages = messages.filter(m => m.role === _types_chat__WEBPACK_IMPORTED_MODULE_4__.MessageRole.Assistant).length;
        return `Conversation with ${userMessages} user and ${assistantMessages} assistant messages. Started with: "${truncatedContent}"`;
    }
    /**
     * Disposes resources
     */
    dispose() {
        // Dispose configuration change listener
        this._configListener.dispose();
        // Save any unsaved sessions
        for (const session of this._sessions.values()) {
            this._saveSession(session).catch(error => {
                console.error(`Error saving session ${session.id} during disposal:`, error);
            });
        }
    }
}


/***/ }),

/***/ "./src/core/services/jiraService.ts":
/*!******************************************!*\
  !*** ./src/core/services/jiraService.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JiraErrorType: () => (/* binding */ JiraErrorType),
/* harmony export */   JiraIssueStatus: () => (/* binding */ JiraIssueStatus),
/* harmony export */   JiraService: () => (/* binding */ JiraService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ "./node_modules/axios/lib/axios.js");
/* harmony import */ var _serviceConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serviceConfig */ "./src/core/services/serviceConfig.ts");
/* harmony import */ var _serviceError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serviceError */ "./src/core/services/serviceError.ts");
/* harmony import */ var _serviceResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serviceResult */ "./src/core/services/serviceResult.ts");
/**
 * Jira 서비스
 *
 * Jira API를 사용하여 이슈 정보를 조회하고 관리하는 서비스입니다.
 * 내부망 Jira 서버와 통신하며, 실제 서버를 사용할 수 없는 경우 모의(Mock) 데이터를 사용합니다.
 */





/**
 * Jira 이슈 상태 유형
 */
var JiraIssueStatus;
(function (JiraIssueStatus) {
    JiraIssueStatus["ToDo"] = "todo";
    JiraIssueStatus["InProgress"] = "in-progress";
    JiraIssueStatus["Done"] = "done";
    JiraIssueStatus["InReview"] = "in-review";
    JiraIssueStatus["Blocked"] = "blocked";
    JiraIssueStatus["Unknown"] = "unknown";
})(JiraIssueStatus || (JiraIssueStatus = {}));
/**
 * Jira 서비스 오류 유형
 */
var JiraErrorType;
(function (JiraErrorType) {
    JiraErrorType["ConnectionFailed"] = "connection_failed";
    JiraErrorType["AuthenticationFailed"] = "authentication_failed";
    JiraErrorType["PermissionDenied"] = "permission_denied";
    JiraErrorType["ResourceNotFound"] = "resource_not_found";
    JiraErrorType["ServerError"] = "server_error";
    JiraErrorType["InvalidRequest"] = "invalid_request";
    JiraErrorType["Unknown"] = "unknown";
})(JiraErrorType || (JiraErrorType = {}));
/**
 * Jira 서비스 클래스
 */
class JiraService {
    context;
    serviceConfigManager;
    baseUrl = '';
    apiPath = '/rest/api/2';
    username = '';
    password = '';
    token = '';
    authType = _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic;
    useMock = true;
    disposables = [];
    _lastError = null;
    /**
     * Jira 서비스 생성자
     * @param context VSCode 확장 컨텍스트
     * @param serviceConfigManager 서비스 설정 관리자 (선택적)
     */
    constructor(context, serviceConfigManager) {
        this.context = context;
        this.serviceConfigManager = serviceConfigManager;
        // 설정 로드
        this.loadConfiguration();
        // 설정 변경 감지
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.jira')) {
                this.loadConfiguration();
            }
        }));
    }
    /**
     * 설정 다시 로드
     */
    loadConfiguration() {
        if (this.serviceConfigManager) {
            // 서비스 설정 관리자를 사용하여 설정 로드
            const config = this.serviceConfigManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira);
            this.baseUrl = config.url;
            this.authType = config.authType;
            this.username = config.username || '';
            this.password = config.password || '';
            this.token = config.token || '';
            this.useMock = config.useMock;
            // 추가 파라미터에서 API 경로 가져오기
            const additionalParams = config.additionalParams || {};
            this.apiPath = additionalParams.apiPath || '/rest/api/2';
        }
        else {
            // 직접 VSCode 설정에서 로드
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.jira');
            this.baseUrl = config.get('url', '');
            this.apiPath = config.get('apiPath', '/rest/api/2');
            this.username = config.get('username', '');
            this.password = config.get('password', '');
            this.token = config.get('token', '');
            this.authType = config.get('authType', _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic);
            this.useMock = config.get('useMock', false);
        }
        // 필수 설정이 없으면 모의 모드 강제 활성화
        if (!this.baseUrl || (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) ||
            (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token)) {
            this.useMock = true;
        }
    }
    /**
     * 마지막 오류 가져오기
     */
    get lastError() {
        return this._lastError;
    }
    /**
     * 이슈 조회
     * @param issueKey Jira 이슈 키 (예: 'APE-123')
     * @returns Jira 이슈 정보를 포함한 서비스 결과
     */
    async getIssue(issueKey) {
        try {
            // 마지막 오류 초기화
            this._lastError = null;
            // 모의 모드인 경우 모의 데이터 반환
            if (this.useMock) {
                const mockIssue = this.getMockIssue(issueKey);
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(mockIssue);
            }
            // 필수 설정 확인
            if (!this.baseUrl) {
                throw new Error('Jira 서버 URL이 설정되지 않았습니다. 설정을 확인하세요.');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira 인증 정보가 설정되지 않았습니다. 사용자 이름과 비밀번호를 확인하세요.');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('Jira 인증 토큰이 설정되지 않았습니다. 토큰 설정을 확인하세요.');
            }
            // Jira REST API 엔드포인트
            const url = `${this.baseUrl}${this.apiPath}/issue/${issueKey}`;
            // API 요청 설정
            const config = {};
            // 인증 유형에 따른 설정
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API 요청 실행
            const response = await axios__WEBPACK_IMPORTED_MODULE_4__["default"].get(url, config);
            // 응답 데이터 파싱
            const issue = this.parseJiraIssue(response.data);
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(issue);
        }
        catch (error) {
            // 오류 처리 및 분류
            this.handleError(error, issueKey);
            // 오류 로그
            console.error(`Jira 이슈 조회 실패 (${issueKey}):`, error);
            // 오류 결과 생성
            let serviceError;
            if (this._lastError) {
                // JiraError를 IServiceError로 변환
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createErrorResult)(serviceError);
        }
    }
    /**
     * Jira 이슈 생성
     * @param issueData 이슈 데이터
     * @returns 생성된 이슈 정보를 포함한 서비스 결과
     */
    async createIssue(issueData) {
        try {
            // 마지막 오류 초기화
            this._lastError = null;
            // 모의 모드인 경우 모의 데이터 반환
            if (this.useMock) {
                const mockIssue = this.getMockIssue(`${issueData.projectKey}-${Math.floor(Math.random() * 1000)}`);
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(mockIssue);
            }
            // 필수 설정 확인
            if (!this.baseUrl) {
                throw new Error('Jira 서버 URL이 설정되지 않았습니다. 설정을 확인하세요.');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira 인증 정보가 설정되지 않았습니다. 사용자 이름과 비밀번호를 확인하세요.');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('Jira 인증 토큰이 설정되지 않았습니다. 토큰 설정을 확인하세요.');
            }
            // Jira REST API 엔드포인트
            const url = `${this.baseUrl}${this.apiPath}/issue`;
            // 필수 필드 확인
            if (!issueData.projectKey) {
                throw new Error('Jira 프로젝트 키가 필요합니다.');
            }
            if (!issueData.issueType) {
                throw new Error('Jira 이슈 유형이 필요합니다.');
            }
            if (!issueData.summary) {
                throw new Error('Jira 이슈 요약이 필요합니다.');
            }
            // 요청 데이터 구성
            const requestData = {
                fields: {
                    project: {
                        key: issueData.projectKey
                    },
                    issuetype: {
                        name: issueData.issueType
                    },
                    summary: issueData.summary,
                    description: issueData.description || '',
                    assignee: issueData.assignee ? { name: issueData.assignee } : undefined,
                    components: issueData.components?.map(name => ({ name })),
                    labels: issueData.labels,
                    duedate: issueData.dueDate
                }
            };
            // API 요청 설정
            const config = {};
            // 인증 유형에 따른 설정
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API 요청 실행
            const response = await axios__WEBPACK_IMPORTED_MODULE_4__["default"].post(url, requestData, config);
            // 생성된 이슈 ID로 이슈 조회
            const issueKey = response.data.key;
            const issueResult = await this.getIssue(issueKey);
            if (issueResult.success && issueResult.data) {
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(issueResult.data);
            }
            else {
                // 이슈를 찾지 못한 경우 기본 정보만 반환
                const basicIssue = {
                    id: '0',
                    key: issueKey,
                    summary: issueData.summary,
                    description: issueData.description || '',
                    status: JiraIssueStatus.ToDo,
                    created: new Date().toISOString(),
                    updated: new Date().toISOString()
                };
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(basicIssue);
            }
        }
        catch (error) {
            // 오류 처리 및 분류
            this.handleError(error);
            // 오류 로그
            console.error('Jira 이슈 생성 실패:', error);
            // 오류 결과 생성
            let serviceError;
            if (this._lastError) {
                // JiraError를 IServiceError로 변환
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createErrorResult)(serviceError);
        }
    }
    /**
     * Jira 이슈 상태 변경
     * @param issueKey Jira 이슈 키 (예: 'APE-123')
     * @param status 변경할 상태
     * @returns 성공 여부를 포함한 서비스 결과
     */
    async updateIssueStatus(issueKey, status) {
        try {
            // 마지막 오류 초기화
            this._lastError = null;
            // 모의 모드인 경우 성공 반환
            if (this.useMock) {
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(true);
            }
            // 필수 설정 확인
            if (!this.baseUrl) {
                throw new Error('Jira 서버 URL이 설정되지 않았습니다. 설정을 확인하세요.');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira 인증 정보가 설정되지 않았습니다. 사용자 이름과 비밀번호를 확인하세요.');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('Jira 인증 토큰이 설정되지 않았습니다. 토큰 설정을 확인하세요.');
            }
            // 이슈 전환에 필요한 트랜지션 ID 조회
            const transitionId = await this.getTransitionIdForStatus(issueKey, status);
            if (!transitionId) {
                throw new Error(`이슈 ${issueKey}에 대해 상태 '${status}'로의 전환이 허용되지 않습니다.`);
            }
            // Jira REST API 엔드포인트
            const url = `${this.baseUrl}${this.apiPath}/issue/${issueKey}/transitions`;
            // 요청 데이터 구성
            const requestData = {
                transition: {
                    id: transitionId
                }
            };
            // API 요청 설정
            const config = {};
            // 인증 유형에 따른 설정
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API 요청 실행
            await axios__WEBPACK_IMPORTED_MODULE_4__["default"].post(url, requestData, config);
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(true);
        }
        catch (error) {
            // 오류 처리 및 분류
            this.handleError(error, issueKey);
            // 오류 로그
            console.error(`Jira 이슈 상태 변경 실패 (${issueKey}):`, error);
            // 오류 결과 생성
            let serviceError;
            if (this._lastError) {
                // JiraError를 IServiceError로 변환
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createErrorResult)(serviceError);
        }
    }
    /**
     * Jira 이슈 검색
     * @param criteria 검색 조건
     * @returns 검색 결과를 포함한 서비스 결과
     */
    async searchIssues(criteria) {
        try {
            // 마지막 오류 초기화
            this._lastError = null;
            // 기본값 설정
            const maxResults = criteria.maxResults || 50;
            const startAt = criteria.startAt || 0;
            // 모의 모드인 경우 모의 데이터 반환
            if (this.useMock) {
                const mockResult = this.getMockSearchResult(criteria);
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(mockResult);
            }
            // 필수 설정 확인
            if (!this.baseUrl) {
                throw new Error('Jira 서버 URL이 설정되지 않았습니다. 설정을 확인하세요.');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira 인증 정보가 설정되지 않았습니다. 사용자 이름과 비밀번호를 확인하세요.');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('Jira 인증 토큰이 설정되지 않았습니다. 토큰 설정을 확인하세요.');
            }
            // JQL 검색 쿼리 구성
            const jql = this.buildJqlQuery(criteria);
            // Jira REST API 엔드포인트
            const url = `${this.baseUrl}${this.apiPath}/search`;
            // 요청 데이터 구성
            const requestData = {
                jql,
                startAt,
                maxResults,
                fields: [
                    'summary',
                    'description',
                    'status',
                    'assignee',
                    'reporter',
                    'created',
                    'updated',
                    'duedate',
                    'priority',
                    'labels',
                    'components',
                    'project'
                ]
            };
            // API 요청 설정
            const config = {
                params: {
                    jql,
                    startAt,
                    maxResults,
                    fields: 'summary,description,status,assignee,reporter,created,updated,duedate,priority,labels,components,project'
                }
            };
            // 인증 유형에 따른 설정
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API 요청 실행
            const response = await axios__WEBPACK_IMPORTED_MODULE_4__["default"].get(url, config);
            // 응답 데이터 파싱
            const data = response.data;
            const issues = (data.issues || []).map((issue) => this.parseJiraIssue(issue));
            const result = {
                issues,
                total: data.total || 0,
                startAt: data.startAt || 0,
                maxResults: data.maxResults || maxResults,
                hasMore: (data.startAt + issues.length) < data.total
            };
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(result);
        }
        catch (error) {
            // 오류 처리 및 분류
            this.handleError(error);
            // 오류 로그
            console.error('Jira 이슈 검색 실패:', error);
            // 오류 결과 생성
            let serviceError;
            if (this._lastError) {
                // JiraError를 IServiceError로 변환
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createErrorResult)(serviceError);
        }
    }
    /**
     * JQL 검색 쿼리 구성
     * @param criteria 검색 조건
     * @returns JQL 쿼리 문자열
     * @private
     */
    buildJqlQuery(criteria) {
        const conditions = [];
        // 프로젝트 필터
        if (criteria.projectKey) {
            conditions.push(`project = "${criteria.projectKey}"`);
        }
        // 담당자 필터
        if (criteria.assignee) {
            conditions.push(`assignee = "${criteria.assignee}"`);
        }
        // 보고자 필터
        if (criteria.reporter) {
            conditions.push(`reporter = "${criteria.reporter}"`);
        }
        // 상태 필터
        if (criteria.status) {
            if (Array.isArray(criteria.status)) {
                if (criteria.status.length > 0) {
                    const statuses = criteria.status.map(s => `"${s}"`).join(',');
                    conditions.push(`status IN (${statuses})`);
                }
            }
            else {
                conditions.push(`status = "${criteria.status}"`);
            }
        }
        // 라벨 필터
        if (criteria.labels && criteria.labels.length > 0) {
            const labelConditions = criteria.labels.map(label => `labels = "${label}"`).join(' AND ');
            conditions.push(`(${labelConditions})`);
        }
        // 컴포넌트 필터
        if (criteria.components && criteria.components.length > 0) {
            const componentConditions = criteria.components.map(component => `component = "${component}"`).join(' OR ');
            conditions.push(`(${componentConditions})`);
        }
        // 텍스트 검색 필터
        if (criteria.text) {
            conditions.push(`(summary ~ "${criteria.text}" OR description ~ "${criteria.text}")`);
        }
        // 생성일 필터
        if (criteria.createdAfter) {
            conditions.push(`created >= "${criteria.createdAfter}"`);
        }
        // 수정일 필터
        if (criteria.updatedAfter) {
            conditions.push(`updated >= "${criteria.updatedAfter}"`);
        }
        // 조건이 없으면 모든 이슈 검색
        if (conditions.length === 0) {
            return 'order by created DESC';
        }
        // 최종 JQL 쿼리 반환
        return `${conditions.join(' AND ')} order by created DESC`;
    }
    /**
     * 모의 검색 결과 생성
     * @param criteria 검색 조건
     * @returns 모의 검색 결과
     * @private
     */
    getMockSearchResult(criteria) {
        // 최대 결과 수 및 시작 위치 설정
        const maxResults = criteria.maxResults || 50;
        const startAt = criteria.startAt || 0;
        // 모의 이슈 생성
        const mockIssues = [];
        const totalIssues = 100; // 모의 데이터의 전체 이슈 수
        // 실제로 반환할 이슈 수 계산
        const count = Math.min(maxResults, totalIssues - startAt);
        // 프로젝트 키 가져오기 (기본값: 'APE')
        const projectKey = criteria.projectKey || 'APE';
        // 모의 이슈 생성
        for (let i = 0; i < count; i++) {
            const issueNumber = startAt + i + 1;
            const issueKey = `${projectKey}-${issueNumber}`;
            const mockIssue = this.getMockIssue(issueKey);
            // 검색 조건에 따른 필터링
            let includeIssue = true;
            // 상태 필터
            if (criteria.status) {
                if (Array.isArray(criteria.status)) {
                    includeIssue = criteria.status.includes(mockIssue.status);
                }
                else {
                    includeIssue = mockIssue.status === criteria.status;
                }
            }
            // 텍스트 검색 필터
            if (includeIssue && criteria.text) {
                const text = criteria.text.toLowerCase();
                includeIssue =
                    mockIssue.summary.toLowerCase().includes(text) ||
                        (mockIssue.description?.toLowerCase().includes(text) || false);
            }
            // 이슈가 필터 조건에 부합하면 결과에 추가
            if (includeIssue) {
                // 요청된 검색 조건에 맞추어 이슈 속성 수정
                if (criteria.assignee) {
                    mockIssue.assignee = {
                        name: criteria.assignee,
                        displayName: `${criteria.assignee} 사용자`
                    };
                }
                // 프로젝트 정보 추가
                mockIssue.project = {
                    id: '10000',
                    key: projectKey,
                    name: `${projectKey} 프로젝트`
                };
                mockIssues.push(mockIssue);
            }
        }
        return {
            issues: mockIssues,
            total: totalIssues,
            startAt,
            maxResults,
            hasMore: (startAt + count) < totalIssues
        };
    }
    /**
     * Jira 프로젝트 요약 조회
     * @param projectKey 프로젝트 키 (선택적, 입력되지 않으면 모든 프로젝트 요약)
     * @param maxRecentIssues 최근 이슈 목록 최대 수 (기본값: 5)
     * @param maxOldIssues 오래된 미해결 이슈 목록 최대 수 (기본값: 5)
     * @returns Jira 요약 정보를 포함한 서비스 결과
     */
    async getProjectSummary(projectKey, maxRecentIssues = 5, maxOldIssues = 5) {
        try {
            // 마지막 오류 초기화
            this._lastError = null;
            // 모의 모드인 경우 모의 데이터 반환
            if (this.useMock) {
                const mockSummary = this.getMockSummary(projectKey, maxRecentIssues, maxOldIssues);
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(mockSummary);
            }
            // 필수 설정 확인
            if (!this.baseUrl) {
                throw new Error('Jira 서버 URL이 설정되지 않았습니다. 설정을 확인하세요.');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira 인증 정보가 설정되지 않았습니다. 사용자 이름과 비밀번호를 확인하세요.');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('Jira 인증 토큰이 설정되지 않았습니다. 토큰 설정을 확인하세요.');
            }
            // 프로젝트 내 모든 이슈 조회
            const searchCriteria = {
                projectKey: projectKey,
                maxResults: 1000 // 충분히 큰 값으로 설정
            };
            const searchResult = await this.searchIssues(searchCriteria);
            if (!searchResult.success || !searchResult.data) {
                throw new Error('이슈 검색에 실패했습니다');
            }
            const issues = searchResult.data.issues;
            // 전체 이슈 수
            const totalIssues = issues.length;
            // 상태별 이슈 수 계산
            const issuesByStatus = {
                [JiraIssueStatus.ToDo]: 0,
                [JiraIssueStatus.InProgress]: 0,
                [JiraIssueStatus.InReview]: 0,
                [JiraIssueStatus.Done]: 0,
                [JiraIssueStatus.Blocked]: 0,
                [JiraIssueStatus.Unknown]: 0
            };
            // 담당자별 이슈 수 계산
            const issuesByAssignee = {};
            // 우선순위별 이슈 수 계산
            const issuesByPriority = {};
            // 최근 이슈 및 오래된 미해결 이슈 목록 준비
            let recentIssues = [];
            const unresolvedIssues = [];
            // 이슈 해결 시간 계산을 위한 준비
            let resolvedCount = 0;
            let totalResolutionTime = 0;
            // 모든 이슈를 반복하며 통계 수집
            for (const issue of issues) {
                // 상태별 이슈 수 업데이트
                const status = issue.status;
                issuesByStatus[status] = (issuesByStatus[status] || 0) + 1;
                // 담당자별 이슈 수 업데이트
                if (issue.assignee) {
                    const assigneeName = issue.assignee.displayName || issue.assignee.name;
                    issuesByAssignee[assigneeName] = (issuesByAssignee[assigneeName] || 0) + 1;
                }
                else {
                    issuesByAssignee['미할당'] = (issuesByAssignee['미할당'] || 0) + 1;
                }
                // 우선순위별 이슈 수 업데이트
                if (issue.priority) {
                    const priorityName = issue.priority.name;
                    issuesByPriority[priorityName] = (issuesByPriority[priorityName] || 0) + 1;
                }
                else {
                    issuesByPriority['미지정'] = (issuesByPriority['미지정'] || 0) + 1;
                }
                // 미해결 이슈 목록 업데이트
                if (issue.status !== JiraIssueStatus.Done) {
                    unresolvedIssues.push(issue);
                }
                else {
                    // 해결된 이슈의 해결 시간 계산
                    const created = new Date(issue.created).getTime();
                    const updated = new Date(issue.updated).getTime();
                    const resolutionTime = updated - created;
                    if (resolutionTime > 0) {
                        totalResolutionTime += resolutionTime;
                        resolvedCount++;
                    }
                }
            }
            // 최근 이슈 정렬 (생성일 기준)
            recentIssues = [...issues].sort((a, b) => new Date(b.created).getTime() - new Date(a.created).getTime()).slice(0, maxRecentIssues);
            // 오래된 미해결 이슈 정렬 (생성일 기준)
            const oldestUnresolvedIssues = unresolvedIssues
                .sort((a, b) => new Date(a.created).getTime() - new Date(b.created).getTime())
                .slice(0, maxOldIssues);
            // 평균 해결 시간 계산 (밀리초 단위)
            const averageResolutionTime = resolvedCount > 0 ? totalResolutionTime / resolvedCount : undefined;
            // 프로젝트 완료율 계산
            const openIssues = totalIssues - (issuesByStatus[JiraIssueStatus.Done] || 0);
            const percentComplete = totalIssues > 0 ? Math.round((issuesByStatus[JiraIssueStatus.Done] || 0) * 100 / totalIssues) : 0;
            // 요약 정보 반환
            const result = {
                totalIssues,
                issuesByStatus,
                issuesByAssignee,
                issuesByPriority,
                recentIssues,
                oldestUnresolvedIssues,
                averageResolutionTime,
                projectStats: projectKey ? {
                    projectKey,
                    totalIssues,
                    openIssues,
                    percentComplete
                } : undefined
            };
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(result);
        }
        catch (error) {
            // 오류 처리 및 분류
            this.handleError(error);
            // 오류 로그
            console.error('Jira 프로젝트 요약 조회 실패:', error);
            // 오류 결과 생성
            let serviceError;
            if (this._lastError) {
                // JiraError를 IServiceError로 변환
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createErrorResult)(serviceError);
        }
    }
    /**
     * 모의 요약 정보 생성
     * @param projectKey 프로젝트 키
     * @param maxRecentIssues 최근 이슈 수
     * @param maxOldIssues 오래된 미해결 이슈 수
     * @returns 모의 요약 정보
     * @private
     */
    getMockSummary(projectKey, maxRecentIssues = 5, maxOldIssues = 5) {
        // 기본 프로젝트 키 설정
        const project = projectKey || 'APE';
        // 모의 이슈 생성
        const mockIssues = [];
        const totalIssues = 50; // 모의 데이터의 전체 이슈 수
        // 모의 이슈 생성
        for (let i = 0; i < totalIssues; i++) {
            const issueNumber = i + 1;
            const issueKey = `${project}-${issueNumber}`;
            const mockIssue = this.getMockIssue(issueKey);
            // 프로젝트 정보 추가
            mockIssue.project = {
                id: '10000',
                key: project,
                name: `${project} 프로젝트`
            };
            mockIssues.push(mockIssue);
        }
        // 상태별 이슈 수 설정
        const issuesByStatus = {
            [JiraIssueStatus.ToDo]: 15,
            [JiraIssueStatus.InProgress]: 10,
            [JiraIssueStatus.InReview]: 5,
            [JiraIssueStatus.Done]: 15,
            [JiraIssueStatus.Blocked]: 3,
            [JiraIssueStatus.Unknown]: 2
        };
        // 담당자별 이슈 수 설정
        const issuesByAssignee = {
            '홍길동': 10,
            '김개발': 15,
            '이테스터': 8,
            '박관리자': 5,
            '미할당': 12
        };
        // 우선순위별 이슈 수 설정
        const issuesByPriority = {
            'Highest': 5,
            'High': 10,
            'Medium': 20,
            'Low': 10,
            '미지정': 5
        };
        // 최근 이슈 목록 설정
        const recentIssues = mockIssues
            .slice(0, maxRecentIssues)
            .map(issue => {
            // 최근 이슈는 생성일을 현재 시간에 가깝게 설정
            const now = new Date();
            const randomHours = Math.floor(Math.random() * 48); // 최근 48시간 내
            const createdDate = new Date(now.getTime() - randomHours * 60 * 60 * 1000);
            return {
                ...issue,
                created: createdDate.toISOString(),
                updated: createdDate.toISOString()
            };
        });
        // 오래된 미해결 이슈 목록 설정
        const oldestUnresolvedIssues = mockIssues
            .filter(issue => issue.status !== JiraIssueStatus.Done)
            .slice(0, maxOldIssues)
            .map(issue => {
            // 오래된 이슈는 생성일을 몇 개월 전으로 설정
            const now = new Date();
            const randomDays = 30 + Math.floor(Math.random() * 60); // 30-90일 전
            const createdDate = new Date(now.getTime() - randomDays * 24 * 60 * 60 * 1000);
            return {
                ...issue,
                created: createdDate.toISOString(),
                updated: createdDate.toISOString(),
                status: [JiraIssueStatus.ToDo, JiraIssueStatus.Blocked][Math.floor(Math.random() * 2)]
            };
        });
        // 평균 해결 시간 설정 (3일의 밀리초)
        const averageResolutionTime = 3 * 24 * 60 * 60 * 1000;
        return {
            totalIssues,
            issuesByStatus,
            issuesByAssignee,
            issuesByPriority,
            recentIssues,
            oldestUnresolvedIssues,
            averageResolutionTime,
            projectStats: projectKey ? {
                projectKey,
                totalIssues,
                openIssues: totalIssues - issuesByStatus[JiraIssueStatus.Done],
                percentComplete: Math.round(issuesByStatus[JiraIssueStatus.Done] * 100 / totalIssues)
            } : undefined
        };
    }
    /**
     * 이슈 상태 변경에 필요한 트랜지션 ID 가져오기
     * @param issueKey Jira 이슈 키
     * @param targetStatus 목표 상태
     * @returns 트랜지션 ID
     * @private
     */
    async getTransitionIdForStatus(issueKey, targetStatus) {
        try {
            // Jira REST API 엔드포인트
            const url = `${this.baseUrl}${this.apiPath}/issue/${issueKey}/transitions`;
            // API 요청 설정
            const config = {};
            // 인증 유형에 따른 설정
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API 요청 실행
            const response = await axios__WEBPACK_IMPORTED_MODULE_4__["default"].get(url, config);
            // 사용 가능한 트랜지션 중에서 목표 상태와 일치하는 것 찾기
            const transitions = response.data.transitions || [];
            // 상태 이름 정규화 함수
            const normalizeStatus = (status) => {
                return status.toLowerCase()
                    .replace(/\s+/g, '-')
                    .replace(/in\s+progress/i, 'in-progress')
                    .replace(/to\s+do/i, 'todo');
            };
            // 목표 상태와 일치하는 트랜지션 찾기
            const matchingTransition = transitions.find((t) => {
                const transitionStatus = normalizeStatus(t.to.name);
                return transitionStatus === targetStatus || transitionStatus.includes(targetStatus);
            });
            return matchingTransition ? matchingTransition.id : null;
        }
        catch (error) {
            console.error(`트랜지션 ID 조회 실패 (${issueKey}):`, error);
            return null;
        }
    }
    /**
     * Jira API 응답에서 이슈 정보 파싱
     * @param data API 응답 데이터
     * @returns 파싱된 이슈 정보
     * @private
     */
    parseJiraIssue(data) {
        const fields = data.fields || {};
        // 상태 정규화
        const normalizeStatus = (statusName) => {
            const lowerStatus = statusName.toLowerCase();
            if (lowerStatus.includes('todo') || lowerStatus.includes('to do') || lowerStatus.includes('open')) {
                return JiraIssueStatus.ToDo;
            }
            else if (lowerStatus.includes('progress')) {
                return JiraIssueStatus.InProgress;
            }
            else if (lowerStatus.includes('review')) {
                return JiraIssueStatus.InReview;
            }
            else if (lowerStatus.includes('done') || lowerStatus.includes('closed') || lowerStatus.includes('resolved')) {
                return JiraIssueStatus.Done;
            }
            else if (lowerStatus.includes('block')) {
                return JiraIssueStatus.Blocked;
            }
            else {
                return JiraIssueStatus.Unknown;
            }
        };
        const statusName = fields.status?.name || 'Unknown';
        const issue = {
            id: data.id,
            key: data.key,
            summary: fields.summary || '',
            description: fields.description || '',
            status: normalizeStatus(statusName),
            assignee: fields.assignee ? {
                name: fields.assignee.name,
                displayName: fields.assignee.displayName,
                email: fields.assignee.emailAddress
            } : undefined,
            reporter: fields.reporter ? {
                name: fields.reporter.name,
                displayName: fields.reporter.displayName,
                email: fields.reporter.emailAddress
            } : undefined,
            created: fields.created || '',
            updated: fields.updated || '',
            dueDate: fields.duedate,
            priority: fields.priority ? {
                id: fields.priority.id,
                name: fields.priority.name
            } : undefined,
            labels: fields.labels || [],
            components: (fields.components || []).map((c) => ({
                id: c.id,
                name: c.name
            }))
        };
        return issue;
    }
    /**
     * 모의 Jira 이슈 생성
     * @param issueKey 이슈 키
     * @returns 모의 이슈 데이터
     * @private
     */
    getMockIssue(issueKey) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [_project, id] = issueKey.split('-');
        // 이슈 번호에 따라 다른 모의 데이터 생성
        const idNum = parseInt(id, 10) || 0;
        const mod = idNum % 5;
        let status;
        let summary;
        switch (mod) {
            case 0:
                status = JiraIssueStatus.ToDo;
                summary = '새로운 기능 개발';
                break;
            case 1:
                status = JiraIssueStatus.InProgress;
                summary = '기존 기능 개선';
                break;
            case 2:
                status = JiraIssueStatus.InReview;
                summary = '버그 수정';
                break;
            case 3:
                status = JiraIssueStatus.Done;
                summary = '문서화 작업';
                break;
            case 4:
                status = JiraIssueStatus.Blocked;
                summary = '성능 최적화';
                break;
            default:
                status = JiraIssueStatus.Unknown;
                summary = '기타 작업';
        }
        const now = new Date().toISOString();
        return {
            id: id,
            key: issueKey,
            summary: `[모의 데이터] ${summary}`,
            description: '이것은 모의 Jira 이슈입니다. 실제 Jira에 연결되지 않았습니다.',
            status: status,
            assignee: {
                name: 'testuser',
                displayName: '테스트 사용자'
            },
            reporter: {
                name: 'reporter',
                displayName: '보고자'
            },
            created: now,
            updated: now,
            priority: {
                id: '3',
                name: 'Medium'
            },
            labels: ['mock', 'test'],
            components: [
                { id: '10000', name: 'UI' },
                { id: '10001', name: 'Backend' }
            ]
        };
    }
    /**
     * 오류 처리 및 분류
     * @param error 발생한 오류
     * @param resourceId 관련 리소스 ID (선택적)
     * @private
     */
    handleError(error, resourceId) {
        if (axios__WEBPACK_IMPORTED_MODULE_4__["default"].isAxiosError(error)) {
            const axiosError = error;
            if (!axiosError.response) {
                // 네트워크 오류
                this.setError(JiraErrorType.ConnectionFailed, `Jira 서버 연결 실패: ${error.message}. 서버 URL을 확인하세요: ${this.baseUrl}`);
            }
            else {
                // HTTP 상태 코드에 따른 오류 분류
                const status = axiosError.response.status;
                if (status === 401 || status === 403) {
                    this.setError(JiraErrorType.AuthenticationFailed, `Jira 인증 실패: ${error.message}. 사용자 이름과 비밀번호를 확인하세요.`);
                }
                else if (status === 404) {
                    this.setError(JiraErrorType.ResourceNotFound, `Jira 리소스를 찾을 수 없습니다${resourceId ? ` (${resourceId})` : ''}: ${error.message}`);
                }
                else if (status >= 500) {
                    this.setError(JiraErrorType.ServerError, `Jira 서버 오류: ${error.message}. 서버 상태를 확인하세요.`);
                }
                else if (status === 400) {
                    this.setError(JiraErrorType.InvalidRequest, `Jira 요청이 잘못되었습니다: ${error.message}`);
                }
                else {
                    this.setError(JiraErrorType.Unknown, `Jira 오류: ${error.message}`);
                }
            }
        }
        else {
            // 일반 오류
            this.setError(JiraErrorType.Unknown, `Jira 오류: ${error.message}`);
        }
    }
    /**
     * 오류 설정
     * @param type 오류 유형
     * @param message 오류 메시지
     * @param details 추가 세부 정보
     * @private
     */
    setError(type, message, details) {
        this._lastError = {
            type,
            message,
            details
        };
        // 콘솔에 오류 기록
        console.error(`Jira 오류 (${type}):`, message, details || '');
    }
    /**
     * 리소스 해제
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/services/rulesService.ts":
/*!*******************************************!*\
  !*** ./src/core/services/rulesService.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RuleStatus: () => (/* binding */ RuleStatus),
/* harmony export */   RulesService: () => (/* binding */ RulesService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _serviceError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serviceError */ "./src/core/services/serviceError.ts");
/**
 * APE Rules 서비스
 *
 * Rules 파일을 관리하고 LLM 시스템 프롬프트에 적용하는 서비스입니다.
 * Rules 생성, 삭제, 활성화/비활성화 기능을 제공합니다.
 */




/**
 * Rule 항목 상태
 */
var RuleStatus;
(function (RuleStatus) {
    RuleStatus["Active"] = "active";
    RuleStatus["Inactive"] = "inactive";
})(RuleStatus || (RuleStatus = {}));
/**
 * Rules 서비스 클래스
 */
class RulesService {
    context;
    configManager;
    _onDidChangeRules = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    onDidChangeRules = this._onDidChangeRules.event;
    rules = new Map();
    disposables = [];
    rulesDir;
    /**
     * 생성자
     * @param context VSCode 확장 컨텍스트
     * @param configManager 서비스 설정 관리자 (옵션)
     */
    constructor(context, configManager) {
        this.context = context;
        this.configManager = configManager;
        // Rules 디렉토리 설정
        this.rulesDir = path__WEBPACK_IMPORTED_MODULE_2__.join(this.context.globalStorageUri.fsPath, 'rules');
        // Rules 디렉토리 생성 (없는 경우)
        this.ensureRulesDir();
        // 설정 변경 이벤트 구독
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.rules')) {
                this.loadAllRules();
            }
        }));
        // 파일 시스템 변경 감지
        const watcher = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.createFileSystemWatcher(new vscode__WEBPACK_IMPORTED_MODULE_0__.RelativePattern(this.rulesDir, '**/*.md'));
        this.disposables.push(watcher, watcher.onDidCreate(() => this.loadAllRules()), watcher.onDidDelete(() => this.loadAllRules()), watcher.onDidChange(() => this.loadAllRules()));
        // 초기 Rules 로드
        this.loadAllRules();
    }
    /**
     * Rules 디렉토리 확인 및 생성
     */
    ensureRulesDir() {
        if (!fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(this.rulesDir)) {
            fs__WEBPACK_IMPORTED_MODULE_1__.mkdirSync(this.rulesDir, { recursive: true });
        }
    }
    /**
     * 모든 Rules 로드
     */
    async loadAllRules() {
        try {
            this.ensureRulesDir();
            this.rules.clear();
            // Rules 디렉토리의 모든 .md 파일 읽기
            const files = fs__WEBPACK_IMPORTED_MODULE_1__.readdirSync(this.rulesDir).filter(file => file.endsWith('.md'));
            // 설정에서 활성화된 Rules 목록 가져오기
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.rules');
            const activeRules = config.get('activeRules', []);
            // 각 파일을 Rule 객체로 변환
            for (const file of files) {
                const filePath = path__WEBPACK_IMPORTED_MODULE_2__.join(this.rulesDir, file);
                const fileStats = fs__WEBPACK_IMPORTED_MODULE_1__.statSync(filePath);
                const content = fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(filePath, 'utf-8');
                // 파일명에서 확장자 제거하여 ID 생성
                const id = path__WEBPACK_IMPORTED_MODULE_2__.basename(file, '.md');
                // Rule 객체 생성
                const rule = {
                    id,
                    name: this.extractNameFromContent(content) || id,
                    filePath,
                    content,
                    status: activeRules.includes(id) ? RuleStatus.Active : RuleStatus.Inactive,
                    createdAt: fileStats.birthtime,
                    updatedAt: fileStats.mtime
                };
                // Rules 맵에 추가
                this.rules.set(id, rule);
            }
            // 변경 이벤트 발생
            this._onDidChangeRules.fire();
        }
        catch (error) {
            console.error('Rules 로드 오류:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rules 로드 중 오류가 발생했습니다: ${error}`);
        }
    }
    /**
     * 파일 내용에서 이름 추출 (첫 번째 제목 사용)
     * @param content 파일 내용
     */
    extractNameFromContent(content) {
        // 마크다운 제목 형식(#으로 시작하는 라인) 찾기
        const titleMatch = content.match(/^#\s+(.+)$/m);
        if (titleMatch && titleMatch[1]) {
            return titleMatch[1].trim();
        }
        return null;
    }
    /**
     * 모든 Rules 가져오기
     */
    getAllRules() {
        return Array.from(this.rules.values());
    }
    /**
     * 활성화된 Rules 가져오기
     */
    getActiveRules() {
        return this.getAllRules().filter(rule => rule.status === RuleStatus.Active);
    }
    /**
     * ID로 Rule 가져오기
     * @param id Rule ID
     */
    getRuleById(id) {
        return this.rules.get(id);
    }
    /**
     * Rule 생성
     * @param name Rule 이름
     * @param content Rule 내용
     * @param activate 생성 후 활성화 여부
     */
    async createRule(name, content, activate = false) {
        try {
            this.ensureRulesDir();
            // 파일명으로 사용할 ID 생성 (공백은 하이픈으로 변환)
            const id = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
            // 이미 존재하는 ID인지 확인
            if (this.rules.has(id)) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`이미 존재하는 Rule 이름입니다: ${name}`, 'rule-already-exists');
            }
            // 마크다운 내용이 제목으로 시작하지 않으면 제목 추가
            let finalContent = content;
            if (!content.trim().startsWith('#')) {
                finalContent = `# ${name}\n\n${content}`;
            }
            // 파일 경로 생성
            const filePath = path__WEBPACK_IMPORTED_MODULE_2__.join(this.rulesDir, `${id}.md`);
            // 파일 작성
            fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(filePath, finalContent, 'utf-8');
            // Rule 객체 생성
            const rule = {
                id,
                name,
                filePath,
                content: finalContent,
                status: RuleStatus.Inactive,
                createdAt: new Date(),
                updatedAt: new Date()
            };
            // Rules 맵에 추가
            this.rules.set(id, rule);
            // 활성화 요청이 있으면 활성화
            if (activate) {
                await this.activateRule(id);
            }
            // 변경 이벤트 발생
            this._onDidChangeRules.fire();
            return rule;
        }
        catch (error) {
            console.error('Rule 생성 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule 생성 중 오류가 발생했습니다: ${error}`, 'rule-creation-failed');
        }
    }
    /**
     * Rule 업데이트
     * @param id Rule ID
     * @param updates 업데이트할 필드
     */
    async updateRule(id, updates) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`ID가 ${id}인 Rule을 찾을 수 없습니다.`, 'rule-not-found');
            }
            // 이름 또는 내용 업데이트
            let updatedContent = rule.content;
            let updatedName = rule.name;
            if (updates.name) {
                updatedName = updates.name;
                // 내용 업데이트 없이 이름만 변경하는 경우 마크다운 제목 업데이트
                if (!updates.content) {
                    const titleRegex = /^#\s+(.+)$/m;
                    if (titleRegex.test(updatedContent)) {
                        updatedContent = updatedContent.replace(titleRegex, `# ${updatedName}`);
                    }
                    else {
                        updatedContent = `# ${updatedName}\n\n${updatedContent}`;
                    }
                }
            }
            if (updates.content) {
                updatedContent = updates.content;
                // 내용에 제목이 없으면 추가
                if (!updatedContent.trim().startsWith('#')) {
                    updatedContent = `# ${updatedName}\n\n${updatedContent}`;
                }
            }
            // 파일 업데이트
            fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(rule.filePath, updatedContent, 'utf-8');
            // Rule 객체 업데이트
            const updatedRule = {
                ...rule,
                name: updatedName,
                content: updatedContent,
                updatedAt: new Date()
            };
            // Rules 맵 업데이트
            this.rules.set(id, updatedRule);
            // 변경 이벤트 발생
            this._onDidChangeRules.fire();
            return updatedRule;
        }
        catch (error) {
            console.error('Rule 업데이트 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule 업데이트 중 오류가 발생했습니다: ${error}`, 'rule-update-failed');
        }
    }
    /**
     * Rule 삭제
     * @param id Rule ID
     */
    async deleteRule(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`ID가 ${id}인 Rule을 찾을 수 없습니다.`, 'rule-not-found');
            }
            // 활성화된 경우 비활성화
            if (rule.status === RuleStatus.Active) {
                await this.deactivateRule(id);
            }
            // 파일 삭제
            if (fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(rule.filePath)) {
                fs__WEBPACK_IMPORTED_MODULE_1__.unlinkSync(rule.filePath);
            }
            // Rules 맵에서 제거
            this.rules.delete(id);
            // 변경 이벤트 발생
            this._onDidChangeRules.fire();
            return true;
        }
        catch (error) {
            console.error('Rule 삭제 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule 삭제 중 오류가 발생했습니다: ${error}`, 'rule-deletion-failed');
        }
    }
    /**
     * Rule 활성화
     * @param id Rule ID
     */
    async activateRule(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`ID가 ${id}인 Rule을 찾을 수 없습니다.`, 'rule-not-found');
            }
            // 이미 활성화된 경우 처리 생략
            if (rule.status === RuleStatus.Active) {
                return true;
            }
            // 설정에서 활성화된 Rules 목록 가져오기
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.rules');
            const activeRules = config.get('activeRules', []);
            // ID가 목록에 없으면 추가
            if (!activeRules.includes(id)) {
                activeRules.push(id);
                await config.update('activeRules', activeRules, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global);
            }
            // Rule 상태 업데이트
            const updatedRule = {
                ...rule,
                status: RuleStatus.Active,
                updatedAt: new Date()
            };
            // Rules 맵 업데이트
            this.rules.set(id, updatedRule);
            // 변경 이벤트 발생
            this._onDidChangeRules.fire();
            return true;
        }
        catch (error) {
            console.error('Rule 활성화 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule 활성화 중 오류가 발생했습니다: ${error}`, 'rule-activation-failed');
        }
    }
    /**
     * Rule 비활성화
     * @param id Rule ID
     */
    async deactivateRule(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`ID가 ${id}인 Rule을 찾을 수 없습니다.`, 'rule-not-found');
            }
            // 이미 비활성화된 경우 처리 생략
            if (rule.status === RuleStatus.Inactive) {
                return true;
            }
            // 설정에서 활성화된 Rules 목록 가져오기
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.rules');
            const activeRules = config.get('activeRules', []);
            // ID가 목록에 있으면 제거
            const updatedActiveRules = activeRules.filter(activeId => activeId !== id);
            await config.update('activeRules', updatedActiveRules, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global);
            // Rule 상태 업데이트
            const updatedRule = {
                ...rule,
                status: RuleStatus.Inactive,
                updatedAt: new Date()
            };
            // Rules 맵 업데이트
            this.rules.set(id, updatedRule);
            // 변경 이벤트 발생
            this._onDidChangeRules.fire();
            return true;
        }
        catch (error) {
            console.error('Rule 비활성화 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule 비활성화 중 오류가 발생했습니다: ${error}`, 'rule-deactivation-failed');
        }
    }
    /**
     * Rules 파일 열기
     * @param id Rule ID
     */
    async openRuleFile(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`ID가 ${id}인 Rule을 찾을 수 없습니다.`, 'rule-not-found');
            }
            // VS Code에서 파일 열기
            const document = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument(rule.filePath);
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showTextDocument(document);
            return true;
        }
        catch (error) {
            console.error('Rule 파일 열기 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule 파일 열기 중 오류가 발생했습니다: ${error}`, 'rule-open-failed');
        }
    }
    /**
     * Rules를 LLM 시스템 프롬프트로 변환
     */
    getRulesAsSystemPrompt() {
        const activeRules = this.getActiveRules();
        if (activeRules.length === 0) {
            return '';
        }
        // 헤더 추가
        let systemPrompt = '# APE Rules\n\n';
        systemPrompt += '다음 규칙을 항상 준수하세요:\n\n';
        // 각 활성화된 Rule 내용 추가
        for (const rule of activeRules) {
            // 제목이 있는 경우 제목 제외하고 내용만 추가
            let content = rule.content;
            const titleMatch = content.match(/^#\s+(.+)$/m);
            if (titleMatch) {
                content = content.replace(titleMatch[0], '').trim();
            }
            systemPrompt += `## ${rule.name}\n\n${content}\n\n`;
        }
        return systemPrompt;
    }
    /**
     * 리소스 해제
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/services/serviceConfig.ts":
/*!********************************************!*\
  !*** ./src/core/services/serviceConfig.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthType: () => (/* binding */ AuthType),
/* harmony export */   ServiceConfigManager: () => (/* binding */ ServiceConfigManager),
/* harmony export */   ServiceType: () => (/* binding */ ServiceType)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/**
 * 서비스 설정 관리자
 *
 * Git, Jira, S3, SWDP 등의 외부 서비스 연결 설정을 관리합니다.
 * 각 서비스별 URL, 인증 정보 등을 VSCode 설정에서 가져오고 검증합니다.
 */

/**
 * 서비스 인증 방식 유형
 */
var AuthType;
(function (AuthType) {
    AuthType["None"] = "none";
    AuthType["Basic"] = "basic";
    AuthType["OAuth"] = "oauth";
    AuthType["Token"] = "token";
    AuthType["AWS"] = "aws";
})(AuthType || (AuthType = {}));
/**
 * 서비스 유형
 */
var ServiceType;
(function (ServiceType) {
    ServiceType["Git"] = "git";
    ServiceType["Bitbucket"] = "bitbucket";
    ServiceType["Jira"] = "jira";
    ServiceType["S3"] = "pocket";
    ServiceType["SWDP"] = "swdp";
    ServiceType["Vault"] = "vault";
    ServiceType["Unknown"] = "unknown";
})(ServiceType || (ServiceType = {}));
/**
 * 서비스 설정 관리자 클래스
 */
class ServiceConfigManager {
    context;
    configs = new Map();
    disposables = [];
    /**
     * 생성자
     * @param context VSCode 확장 컨텍스트
     */
    constructor(context) {
        this.context = context;
        // 초기 설정 로드
        this.loadAllConfigs();
        // 설정 변경 감지
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            let configChanged = false;
            for (const serviceType of Object.values(ServiceType)) {
                if (e.affectsConfiguration(`ape.${serviceType}`)) {
                    this.loadServiceConfig(serviceType);
                    configChanged = true;
                }
            }
            if (configChanged) {
                // 설정 변경 이벤트 발생
                this.onConfigChange();
            }
        }));
    }
    /**
     * 설정 변경 시 호출될 이벤트 핸들러
     * @private
     */
    onConfigChange() {
        // 설정 변경 이벤트를 구독자에게 알림
        // 향후 EventEmitter 추가 가능
    }
    /**
     * 모든 서비스 설정 로드
     * @private
     */
    loadAllConfigs() {
        for (const serviceType of Object.values(ServiceType)) {
            this.loadServiceConfig(serviceType);
        }
    }
    /**
     * 특정 서비스 설정 로드
     * @param serviceType 서비스 유형
     * @private
     */
    loadServiceConfig(serviceType) {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(`ape.${serviceType}`);
        const serviceConfig = {
            enabled: config.get('enabled', false),
            url: config.get('url', ''),
            authType: config.get('authType', AuthType.None),
            username: config.get('username', ''),
            password: config.get('password', ''),
            token: config.get('token', ''),
            useMock: config.get('useMock', true),
            additionalParams: {}
        };
        // VAULT 서비스인 경우 디렉토리 경로 추가
        if (serviceType === ServiceType.Vault) {
            serviceConfig.additionalParams = {
                vaultDirectory: config.get('vaultDirectory', '.ape-vault')
            };
        }
        else {
            serviceConfig.additionalParams = config.get('additionalParams', {});
        }
        this.configs.set(serviceType, serviceConfig);
    }
    /**
     * 서비스 설정 가져오기
     * @param serviceType 서비스 유형
     */
    getServiceConfig(serviceType) {
        // 설정이 없으면 새로 로드
        if (!this.configs.has(serviceType)) {
            this.loadServiceConfig(serviceType);
        }
        return this.configs.get(serviceType);
    }
    /**
     * 서비스 설정 업데이트
     * @param serviceType 서비스 유형
     * @param config 새 설정
     */
    async updateServiceConfig(serviceType, config) {
        try {
            const vscodeConfig = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(`ape.${serviceType}`);
            // 각 필드 업데이트
            for (const [key, value] of Object.entries(config)) {
                if (value !== undefined) {
                    await vscodeConfig.update(key, value, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global);
                }
            }
            // 설정 다시 로드
            this.loadServiceConfig(serviceType);
            return true;
        }
        catch (error) {
            console.error(`서비스 설정 업데이트 오류 (${serviceType}):`, error);
            return false;
        }
    }
    /**
     * 서비스 설정 검증
     * @param serviceType 서비스 유형
     */
    validateServiceConfig(serviceType) {
        const config = this.getServiceConfig(serviceType);
        const errors = [];
        // 기본 검증: 서비스가 활성화되어 있는 경우 URL 필수
        if (config.enabled && !config.useMock) {
            if (!config.url) {
                errors.push(`${serviceType} 서비스 URL이 설정되지 않았습니다.`);
            }
            else if (!this.isValidUrl(config.url)) {
                errors.push(`${serviceType} 서비스 URL 형식이 올바르지 않습니다: ${config.url}`);
            }
            // 인증 유형에 따른 검증
            if (config.authType === AuthType.Basic) {
                if (!config.username) {
                    errors.push(`${serviceType} 서비스 사용자 이름이 설정되지 않았습니다.`);
                }
                if (!config.password) {
                    errors.push(`${serviceType} 서비스 비밀번호가 설정되지 않았습니다.`);
                }
            }
            else if (config.authType === AuthType.Token) {
                if (!config.token) {
                    errors.push(`${serviceType} 서비스 토큰이 설정되지 않았습니다.`);
                }
            }
            else if (config.authType === AuthType.OAuth) {
                if (!config.token) {
                    errors.push(`${serviceType} 서비스 OAuth 토큰이 설정되지 않았습니다.`);
                }
            }
            else if (config.authType === AuthType.AWS) {
                const params = config.additionalParams || {};
                if (!params.accessKeyId) {
                    errors.push(`${serviceType} 서비스 AWS 액세스 키 ID가 설정되지 않았습니다.`);
                }
                if (!params.secretAccessKey) {
                    errors.push(`${serviceType} 서비스 AWS 시크릿 액세스 키가 설정되지 않았습니다.`);
                }
                if (!params.region) {
                    errors.push(`${serviceType} 서비스 AWS 리전이 설정되지 않았습니다.`);
                }
            }
        }
        return errors;
    }
    /**
     * URL 유효성 검사
     * @param url 검사할 URL
     * @private
     */
    isValidUrl(url) {
        try {
            new URL(url);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * 서비스 연결 테스트
     * @param serviceType 서비스 유형
     */
    async testConnection(serviceType) {
        const config = this.getServiceConfig(serviceType);
        // 모의 모드인 경우 항상 성공
        if (config.useMock) {
            return {
                success: true,
                message: `${serviceType} 서비스가 모의 모드로 설정되어 있습니다. 실제 서버에 연결하지 않습니다.`
            };
        }
        // 유효성 검사
        const errors = this.validateServiceConfig(serviceType);
        if (errors.length > 0) {
            return {
                success: false,
                message: `설정 오류: ${errors.join(' ')}`
            };
        }
        // 실제 연결 테스트는 각 서비스별 클래스에서 구현
        return {
            success: true,
            message: `${serviceType} 서비스 설정이 유효합니다. 실제 연결 테스트는 각 서비스 클래스에서 수행합니다.`
        };
    }
    /**
     * 리소스 해제
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/services/serviceError.ts":
/*!*******************************************!*\
  !*** ./src/core/services/serviceError.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ServiceError: () => (/* binding */ ServiceError),
/* harmony export */   ServiceErrorManager: () => (/* binding */ ServiceErrorManager),
/* harmony export */   ServiceErrorType: () => (/* binding */ ServiceErrorType)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _serviceConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serviceConfig */ "./src/core/services/serviceConfig.ts");
/**
 * 서비스 오류 모듈
 *
 * 외부 서비스 연결 및 사용 중 발생하는 오류를 처리하는 기능 제공
 * 일관된 오류 처리와 사용자 친화적인 오류 메시지를 위한 유틸리티
 */


/**
 * 서비스 오류 유형 열거형
 */
var ServiceErrorType;
(function (ServiceErrorType) {
    // 연결 관련 오류
    ServiceErrorType["ConnectionFailed"] = "connection_failed";
    ServiceErrorType["Timeout"] = "timeout";
    // 인증 관련 오류
    ServiceErrorType["AuthenticationFailed"] = "authentication_failed";
    ServiceErrorType["TokenExpired"] = "token_expired";
    ServiceErrorType["PermissionDenied"] = "permission_denied";
    // 리소스 관련 오류
    ServiceErrorType["ResourceNotFound"] = "resource_not_found";
    ServiceErrorType["InvalidResource"] = "invalid_resource";
    // 요청 관련 오류
    ServiceErrorType["InvalidRequest"] = "invalid_request";
    ServiceErrorType["BadRequest"] = "bad_request";
    ServiceErrorType["RateLimited"] = "rate_limited";
    // 서버 관련 오류
    ServiceErrorType["ServerError"] = "server_error";
    ServiceErrorType["ServiceUnavailable"] = "service_unavailable";
    // 환경 관련 오류
    ServiceErrorType["ConfigurationError"] = "configuration_error";
    // 기타 오류
    ServiceErrorType["Unknown"] = "unknown";
})(ServiceErrorType || (ServiceErrorType = {}));
/**
 * 서비스 오류 클래스
 */
class ServiceError extends Error {
    type;
    serviceType;
    details;
    timestamp;
    /**
     * 서비스 오류 생성자
     * @param message 오류 메시지
     * @param originalError 원본 오류 (옵션)
     * @param serviceType 서비스 타입 (기본값: Unknown)
     * @param errorType 오류 타입 (기본값: Unknown)
     */
    constructor(message, originalError, serviceType = _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Unknown, errorType = ServiceErrorType.Unknown) {
        super(message);
        this.name = 'ServiceError';
        this.message = message;
        this.type = errorType;
        this.serviceType = serviceType;
        this.details = originalError;
        this.timestamp = new Date();
        // Error 객체의 프로토타입 체인 유지
        Object.setPrototypeOf(this, ServiceError.prototype);
    }
}
/**
 * 서비스 오류 관리자 클래스
 */
class ServiceErrorManager {
    static _lastErrors = new Map();
    /**
     * 오류 생성 및 등록
     * @param serviceType 서비스 유형
     * @param errorType 오류 유형
     * @param message 오류 메시지
     * @param details 추가 세부 정보
     * @returns 생성된 서비스 오류
     */
    static createError(serviceType, errorType, message, details) {
        const error = new ServiceError(message, details, serviceType, errorType);
        // 해당 서비스의 마지막 오류 저장
        this._lastErrors.set(serviceType, error);
        // 콘솔에 오류 기록
        console.error(`[${serviceType}] ${errorType}: ${message}`, details || '');
        return error;
    }
    /**
     * 마지막 오류 가져오기
     * @param serviceType 서비스 유형
     * @returns 마지막 서비스 오류 또는 null
     */
    static getLastError(serviceType) {
        return this._lastErrors.get(serviceType) || null;
    }
    /**
     * 모든 서비스 오류 가져오기
     * @returns 모든 서비스 오류 맵
     */
    static getAllErrors() {
        return new Map(this._lastErrors);
    }
    /**
     * 서비스 오류를 사용자 친화적인 메시지로 변환
     * @param error 서비스 오류
     * @returns 사용자 친화적인 오류 메시지
     */
    static getUserFriendlyMessage(error) {
        // 서비스 유형별 한글 이름
        const serviceNames = {
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Git]: 'Git',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Bitbucket]: 'Bitbucket',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira]: 'Jira',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.S3]: 'Pocket/S3',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.SWDP]: 'SWDP',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault]: 'VAULT',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Unknown]: '알 수 없는 서비스'
        };
        const serviceName = serviceNames[error.serviceType] || error.serviceType;
        // 오류 유형별 기본 메시지
        switch (error.type) {
            case ServiceErrorType.ConnectionFailed:
                return `${serviceName} 서버 연결에 실패했습니다. URL을 확인하세요: ${error.details?.url || ''}`;
            case ServiceErrorType.Timeout:
                return `${serviceName} 서버 응답 시간이 초과되었습니다. 서버 상태나 네트워크를 확인하세요.`;
            case ServiceErrorType.AuthenticationFailed:
                return `${serviceName} 인증에 실패했습니다. 아이디와 비밀번호를 확인하세요.`;
            case ServiceErrorType.TokenExpired:
                return `${serviceName} 인증 토큰이 만료되었습니다. 토큰을 갱신하세요.`;
            case ServiceErrorType.PermissionDenied:
                return `${serviceName} 접근 권한이 없습니다. 계정 권한을 확인하세요.`;
            case ServiceErrorType.ResourceNotFound:
                return `${serviceName}에서 요청한 리소스를 찾을 수 없습니다.`;
            case ServiceErrorType.InvalidResource:
                return `${serviceName}에 잘못된 리소스가 요청되었습니다.`;
            case ServiceErrorType.InvalidRequest:
            case ServiceErrorType.BadRequest:
                return `${serviceName}에 잘못된 요청이 전송되었습니다.`;
            case ServiceErrorType.RateLimited:
                return `${serviceName} 요청 한도를 초과했습니다. 잠시 후 다시 시도하세요.`;
            case ServiceErrorType.ServerError:
                return `${serviceName} 서버에 오류가 발생했습니다. 서버 관리자에게 문의하세요.`;
            case ServiceErrorType.ServiceUnavailable:
                return `${serviceName} 서비스를 현재 사용할 수 없습니다. 서비스 상태를 확인하세요.`;
            case ServiceErrorType.ConfigurationError:
                return `${serviceName} 설정 오류: ${error.message}`;
            case ServiceErrorType.Unknown:
            default:
                return `${serviceName} 오류: ${error.message}`;
        }
    }
    /**
     * 오류를 사용자에게 표시
     * @param error 서비스 오류
     * @param showDetailAction 세부 정보 표시 액션 포함 여부
     */
    static async showErrorToUser(error, showDetailAction = true) {
        const userMessage = this.getUserFriendlyMessage(error);
        if (showDetailAction) {
            const selection = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(userMessage, '세부 정보', '닫기');
            if (selection === '세부 정보') {
                // 세부 정보를 출력 채널에 표시
                const outputChannel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createOutputChannel(`APE ${error.serviceType} 오류`);
                outputChannel.appendLine(`시간: ${error.timestamp.toLocaleString()}`);
                outputChannel.appendLine(`서비스: ${error.serviceType}`);
                outputChannel.appendLine(`오류 유형: ${error.type}`);
                outputChannel.appendLine(`메시지: ${error.message}`);
                if (error.details) {
                    outputChannel.appendLine('\n세부 정보:');
                    outputChannel.appendLine(JSON.stringify(error.details, null, 2));
                }
                outputChannel.show();
            }
        }
        else {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(userMessage);
        }
    }
    /**
     * HTTP 상태 코드를 ServiceErrorType으로 변환
     * @param statusCode HTTP 상태 코드
     * @returns 대응하는 서비스 오류 유형
     */
    static errorTypeFromHttpStatus(statusCode) {
        if (statusCode >= 500) {
            return ServiceErrorType.ServerError;
        }
        switch (statusCode) {
            case 400:
                return ServiceErrorType.BadRequest;
            case 401:
                return ServiceErrorType.AuthenticationFailed;
            case 403:
                return ServiceErrorType.PermissionDenied;
            case 404:
                return ServiceErrorType.ResourceNotFound;
            case 408:
                return ServiceErrorType.Timeout;
            case 429:
                return ServiceErrorType.RateLimited;
            default:
                return ServiceErrorType.Unknown;
        }
    }
}


/***/ }),

/***/ "./src/core/services/serviceResult.ts":
/*!********************************************!*\
  !*** ./src/core/services/serviceResult.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createErrorResult: () => (/* binding */ createErrorResult),
/* harmony export */   createSuccessResult: () => (/* binding */ createSuccessResult)
/* harmony export */ });
/**
 * 서비스 결과 모듈
 *
 * 외부 서비스 호출의 결과를 표준화된 형식으로 처리하는 인터페이스 정의
 * 성공/실패 여부, 데이터, 오류 정보를 일관된 방식으로 관리
 */
/**
 * 성공 결과 생성 유틸리티 함수
 *
 * @param data 결과 데이터
 * @returns 성공 결과 객체
 */
function createSuccessResult(data) {
    return {
        success: true,
        data
    };
}
/**
 * 실패 결과 생성 유틸리티 함수
 *
 * @param error 오류 정보
 * @returns 실패 결과 객체
 */
function createErrorResult(error) {
    return {
        success: false,
        error
    };
}


/***/ }),

/***/ "./src/core/services/vaultService.ts":
/*!*******************************************!*\
  !*** ./src/core/services/vaultService.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VaultContextType: () => (/* binding */ VaultContextType),
/* harmony export */   VaultService: () => (/* binding */ VaultService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _serviceConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serviceConfig */ "./src/core/services/serviceConfig.ts");
/* harmony import */ var _serviceError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serviceError */ "./src/core/services/serviceError.ts");
/**
 * VAULT 서비스
 *
 * VAULT 컨텍스트 및 아이템을 관리하는 서비스입니다.
 * 컨텍스트 저장, 불러오기, 아이템 관리 기능을 제공합니다.
 */



/**
 * VAULT 컨텍스트 타입
 */
var VaultContextType;
(function (VaultContextType) {
    VaultContextType["System"] = "system";
    VaultContextType["Project"] = "project";
    VaultContextType["Personal"] = "personal";
    VaultContextType["Shared"] = "shared";
    VaultContextType["Template"] = "template";
})(VaultContextType || (VaultContextType = {}));
/**
 * VAULT 서비스 클래스
 */
class VaultService {
    context;
    configManager;
    _onDidChangeVault = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    onDidChangeVault = this._onDidChangeVault.event;
    contexts = new Map();
    disposables = [];
    vaultDir;
    fs = __webpack_require__(/*! fs */ "fs");
    path = __webpack_require__(/*! path */ "path");
    /**
     * 생성자
     * @param context VSCode 확장 컨텍스트
     * @param configManager 서비스 설정 관리자
     */
    constructor(context, configManager) {
        this.context = context;
        this.configManager = configManager;
        // VAULT 디렉토리 경로 설정
        const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
        this.vaultDir = config.additionalParams?.vaultDirectory || '.ape-vault';
        // 절대 경로가 아니면 홈 디렉토리 기준으로 설정
        if (!this.path.isAbsolute(this.vaultDir)) {
            this.vaultDir = this.path.join(this.getUserHomeDir(), this.vaultDir);
        }
        // VAULT 디렉토리 존재 확인 및 생성
        this.ensureVaultDirectory();
        // 설정 변경 이벤트 구독
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.vault')) {
                // 설정이 변경되면 디렉토리 경로 업데이트
                const newConfig = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
                const newDir = newConfig.additionalParams?.vaultDirectory || '.ape-vault';
                if (newDir !== this.vaultDir) {
                    this.vaultDir = this.path.isAbsolute(newDir)
                        ? newDir
                        : this.path.join(this.getUserHomeDir(), newDir);
                    this.ensureVaultDirectory();
                    this.loadAllContexts();
                }
                else {
                    this.loadAllContexts();
                }
            }
        }));
        // 초기 데이터 로드
        this.loadAllContexts();
    }
    /**
     * 사용자 홈 디렉토리 가져오기
     */
    getUserHomeDir() {
        return process.env.HOME || process.env.USERPROFILE || '.';
    }
    /**
     * VAULT 디렉토리 존재 확인 및 생성
     */
    ensureVaultDirectory() {
        try {
            // 메인 VAULT 디렉토리
            if (!this.fs.existsSync(this.vaultDir)) {
                this.fs.mkdirSync(this.vaultDir, { recursive: true });
                console.log(`VAULT 디렉토리 생성됨: ${this.vaultDir}`);
            }
            // 컨텍스트 타입별 하위 디렉토리
            const contextTypeDirs = Object.values(VaultContextType);
            for (const dir of contextTypeDirs) {
                const typePath = this.path.join(this.vaultDir, dir);
                if (!this.fs.existsSync(typePath)) {
                    this.fs.mkdirSync(typePath, { recursive: true });
                }
            }
        }
        catch (error) {
            console.error('VAULT 디렉토리 생성 오류:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`VAULT 디렉토리를 생성할 수 없습니다: ${error}`);
        }
    }
    /**
     * 모든 컨텍스트 로드
     */
    async loadAllContexts() {
        try {
            this.contexts.clear();
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (config.useMock) {
                // 모의 데이터 로드
                this.loadMockContexts();
            }
            else if (config.enabled) {
                // 파일 시스템에서 데이터 로드
                await this.loadContextsFromFileSystem();
                // 컨텍스트가 없으면 기본 컨텍스트 생성
                if (this.contexts.size === 0) {
                    this.createDefaultContexts();
                }
            }
            // 변경 이벤트 발생
            this._onDidChangeVault.fire();
        }
        catch (error) {
            console.error('VAULT 컨텍스트 로드 오류:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`VAULT 컨텍스트 로드 중 오류가 발생했습니다: ${error}`);
        }
    }
    /**
     * 파일 시스템에서 컨텍스트 로드
     */
    async loadContextsFromFileSystem() {
        try {
            // 각 컨텍스트 타입 디렉토리 처리
            for (const contextType of Object.values(VaultContextType)) {
                const typeDir = this.path.join(this.vaultDir, contextType);
                // 디렉토리가 없으면 건너뛰기
                if (!this.fs.existsSync(typeDir)) {
                    continue;
                }
                // 컨텍스트 메타데이터 파일 목록 가져오기
                const contextFiles = this.fs.readdirSync(typeDir)
                    .filter((file) => file.endsWith('.context.json'));
                // 각 컨텍스트 파일 로드
                for (const fileName of contextFiles) {
                    try {
                        const filePath = this.path.join(typeDir, fileName);
                        const data = this.fs.readFileSync(filePath, 'utf8');
                        const contextData = JSON.parse(data);
                        // 날짜 문자열을 Date 객체로 변환
                        contextData.createdAt = new Date(contextData.createdAt);
                        contextData.updatedAt = new Date(contextData.updatedAt);
                        // 컨텍스트 아이템 로드
                        contextData.items = await this.loadContextItems(contextData.id, contextType);
                        // 컨텍스트 맵에 추가
                        this.contexts.set(contextData.id, contextData);
                    }
                    catch (error) {
                        console.error(`컨텍스트 파일 로드 오류 (${fileName}):`, error);
                    }
                }
            }
        }
        catch (error) {
            console.error('파일 시스템에서 컨텍스트 로드 오류:', error);
            throw error;
        }
    }
    /**
     * 특정 컨텍스트의 아이템 로드
     * @param contextId 컨텍스트 ID
     * @param contextType 컨텍스트 타입
     */
    async loadContextItems(contextId, contextType) {
        const items = [];
        const itemsDir = this.path.join(this.vaultDir, contextType, contextId);
        // 아이템 디렉토리가 없으면 빈 배열 반환
        if (!this.fs.existsSync(itemsDir)) {
            return items;
        }
        // 아이템 파일 목록 가져오기
        const itemFiles = this.fs.readdirSync(itemsDir)
            .filter((file) => file.endsWith('.item.json'));
        // 각 아이템 파일 로드
        for (const fileName of itemFiles) {
            try {
                const filePath = this.path.join(itemsDir, fileName);
                const data = this.fs.readFileSync(filePath, 'utf8');
                const itemData = JSON.parse(data);
                // 날짜 문자열을 Date 객체로 변환
                itemData.createdAt = new Date(itemData.createdAt);
                itemData.updatedAt = new Date(itemData.updatedAt);
                // 콘텐츠 파일 로드
                const contentFilePath = this.path.join(itemsDir, `${itemData.id}.content.md`);
                if (this.fs.existsSync(contentFilePath)) {
                    itemData.content = this.fs.readFileSync(contentFilePath, 'utf8');
                }
                items.push(itemData);
            }
            catch (error) {
                console.error(`아이템 파일 로드 오류 (${fileName}):`, error);
            }
        }
        return items;
    }
    /**
     * 기본 컨텍스트 생성
     */
    createDefaultContexts() {
        // 모의 데이터 로드하여 기본 컨텍스트로 저장
        this.loadMockContexts();
        // 각 컨텍스트 저장
        this.contexts.forEach(context => {
            this.saveContextToFileSystem(context);
        });
    }
    /**
     * 컨텍스트를 파일 시스템에 저장
     * @param context 저장할 컨텍스트
     */
    saveContextToFileSystem(context) {
        try {
            // 컨텍스트 타입 디렉토리 경로
            const typeDir = this.path.join(this.vaultDir, context.type);
            // 컨텍스트 메타데이터 저장
            const contextMetadata = { ...context };
            delete contextMetadata.items; // 아이템은 별도로 저장
            const contextFilePath = this.path.join(typeDir, `${context.id}.context.json`);
            this.fs.writeFileSync(contextFilePath, JSON.stringify(contextMetadata, null, 2), 'utf8');
            // 컨텍스트 아이템 디렉토리 생성
            const itemsDir = this.path.join(typeDir, context.id);
            if (!this.fs.existsSync(itemsDir)) {
                this.fs.mkdirSync(itemsDir, { recursive: true });
            }
            // 각 아이템 저장
            context.items.forEach(item => {
                this.saveItemToFileSystem(item, context.id, context.type);
            });
        }
        catch (error) {
            console.error(`컨텍스트 저장 오류 (${context.id}):`, error);
        }
    }
    /**
     * 아이템을 파일 시스템에 저장
     * @param item 저장할 아이템
     * @param contextId 컨텍스트 ID
     * @param contextType 컨텍스트 타입
     */
    saveItemToFileSystem(item, contextId, contextType) {
        try {
            // 아이템 디렉토리 경로
            const itemsDir = this.path.join(this.vaultDir, contextType, contextId);
            // 아이템 메타데이터 저장
            const itemMetadata = { ...item };
            const content = itemMetadata.content;
            delete itemMetadata.content; // 내용은 별도 파일로 저장
            const itemFilePath = this.path.join(itemsDir, `${item.id}.item.json`);
            this.fs.writeFileSync(itemFilePath, JSON.stringify(itemMetadata, null, 2), 'utf8');
            // 아이템 내용 저장
            const contentFilePath = this.path.join(itemsDir, `${item.id}.content.md`);
            this.fs.writeFileSync(contentFilePath, content, 'utf8');
        }
        catch (error) {
            console.error(`아이템 저장 오류 (${item.id}):`, error);
        }
    }
    /**
     * 모의 컨텍스트 데이터 로드
     */
    loadMockContexts() {
        this.contexts.clear();
        // 시스템 컨텍스트
        const systemContext = {
            id: 'system-context',
            name: '시스템 컨텍스트',
            description: '시스템 기본 컨텍스트입니다.',
            type: VaultContextType.System,
            createdAt: new Date('2023-01-01'),
            updatedAt: new Date('2023-01-01'),
            items: [
                {
                    id: 'system-item-1',
                    name: '기본 시스템 프롬프트',
                    description: '표준 시스템 프롬프트입니다.',
                    content: 'You are an AI assistant. Answer questions concisely and accurately.',
                    createdAt: new Date('2023-01-01'),
                    updatedAt: new Date('2023-01-01'),
                    contextType: VaultContextType.System,
                    contextId: 'system-context',
                    tags: ['system', 'default', 'prompt']
                },
                {
                    id: 'system-item-2',
                    name: '코드 리뷰 프롬프트',
                    description: '코드 리뷰용 시스템 프롬프트입니다.',
                    content: 'You are a code review assistant. Analyze the provided code and give feedback.',
                    createdAt: new Date('2023-01-02'),
                    updatedAt: new Date('2023-01-02'),
                    contextType: VaultContextType.System,
                    contextId: 'system-context',
                    tags: ['system', 'code-review', 'prompt']
                }
            ]
        };
        // 프로젝트 컨텍스트
        const projectContext = {
            id: 'project-context',
            name: 'APE 프로젝트 컨텍스트',
            description: 'APE 프로젝트 관련 컨텍스트입니다.',
            type: VaultContextType.Project,
            createdAt: new Date('2023-02-01'),
            updatedAt: new Date('2023-02-01'),
            items: [
                {
                    id: 'project-item-1',
                    name: '프로젝트 아키텍처',
                    description: 'APE 프로젝트 아키텍처 설명입니다.',
                    content: 'APE 프로젝트는 다음과 같은 구조로 이루어져 있습니다. Core 모듈, UI 모듈, 서비스 모듈...',
                    createdAt: new Date('2023-02-01'),
                    updatedAt: new Date('2023-02-01'),
                    contextType: VaultContextType.Project,
                    contextId: 'project-context',
                    tags: ['project', 'architecture', 'documentation']
                },
                {
                    id: 'project-item-2',
                    name: '개발 가이드라인',
                    description: '프로젝트 개발 가이드라인입니다.',
                    content: '코드 작성 시 다음 가이드라인을 따라주세요. 1. 함수는 단일 책임을 가집니다...',
                    createdAt: new Date('2023-02-02'),
                    updatedAt: new Date('2023-02-02'),
                    contextType: VaultContextType.Project,
                    contextId: 'project-context',
                    tags: ['project', 'guidelines', 'development']
                }
            ]
        };
        // 개인 컨텍스트
        const personalContext = {
            id: 'personal-context',
            name: '개인 컨텍스트',
            description: '개인적인 작업 맥락입니다.',
            type: VaultContextType.Personal,
            createdAt: new Date('2023-03-01'),
            updatedAt: new Date('2023-03-01'),
            items: [
                {
                    id: 'personal-item-1',
                    name: '내 작업 메모',
                    description: '현재 작업 메모입니다.',
                    content: '트리뷰 기능 구현 중이며, 다음 단계로 컨텍스트 처리 기능 구현 예정...',
                    createdAt: new Date('2023-03-01'),
                    updatedAt: new Date('2023-03-01'),
                    contextType: VaultContextType.Personal,
                    contextId: 'personal-context',
                    tags: ['personal', 'memo', 'work']
                }
            ]
        };
        // 공유 컨텍스트
        const sharedContext = {
            id: 'shared-context',
            name: '팀 공유 컨텍스트',
            description: '팀 간 공유되는 컨텍스트입니다.',
            type: VaultContextType.Shared,
            createdAt: new Date('2023-04-01'),
            updatedAt: new Date('2023-04-01'),
            items: [
                {
                    id: 'shared-item-1',
                    name: '팀 회의록',
                    description: '최근 팀 회의록입니다.',
                    content: '날짜: 2023-04-01\n참석자: ...\n안건: 프로젝트 진행 상황 공유 및 이슈 논의...',
                    createdAt: new Date('2023-04-01'),
                    updatedAt: new Date('2023-04-01'),
                    contextType: VaultContextType.Shared,
                    contextId: 'shared-context',
                    tags: ['shared', 'meeting', 'team']
                }
            ]
        };
        // 템플릿 컨텍스트
        const templateContext = {
            id: 'template-context',
            name: '템플릿 컨텍스트',
            description: '재사용 가능한 템플릿 모음입니다.',
            type: VaultContextType.Template,
            createdAt: new Date('2023-05-01'),
            updatedAt: new Date('2023-05-01'),
            items: [
                {
                    id: 'template-item-1',
                    name: '코드 생성 템플릿',
                    description: '표준 코드 생성 템플릿입니다.',
                    content: '다음 템플릿을 사용하여 [기능명]을 구현하는 코드를 생성해주세요...',
                    createdAt: new Date('2023-05-01'),
                    updatedAt: new Date('2023-05-01'),
                    contextType: VaultContextType.Template,
                    contextId: 'template-context',
                    tags: ['template', 'code-generation']
                },
                {
                    id: 'template-item-2',
                    name: '문서 템플릿',
                    description: '기술 문서 템플릿입니다.',
                    content: '# [문서 제목]\n\n## 개요\n\n## 아키텍처\n\n## 기능 설명\n\n## 주의사항',
                    createdAt: new Date('2023-05-02'),
                    updatedAt: new Date('2023-05-02'),
                    contextType: VaultContextType.Template,
                    contextId: 'template-context',
                    tags: ['template', 'documentation']
                }
            ]
        };
        // 컨텍스트 맵에 추가
        this.contexts.set(systemContext.id, systemContext);
        this.contexts.set(projectContext.id, projectContext);
        this.contexts.set(personalContext.id, personalContext);
        this.contexts.set(sharedContext.id, sharedContext);
        this.contexts.set(templateContext.id, templateContext);
    }
    /**
     * 모든 컨텍스트 가져오기
     */
    getAllContexts() {
        return Array.from(this.contexts.values());
    }
    /**
     * 컨텍스트 타입별 컨텍스트 가져오기
     * @param type 컨텍스트 타입
     */
    getContextsByType(type) {
        return Array.from(this.contexts.values()).filter(context => context.type === type);
    }
    /**
     * 컨텍스트 ID로 컨텍스트 가져오기
     * @param contextId 컨텍스트 ID
     */
    getContextById(contextId) {
        return this.contexts.get(contextId);
    }
    /**
     * 컨텍스트 생성
     * @param name 컨텍스트 이름
     * @param type 컨텍스트 타입
     * @param description 설명 (선택)
     */
    async createContext(name, type, description) {
        try {
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT 서비스가 비활성화되어 있습니다.', 'vault-disabled');
            }
            const newContext = {
                id: `${type}-${Date.now()}`,
                name,
                description,
                type,
                createdAt: new Date(),
                updatedAt: new Date(),
                items: []
            };
            if (!config.useMock) {
                // 파일 시스템에 컨텍스트 저장
                this.saveContextToFileSystem(newContext);
            }
            // 컨텍스트 맵에 추가
            this.contexts.set(newContext.id, newContext);
            // 변경 이벤트 발생
            this._onDidChangeVault.fire();
            return newContext;
        }
        catch (error) {
            console.error('VAULT 컨텍스트 생성 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT 컨텍스트 생성 중 오류가 발생했습니다: ${error}`, 'vault-context-creation-failed');
        }
    }
    /**
     * 컨텍스트 업데이트
     * @param contextId 컨텍스트 ID
     * @param updates 업데이트할 필드
     */
    async updateContext(contextId, updates) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID가 ${contextId}인 컨텍스트를 찾을 수 없습니다.`, 'vault-context-not-found');
            }
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT 서비스가 비활성화되어 있습니다.', 'vault-disabled');
            }
            // 컨텍스트 업데이트
            const updatedContext = {
                ...context,
                ...updates,
                updatedAt: new Date()
            };
            if (!config.useMock) {
                // 파일 시스템에 업데이트된 컨텍스트 저장
                this.saveContextToFileSystem(updatedContext);
            }
            // 컨텍스트 맵 업데이트
            this.contexts.set(contextId, updatedContext);
            // 변경 이벤트 발생
            this._onDidChangeVault.fire();
            return updatedContext;
        }
        catch (error) {
            console.error('VAULT 컨텍스트 업데이트 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT 컨텍스트 업데이트 중 오류가 발생했습니다: ${error}`, 'vault-context-update-failed');
        }
    }
    /**
     * 컨텍스트 삭제
     * @param contextId 컨텍스트 ID
     */
    async deleteContext(contextId) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID가 ${contextId}인 컨텍스트를 찾을 수 없습니다.`, 'vault-context-not-found');
            }
            // 시스템 컨텍스트는 삭제 불가
            if (context.type === VaultContextType.System) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('시스템 컨텍스트는 삭제할 수 없습니다.', 'vault-system-context-deletion-forbidden');
            }
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT 서비스가 비활성화되어 있습니다.', 'vault-disabled');
            }
            if (!config.useMock) {
                // 파일 시스템에서 컨텍스트 삭제
                this.deleteContextFromFileSystem(context);
            }
            // 컨텍스트 맵에서 제거
            this.contexts.delete(contextId);
            // 변경 이벤트 발생
            this._onDidChangeVault.fire();
            return true;
        }
        catch (error) {
            console.error('VAULT 컨텍스트 삭제 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT 컨텍스트 삭제 중 오류가 발생했습니다: ${error}`, 'vault-context-deletion-failed');
        }
    }
    /**
     * 파일 시스템에서 컨텍스트 삭제
     * @param context 삭제할 컨텍스트
     */
    deleteContextFromFileSystem(context) {
        try {
            // 컨텍스트 타입 디렉토리 경로
            const typeDir = this.path.join(this.vaultDir, context.type);
            // 컨텍스트 메타데이터 파일 삭제
            const contextFilePath = this.path.join(typeDir, `${context.id}.context.json`);
            if (this.fs.existsSync(contextFilePath)) {
                this.fs.unlinkSync(contextFilePath);
            }
            // 컨텍스트 아이템 디렉토리 삭제 (재귀적으로)
            const itemsDir = this.path.join(typeDir, context.id);
            if (this.fs.existsSync(itemsDir)) {
                this.deleteDirectoryRecursive(itemsDir);
            }
        }
        catch (error) {
            console.error(`컨텍스트 파일 삭제 오류 (${context.id}):`, error);
            throw error;
        }
    }
    /**
     * 디렉토리 재귀적 삭제
     * @param dirPath 삭제할 디렉토리 경로
     */
    deleteDirectoryRecursive(dirPath) {
        if (this.fs.existsSync(dirPath)) {
            this.fs.readdirSync(dirPath).forEach((file) => {
                const curPath = this.path.join(dirPath, file);
                if (this.fs.lstatSync(curPath).isDirectory()) {
                    // 재귀적 호출로 하위 디렉토리 삭제
                    this.deleteDirectoryRecursive(curPath);
                }
                else {
                    // 파일 삭제
                    this.fs.unlinkSync(curPath);
                }
            });
            // 디렉토리 자체 삭제
            this.fs.rmdirSync(dirPath);
        }
    }
    /**
     * 아이템 생성
     * @param contextId 컨텍스트 ID
     * @param item 아이템 정보
     */
    async createItem(contextId, item) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID가 ${contextId}인 컨텍스트를 찾을 수 없습니다.`, 'vault-context-not-found');
            }
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT 서비스가 비활성화되어 있습니다.', 'vault-disabled');
            }
            const newItem = {
                ...item,
                id: `${contextId}-item-${Date.now()}`,
                createdAt: new Date(),
                updatedAt: new Date(),
                contextId: contextId
            };
            if (!config.useMock) {
                // 파일 시스템에 아이템 저장
                this.saveItemToFileSystem(newItem, contextId, context.type);
            }
            // 컨텍스트 아이템 추가
            context.items.push(newItem);
            context.updatedAt = new Date();
            // 변경 이벤트 발생
            this._onDidChangeVault.fire();
            return newItem;
        }
        catch (error) {
            console.error('VAULT 아이템 생성 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT 아이템 생성 중 오류가 발생했습니다: ${error}`, 'vault-item-creation-failed');
        }
    }
    /**
     * 아이템 업데이트
     * @param contextId 컨텍스트 ID
     * @param itemId 아이템 ID
     * @param updates 업데이트할 필드
     */
    async updateItem(contextId, itemId, updates) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID가 ${contextId}인 컨텍스트를 찾을 수 없습니다.`, 'vault-context-not-found');
            }
            const itemIndex = context.items.findIndex(item => item.id === itemId);
            if (itemIndex === -1) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID가 ${itemId}인 아이템을 찾을 수 없습니다.`, 'vault-item-not-found');
            }
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT 서비스가 비활성화되어 있습니다.', 'vault-disabled');
            }
            // 아이템 업데이트
            const item = context.items[itemIndex];
            const updatedItem = {
                ...item,
                ...updates,
                updatedAt: new Date()
            };
            if (!config.useMock) {
                // 파일 시스템에 업데이트된 아이템 저장
                this.saveItemToFileSystem(updatedItem, contextId, context.type);
            }
            // 컨텍스트 아이템 업데이트
            context.items[itemIndex] = updatedItem;
            context.updatedAt = new Date();
            // 변경 이벤트 발생
            this._onDidChangeVault.fire();
            return updatedItem;
        }
        catch (error) {
            console.error('VAULT 아이템 업데이트 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT 아이템 업데이트 중 오류가 발생했습니다: ${error}`, 'vault-item-update-failed');
        }
    }
    /**
     * 아이템 삭제
     * @param contextId 컨텍스트 ID
     * @param itemId 아이템 ID
     */
    async deleteItem(contextId, itemId) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID가 ${contextId}인 컨텍스트를 찾을 수 없습니다.`, 'vault-context-not-found');
            }
            const itemIndex = context.items.findIndex(item => item.id === itemId);
            if (itemIndex === -1) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID가 ${itemId}인 아이템을 찾을 수 없습니다.`, 'vault-item-not-found');
            }
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT 서비스가 비활성화되어 있습니다.', 'vault-disabled');
            }
            if (!config.useMock) {
                // 파일 시스템에서 아이템 삭제
                this.deleteItemFromFileSystem(context.items[itemIndex], contextId, context.type);
            }
            // 컨텍스트 아이템 삭제
            context.items.splice(itemIndex, 1);
            context.updatedAt = new Date();
            // 변경 이벤트 발생
            this._onDidChangeVault.fire();
            return true;
        }
        catch (error) {
            console.error('VAULT 아이템 삭제 오류:', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT 아이템 삭제 중 오류가 발생했습니다: ${error}`, 'vault-item-deletion-failed');
        }
    }
    /**
     * 파일 시스템에서 아이템 삭제
     * @param item 삭제할 아이템
     * @param contextId 컨텍스트 ID
     * @param contextType 컨텍스트 타입
     */
    deleteItemFromFileSystem(item, contextId, contextType) {
        try {
            // 아이템 디렉토리 경로
            const itemsDir = this.path.join(this.vaultDir, contextType, contextId);
            // 아이템 메타데이터 파일 삭제
            const itemFilePath = this.path.join(itemsDir, `${item.id}.item.json`);
            if (this.fs.existsSync(itemFilePath)) {
                this.fs.unlinkSync(itemFilePath);
            }
            // 아이템 내용 파일 삭제
            const contentFilePath = this.path.join(itemsDir, `${item.id}.content.md`);
            if (this.fs.existsSync(contentFilePath)) {
                this.fs.unlinkSync(contentFilePath);
            }
        }
        catch (error) {
            console.error(`아이템 파일 삭제 오류 (${item.id}):`, error);
            throw error;
        }
    }
    /**
     * 아이템 검색
     * @param query 검색어
     * @param filters 필터 (컨텍스트 타입, 태그 등)
     */
    searchItems(query, filters) {
        const allContexts = this.getAllContexts();
        let filteredContexts = allContexts;
        // 컨텍스트 타입 필터링
        if (filters?.contextTypes && filters.contextTypes.length > 0) {
            filteredContexts = filteredContexts.filter(context => filters.contextTypes.includes(context.type));
        }
        // 컨텍스트 ID 필터링
        if (filters?.contextIds && filters.contextIds.length > 0) {
            filteredContexts = filteredContexts.filter(context => filters.contextIds.includes(context.id));
        }
        // 모든 아이템 가져오기
        let items = filteredContexts.flatMap(context => context.items);
        // 태그 필터링
        if (filters?.tags && filters.tags.length > 0) {
            items = items.filter(item => {
                if (!item.tags)
                    return false;
                return filters.tags.some(tag => item.tags.includes(tag));
            });
        }
        // 검색어가 있는 경우 아이템 검색
        if (query) {
            const lowerQuery = query.toLowerCase();
            items = items.filter(item => item.name.toLowerCase().includes(lowerQuery) ||
                (item.description && item.description.toLowerCase().includes(lowerQuery)) ||
                item.content.toLowerCase().includes(lowerQuery) ||
                (item.tags && item.tags.some(tag => tag.toLowerCase().includes(lowerQuery))));
        }
        return items;
    }
    /**
     * 아이템을 LLM 컨텍스트로 변환
     * @param item 아이템
     */
    itemToLLMContext(item) {
        // 기본 형식: 아이템 내용 그대로 반환
        return item.content;
    }
    /**
     * 리소스 해제
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/services/versionManager.ts":
/*!*********************************************!*\
  !*** ./src/core/services/versionManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VersionManager: () => (/* binding */ VersionManager),
/* harmony export */   VersionType: () => (/* binding */ VersionType)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _serviceError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serviceError */ "./src/core/services/serviceError.ts");




/**
 * 시맨틱 버전 규칙에 따른 버전 종류
 */
var VersionType;
(function (VersionType) {
    /**
     * 패치 버전: 버그 수정 및 마이너 변경 (0.0.1)
     */
    VersionType["PATCH"] = "patch";
    /**
     * 마이너 버전: 하위 호환성 있는 새 기능 추가 (0.1.0)
     */
    VersionType["MINOR"] = "minor";
    /**
     * 메이저 버전: 주요 기능 또는 하위 호환성이 없는 변경 (1.0.0)
     */
    VersionType["MAJOR"] = "major";
})(VersionType || (VersionType = {}));
/**
 * 버전 관리 서비스
 * - 프로젝트 버전 관리
 * - 버전 업데이트 (patch, minor, major)
 * - Git 태그 생성
 */
class VersionManager {
    _extensionContext;
    constructor(context) {
        this._extensionContext = context;
    }
    /**
     * 현재 프로젝트 버전 정보 조회
     * @returns 버전 정보
     */
    async getCurrentVersion() {
        try {
            const packageJsonPath = this.getPackageJsonPath();
            const packageJson = await this.readPackageJson(packageJsonPath);
            const version = packageJson.version || '0.0.0';
            const versionParts = this.parseVersion(version);
            return {
                version,
                packageJsonPath,
                versionParts
            };
        }
        catch (error) {
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError('버전 정보를 읽어오는 중 오류가 발생했습니다.', error);
        }
    }
    /**
     * 버전 업데이트
     * @param type 버전 업데이트 유형 (patch, minor, major)
     * @param message 버전 업데이트 이유/메시지
     * @param createGitTag Git 태그 생성 여부
     * @returns 업데이트된 버전 정보
     */
    async updateVersion(type, message, createGitTag = false) {
        try {
            // 현재 버전 정보 조회
            const currentVersionInfo = await this.getCurrentVersion();
            const { versionParts, packageJsonPath } = currentVersionInfo;
            // 새 버전 계산
            const newVersionParts = [...versionParts];
            switch (type) {
                case VersionType.PATCH:
                    newVersionParts[2] += 1;
                    break;
                case VersionType.MINOR:
                    newVersionParts[1] += 1;
                    newVersionParts[2] = 0;
                    break;
                case VersionType.MAJOR:
                    newVersionParts[0] += 1;
                    newVersionParts[1] = 0;
                    newVersionParts[2] = 0;
                    break;
            }
            const newVersion = newVersionParts.join('.');
            // package.json 업데이트
            await this.updatePackageJsonVersion(packageJsonPath, newVersion);
            // Git 태그 생성 (옵션)
            if (createGitTag) {
                await this.createGitTag(newVersion, message);
            }
            // 상태바 업데이트
            this.updateStatusBar(newVersion);
            // 결과 반환
            return {
                version: newVersion,
                packageJsonPath,
                versionParts: newVersionParts
            };
        }
        catch (error) {
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError('버전 업데이트 중 오류가 발생했습니다.', error);
        }
    }
    /**
     * Git 태그 생성
     * @param version 버전 문자열
     * @param message 태그 메시지
     */
    async createGitTag(version, message) {
        try {
            const tagName = `v${version}`;
            const tagMessage = message || `Version ${version}`;
            // Git 태그 명령 실행
            const terminal = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createTerminal('APE Version Manager');
            terminal.sendText(`git tag -a "${tagName}" -m "${tagMessage}"`);
            terminal.sendText('git push --tags');
            terminal.show();
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Created Git tag: ${tagName}`);
        }
        catch (error) {
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError('Git 태그 생성 중 오류가 발생했습니다.', error);
        }
    }
    /**
     * 버전 관리 명령어 등록
     */
    registerCommands() {
        // 내부 개발용 명령어만 등록
        this._extensionContext.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.internal.version.bump.patch', async () => {
            await this.bumpVersion(VersionType.PATCH);
        }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.internal.version.bump.minor', async () => {
            await this.bumpVersion(VersionType.MINOR);
        }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.internal.version.bump.major', async () => {
            await this.bumpVersion(VersionType.MAJOR);
        }));
    }
    /**
     * VS Code 상태 표시줄에 버전 표시
     * @param version 버전 문자열
     */
    updateStatusBar(version) {
        // 상태 표시줄 아이템이 이미 있는지 확인
        const statusBarItem = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createStatusBarItem(vscode__WEBPACK_IMPORTED_MODULE_0__.StatusBarAlignment.Right, 100);
        statusBarItem.text = `$(tag) APE v${version}`;
        statusBarItem.tooltip = 'APE Extension Version';
        statusBarItem.show();
        // Extension Context에 상태 표시줄 아이템 등록
        this._extensionContext.subscriptions.push(statusBarItem);
    }
    /**
     * 버전 증가 작업 수행
     * @param type 버전 증가 유형
     */
    async bumpVersion(type) {
        try {
            // 메시지 입력 받기
            const message = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: '버전 업데이트 메시지를 입력하세요',
                placeHolder: '예: 스트리밍 채팅 UI 개선'
            });
            if (message === undefined) {
                return; // 취소됨
            }
            // Git 태그 생성 여부 확인
            const createTag = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(['Yes', 'No'], {
                placeHolder: 'Git 태그를 생성하시겠습니까?'
            });
            if (createTag === undefined) {
                return; // 취소됨
            }
            // 버전 업데이트
            const newVersionInfo = await this.updateVersion(type, message, createTag === 'Yes');
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`버전이 ${newVersionInfo.version}(으)로 업데이트되었습니다.`);
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`버전 업데이트 실패: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * package.json 경로 조회
     */
    getPackageJsonPath() {
        return path__WEBPACK_IMPORTED_MODULE_2__.join(this._extensionContext.extensionPath, 'package.json');
    }
    /**
     * package.json 파일 읽기
     * @param filePath package.json 파일 경로
     */
    async readPackageJson(filePath) {
        return new Promise((resolve, reject) => {
            fs__WEBPACK_IMPORTED_MODULE_1__.readFile(filePath, 'utf8', (err, data) => {
                if (err) {
                    reject(err);
                    return;
                }
                try {
                    const packageJson = JSON.parse(data);
                    resolve(packageJson);
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
    /**
     * package.json 버전 업데이트
     * @param filePath package.json 파일 경로
     * @param newVersion 새 버전 문자열
     */
    async updatePackageJsonVersion(filePath, newVersion) {
        return new Promise((resolve, reject) => {
            fs__WEBPACK_IMPORTED_MODULE_1__.readFile(filePath, 'utf8', (err, data) => {
                if (err) {
                    reject(err);
                    return;
                }
                try {
                    const packageJson = JSON.parse(data);
                    packageJson.version = newVersion;
                    const updatedContent = JSON.stringify(packageJson, null, 2);
                    fs__WEBPACK_IMPORTED_MODULE_1__.writeFile(filePath, updatedContent, 'utf8', (writeErr) => {
                        if (writeErr) {
                            reject(writeErr);
                            return;
                        }
                        resolve();
                    });
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
    /**
     * 버전 문자열 파싱
     * @param version 버전 문자열 (x.y.z 형식)
     * @returns [major, minor, patch] 숫자 배열
     */
    parseVersion(version) {
        const parts = version.split('.').map(part => parseInt(part, 10));
        // 배열이 3개 요소를 갖도록 보장
        while (parts.length < 3) {
            parts.push(0);
        }
        return parts;
    }
}


/***/ }),

/***/ "./src/data/helpSystemPrompt.ts":
/*!**************************************!*\
  !*** ./src/data/helpSystemPrompt.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CODE_HELP_PROMPT: () => (/* binding */ CODE_HELP_PROMPT),
/* harmony export */   GIT_HELP_PROMPT: () => (/* binding */ GIT_HELP_PROMPT),
/* harmony export */   HELP_SYSTEM_PROMPT: () => (/* binding */ HELP_SYSTEM_PROMPT),
/* harmony export */   generateCommandDetailPrompt: () => (/* binding */ generateCommandDetailPrompt),
/* harmony export */   generateFaqPrompt: () => (/* binding */ generateFaqPrompt),
/* harmony export */   generateGuidePrompt: () => (/* binding */ generateGuidePrompt),
/* harmony export */   generateGuidesListPrompt: () => (/* binding */ generateGuidesListPrompt),
/* harmony export */   generateHelpSystemPrompt: () => (/* binding */ generateHelpSystemPrompt)
/* harmony export */ });
/**
 * 도움말 시스템 프롬프트
 *
 * 이 파일은 LLM을 통한 스마트 도움말 시스템에 사용될 프롬프트를 정의합니다.
 */
/**
 * 기본 도움말 시스템 프롬프트
 */
const HELP_SYSTEM_PROMPT = `
당신은 APE(Agentic Pipeline Engine) VS Code 확장 프로그램의 AI 비서입니다.
사용자에게 사용 가능한 명령어와 기능을 안내하고 도움을 제공해주세요.

# 명령어 목록

## 일반 명령어
- /help, /? - 이 도움말 표시
- /clear, /cls - 채팅 내역 지우기
- /settings, /config - 설정 페이지 열기
- /model [모델명] - LLM 모델 변경 (예: /model NARRNAS, /model list)

## Git 명령어
- /git status - Git 상태 확인
- /git commit - 변경사항 자동 커밋 (메시지 자동 생성)
- /git push - 원격 저장소에 푸시
- /git pull - 원격 저장소에서 풀
- /git solve - 충돌 자동 해결
- /git auto - 자동 커밋 기능 토글
- /git consolidate - 임시 커밋 통합

## 코드 명령어
- /analyze, /code - 선택한 코드 분석
- /open, /file - 지정한 파일 열기

# 특수 기능
- 인라인 코드 완성: 코드 작성 중 자동으로 다음 코드 제안
- 탭 완성: 탭 키를 눌러 코드 완성 활성화
- 코드 영역 별도 표시: 코드 블록 아래 복사, 삽입, 새 파일 생성 버튼 제공
- 컨텍스트 인식 명령어: 현재 작업 환경에 맞는 명령어 자동 제안

# 기타 정보
- 버전: v0.3.0
- 개발자: APE 프로젝트 팀

자세한 사용법과 예제는 각 명령어 설명에 포함되어 있습니다.
`;
/**
 * 코드 관련 도움말 프롬프트
 */
const CODE_HELP_PROMPT = `
# 코드 처리 명령어 사용법

## 코드 분석
- /analyze, /code - 선택한 코드를 분석하고 설명합니다.
  예: (코드 선택 후) /analyze

## 코드 최적화
- /optimize - 선택한 코드를 최적화하고 개선합니다.
  예: (코드 선택 후) /optimize

## 코드 리팩토링
- /refactor - 선택한 코드를 리팩토링하여 품질을 개선합니다.
  예: (코드 선택 후) /refactor

## 코드 설명
- /explain - 선택한 코드의 기능과 동작을 설명합니다.
  예: (코드 선택 후) /explain

# 코드 블록 기능

## 코드 블록 작업
- 복사 버튼: 코드 블록 내용을 클립보드에 복사합니다.
- 삽입 버튼: 코드 블록 내용을 현재 편집기에 삽입합니다.
- 새 파일 버튼: 코드 블록 내용으로 새 파일을 생성합니다.

## 코드 작성 요청
다음과 같이 요청하여 특정 코드를 생성할 수 있습니다:
- "TypeScript로 정렬 알고리즘 작성해줄"
- "Python으로 파일 읽기 예제 보여줄"
- "Java로 HTTP 클라이언트 구현해줄"
`;
/**
 * Git 관련 도움말 프롬프트
 */
const GIT_HELP_PROMPT = `
# Git 명령어 사용법

## 기본 Git 명령어
- /git status - 현재 Git 저장소의 상태를 확인합니다.
- /git commit - 변경된 파일을 자동으로 커밋합니다. 커밋 메시지는 변경 내용을 분석하여 자동 생성됩니다.
- /git push - 현재 브랜치의 변경사항을 원격 저장소에 푸시합니다.
- /git pull - 원격 저장소의 변경사항을 현재 브랜치로 가져옵니다.

## 고급 Git 명령어
- /git solve - 충돌이 발생한 파일을 자동으로 해결합니다.
- /git branch [이름] - 새 브랜치를 생성하거나 브랜치 목록을 표시합니다.
- /git auto [on|off] - 자동 커밋 기능을 켜거나 끗니다. 활성화되면 파일 저장 시 자동으로 커밋됩니다.
- /git consolidate - '[APE][Temporary]' 접두사가 붙은 연속된 임시 커밋을 하나의 정식 커밋으로 통합합니다.

## 예제
- 현재 상태 확인: /git status
- 변경사항 커밋: /git commit
- 자동 커밋 켜기: /git auto on
- 임시 커밋 통합: /git consolidate

## 참고사항
- 자동 커밋 메시지는 변경 내용을 분석하여 생성됩니다.
- 충돌 해결은 AI 기반으로 진행되며, 복잡한 충돌은 수동 개입이 필요할 수 있습니다.
- 브랜치 생성 시 현재 체크아웃된 브랜치에서 분기됩니다.
`;
/**
 * 도움말 시스템 프롬프트 생성
 * @param helpData 도움말 데이터 객체
 * @param query 사용자 질문
 * @returns LLM에 전달할 프롬프트
 */
function generateHelpSystemPrompt(helpData, query) {
    return `
# APE 도움말 시스템 - LLM 응답 가이드

당신은 APE(Agentic Pipeline Extension)의 도움말 시스템입니다. 사용자의 질문에 대해 제공된 도움말 데이터 내에서만 정보를 찾아 응답해야 합니다. 제공된 정보에 없는 내용은 절대 추가하지 마세요.

## 응답 지침

1. 사용자 질문을 정확하게 이해하고 관련 정보만 제공하세요.
2. 제공된 도움말 데이터에 없는 내용은 "해당 정보는 제공된 도움말에 포함되어 있지 않습니다."라고 응답하세요.
3. 명령어 관련 질문에는 사용법, 예시, 상세 설명을 포함하세요.
4. 응답은 간결하고 명확하게 작성하되, 필요한 모든 정보는 포함해야 합니다.
5. 적절한 마크다운 형식을 사용하여 가독성을 높이세요.
6. 질문이 일반적인 프로그래밍이나 도구에 관한 것이라면, 반드시 APE 컨텍스트 내에서만 답변하세요.

## 도움말 데이터

이 데이터를 기반으로 사용자 질문에 응답하세요:

${JSON.stringify(helpData, null, 2)}

## 사용자 질문

사용자: ${query}

## 응답 형식

응답 시 다음 형식을 따르세요:

1. 질문 요약 또는 주제를 최상단에 H1 또는 H2 제목으로 표시
2. 관련 명령어가 있다면 코드 블록으로 표시 (\`/command\`)
3. 필요한 경우 단계별 안내 제공
4. 관련 명령어나 가이드가 있다면 "관련 명령어" 또는 "더 알아보기" 섹션 추가

답변을 시작하세요.
`;
}
/**
 * 명령어에 대한 상세 프롬프트 생성
 * @param commandData 명령어 데이터
 * @returns LLM에 전달할 프롬프트
 */
function generateCommandDetailPrompt(commandData) {
    return `
# APE 명령어 상세 정보 - LLM 응답 가이드

당신은 APE(Agentic Pipeline Extension)의 도움말 시스템입니다. 다음 명령어의 상세 정보를 제공해야 합니다.

## 명령어 데이터

${JSON.stringify(commandData, null, 2)}

## 응답 지침

다음 형식으로 명령어 상세 정보를 제공하세요:

1. 명령어 이름과 간단한 설명을 H1 제목으로 표시
2. 사용법을 코드 블록으로 표시
3. 상세 설명 제공
4. 예시 명령어 나열
5. 별칭 목록 제공
6. 관련 명령어 제안

답변은 마크다운 형식으로 작성하세요. 제공된 데이터에 없는 내용을 추가하지 마세요.

답변을 시작하세요.
`;
}
/**
 * FAQ 질문에 대한 프롬프트 생성
 * @param faqData FAQ 데이터
 * @param query 사용자 질문
 * @returns LLM에 전달할 프롬프트
 */
function generateFaqPrompt(faqData, query) {
    return `
# APE FAQ 응답 가이드

당신은 APE(Agentic Pipeline Extension)의 FAQ 시스템입니다. 사용자의 질문과 가장 관련성 높은 FAQ 항목을 찾아 응답해야 합니다.

## FAQ 데이터

${JSON.stringify(faqData, null, 2)}

## 사용자 질문

사용자: ${query}

## 응답 지침

1. 질문과 가장 관련성 높은 FAQ 항목(들)을 찾으세요.
2. FAQ 내용을 기반으로 응답하되, 질문에 맞게 약간 조정할 수 있습니다.
3. 관련 FAQ가 없다면 "해당 질문에 관한 FAQ 항목이 없습니다."라고 응답하세요.
4. 관련 명령어가 있다면 함께 제안하세요.

답변을 마크다운 형식으로 작성하세요.

답변을 시작하세요.
`;
}
/**
 * 가이드 문서에 대한 프롬프트 생성
 * @param guideData 가이드 문서 데이터
 * @param guideId 가이드 ID
 * @returns LLM에 전달할 프롬프트
 */
function generateGuidePrompt(guideData, guideId) {
    const guide = guideData.find(g => g.id === guideId);
    if (!guide) {
        return `
# APE 가이드 문서 에러

요청하신 가이드 문서(ID: ${guideId})를 찾을 수 없습니다. 다음 가이드 문서가 사용 가능합니다:

${guideData.map(g => `- ${g.id}: ${g.title}`).join('\n')}

올바른 가이드 ID를 선택하여 다시 요청해주세요.
`;
    }
    return `
# APE 가이드 문서 - ${guide.title}

다음 가이드 문서 내용을 마크다운 형식으로 정리하여 제공하세요:

${guide.content}

답변 시 다음 사항을 고려하세요:
1. 문서 형식과 구조를 유지하세요.
2. 내용을 변경하거나 추가하지 마세요.
3. 필요한 경우 마크다운 형식을 향상시켜 가독성을 높이세요.
4. 코드 예제와 명령어는 적절한 코드 블록으로 표시하세요.

답변을 시작하세요.
`;
}
/**
 * 모든 가이드 목록 프롬프트 생성
 * @param guideData 가이드 문서 데이터
 * @returns LLM에 전달할 프롬프트
 */
function generateGuidesListPrompt(guideData) {
    return `
# APE 가이드 문서 목록

다음 APE 가이드 문서 목록을 마크다운 형식으로 정리하여 제공하세요:

${JSON.stringify(guideData, null, 2)}

각 가이드에 대해 다음 정보를 포함하세요:
1. 가이드 제목
2. 짧은 설명 (가능한 경우)
3. 가이드 ID (사용자가 특정 가이드를 요청할 때 사용)

답변 형식:

## APE 가이드 문서

다음 가이드 문서를 이용할 수 있습니다:

1. **[가이드 제목 1]**
   - ID: [가이드 ID]
   - [짧은 설명]

2. **[가이드 제목 2]**
   - ID: [가이드 ID]
   - [짧은 설명]

특정 가이드 문서를 보려면 "/help guide [가이드 ID]" 명령어를 사용하세요.
예시: /help guide auto-commit

답변을 시작하세요.
`;
}


/***/ }),

/***/ "./src/plugins/core sync recursive":
/*!********************************!*\
  !*** ./src/plugins/core/ sync ***!
  \********************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./src/plugins/core sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./src/plugins/core/api.ts":
/*!*********************************!*\
  !*** ./src/plugins/core/api.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PluginAPIImpl: () => (/* binding */ PluginAPIImpl)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Implementation of the LLM Service API
 */
class LLMServiceAPIImpl {
    _llmService;
    constructor(_llmService) {
        this._llmService = _llmService;
    }
    /**
     * Get currently active LLM model
     * @returns Active LLM model
     */
    getActiveModel() {
        return this._llmService.getActiveModel();
    }
    /**
     * Set active LLM model
     * @param model Model to set as active
     */
    setActiveModel(model) {
        this._llmService.setActiveModel(model);
    }
    /**
     * Get available LLM models
     * @returns Array of available models
     */
    getAvailableModels() {
        return this._llmService.getAvailableModels();
    }
    /**
     * Send a request to the LLM
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to a service result containing the response
     */
    async sendRequest(messages, options) {
        return await this._llmService.sendRequest(messages, options);
    }
    /**
     * Stream a response from the LLM
     * @param messages Messages to send
     * @param onChunk Callback for each chunk of the response
     * @param options Request options
     * @returns Promise that resolves to a service result indicating success
     */
    async streamResponse(messages, onChunk, options) {
        return await this._llmService.streamResponse(messages, onChunk, options);
    }
    /**
     * Cancel an ongoing streaming response
     */
    cancelStream() {
        this._llmService.cancelStream();
    }
}
/**
 * Implementation of the Memory Service API
 */
class MemoryServiceAPIImpl {
    _memoryService;
    constructor(_memoryService) {
        this._memoryService = _memoryService;
    }
    /**
     * Get current session ID
     * @returns Current session ID or null if no session is active
     */
    getCurrentSessionId() {
        return this._memoryService.getCurrentSessionId();
    }
    /**
     * Get messages from current session
     * @returns Promise that resolves to a service result containing messages
     */
    async getMessages() {
        return await this._memoryService.getMessages();
    }
    /**
     * Add a message to the current session
     * @param message Message to add
     * @returns Promise that resolves to a service result indicating success
     */
    async addMessage(message) {
        return await this._memoryService.addMessage(message);
    }
    /**
     * Create a new session
     * @param options Session creation options
     * @returns Promise that resolves to a service result containing the session ID
     */
    async createSession(options) {
        return await this._memoryService.createSession(options.name, { metadata: options.metadata });
    }
    /**
     * Switch to a different session
     * @param sessionId Session ID to switch to
     * @returns Promise that resolves to a service result indicating success
     */
    async switchSession(sessionId) {
        return await this._memoryService.switchSession(sessionId);
    }
    /**
     * Get all available sessions
     * @returns Promise that resolves to a service result containing session summaries
     */
    async getSessions() {
        const result = await this._memoryService.getSessions();
        if (result.success && result.data) {
            const simplifiedSessions = result.data.map(session => ({
                id: session.id,
                name: session.name,
                messageCount: session.messageCount,
                updatedAt: session.updatedAt
            }));
            return {
                success: true,
                data: simplifiedSessions
            };
        }
        return result;
    }
    /**
     * Clear messages from current session
     * @returns Promise that resolves to a service result indicating success
     */
    async clearMessages() {
        return await this._memoryService.clearMessages();
    }
}
/**
 * Implementation of the UI Service API
 */
class UIServiceAPIImpl {
    /**
     * Show an information message
     * @param message Message to show
     * @param items Items to include in the message
     * @returns Promise that resolves to the selected item
     */
    async showInformationMessage(message, ...items) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(message, ...items);
    }
    /**
     * Show a warning message
     * @param message Message to show
     * @param items Items to include in the message
     * @returns Promise that resolves to the selected item
     */
    async showWarningMessage(message, ...items) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage(message, ...items);
    }
    /**
     * Show an error message
     * @param message Message to show
     * @param items Items to include in the message
     * @returns Promise that resolves to the selected item
     */
    async showErrorMessage(message, ...items) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(message, ...items);
    }
    /**
     * Show quick pick selection
     * @param items Items to show in the quick pick
     * @param options Quick pick options
     * @returns Promise that resolves to the selected item
     */
    async showQuickPick(items, options) {
        // Convert string items to QuickPickItems if needed
        const quickPickItems = Array.isArray(items) && items.length > 0 && typeof items[0] === 'string'
            ? items.map(item => ({ label: item }))
            : items;
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(quickPickItems, options);
    }
    /**
     * Show input box
     * @param options Input box options
     * @returns Promise that resolves to the entered text
     */
    async showInputBox(options) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox(options);
    }
    /**
     * Create and show a webview panel
     * @param viewType Type of the webview
     * @param title Title of the webview
     * @param options Webview options
     * @returns The created webview panel
     */
    createWebviewPanel(viewType, title, options) {
        const viewColumn = options?.viewColumn || vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.Active;
        const preserveFocus = options?.preserveFocus || false;
        return vscode__WEBPACK_IMPORTED_MODULE_0__.window.createWebviewPanel(viewType, title, { viewColumn, preserveFocus });
    }
    /**
     * Create status bar item
     * @param options Status bar item options
     * @returns The created status bar item
     */
    createStatusBarItem(options) {
        const alignment = options?.alignment || vscode__WEBPACK_IMPORTED_MODULE_0__.StatusBarAlignment.Left;
        const priority = options?.priority || 0;
        return vscode__WEBPACK_IMPORTED_MODULE_0__.window.createStatusBarItem(alignment, priority);
    }
}
/**
 * Implementation of the File System API
 */
class FileSystemAPIImpl {
    /**
     * Read file contents
     * @param uri File URI
     * @returns Promise that resolves to file contents
     */
    async readFile(uri) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(uri);
    }
    /**
     * Read file as text
     * @param uri File URI
     * @returns Promise that resolves to file contents as text
     */
    async readFileAsText(uri) {
        const data = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(uri);
        return new TextDecoder().decode(data);
    }
    /**
     * Write data to a file
     * @param uri File URI
     * @param content Content to write
     * @returns Promise that resolves when the file is written
     */
    async writeFile(uri, content) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.writeFile(uri, content);
    }
    /**
     * Write text to a file
     * @param uri File URI
     * @param content Content to write
     * @returns Promise that resolves when the file is written
     */
    async writeFileAsText(uri, content) {
        const data = new TextEncoder().encode(content);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.writeFile(uri, data);
    }
    /**
     * Delete a file
     * @param uri File URI
     * @returns Promise that resolves when the file is deleted
     */
    async deleteFile(uri) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.delete(uri);
    }
    /**
     * Check if a file exists
     * @param uri File URI
     * @returns Promise that resolves to true if the file exists
     */
    async fileExists(uri) {
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(uri);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * List files in a directory
     * @param uri Directory URI
     * @returns Promise that resolves to an array of files and their types
     */
    async readDirectory(uri) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readDirectory(uri);
    }
    /**
     * Create a directory
     * @param uri Directory URI
     * @returns Promise that resolves when the directory is created
     */
    async createDirectory(uri) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.createDirectory(uri);
    }
    /**
     * Delete a directory
     * @param uri Directory URI
     * @param options Delete options
     * @returns Promise that resolves when the directory is deleted
     */
    async deleteDirectory(uri, options) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.delete(uri, {
            recursive: options?.recursive || false,
            useTrash: false
        });
    }
    /**
     * Rename a file or directory
     * @param oldUri Old URI
     * @param newUri New URI
     * @returns Promise that resolves when the rename is complete
     */
    async rename(oldUri, newUri) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.rename(oldUri, newUri);
    }
    /**
     * Copy a file or directory
     * @param source Source URI
     * @param target Target URI
     * @returns Promise that resolves when the copy is complete
     */
    async copy(source, target) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.copy(source, target);
    }
}
/**
 * Implementation of the Git Service API
 */
class GitServiceAPIImpl {
    /**
     * Get Git repositories in workspace
     * @returns Promise that resolves to an array of repository URIs
     */
    async getRepositories() {
        try {
            // Try to get git extension
            const gitExtension = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('vscode.git')?.exports;
            if (gitExtension) {
                const api = gitExtension.getAPI(1);
                if (api) {
                    // Return URIs for all repositories
                    return api.repositories.map((repo) => {
                        return vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.parse(repo.rootUri.toString());
                    });
                }
            }
            // If extension not available or no repositories, try to infer from workspace folders
            const workspaceFolders = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders;
            if (workspaceFolders && workspaceFolders.length > 0) {
                // Filter to include only folders that contain a .git directory
                const repoFolders = [];
                for (const folder of workspaceFolders) {
                    try {
                        const gitFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(folder.uri, '.git');
                        const stat = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(gitFolder);
                        if (stat.type === vscode__WEBPACK_IMPORTED_MODULE_0__.FileType.Directory) {
                            repoFolders.push(folder.uri);
                        }
                    }
                    catch (e) {
                        // No .git folder, skip
                    }
                }
                return repoFolders;
            }
        }
        catch (error) {
            console.error('Error getting Git repositories:', error);
        }
        return [];
    }
    /**
     * Get current branch name
     * @param repoUri Repository URI
     * @returns Promise that resolves to the branch name
     */
    async getCurrentBranch(repoUri) {
        try {
            // Try to get git extension
            const gitExtension = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('vscode.git')?.exports;
            if (gitExtension) {
                const api = gitExtension.getAPI(1);
                if (api) {
                    const repo = api.repositories.find((r) => r.rootUri.toString() === repoUri.toString());
                    if (repo) {
                        return repo.state.HEAD?.name || 'main';
                    }
                }
            }
            // If extension not available, try to read from .git/HEAD
            try {
                const headFile = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(repoUri, '.git', 'HEAD');
                const headContent = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(headFile);
                const headText = new TextDecoder().decode(headContent);
                const match = /ref: refs\/heads\/(.+)/.exec(headText);
                if (match && match[1]) {
                    return match[1];
                }
            }
            catch (e) {
                // Failed to read HEAD file
            }
        }
        catch (error) {
            console.error('Error getting current branch:', error);
        }
        return 'main'; // Default fallback
    }
    /**
     * Get repository status
     * @param repoUri Repository URI
     * @returns Promise that resolves to an array of resource states
     */
    async getStatus(repoUri) {
        try {
            // Try to get git extension
            const gitExtension = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('vscode.git')?.exports;
            if (gitExtension) {
                const api = gitExtension.getAPI(1);
                if (api) {
                    const repo = api.repositories.find((r) => r.rootUri.toString() === repoUri.toString());
                    if (repo) {
                        // Combine working tree and index changes
                        return [
                            ...repo.state.workingTreeChanges,
                            ...repo.state.indexChanges
                        ];
                    }
                }
            }
        }
        catch (error) {
            console.error('Error getting repository status:', error);
        }
        return [];
    }
    /**
     * Commit changes
     * @param repoUri Repository URI
     * @param message Commit message
     * @param stagedOnly Whether to commit only staged changes
     * @returns Promise that resolves when the commit is complete
     */
    async commit(repoUri, message, stagedOnly) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.commit', {
                repository: repoUri.toString(),
                message: message,
                stagedOnly: stagedOnly || false
            });
        }
        catch (error) {
            console.error('Error committing changes:', error);
            // Fallback to default git command if the repository-specific command fails
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.commit', stagedOnly);
        }
    }
    /**
     * Create a new branch
     * @param repoUri Repository URI
     * @param name Branch name
     * @param checkout Whether to checkout the new branch
     * @returns Promise that resolves when the branch is created
     */
    async createBranch(repoUri, name, checkout) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.branch', {
                repository: repoUri.toString(),
                name: name,
                checkout: checkout || false
            });
        }
        catch (error) {
            console.error('Error creating branch:', error);
            // Fallback to default git command if the repository-specific command fails
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.createBranch', name);
        }
    }
    /**
     * Checkout a branch
     * @param repoUri Repository URI
     * @param name Branch name
     * @returns Promise that resolves when the branch is checked out
     */
    async checkoutBranch(repoUri, name) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.checkout', {
                repository: repoUri.toString(),
                name: name
            });
        }
        catch (error) {
            console.error('Error checking out branch:', error);
            // Fallback to default git command if the repository-specific command fails
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.checkout', name);
        }
    }
    /**
     * Pull changes
     * @param repoUri Repository URI
     * @returns Promise that resolves when the pull is complete
     */
    async pull(repoUri) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.pull', {
                repository: repoUri.toString()
            });
        }
        catch (error) {
            console.error('Error pulling changes:', error);
            // Fallback to default git command if the repository-specific command fails
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.pull');
        }
    }
    /**
     * Push changes
     * @param repoUri Repository URI
     * @param forcePush Whether to force push
     * @returns Promise that resolves when the push is complete
     */
    async push(repoUri, forcePush) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.push', {
                repository: repoUri.toString(),
                forcePush: forcePush || false
            });
        }
        catch (error) {
            console.error('Error pushing changes:', error);
            // Fallback to default git command if the repository-specific command fails
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.push', forcePush ? '--force' : undefined);
        }
    }
}
/**
 * Implementation of the Workspace API
 */
class WorkspaceAPIImpl {
    /**
     * Get workspace folders
     * @returns Workspace folders or undefined if none
     */
    getWorkspaceFolders() {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders;
    }
    /**
     * Find files matching a glob pattern
     * @param include Include pattern
     * @param exclude Exclude pattern
     * @returns Promise that resolves to an array of matching file URIs
     */
    async findFiles(include, exclude) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.findFiles(include, exclude);
    }
    /**
     * Save all dirty editors
     * @param includeUntitled Whether to include untitled documents
     * @returns Promise that resolves to true if all files were saved
     */
    async saveAll(includeUntitled) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.saveAll(includeUntitled);
    }
    /**
     * Open a text document
     * @param uri Document URI
     * @returns Promise that resolves to the opened document
     */
    async openTextDocument(uri) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument(uri);
    }
    /**
     * Create a file system watcher
     * @param globPattern Glob pattern to watch
     * @param ignoreCreateEvents Whether to ignore create events
     * @param ignoreChangeEvents Whether to ignore change events
     * @param ignoreDeleteEvents Whether to ignore delete events
     * @returns File system watcher
     */
    createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
    }
    /**
     * Register a text document content provider
     * @param scheme URI scheme
     * @param provider Content provider
     * @returns Disposable for unregistering
     */
    registerTextDocumentContentProvider(scheme, provider) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.registerTextDocumentContentProvider(scheme, provider);
    }
}
/**
 * Implementation of the Debug API
 */
class DebugAPIImpl {
    /**
     * Register a debug adapter descriptor factory
     * @param debugType Debug type
     * @param factory Factory implementation
     * @returns Disposable for unregistering
     */
    registerDebugAdapterDescriptorFactory(debugType, factory) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.debug.registerDebugAdapterDescriptorFactory(debugType, factory);
    }
    /**
     * Start debugging
     * @param folder Workspace folder
     * @param nameOrConfig Debug configuration name or configuration object
     * @returns Promise that resolves to true if debugging started
     */
    async startDebugging(folder, nameOrConfig) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.debug.startDebugging(folder, nameOrConfig);
    }
    /**
     * Add breakpoints
     * @param breakpoints Breakpoints to add
     */
    addBreakpoints(breakpoints) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.debug.addBreakpoints(breakpoints);
    }
    /**
     * Remove breakpoints
     * @param breakpoints Breakpoints to remove
     */
    removeBreakpoints(breakpoints) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.debug.removeBreakpoints(breakpoints);
    }
    /**
     * Get current debug session
     * @returns Active debug session or undefined if none
     */
    getActiveDebugSession() {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.debug.activeDebugSession;
    }
}
/**
 * Implementation of the Plugin API
 */
class PluginAPIImpl {
    _llmService;
    _memoryService;
    events;
    vscode = vscode__WEBPACK_IMPORTED_MODULE_0__;
    llm;
    memory;
    ui;
    fs;
    git;
    workspace;
    debug;
    /**
     * Creates a new Plugin API implementation
     * @param _llmService LLM service
     * @param _memoryService Memory service
     * @param _events Event emitter
     */
    constructor(_llmService, _memoryService, events) {
        this._llmService = _llmService;
        this._memoryService = _memoryService;
        this.events = events;
        // Initialize API implementations
        this.llm = new LLMServiceAPIImpl(_llmService);
        this.memory = new MemoryServiceAPIImpl(_memoryService);
        this.ui = new UIServiceAPIImpl();
        this.fs = new FileSystemAPIImpl();
        this.git = new GitServiceAPIImpl();
        this.workspace = new WorkspaceAPIImpl();
        this.debug = new DebugAPIImpl();
    }
    /**
     * Register a command with VSCode
     * @param command Command ID
     * @param callback Command implementation
     * @param thisArg 'this' context for the callback
     * @returns Disposable for unregistering the command
     */
    registerCommand(command, callback, thisArg) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand(command, callback, thisArg);
    }
    /**
     * Execute a command
     * @param command Command ID
     * @param args Command arguments
     * @returns Promise that resolves to the command result
     */
    async executeCommand(command, ...args) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand(command, ...args);
    }
    /**
     * Get configuration section
     * @param section Configuration section name
     * @returns Configuration object
     */
    getConfiguration(section) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(section);
    }
}


/***/ }),

/***/ "./src/plugins/core/events.ts":
/*!************************************!*\
  !*** ./src/plugins/core/events.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventEmitterImpl: () => (/* binding */ EventEmitterImpl)
/* harmony export */ });
/**
 * Implementation of EventEmitter interface
 */
class EventEmitterImpl {
    _eventId = 0;
    _handlers = new Map();
    /**
     * Subscribe to events
     * @param filter Optional filter to limit which events are received
     * @param handler Event handler function
     * @returns Disposable for unsubscribing
     */
    on(filter, handler) {
        const handlerId = `handler_${++this._eventId}`;
        this._handlers.set(handlerId, { filter, handler });
        return {
            dispose: () => {
                this._handlers.delete(handlerId);
            }
        };
    }
    /**
     * Subscribe to a single event occurrence
     * @param filter Optional filter to limit which events are received
     * @param handler Event handler function
     * @returns Disposable for unsubscribing
     */
    once(filter, handler) {
        const handlerId = `once_handler_${++this._eventId}`;
        // Create a wrapper handler that self-disposes after one execution
        const onceHandler = (event) => {
            // Call the original handler
            handler(event);
            // Self-dispose after execution
            this._handlers.delete(handlerId);
        };
        this._handlers.set(handlerId, { filter, handler: onceHandler });
        return {
            dispose: () => {
                this._handlers.delete(handlerId);
            }
        };
    }
    /**
     * Emit an event
     * @param type Event type
     * @param payload Event payload
     * @param source Event source (defaults to 'system')
     * @returns The emitted event data
     */
    emit(type, payload, source = 'system') {
        // Create event data
        const event = {
            id: `event_${Date.now()}_${++this._eventId}`,
            source,
            type,
            timestamp: new Date(),
            payload
        };
        // Call all handlers that match the filter
        for (const { filter, handler } of this._handlers.values()) {
            if (this._matchesFilter(event, filter)) {
                try {
                    handler(event);
                }
                catch (error) {
                    console.error(`Error in event handler for ${event.type}:`, error);
                }
            }
        }
        return event;
    }
    /**
     * Check if an event matches a filter
     * @param event Event to check
     * @param filter Filter to apply (or null for all events)
     * @returns Whether the event matches the filter
     */
    _matchesFilter(event, filter) {
        // If no filter, match all events
        if (!filter) {
            return true;
        }
        // Check source filter
        if (filter.source !== undefined) {
            if (typeof filter.source === 'string') {
                if (event.source !== filter.source) {
                    return false;
                }
            }
            else if (filter.source instanceof RegExp) {
                if (!filter.source.test(event.source)) {
                    return false;
                }
            }
        }
        // Check type filter
        if (filter.type !== undefined) {
            if (typeof filter.type === 'string') {
                if (event.type !== filter.type) {
                    return false;
                }
            }
            else if (filter.type instanceof RegExp) {
                if (!filter.type.test(event.type)) {
                    return false;
                }
            }
        }
        // Passed all filters
        return true;
    }
}


/***/ }),

/***/ "./src/plugins/core/index.ts":
/*!***********************************!*\
  !*** ./src/plugins/core/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventEmitterImpl: () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.EventEmitterImpl),
/* harmony export */   PluginAPIImpl: () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.PluginAPIImpl),
/* harmony export */   PluginLoader: () => (/* reexport safe */ _loader__WEBPACK_IMPORTED_MODULE_2__.PluginLoader),
/* harmony export */   PluginRegistryImpl: () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_3__.PluginRegistryImpl),
/* harmony export */   PluginSettingsManagerImpl: () => (/* reexport safe */ _settings__WEBPACK_IMPORTED_MODULE_4__.PluginSettingsManagerImpl)
/* harmony export */ });
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ "./src/plugins/core/api.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ "./src/plugins/core/events.ts");
/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader */ "./src/plugins/core/loader.ts");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registry */ "./src/plugins/core/registry.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./settings */ "./src/plugins/core/settings.ts");
// Export plugin core components







/***/ }),

/***/ "./src/plugins/core/loader.ts":
/*!************************************!*\
  !*** ./src/plugins/core/loader.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PluginLoader: () => (/* binding */ PluginLoader)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs/promises */ "fs/promises");
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _types_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types/plugin */ "./src/plugins/types/plugin.ts");





/**
 * Manages loading and unloading of plugins
 */
class PluginLoader {
    _extensionContext;
    _registry;
    _pluginAPI;
    _internalPluginPath;
    _externalPluginPath = null;
    /**
     * Creates a new plugin loader
     * @param _extensionContext Extension context
     * @param _registry Plugin registry
     * @param _pluginAPI Plugin API
     */
    constructor(_extensionContext, _registry, _pluginAPI) {
        this._extensionContext = _extensionContext;
        this._registry = _registry;
        this._pluginAPI = _pluginAPI;
        // Set up plugin paths
        this._internalPluginPath = path__WEBPACK_IMPORTED_MODULE_1__.join(_extensionContext.extensionPath, 'out', 'plugins', 'internal');
        // Load external plugin path from configuration
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.plugins');
        const configuredPath = config.get('path', '');
        if (configuredPath) {
            this._externalPluginPath = configuredPath;
        }
        else {
            // Use default path in global storage
            this._externalPluginPath = path__WEBPACK_IMPORTED_MODULE_1__.join(_extensionContext.globalStoragePath, 'plugins');
            // Create directory if it doesn't exist
            if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(this._externalPluginPath)) {
                (0,fs__WEBPACK_IMPORTED_MODULE_3__.mkdirSync)(this._externalPluginPath, { recursive: true });
            }
        }
        // Listen for configuration changes
        vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration('ape.plugins.path')) {
                this._updateExternalPluginPath();
            }
        });
    }
    /**
     * Update external plugin path when configuration changes
     */
    _updateExternalPluginPath() {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.plugins');
        const configuredPath = config.get('path', '');
        if (configuredPath) {
            this._externalPluginPath = configuredPath;
        }
        else {
            this._externalPluginPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this._extensionContext.globalStoragePath, 'plugins');
        }
    }
    /**
     * Discover and load all internal plugins
     * @returns Promise that resolves to the number of plugins loaded
     */
    async loadInternalPlugins() {
        console.log('Loading internal plugins from:', this._internalPluginPath);
        try {
            const pluginDirs = await this._getDirectories(this._internalPluginPath);
            let loadedCount = 0;
            for (const dir of pluginDirs) {
                try {
                    const loaded = await this._loadPluginFromDirectory(path__WEBPACK_IMPORTED_MODULE_1__.join(this._internalPluginPath, dir), true);
                    if (loaded) {
                        loadedCount++;
                    }
                }
                catch (error) {
                    console.error(`Error loading internal plugin from ${dir}:`, error);
                }
            }
            return loadedCount;
        }
        catch (error) {
            console.error('Error loading internal plugins:', error);
            return 0;
        }
    }
    /**
     * Discover and load all external plugins
     * @returns Promise that resolves to the number of plugins loaded
     */
    async loadExternalPlugins() {
        if (!this._externalPluginPath) {
            return 0;
        }
        console.log('Loading external plugins from:', this._externalPluginPath);
        try {
            const pluginDirs = await this._getDirectories(this._externalPluginPath);
            let loadedCount = 0;
            for (const dir of pluginDirs) {
                try {
                    const loaded = await this._loadPluginFromDirectory(path__WEBPACK_IMPORTED_MODULE_1__.join(this._externalPluginPath, dir), false);
                    if (loaded) {
                        loadedCount++;
                    }
                }
                catch (error) {
                    console.error(`Error loading external plugin from ${dir}:`, error);
                }
            }
            return loadedCount;
        }
        catch (error) {
            console.error('Error loading external plugins:', error);
            return 0;
        }
    }
    /**
     * Load a plugin from a specific directory
     * @param pluginDir Plugin directory path
     * @param isInternal Whether this is an internal plugin
     * @returns Promise that resolves to true if the plugin was loaded
     */
    async _loadPluginFromDirectory(pluginDir, isInternal) {
        // Check for package.json
        const packageJsonPath = path__WEBPACK_IMPORTED_MODULE_1__.join(pluginDir, 'package.json');
        if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(packageJsonPath)) {
            console.log(`No package.json found in ${pluginDir}, skipping`);
            return false;
        }
        try {
            // Load package.json
            const packageJson = JSON.parse(await fs_promises__WEBPACK_IMPORTED_MODULE_2__.readFile(packageJsonPath, 'utf-8'));
            // Skip if this is not an APE plugin
            if (packageJson.apePlugin !== true) {
                console.log(`Directory ${pluginDir} is not an APE plugin, skipping`);
                return false;
            }
            // Extract metadata
            const metadata = {
                id: packageJson.name,
                name: packageJson.displayName || packageJson.name,
                version: packageJson.version || '0.0.1',
                description: packageJson.description,
                author: packageJson.author,
                dependencies: packageJson.apeDependencies || [],
                activationEvents: packageJson.activationEvents || [],
                features: packageJson.apeFeatures || [],
                configuration: packageJson.apeConfiguration,
                category: packageJson.category,
                isBuiltIn: isInternal,
                enabledByDefault: packageJson.enabledByDefault !== false
            };
            // Load the plugin implementation
            const mainModulePath = path__WEBPACK_IMPORTED_MODULE_1__.join(pluginDir, packageJson.main || 'index.js');
            if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(mainModulePath)) {
                throw new Error(`Plugin main module not found: ${mainModulePath}`);
            }
            // Use require() for webpack compatibility instead of dynamic import
            // This is still dynamic but uses CommonJS which webpack can handle better
            // eslint-disable-next-line @typescript-eslint/no-require-imports
            const pluginModule = __webpack_require__("./src/plugins/core sync recursive")(mainModulePath);
            const pluginImpl = pluginModule.default || pluginModule;
            // Check if plugin implements required interface
            if (!pluginImpl || typeof pluginImpl.activate !== 'function') {
                throw new Error(`Plugin does not implement the required interface`);
            }
            // Register the plugin
            const pluginId = await this._registry.registerPlugin(pluginImpl, metadata);
            // Create storage path for the plugin
            const pluginStoragePath = path__WEBPACK_IMPORTED_MODULE_1__.join(this._extensionContext.globalStoragePath, 'plugin-storage', pluginId);
            // Ensure storage directory exists
            if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(pluginStoragePath)) {
                (0,fs__WEBPACK_IMPORTED_MODULE_3__.mkdirSync)(pluginStoragePath, { recursive: true });
            }
            // Create plugin context
            const plugin = this._registry.getPlugin(pluginId);
            if (plugin) {
                const subscriptions = [];
                const context = {
                    extensionContext: this._extensionContext,
                    api: this._pluginAPI,
                    metadata,
                    storagePath: pluginStoragePath,
                    subscriptions,
                    log: (message, severity = 'info') => {
                        switch (severity) {
                            case 'info':
                                console.log(`[Plugin: ${pluginId}] ${message}`);
                                break;
                            case 'warn':
                                console.warn(`[Plugin: ${pluginId}] ${message}`);
                                break;
                            case 'error':
                                console.error(`[Plugin: ${pluginId}] ${message}`);
                                break;
                        }
                    },
                    getConfig: (key) => {
                        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(`ape.plugins.${pluginId}`);
                        return config.get(key);
                    },
                    updateConfig: (key, value) => {
                        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(`ape.plugins.${pluginId}`);
                        return Promise.resolve(config.update(key, value, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global));
                    }
                };
                // Set the context on the plugin instance
                plugin.context = context;
                // Auto-activate if configured
                const autoActivate = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.plugins')
                    .get('autoActivate', true);
                if (autoActivate && metadata.enabledByDefault !== false) {
                    // Queue activation to avoid blocking the loading process
                    setImmediate(() => {
                        this._registry.activatePlugin(pluginId).catch(error => {
                            console.error(`Error auto-activating plugin ${pluginId}:`, error);
                        });
                    });
                }
                return true;
            }
            return false;
        }
        catch (error) {
            console.error(`Error loading plugin from ${pluginDir}:`, error);
            return false;
        }
    }
    /**
     * Activate all plugins that match a specific activation event
     * @param activationEvent Activation event to match
     * @returns Promise that resolves to the number of plugins activated
     */
    async activatePluginsByEvent(activationEvent) {
        const plugins = this._registry.getAllPlugins().filter(plugin => plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_4__.PluginState.Registered &&
            plugin.metadata.activationEvents?.some(event => {
                // Exact match
                if (event === activationEvent) {
                    return true;
                }
                // Wildcard match
                if (event.endsWith('*')) {
                    const prefix = event.slice(0, -1);
                    return activationEvent.startsWith(prefix);
                }
                return false;
            }));
        let activatedCount = 0;
        for (const plugin of plugins) {
            try {
                const success = await this._registry.activatePlugin(plugin.id);
                if (success) {
                    activatedCount++;
                }
            }
            catch (error) {
                console.error(`Error activating plugin ${plugin.id} for event ${activationEvent}:`, error);
            }
        }
        return activatedCount;
    }
    /**
     * Activate all registered plugins
     * @returns Promise that resolves to the number of plugins activated
     */
    async activateAllPlugins() {
        const plugins = this._registry.getAllPlugins().filter(plugin => plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_4__.PluginState.Registered);
        let activatedCount = 0;
        for (const plugin of plugins) {
            try {
                const success = await this._registry.activatePlugin(plugin.id);
                if (success) {
                    activatedCount++;
                }
            }
            catch (error) {
                console.error(`Error activating plugin ${plugin.id}:`, error);
            }
        }
        return activatedCount;
    }
    /**
     * Deactivate all active plugins
     * @returns Promise that resolves to the number of plugins deactivated
     */
    async deactivateAllPlugins() {
        const activePlugins = this._registry.getActivePlugins();
        let deactivatedCount = 0;
        for (const plugin of activePlugins) {
            try {
                const success = await this._registry.deactivatePlugin(plugin.id);
                if (success) {
                    deactivatedCount++;
                }
            }
            catch (error) {
                console.error(`Error deactivating plugin ${plugin.id}:`, error);
            }
        }
        return deactivatedCount;
    }
    /**
     * Helper function to get directories in a path
     * @param dirPath Directory path to scan
     * @returns Promise that resolves to an array of directory names
     */
    async _getDirectories(dirPath) {
        try {
            const entries = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.readdir(dirPath, { withFileTypes: true });
            return entries
                .filter(entry => entry.isDirectory())
                .map(entry => entry.name);
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                // Directory doesn't exist, return empty array
                return [];
            }
            throw error;
        }
    }
}


/***/ }),

/***/ "./src/plugins/core/registry.ts":
/*!**************************************!*\
  !*** ./src/plugins/core/registry.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PluginRegistryImpl: () => (/* binding */ PluginRegistryImpl)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/plugin */ "./src/plugins/types/plugin.ts");


/**
 * Implementation of the Plugin Registry
 */
class PluginRegistryImpl {
    _eventEmitter;
    /** Maps plugin IDs to plugin instances */
    _plugins = new Map();
    /** Event emitters for plugin state changes */
    _stateChangeEmitter = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    /** Observable for plugin state changes */
    onDidChangePluginState = (listener) => {
        return this._stateChangeEmitter.event(e => listener(e.pluginId, e.oldState, e.newState));
    };
    /**
     * Creates a new plugin registry
     * @param _eventEmitter Event emitter for plugin events
     */
    constructor(_eventEmitter) {
        this._eventEmitter = _eventEmitter;
    }
    /**
     * Register a plugin with the registry
     * @param plugin Plugin implementation
     * @param metadata Plugin metadata
     * @returns Promise that resolves to the plugin ID
     */
    async registerPlugin(plugin, metadata) {
        // Check for duplicate plugin ID
        if (this._plugins.has(metadata.id)) {
            throw new Error(`Plugin with ID ${metadata.id} is already registered`);
        }
        // Create plugin instance
        const instance = {
            id: metadata.id,
            metadata,
            implementation: plugin,
            state: _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Registered
        };
        // Add to registry
        this._plugins.set(metadata.id, instance);
        // Emit event
        this._eventEmitter.emit('plugin:registered', {
            pluginId: metadata.id,
            metadata
        });
        return metadata.id;
    }
    /**
     * Unregister a plugin from the registry
     * @param pluginId Plugin ID to unregister
     * @returns Promise that resolves to true if successful
     */
    async unregisterPlugin(pluginId) {
        const plugin = this._plugins.get(pluginId);
        if (!plugin) {
            return false;
        }
        // Deactivate plugin if it's active
        if (plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active) {
            await this.deactivatePlugin(pluginId);
        }
        // Remove from registry
        this._plugins.delete(pluginId);
        // Emit event
        this._eventEmitter.emit('plugin:unregistered', {
            pluginId
        });
        return true;
    }
    /**
     * Activate a plugin
     * @param pluginId Plugin ID to activate
     * @returns Promise that resolves to true if successful
     */
    async activatePlugin(pluginId) {
        const plugin = this._plugins.get(pluginId);
        if (!plugin) {
            return false;
        }
        // Check if already active or activating
        if (plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active) {
            return true;
        }
        if (plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Activating) {
            return false; // Already activating
        }
        // Update state to activating
        this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Activating);
        try {
            // Check and activate dependencies if needed
            if (plugin.metadata.dependencies?.length) {
                for (const depId of plugin.metadata.dependencies) {
                    const dependency = this._plugins.get(depId);
                    if (!dependency) {
                        throw new _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginActivationError(pluginId, `Missing dependency: ${depId}`);
                    }
                    if (dependency.state !== _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active) {
                        const success = await this.activatePlugin(depId);
                        if (!success) {
                            throw new _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginActivationError(pluginId, `Failed to activate dependency: ${depId}`);
                        }
                    }
                }
            }
            // Context will be provided by PluginLoader
            if (!plugin.context) {
                throw new _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginActivationError(pluginId, 'Plugin context not set. This is likely an internal error.');
            }
            // Activate the plugin
            await plugin.implementation.activate(plugin.context);
            // Update state to active
            this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active);
            // Emit event
            this._eventEmitter.emit('plugin:activated', {
                pluginId,
                metadata: plugin.metadata
            });
            return true;
        }
        catch (error) {
            // Update state to activation failed
            plugin.error = error instanceof Error ? error : new Error(String(error));
            this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.ActivationFailed);
            // Emit failure event
            this._eventEmitter.emit('plugin:activation:failed', {
                pluginId,
                error: plugin.error
            });
            return false;
        }
    }
    /**
     * Deactivate a plugin
     * @param pluginId Plugin ID to deactivate
     * @returns Promise that resolves to true if successful
     */
    async deactivatePlugin(pluginId) {
        const plugin = this._plugins.get(pluginId);
        if (!plugin) {
            return false;
        }
        // Check if already inactive or deactivating
        if (plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Inactive ||
            plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Registered ||
            plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Discovered) {
            return true;
        }
        if (plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Deactivating) {
            return false; // Already deactivating
        }
        // Check if this plugin is a dependency of any active plugins
        const activePlugins = this.getPluginsByState(_types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active);
        const dependents = activePlugins.filter(p => p.metadata.dependencies?.includes(pluginId));
        // Deactivate dependents first
        for (const dependent of dependents) {
            await this.deactivatePlugin(dependent.id);
        }
        // Update state to deactivating
        this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Deactivating);
        try {
            // Call deactivate if implemented
            if (plugin.implementation.deactivate) {
                await plugin.implementation.deactivate();
            }
            // Dispose context subscriptions
            if (plugin.context) {
                for (const subscription of plugin.context.subscriptions) {
                    try {
                        subscription.dispose();
                    }
                    catch (error) {
                        console.error(`Error disposing subscription for plugin ${pluginId}:`, error);
                    }
                }
            }
            // Update state to inactive
            this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Inactive);
            // Clear error if previously failed
            delete plugin.error;
            // Emit event
            this._eventEmitter.emit('plugin:deactivated', {
                pluginId,
                metadata: plugin.metadata
            });
            return true;
        }
        catch (error) {
            // Still mark as inactive, but keep error
            plugin.error = error instanceof Error ? error : new Error(String(error));
            this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Inactive);
            // Emit warning event
            this._eventEmitter.emit('plugin:deactivation:warning', {
                pluginId,
                error: plugin.error
            });
            // Still return true because the plugin is now inactive
            return true;
        }
    }
    /**
     * Check if a plugin is active
     * @param pluginId Plugin ID to check
     * @returns Whether the plugin is active
     */
    isPluginActive(pluginId) {
        const plugin = this._plugins.get(pluginId);
        return plugin?.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active;
    }
    /**
     * Get a plugin instance by ID
     * @param pluginId Plugin ID to get
     * @returns Plugin instance or undefined if not found
     */
    getPlugin(pluginId) {
        return this._plugins.get(pluginId);
    }
    /**
     * Get all registered plugins
     * @returns Array of all plugin instances
     */
    getAllPlugins() {
        return Array.from(this._plugins.values());
    }
    /**
     * Get plugins by state
     * @param state State to filter by
     * @returns Array of matching plugin instances
     */
    getPluginsByState(state) {
        return Array.from(this._plugins.values()).filter(p => p.state === state);
    }
    /**
     * Get active plugins only
     * @returns Array of active plugin instances
     */
    getActivePlugins() {
        return this.getPluginsByState(_types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active);
    }
    /**
     * Update a plugin's state and emit change event
     * @param plugin Plugin instance to update
     * @param newState New state to set
     */
    _changePluginState(plugin, newState) {
        const oldState = plugin.state;
        plugin.state = newState;
        // Emit event for state change
        this._stateChangeEmitter.fire({
            pluginId: plugin.id,
            oldState,
            newState
        });
    }
}


/***/ }),

/***/ "./src/plugins/core/settings.ts":
/*!**************************************!*\
  !*** ./src/plugins/core/settings.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PluginSettingsManagerImpl: () => (/* binding */ PluginSettingsManagerImpl)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Implementation of PluginSettingsManager
 */
class PluginSettingsManagerImpl {
    _extensionContext;
    // Map of registered schemas by plugin ID
    _schemas = new Map();
    // Map of configuration change listeners
    _listeners = new Map();
    /**
     * Creates a new PluginSettingsManager
     * @param _extensionContext Extension context
     */
    constructor(_extensionContext) {
        this._extensionContext = _extensionContext;
        // Listen for configuration changes
        vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(this._handleConfigChange, this);
    }
    /**
     * Register configuration schema for a plugin
     * @param pluginId Plugin ID
     * @param schema Settings schema
     */
    registerSettings(pluginId, schema) {
        this._schemas.set(pluginId, schema);
        // TODO: Register settings with VSCode dynamically
        // This is normally done via package.json, but for dynamically loaded plugins
        // we might need a different approach
    }
    /**
     * Get configuration for a plugin
     * @param pluginId Plugin ID
     * @returns Configuration object
     */
    getConfiguration(pluginId) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(`ape.plugins.${pluginId}`);
    }
    /**
     * Get a specific setting value
     * @param pluginId Plugin ID
     * @param key Setting key
     * @param defaultValue Default value if setting is not found
     * @returns Setting value or default value
     */
    get(pluginId, key, defaultValue) {
        const config = this.getConfiguration(pluginId);
        return config.get(key, defaultValue);
    }
    /**
     * Update a specific setting value
     * @param pluginId Plugin ID
     * @param key Setting key
     * @param value New value
     * @param configurationTarget Where to update the setting
     * @returns Promise that resolves when the update is complete
     */
    async update(pluginId, key, value, configurationTarget = vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global) {
        const config = this.getConfiguration(pluginId);
        await config.update(key, value, configurationTarget);
    }
    /**
     * Listen for setting changes
     * @param pluginId Plugin ID
     * @param key Setting key
     * @param callback Callback function invoked when the setting changes
     * @returns Disposable for unsubscribing
     */
    onDidChangeConfiguration(pluginId, key, callback) {
        // Get current value as baseline
        const initialValue = this.get(pluginId, key);
        // Create a disposable to manage this listener
        const disposable = {
            dispose: () => {
                // Remove this listener from our records
                const listeners = this._listeners.get(pluginId) || [];
                const index = listeners.findIndex(l => l === disposable);
                if (index !== -1) {
                    listeners.splice(index, 1);
                }
                this._listeners.set(pluginId, listeners);
            }
        };
        // Add to our listeners
        const listeners = this._listeners.get(pluginId) || [];
        listeners.push(disposable);
        this._listeners.set(pluginId, listeners);
        // Store state for this listener
        disposable._lastValue = initialValue;
        disposable._pluginId = pluginId;
        disposable._key = key;
        disposable._callback = callback;
        return disposable;
    }
    /**
     * Handle configuration changes
     * @param event Configuration change event
     */
    _handleConfigChange(event) {
        // Check each plugin and its listeners
        for (const [pluginId, listeners] of this._listeners.entries()) {
            const configSection = `ape.plugins.${pluginId}`;
            if (event.affectsConfiguration(configSection)) {
                // Configuration for this plugin has changed
                for (const listener of listeners) {
                    // Get stored properties
                    const key = listener._key;
                    const lastValue = listener._lastValue;
                    const callback = listener._callback;
                    // Check if this specific key was affected
                    if (event.affectsConfiguration(`${configSection}.${key}`)) {
                        // Get the new value
                        const newValue = this.get(pluginId, key);
                        // Only notify if value actually changed
                        if (JSON.stringify(newValue) !== JSON.stringify(lastValue)) {
                            // Update stored last value
                            listener._lastValue = newValue;
                            // Call the callback with the new value
                            try {
                                callback(newValue);
                            }
                            catch (error) {
                                console.error(`Error in settings change listener for ${pluginId}.${key}:`, error);
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * Dispose of all listeners
     */
    dispose() {
        // Clear all listeners
        this._listeners.clear();
        this._schemas.clear();
    }
}


/***/ }),

/***/ "./src/plugins/types/plugin.ts":
/*!*************************************!*\
  !*** ./src/plugins/types/plugin.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PluginActivationError: () => (/* binding */ PluginActivationError),
/* harmony export */   PluginFeatureType: () => (/* binding */ PluginFeatureType),
/* harmony export */   PluginState: () => (/* binding */ PluginState)
/* harmony export */ });
/**
 * Possible states for a plugin
 */
var PluginState;
(function (PluginState) {
    /** Plugin has been discovered but not registered yet */
    PluginState["Discovered"] = "discovered";
    /** Plugin is registered but not activated */
    PluginState["Registered"] = "registered";
    /** Plugin is currently being activated */
    PluginState["Activating"] = "activating";
    /** Plugin is active */
    PluginState["Active"] = "active";
    /** Plugin is currently being deactivated */
    PluginState["Deactivating"] = "deactivating";
    /** Plugin has been activated and is now deactivated */
    PluginState["Inactive"] = "inactive";
    /** Plugin activation failed */
    PluginState["ActivationFailed"] = "activation_failed";
    /** Plugin is disabled */
    PluginState["Disabled"] = "disabled";
})(PluginState || (PluginState = {}));
/**
 * Error thrown when plugin activation fails
 */
class PluginActivationError extends Error {
    pluginId;
    cause;
    constructor(pluginId, message, cause) {
        super(`Failed to activate plugin ${pluginId}: ${message}${cause ? ` (${cause.message})` : ''}`);
        this.pluginId = pluginId;
        this.cause = cause;
        this.name = 'PluginActivationError';
    }
}
/**
 * Supported plugin feature types
 */
var PluginFeatureType;
(function (PluginFeatureType) {
    // UI components
    PluginFeatureType["WebviewPanel"] = "webview_panel";
    PluginFeatureType["StatusBarItem"] = "status_bar_item";
    PluginFeatureType["TreeView"] = "tree_view";
    // Commands and actions
    PluginFeatureType["Command"] = "command";
    PluginFeatureType["ContextMenu"] = "context_menu";
    PluginFeatureType["KeyBinding"] = "key_binding";
    // Language features
    PluginFeatureType["CodeLens"] = "code_lens";
    PluginFeatureType["CompletionProvider"] = "completion_provider";
    PluginFeatureType["DiagnosticProvider"] = "diagnostic_provider";
    PluginFeatureType["FormattingProvider"] = "formatting_provider";
    // Other
    PluginFeatureType["Watcher"] = "watcher";
    PluginFeatureType["Task"] = "task";
    PluginFeatureType["Custom"] = "custom";
})(PluginFeatureType || (PluginFeatureType = {}));


/***/ }),

/***/ "./src/types/chat.ts":
/*!***************************!*\
  !*** ./src/types/chat.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LLMModel: () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_0__.ModelId),
/* harmony export */   MessageRole: () => (/* binding */ MessageRole)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models */ "./src/types/models.ts");
/**
 * Message roles representing different participants in a conversation
 */
var MessageRole;
(function (MessageRole) {
    MessageRole["User"] = "user";
    MessageRole["Assistant"] = "assistant";
    MessageRole["System"] = "system"; // System messages (e.g., errors, notifications)
})(MessageRole || (MessageRole = {}));
/**
 * @deprecated Use ModelId from 'types/models.ts' instead.
 * This type is kept for backward compatibility.
 */



/***/ }),

/***/ "./src/types/models.ts":
/*!*****************************!*\
  !*** ./src/types/models.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModelDescriptions: () => (/* binding */ ModelDescriptions),
/* harmony export */   ModelDisplayNames: () => (/* binding */ ModelDisplayNames),
/* harmony export */   ModelId: () => (/* binding */ ModelId),
/* harmony export */   getModelInfo: () => (/* binding */ getModelInfo),
/* harmony export */   parseModelId: () => (/* binding */ parseModelId)
/* harmony export */ });
/**
 * 모델 정보 관리를 위한 타입 정의
 */
/**
 * 실제 모델 식별자 - LLM API 호출 시 사용
 * 실제 API 호출에 사용되는 모델 식별자 문자열
 */
var ModelId;
(function (ModelId) {
    // OpenAI models (최신 모델들)
    ModelId["GPT_4_1_MINI"] = "openai/gpt-4.1-mini";
    ModelId["GPT_4_1_PREVIEW"] = "openai/gpt-4.1-preview";
    ModelId["GPT_4O"] = "openai/gpt-4o";
    ModelId["GPT_3_5_TURBO"] = "openai/gpt-3.5-turbo";
    // Anthropic models (Claude 모델들)
    ModelId["CLAUDE_3_OPUS"] = "anthropic/claude-3-opus-20240229";
    ModelId["CLAUDE_3_SONNET"] = "anthropic/claude-3-sonnet-20240229";
    ModelId["CLAUDE_3_HAIKU"] = "anthropic/claude-3-haiku-20240307";
    // 추가 모델들
    ModelId["GEMINI_PRO"] = "google/gemini-pro";
    ModelId["GEMMA_7B"] = "google/gemma-7b-it";
    ModelId["QWEN_72B"] = "qwen/qwen-72b-chat";
    ModelId["DEEPSEEK"] = "deepseek/deepseek-coder";
    // 무료 모델들
    ModelId["MISTRAL_7B"] = "mistralai/mistral-7b-instruct";
    ModelId["LLAMA3_8B"] = "meta-llama/llama-3-8b-instruct"; // 무료 오픈소스 모델
})(ModelId || (ModelId = {}));
/**
 * 모델 표시 이름 - UI에 표시할 사용자 친화적인 이름
 */
const ModelDisplayNames = {
    // OpenAI 모델들
    [ModelId.GPT_4_1_MINI]: 'GPT-4.1 Mini',
    [ModelId.GPT_4_1_PREVIEW]: 'GPT-4.1 Preview',
    [ModelId.GPT_4O]: 'GPT-4o',
    [ModelId.GPT_3_5_TURBO]: 'GPT-3.5 Turbo',
    // Anthropic 모델들
    [ModelId.CLAUDE_3_OPUS]: 'Claude 3 Opus',
    [ModelId.CLAUDE_3_SONNET]: 'Claude 3 Sonnet',
    [ModelId.CLAUDE_3_HAIKU]: 'Claude 3 Haiku',
    // 추가 모델들
    [ModelId.GEMINI_PRO]: 'Gemini Pro',
    [ModelId.GEMMA_7B]: 'Gemma 7B',
    [ModelId.QWEN_72B]: 'Qwen 72B',
    [ModelId.DEEPSEEK]: 'DeepSeek Coder',
    // 무료 모델들
    [ModelId.MISTRAL_7B]: 'Mistral 7B',
    [ModelId.LLAMA3_8B]: 'Llama 3 8B'
};
/**
 * 모델 설명 - 모델에 대한 추가 정보
 */
const ModelDescriptions = {
    // OpenAI 모델들
    [ModelId.GPT_4_1_MINI]: '균형 잡힌 성능과 속도 (기본 모델)',
    [ModelId.GPT_4_1_PREVIEW]: '최신 고성능 모델',
    [ModelId.GPT_4O]: '최고 성능의 다목적 모델',
    [ModelId.GPT_3_5_TURBO]: '빠른 속도와 경제적인 비용',
    // Anthropic 모델들
    [ModelId.CLAUDE_3_OPUS]: '최고 수준의 추론 및 복잡한 작업 처리',
    [ModelId.CLAUDE_3_SONNET]: '높은 품질과 효율적인 성능의 균형',
    [ModelId.CLAUDE_3_HAIKU]: '빠른 응답이 필요한 작업에 최적화',
    // 추가 모델들
    [ModelId.GEMINI_PRO]: 'Google의 고급 멀티모달 모델',
    [ModelId.GEMMA_7B]: '경량 오픈소스 모델, 낮은 지연 시간',
    [ModelId.QWEN_72B]: 'Alibaba의 대형 고성능 모델',
    [ModelId.DEEPSEEK]: '코드 생성에 특화된 모델',
    // 무료 모델들
    [ModelId.MISTRAL_7B]: '경량 오픈소스 모델, 합리적인 성능',
    [ModelId.LLAMA3_8B]: 'Meta의 소형 오픈소스 모델'
};
/**
 * ModelId를 ModelInfo 객체로 변환
 * @param modelId 모델 ID
 * @returns ModelInfo 객체
 */
function getModelInfo(modelId) {
    return {
        id: modelId,
        displayName: ModelDisplayNames[modelId],
        description: ModelDescriptions[modelId]
    };
}
/**
 * 문자열 모델 ID를 ModelId 열거형으로 안전하게 변환
 * @param modelIdString 모델 ID 문자열
 * @returns ModelId 또는 기본값 (변환 실패 시)
 */
function parseModelId(modelIdString) {
    if (Object.values(ModelId).includes(modelIdString)) {
        return modelIdString;
    }
    // 기본 모델 반환
    console.warn(`Invalid model ID: ${modelIdString}, using default model`);
    return ModelId.GPT_4_1_MINI;
}


/***/ }),

/***/ "./src/ui/chat/codeService.ts":
/*!************************************!*\
  !*** ./src/ui/chat/codeService.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodeService: () => (/* binding */ CodeService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/**
 * 코드 서비스
 *
 * 코드 블록 UI 및 상호 작용 기능, 코드 삽입 기능을 통합 제공
 */



/**
 * 통합된 코드 서비스 클래스
 */
class CodeService {
    static codeBlockCounter = 0;
    /**
     * 웹뷰에서 메시지 핸들러 등록
     * @param context 확장 컨텍스트
     * @param webview 웹뷰
     */
    static async registerHandlers(context, webview) {
        console.log('CodeService.registerHandlers called');
        // 코드 블록 관련 명령 등록 (비동기 함수로 변경됨)
        await this.registerCommands(context);
        // 웹뷰 메시지 핸들러 등록
        webview.onDidReceiveMessage(async (message) => {
            switch (message.type) {
                case 'copyCode': {
                    await this.handleCopyCode(message.code);
                    break;
                }
                case 'insertCodeToEditor': {
                    await this.handleInsertCode(message);
                    break;
                }
                case 'createFileWithCode': {
                    await this.handleCreateFile(message);
                    break;
                }
                case 'attachFile': {
                    await this.handleAttachFile(webview);
                    break;
                }
            }
        }, undefined, context.subscriptions);
    }
    /**
     * 코드 복사 처리
     * @param code 복사할 코드
     */
    static async handleCopyCode(code) {
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.env.clipboard.writeText(code);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('코드가 클립보드에 복사되었습니다.');
        }
        catch (error) {
            console.error('코드 복사 중 오류 발생:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('코드 복사 중 오류가 발생했습니다.');
        }
    }
    /**
     * 코드 삽입 처리
     * @param message 메시지 객체
     */
    static async handleInsertCode(message) {
        try {
            const options = {
                code: message.code,
                language: message.language || 'plaintext',
                insertAtCursor: message.insertAtCursor,
                replaceSelection: message.replaceSelection,
                createNewFile: message.createNewFile,
                filename: message.filename
            };
            const result = await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.insertCodeToEditor', options);
            if (!result) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('코드를 에디터에 삽입하지 못했습니다.');
            }
        }
        catch (error) {
            console.error('코드 삽입 중 오류 발생:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('코드 삽입 중 오류가 발생했습니다.');
        }
    }
    /**
     * 새 파일 생성 처리
     * @param message 메시지 객체
     */
    static async handleCreateFile(message) {
        try {
            const options = {
                code: message.code,
                language: message.language || 'plaintext',
                createNewFile: true,
                filename: message.filename
            };
            const result = await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.createNewFileWithCode', options);
            if (!result) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('새 파일을 생성하지 못했습니다.');
            }
        }
        catch (error) {
            console.error('파일 생성 중 오류 발생:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('파일 생성 중 오류가 발생했습니다.');
        }
    }
    /**
     * 파일 첨부 처리
     * @param webview 웹뷰
     */
    static async handleAttachFile(webview) {
        try {
            // VSCode의 파일 선택 대화상자 표시
            const fileUris = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showOpenDialog({
                canSelectFiles: true,
                canSelectFolders: false,
                canSelectMany: false,
                openLabel: '첨부',
                filters: {
                    'All Files': ['*']
                }
            });
            if (!fileUris || fileUris.length === 0) {
                return; // 사용자가 취소함
            }
            const fileUri = fileUris[0];
            const fileName = path__WEBPACK_IMPORTED_MODULE_2__.basename(fileUri.fsPath);
            const fileExtension = path__WEBPACK_IMPORTED_MODULE_2__.extname(fileUri.fsPath).toLowerCase();
            let fileContent = '';
            // 파일 크기 확인 (큰 파일은 내용 로드하지 않음)
            const stat = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(fileUri);
            const fileSize = stat.size;
            const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
            // 작은 파일인 경우 내용 로드
            if (fileSize <= MAX_FILE_SIZE) {
                try {
                    const buffer = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(fileUri);
                    fileContent = new TextDecoder().decode(buffer);
                }
                catch (error) {
                    console.log('텍스트 파일이 아닌 것으로 추정됩니다:', error);
                    // 텍스트가 아닌 파일은 내용 로드하지 않음
                }
            }
            // 상대 경로 구하기
            let relativePath = fileUri.fsPath;
            if (vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.length) {
                const workspaceFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders[0];
                const workspacePath = workspaceFolder.uri.fsPath;
                if (fileUri.fsPath.startsWith(workspacePath)) {
                    relativePath = fileUri.fsPath.substring(workspacePath.length + 1);
                }
            }
            // 파일 정보 웹뷰로 전송
            webview.postMessage({
                type: 'fileAttached',
                file: {
                    path: fileUri.fsPath,
                    relativePath: relativePath,
                    name: fileName,
                    type: fileExtension,
                    size: fileSize,
                    content: fileContent,
                    hasContent: fileContent.length > 0
                }
            });
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`${fileName} 파일이 첨부되었습니다.`);
        }
        catch (error) {
            console.error('파일 첨부 중 오류 발생:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`파일 첨부 중 오류가 발생했습니다: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * 코드 블록 CSS 스타일 로드
     * @param webview 웹뷰
     * @param context 확장 컨텍스트
     * @returns CSS URI
     */
    static getCodeBlockStyleUri(webview, context) {
        return webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(context.extensionUri, 'media', 'code-block.css'));
    }
    /**
     * 코드 블록 스크립트 생성
     * @returns JavaScript 코드
     */
    static getCodeBlockScript() {
        return `
    // 코드 블록 관련 기능
    (function() {
      document.addEventListener('click', function(event) {
        const target = event.target;
        
        // 복사 버튼 클릭 (버튼 또는 버튼 내부 아이콘)
        const copyButton = target.closest('.code-action-button.copy-button');
        if (copyButton) {
          const codeId = copyButton.getAttribute('data-code-id');
          const codeElement = document.getElementById('code-' + codeId);
          
          if (codeElement) {
            const code = codeElement.textContent;
            
            // VS Code에 복사 요청 전송
            vscode.postMessage({
              type: 'copyCode',
              code: code,
              language: codeElement.className.replace('language-', '')
            });
            
            // 복사 성공 시각적 피드백
            const codeBlock = copyButton.closest('.code-block-container');
            codeBlock.classList.add('success-animation');
            setTimeout(() => {
              codeBlock.classList.remove('success-animation');
            }, 1000);
          }
          
          event.preventDefault();
          return;
        }
        
        // 에디터에 삽입 버튼 클릭
        const insertButton = target.closest('.code-action-button.insert-code-button');
        if (insertButton) {
          const codeId = insertButton.getAttribute('data-code-id');
          const codeElement = document.getElementById('code-' + codeId);
          
          if (codeElement) {
            const code = codeElement.textContent;
            const language = codeElement.className.replace('language-', '');
            
            // VS Code에 삽입 요청 전송
            vscode.postMessage({
              type: 'insertCodeToEditor',
              code: code,
              language: language,
              insertAtCursor: true
            });
          }
          
          event.preventDefault();
          return;
        }
        
        // 새 파일 생성 버튼 클릭
        const newFileButton = target.closest('.code-action-button.new-file-button');
        if (newFileButton) {
          const codeId = newFileButton.getAttribute('data-code-id');
          const codeElement = document.getElementById('code-' + codeId);
          
          if (codeElement) {
            const code = codeElement.textContent;
            const language = codeElement.className.replace('language-', '');
            
            // VS Code에 새 파일 생성 요청 전송
            vscode.postMessage({
              type: 'createFileWithCode',
              code: code,
              language: language
            });
          }
          
          event.preventDefault();
          return;
        }
      });
      
      // 스트리밍 중인 코드 블록 표시
      function markStreamingCodeBlock(id, isStreaming) {
        const codeBlock = document.getElementById('code-' + id)?.closest('.code-block-container');
        if (codeBlock) {
          if (isStreaming) {
            codeBlock.classList.add('streaming-code-block');
          } else {
            codeBlock.classList.remove('streaming-code-block');
          }
        }
      }
      
      // 스트리밍 시작/종료 이벤트 리스닝
      window.addEventListener('message', (event) => {
        const message = event.data;
        if (message.type === 'streamingCodeStart') {
          markStreamingCodeBlock(message.codeId, true);
        } 
        else if (message.type === 'streamingCodeEnd') {
          markStreamingCodeBlock(message.codeId, false);
        }
      });
    })();
    `;
    }
    /**
     * 코드 블록 템플릿 가져오기
     */
    static async getCodeBlockTemplate() {
        const extensionPath = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape.ape-extension')?.extensionPath;
        if (!extensionPath) {
            console.error('확장 프로그램 경로를 찾을 수 없습니다.');
            return this.getDefaultCodeBlockTemplate();
        }
        const templatePath = path__WEBPACK_IMPORTED_MODULE_2__.join(extensionPath, 'src', 'data', 'codeBlockTemplate.html');
        try {
            return await fs__WEBPACK_IMPORTED_MODULE_1__.promises.readFile(templatePath, 'utf-8');
        }
        catch (error) {
            console.error('코드 블록 템플릿을 로드할 수 없습니다:', error);
            return this.getDefaultCodeBlockTemplate();
        }
    }
    /**
     * 기본 코드 블록 템플릿 반환
     */
    static getDefaultCodeBlockTemplate() {
        return '<div class="code-block-container code-block-popup">\n' +
            '  <div class="code-block-header">\n' +
            '    <span class="code-block-language language-${language}">${language}</span>\n' +
            '    <div class="code-block-actions">\n' +
            '      <button class="code-action-button copy-button" data-code-id="${codeId}" title="복사">\n' +
            '        <i class="codicon codicon-copy"></i>\n' +
            '        <span class="tooltip">클립보드에 복사</span>\n' +
            '      </button>\n' +
            '      <button class="code-action-button insert-code-button" data-code-id="${codeId}" title="에디터에 삽입">\n' +
            '        <i class="codicon codicon-arrow-small-right"></i>\n' +
            '        <span class="tooltip">현재 파일에 복사</span>\n' +
            '      </button>\n' +
            '      <button class="code-action-button new-file-button" data-code-id="${codeId}" title="새 파일로 생성">\n' +
            '        <i class="codicon codicon-new-file"></i>\n' +
            '        <span class="tooltip">새 파일로 생성</span>\n' +
            '      </button>\n' +
            '    </div>\n' +
            '  </div>\n' +
            '  <div class="code-content ${showLineNumbers ? \'with-line-numbers\' : \'\'}">\n' +
            '    ${showLineNumbers ? \'<div class="line-numbers">${lineNumbers}</div>\' : \'\'}\n' +
            '    <div class="code-area">\n' +
            '      <code class="language-${language}" id="code-${codeId}">${codeContent}</code>\n' +
            '    </div>\n' +
            '  </div>\n' +
            '</div>';
    }
    /**
     * 코드를 현재 열려있는 파일에 삽입
     * @param options 코드 삽입 옵션
     * @returns 성공 여부
     */
    static async insertCodeToEditor(options) {
        try {
            const { code, replaceSelection, insertAtCursor, createNewFile, filename } = options;
            // 새 파일 생성 옵션이 있는 경우
            if (createNewFile) {
                return await this.createNewFileWithCode(code, options.language, filename);
            }
            // 현재 활성화된 에디터 가져오기
            const editor = vscode__WEBPACK_IMPORTED_MODULE_0__.window.activeTextEditor;
            if (!editor) {
                // 활성화된 에디터가 없는 경우, 새 파일 생성 제안
                const createNewFile = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('열린 편집기가 없습니다. 새 파일을 생성할까요?', '새 파일 생성', '취소');
                if (createNewFile === '새 파일 생성') {
                    return await this.createNewFileWithCode(code, options.language);
                }
                return false;
            }
            // 현재 선택 영역 가져오기
            const selection = editor.selection;
            // 에디터에 코드 삽입
            await editor.edit(editBuilder => {
                if (replaceSelection && !selection.isEmpty) {
                    // 선택 영역 대체
                    editBuilder.replace(selection, code);
                }
                else if (insertAtCursor) {
                    // 커서 위치에 삽입
                    editBuilder.insert(selection.active, code);
                }
                else {
                    // 선택 영역이 없는 경우 커서 위치에 삽입
                    editBuilder.insert(selection.active, code);
                }
            });
            // 삽입된 코드 포맷팅 (언어에 따라 다를 수 있음)
            try {
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('editor.action.formatDocument');
            }
            catch (error) {
                console.log('코드 포맷팅 중 오류 발생:', error);
                // 포맷팅 실패는 무시 (모든 언어가 포맷터를 지원하지는 않음)
            }
            return true;
        }
        catch (error) {
            console.error('코드 삽입 중 오류 발생:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`코드 삽입 중 오류가 발생했습니다: ${error instanceof Error ? error.message : String(error)}`);
            return false;
        }
    }
    /**
     * 코드로 새 파일 생성
     * @param code 코드 내용
     * @param language 언어
     * @param suggestedFilename 제안 파일명
     * @returns 성공 여부
     */
    static async createNewFileWithCode(code, language, suggestedFilename) {
        try {
            // 파일 확장자 추론
            const extension = this.getFileExtensionForLanguage(language);
            const filename = suggestedFilename || `new_file${extension}`;
            // 새 파일 생성
            const document = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument({
                language: language,
                content: code
            });
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showTextDocument(document);
            // 파일을 실제로 저장할지 물어보기
            const saveFile = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('새 파일이 생성되었습니다. 저장하시겠습니까?', '저장', '나중에');
            if (saveFile === '저장') {
                if (document.isDirty) {
                    const uri = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showSaveDialog({
                        defaultUri: vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.file(filename),
                        filters: {
                            '모든 파일': ['*']
                        }
                    });
                    if (uri) {
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.writeFile(uri, Buffer.from(code));
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`파일이 저장되었습니다: ${uri.fsPath}`);
                    }
                }
            }
            return true;
        }
        catch (error) {
            console.error('새 파일 생성 중 오류 발생:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`새 파일 생성 중 오류가 발생했습니다: ${error instanceof Error ? error.message : String(error)}`);
            return false;
        }
    }
    /**
     * 언어 ID로 파일 확장자 추론
     * @param language 언어 ID
     * @returns 파일 확장자
     */
    static getFileExtensionForLanguage(language) {
        const languageToExtension = {
            'typescript': '.ts',
            'javascript': '.js',
            'python': '.py',
            'java': '.java',
            'csharp': '.cs',
            'c': '.c',
            'cpp': '.cpp',
            'go': '.go',
            'rust': '.rs',
            'php': '.php',
            'ruby': '.rb',
            'html': '.html',
            'css': '.css',
            'json': '.json',
            'markdown': '.md',
            'plaintext': '.txt',
            'xml': '.xml',
            'yaml': '.yml',
            'shell': '.sh',
            'bash': '.sh',
            'powershell': '.ps1',
            'sql': '.sql'
        };
        return languageToExtension[language] || '.txt';
    }
    /**
     * 코드 삽입 전 위치 선택 대화상자 표시
     * @returns 삽입 옵션
     */
    static async promptForInsertionMode() {
        const options = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick([
            {
                label: '$(cursor) 커서 위치에 삽입',
                description: '현재 커서 위치에 코드를 삽입합니다.',
                detail: '기존 텍스트는 그대로 유지됩니다.',
                value: 'insert'
            },
            {
                label: '$(edit) 선택 영역 대체',
                description: '현재 선택 영역을 코드로 대체합니다.',
                detail: '선택 영역이 없으면 커서 위치에 삽입합니다.',
                value: 'replace'
            },
            {
                label: '$(new-file) 새 파일 생성',
                description: '코드로 새 파일을 생성합니다.',
                detail: '에디터에서 새 파일을 열고 코드를 삽입합니다.',
                value: 'new'
            }
        ], {
            placeHolder: '코드 삽입 방식을 선택하세요',
            matchOnDescription: true,
            matchOnDetail: true
        });
        if (!options) {
            return undefined; // 사용자가 취소함
        }
        switch (options.value) {
            case 'insert': {
                return { insertAtCursor: true };
            }
            case 'replace': {
                return { replaceSelection: true };
            }
            case 'new': {
                return { createNewFile: true };
            }
        }
        return undefined;
    }
    /**
     * 코드 삽입 명령 등록
     * @param context 확장 컨텍스트
     */
    static async registerCommands(context) {
        // 명령어 등록 전에 이미 등록되어 있는지 확인
        const existingCommands = await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.getCommands();
        // 코드 삽입 명령 등록 (중복 방지)
        if (!existingCommands.includes('ape.insertCodeToEditor')) {
            context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.insertCodeToEditor', async (options) => {
                const insertionOptions = await this.promptForInsertionMode();
                if (!insertionOptions) {
                    return false;
                }
                return await this.insertCodeToEditor({
                    ...options,
                    ...insertionOptions
                });
            }));
        }
        // 명령 바로 실행 (옵션 선택 없이)
        if (!existingCommands.includes('ape.insertCodeAtCursor')) {
            context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.insertCodeAtCursor', async (options) => {
                return await this.insertCodeToEditor({
                    ...options,
                    insertAtCursor: true
                });
            }));
        }
        // 선택 영역 대체 명령
        if (!existingCommands.includes('ape.replaceSelectionWithCode')) {
            context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.replaceSelectionWithCode', async (options) => {
                return await this.insertCodeToEditor({
                    ...options,
                    replaceSelection: true
                });
            }));
        }
        // 새 파일 생성 명령
        if (!existingCommands.includes('ape.createNewFileWithCode')) {
            context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.createNewFileWithCode', async (options) => {
                return await this.insertCodeToEditor({
                    ...options,
                    createNewFile: true
                });
            }));
        }
        // 파일 첨부 명령
        if (!existingCommands.includes('ape.attachFile')) {
            context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.attachFile', async () => {
                try {
                    // 현재 웹뷰 찾기
                    const activeViewColumn = vscode__WEBPACK_IMPORTED_MODULE_0__.window.activeTextEditor?.viewColumn || vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.One;
                    const panel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.visibleTextEditors
                        .find(editor => editor.viewColumn === activeViewColumn);
                    if (panel) {
                        // 파일 선택 대화상자 표시
                        const fileUris = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showOpenDialog({
                            canSelectFiles: true,
                            canSelectFolders: false,
                            canSelectMany: false,
                            openLabel: '첨부',
                            filters: {
                                'All Files': ['*']
                            }
                        });
                        if (fileUris && fileUris.length > 0) {
                            return fileUris[0].fsPath;
                        }
                    }
                    return null;
                }
                catch (error) {
                    console.error('파일 첨부 중 오류:', error);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`파일 첨부 중 오류가 발생했습니다: ${error instanceof Error ? error.message : String(error)}`);
                    return null;
                }
            }));
        }
    }
    /**
     * 코드 블록 UI 생성
     * @param codeContent 코드 내용
     * @param language 언어
     * @param showLineNumbers 라인 번호 표시 여부
     * @returns 포맷팅된 HTML
     */
    static formatCodeBlock(codeContent, language = 'plaintext', showLineNumbers = true) {
        const codeId = `code_${++this.codeBlockCounter}`;
        const escapedCode = this.escapeHtml(codeContent);
        // 라인 번호 생성
        const lineNumbers = showLineNumbers ?
            codeContent.split('\n').map((_, i) => `${i + 1}`).join('\n') : '';
        // 코드 블록 템플릿 사용
        const template = `<div class="code-block-container code-block-popup">
  <div class="code-block-header">
    <span class="code-block-language language-${language}">${language}</span>
    <div class="code-block-actions">
      <button class="code-action-button copy-button" data-code-id="${codeId}" title="복사">
        <i class="codicon codicon-copy"></i>
        <span class="tooltip">클립보드에 복사</span>
      </button>
      <button class="code-action-button insert-code-button" data-code-id="${codeId}" title="에디터에 삽입">
        <i class="codicon codicon-arrow-small-right"></i>
        <span class="tooltip">현재 파일에 복사</span>
      </button>
      <button class="code-action-button new-file-button" data-code-id="${codeId}" title="새 파일로 생성">
        <i class="codicon codicon-new-file"></i>
        <span class="tooltip">새 파일로 생성</span>
      </button>
    </div>
  </div>
  <div class="code-content ${showLineNumbers ? 'with-line-numbers' : ''}">
    ${showLineNumbers ? `<div class="line-numbers">${lineNumbers}</div>` : ''}
    <div class="code-area">
      <code class="language-${language}" id="code-${codeId}">${escapedCode}</code>
    </div>
  </div>
</div>`;
        return template;
    }
    /**
     * HTML 이스케이프 처리
     * @param unsafe 이스케이프할 문자열
     * @returns 이스케이프된 문자열
     */
    static escapeHtml(unsafe) {
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }
}


/***/ }),

/***/ "./src/ui/mainChatViewProvider.ts":
/*!****************************************!*\
  !*** ./src/ui/mainChatViewProvider.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MainChatViewProvider: () => (/* binding */ MainChatViewProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/chat */ "./src/types/chat.ts");
/* harmony import */ var _chat_codeService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chat/codeService */ "./src/ui/chat/codeService.ts");
/* harmony import */ var _welcomeView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./welcomeView */ "./src/ui/welcomeView.ts");




/**
 * MainChatViewProvider manages the primary chat interface WebView
 * with a clean, modern, and user-friendly design
 */
class MainChatViewProvider {
    _context;
    _llmService;
    _memoryService;
    _commandManager;
    _modelManager;
    static viewType = 'apeChat';
    _view;
    _messages = [];
    _isStreaming = false;
    _currentStreamMessageId = null;
    _streamUpdateTimeout = null;
    _modelChangeListener;
    // Command suggestion event
    _onDidSuggestCommands = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    onDidSuggestCommands = this._onDidSuggestCommands.event;
    constructor(_context, _llmService, _memoryService, _commandManager, _modelManager) {
        this._context = _context;
        this._llmService = _llmService;
        this._memoryService = _memoryService;
        this._commandManager = _commandManager;
        this._modelManager = _modelManager;
    }
    /**
     * Converts a URI to a webview-compatible URI
     */
    getWebviewResource(uri) {
        if (!this._view) {
            return null;
        }
        return this._view.webview.asWebviewUri(uri);
    }
    /**
     * Called when the view is first created or becomes visible again
     */
    async resolveWebviewView(webviewView, _context, _token) {
        this._view = webviewView;
        // Set options for the webview
        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [
                vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this._context.extensionUri, 'media'),
                vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this._context.extensionUri, 'out'),
                vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this._context.extensionUri, 'src')
            ]
        };
        // Load previous messages from memory service
        await this.loadMessages();
        // Set initial HTML content
        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);
        // Handle messages from the webview
        webviewView.webview.onDidReceiveMessage(this._handleMessage.bind(this));
        // Register code service handlers
        try {
            await _chat_codeService__WEBPACK_IMPORTED_MODULE_2__.CodeService.registerHandlers(this._context, webviewView.webview);
        }
        catch (error) {
            console.log('Code service handlers may already be registered:', error);
        }
        // Listen for model changes if ModelManager is available
        if (this._modelManager) {
            // Dispose any existing listener
            if (this._modelChangeListener) {
                this._modelChangeListener.dispose();
            }
            // Register new listener
            this._modelChangeListener = this._modelManager.onDidChangeModel(() => {
                // Update the UI when model changes
                this.updateModelIndicator();
            });
            // Add listener to context for disposal
            this._context.subscriptions.push(this._modelChangeListener);
        }
    }
    /**
     * Updates the model indicator UI with the current model
     */
    updateModelIndicator() {
        if (!this._view) {
            console.log('Model indicator update failed: no webview');
            return;
        }
        try {
            // Use ModelManager if available, otherwise fall back to LLMService
            let currentModel, displayName;
            if (this._modelManager) {
                currentModel = this._modelManager.getActiveModel();
                displayName = this._modelManager.getModelDisplayName(currentModel);
                console.log('Using ModelManager to get current model info:', currentModel);
            }
            else {
                currentModel = this._llmService.getActiveModel();
                displayName = this.getModelDisplayName(currentModel);
                console.log('Using LLMService to get current model info:', currentModel);
            }
            // Send message to webview to update model name display
            this._view.webview.postMessage({
                type: 'updateModelIndicator',
                modelName: displayName
            });
            console.log('Model indicator update message sent to webview');
        }
        catch (error) {
            console.error('Error updating model indicator:', error);
        }
    }
    /**
     * Converts model ID to a user-friendly display name
     * @deprecated Use the ModelManager.getModelDisplayName method instead
     */
    getModelDisplayName(modelId) {
        return this._llmService.getModelDisplayName(modelId);
    }
    /**
     * Sends a user message to the LLM and processes the response
     */
    async sendMessage(content) {
        if (!this._view) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('APE Chat view is not available');
            return;
        }
        if (this._isStreaming) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('Please wait for the current response to complete');
            return;
        }
        // Handle slash commands
        if (content.trim().startsWith('/')) {
            // Execute slash command directly via commandManager
            await this._commandManager.slashCommandManager.executeCommand(content);
            return;
        }
        // Create and add user message
        const userMessage = {
            id: `msg_${Date.now()}`,
            role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.User,
            content,
            timestamp: new Date()
        };
        this._messages.push(userMessage);
        this.updateChatView();
        try {
            // Create assistant message placeholder for streaming
            const assistantMessageId = `msg_${Date.now() + 1}`;
            const assistantMessage = {
                id: assistantMessageId,
                role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.Assistant,
                content: '',
                timestamp: new Date()
            };
            this._messages.push(assistantMessage);
            this._currentStreamMessageId = assistantMessageId;
            this._isStreaming = true;
            this.updateChatView();
            // Filter messages before sending to LLM
            const filteredMessages = this._messages.filter(message => {
                // Remove UI-only messages by checking metadata flag
                if (message.metadata?.uiOnly === true) {
                    console.log(`Filtering out UI-only message: ${message.id}`);
                    return false;
                }
                // As a fallback, also filter by content for older message formats
                if (message.role === _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System) {
                    const content = message.content || '';
                    if (content.includes('<div class="welcome-container"') ||
                        (content.trim().startsWith('<') && content.includes('</div>'))) {
                        console.log(`Filtering out HTML system message: ${message.id}`);
                        return false;
                    }
                }
                // Keep all other messages
                return true;
            });
            console.log(`Filtered out ${this._messages.length - filteredMessages.length} UI-only messages before LLM request`);
            // Start streaming response from LLM with filtered messages
            await this._llmService.streamResponse(filteredMessages, (chunk, done) => {
                // Update the assistant message with the new chunk only if it has content
                const assistantMessage = this._messages.find(m => m.id === this._currentStreamMessageId);
                if (assistantMessage) {
                    // Only append non-empty chunks
                    if (chunk && chunk.trim()) {
                        assistantMessage.content += chunk;
                        // Debounce updates for efficiency
                        if (!this._streamUpdateTimeout) {
                            this._streamUpdateTimeout = setTimeout(() => {
                                this.updateChatView();
                                this._streamUpdateTimeout = null;
                            }, 30); // 30ms debouncing
                        }
                    }
                    if (done) {
                        // Stream completed
                        this._isStreaming = false;
                        this._currentStreamMessageId = null;
                        // Cancel any pending timeout
                        if (this._streamUpdateTimeout) {
                            clearTimeout(this._streamUpdateTimeout);
                            this._streamUpdateTimeout = null;
                        }
                        // Save messages to memory
                        this.saveMessages();
                        this.updateChatView();
                    }
                }
            });
        }
        catch (error) {
            this._isStreaming = false;
            this._currentStreamMessageId = null;
            // Cancel any pending timeout
            if (this._streamUpdateTimeout) {
                clearTimeout(this._streamUpdateTimeout);
                this._streamUpdateTimeout = null;
            }
            // Add error message
            const errorMessage = {
                id: `msg_error_${Date.now()}`,
                role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System,
                content: `Error: ${error instanceof Error ? error.message : String(error)}`,
                timestamp: new Date()
            };
            this._messages.push(errorMessage);
            this.updateChatView();
        }
    }
    /**
     * Clears all messages from the chat and shows welcome screen
     */
    clearChat() {
        console.log('Clearing chat - creating new welcome message');
        // Clear messages from memory service
        this._memoryService.clearMessages();
        try {
            // Get HTML content for welcome message
            const welcomeHTML = _welcomeView__WEBPACK_IMPORTED_MODULE_3__.WelcomeViewProvider.getWelcomeMessageHTML();
            console.log('WelcomeViewProvider used - welcome HTML generated, length:', welcomeHTML.length);
            // Create welcome messages
            const welcomeId = `welcome_${Date.now()}`;
            const assistantId = `assistant_welcome_${Date.now()}`;
            this._messages = [
                {
                    id: welcomeId,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System,
                    content: welcomeHTML,
                    timestamp: new Date()
                },
                {
                    id: assistantId,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.Assistant,
                    content: '안녕하세요! 무엇을 도와드릴까요?',
                    timestamp: new Date()
                }
            ];
            console.log('Welcome messages added - IDs:', welcomeId, assistantId);
            // Update UI immediately
            this.updateChatView();
        }
        catch (error) {
            console.error('Error creating welcome message:', error);
            this._messages = [{
                    id: `error_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System,
                    content: '웰컴 화면을 불러오는 중 오류가 발생했습니다.',
                    timestamp: new Date()
                }];
            // Update UI with error message
            this.updateChatView();
        }
    }
    /**
     * Loads messages from memory service
     */
    async loadMessages() {
        console.log('Loading messages - checking for existing messages');
        const result = await this._memoryService.getMessages();
        if (result.success && result.data && result.data.length > 0) {
            console.log(`Loaded ${result.data.length} saved messages`);
            this._messages = result.data;
        }
        else {
            console.log('No saved messages found, adding welcome message');
            try {
                // Get HTML content for welcome message with error handling
                let welcomeHTML = '';
                try {
                    welcomeHTML = _welcomeView__WEBPACK_IMPORTED_MODULE_3__.WelcomeViewProvider.getWelcomeMessageHTML();
                    console.log('WelcomeViewProvider used - welcome HTML generated');
                }
                catch (welcomeError) {
                    console.error('Error getting welcome HTML from provider:', welcomeError);
                    welcomeHTML = '<div class="welcome-container minimal"><h1>Welcome to APE</h1></div>';
                }
                // Create UI-only welcome message and conversation starter
                const welcomeId = `welcome_ui_${Date.now()}`;
                const assistantId = `assistant_welcome_${Date.now()}`;
                // Ensure welcome HTML is not empty
                if (!welcomeHTML || welcomeHTML.trim() === '') {
                    welcomeHTML = '<div class="welcome-container minimal"><h1>Welcome to APE</h1></div>';
                    console.warn('Empty welcome HTML detected, using fallback');
                }
                this._messages = [
                    // UI-only message with metadata flag
                    {
                        id: welcomeId,
                        role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System,
                        content: welcomeHTML,
                        timestamp: new Date(),
                        metadata: {
                            uiOnly: true, // Flag to indicate this shouldn't be sent to LLM
                            type: 'welcome' // Mark this as a welcome message
                        }
                    },
                    // Actual assistant greeting message
                    {
                        id: assistantId,
                        role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.Assistant,
                        content: 'Welcome to APE. How can I assist with your development today?',
                        timestamp: new Date()
                    }
                ];
                console.log('Welcome messages added - IDs:', welcomeId, assistantId);
            }
            catch (error) {
                console.error('Error creating welcome message:', error);
                this._messages = [{
                        id: `error_${Date.now()}`,
                        role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System,
                        content: '웰컴 화면을 불러오는 중 오류가 발생했습니다.',
                        timestamp: new Date()
                    }];
            }
        }
    }
    /**
     * Saves messages to memory service
     */
    async saveMessages() {
        for (const message of this._messages) {
            await this._memoryService.addMessage(message);
        }
    }
    /**
     * Updates the chat view with the current messages
     */
    updateChatView() {
        if (this._view) {
            this._view.webview.postMessage({
                type: 'updateMessages',
                messages: this._messages,
                isStreaming: this._isStreaming
            });
        }
    }
    /**
     * Handles messages sent from the webview
     */
    _handleMessage(message) {
        switch (message.type) {
            case 'sendMessage':
                this.sendMessage(message.content);
                break;
            case 'cancelStream':
                this._llmService.cancelStream();
                this._isStreaming = false;
                this._currentStreamMessageId = null;
                // Cancel any pending timeout
                if (this._streamUpdateTimeout) {
                    clearTimeout(this._streamUpdateTimeout);
                    this._streamUpdateTimeout = null;
                }
                this.updateChatView();
                break;
            case 'clearChat':
                this.clearChat();
                break;
            case 'command':
                // Execute command from help panel
                this.sendMessage(message.command);
                break;
            case 'insertCommand':
                // Insert command text into chat input
                this.insertCommandToChat(message.command);
                break;
            case 'getEditorContent':
                this.getEditorContent().then(content => {
                    if (this._view) {
                        this._view.webview.postMessage({
                            type: 'editorContent',
                            content
                        });
                    }
                });
                break;
            case 'inputChanged':
                // Update command suggestions when input changes
                this.updateCommandSuggestions(message.content);
                break;
            case 'showModelSelector':
                console.log('Model selector request received');
                try {
                    // Call CommandManager's selectModel directly
                    if (this._commandManager) {
                        Promise.resolve(this._commandManager.selectModel()).catch((error) => {
                            console.error('Error executing model selection command:', error);
                            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Unable to execute model selection');
                        });
                    }
                    else {
                        // Fallback: Use VSCode command system
                        Promise.resolve(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.selectModel')).catch((error) => {
                            console.error('Error executing VSCode command:', error);
                            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Unable to execute model selection');
                        });
                    }
                }
                catch (error) {
                    console.error('Unexpected error:', error);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Unexpected error during model selection');
                }
                break;
            case 'copyCode':
            case 'insertCodeToEditor':
            case 'createFileWithCode':
                // Code block actions handled by CodeService
                break;
        }
    }
    /**
     * Updates command suggestions
     */
    updateCommandSuggestions(input) {
        if (input.startsWith('/')) {
            // Get slash command suggestions
            const suggestions = this._commandManager.slashCommandManager.getCommandSuggestions(input);
            // Send suggestions to webview
            if (this._view) {
                this._view.webview.postMessage({
                    type: 'commandSuggestions',
                    suggestions
                });
            }
            // Fire event for VSCode integration
            this._onDidSuggestCommands.fire(suggestions);
        }
        else if (this._view) {
            // Clear suggestions
            this._view.webview.postMessage({
                type: 'commandSuggestions',
                suggestions: []
            });
        }
    }
    /**
     * Inserts a command into the chat input
     */
    insertCommandToChat(command) {
        if (!this._view) {
            return;
        }
        // Send insert command request to webview
        this._view.webview.postMessage({
            type: 'insertCommandToInput',
            command: command
        });
    }
    /**
     * Inserts text into the chat input from external sources
     */
    handleChatInput(text) {
        if (!this._view) {
            return;
        }
        // Send insert text request to webview
        this._view.webview.postMessage({
            type: 'insertCommandToInput',
            command: text
        });
    }
    /**
     * Adds a direct LLM response to the chat from external sources
     * Used for automated test results or system messages
     */
    async sendLlmResponse(message) {
        if (!this._view) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('APE Chat view is not available');
            return;
        }
        // Create message object
        const newMessage = {
            id: `msg_${Date.now()}`,
            role: message.role,
            content: message.content,
            timestamp: new Date()
        };
        // Add message to list
        this._messages.push(newMessage);
        // Save to memory
        await this._memoryService.addMessage(newMessage);
        // Update UI
        this.updateChatView();
    }
    /**
     * Gets content from the active editor
     */
    async getEditorContent() {
        const editor = vscode__WEBPACK_IMPORTED_MODULE_0__.window.activeTextEditor;
        if (editor) {
            const document = editor.document;
            const selection = editor.selection;
            // Return selected text if there's a selection, otherwise entire document
            if (!selection.isEmpty) {
                return document.getText(selection);
            }
            else {
                return document.getText();
            }
        }
        return null;
    }
    /**
     * Generates the HTML for the main chat interface webview
     */
    _getHtmlForWebview(webview) {
        console.log('Generating main chat interface HTML for webview');
        // Get paths to local resources
        const mainStylesUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this._context.extensionUri, 'media', 'chat-ape.css'));
        console.log('chat-main.css URI:', mainStylesUri.toString());
        const codiconsUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this._context.extensionUri, 'media', 'codicon', 'codicon.css'));
        console.log('codicon.css URI:', codiconsUri.toString());
        const codeBlockStylesUri = _chat_codeService__WEBPACK_IMPORTED_MODULE_2__.CodeService.getCodeBlockStyleUri(webview, this._context);
        console.log('code-block.css URI:', codeBlockStylesUri.toString());
        const nonce = this._getNonce();
        return `<!DOCTYPE html>
    <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; font-src ${webview.cspSource} data:; img-src ${webview.cspSource} https: data:; script-src 'nonce-${nonce}' 'unsafe-inline';">
      <link href="${mainStylesUri}" rel="stylesheet" onload="console.log('chat-main.css loaded')" onerror="console.error('Failed to load chat-main.css')">
      <link href="${codiconsUri}" rel="stylesheet" onload="console.log('codicon.css loaded')" onerror="console.error('Failed to load codicon.css')">
      <link href="${codeBlockStylesUri}" rel="stylesheet" onload="console.log('code-block.css loaded')" onerror="console.error('Failed to load code-block.css')">
      <title>APE Chat</title>
    </head>
    <body>
      <div id="chat-container">
        <div class="chat-header">
          <div class="chat-title">APE Chat</div>
        </div>
        <div id="chat-messages"></div>
        <div id="chat-input-container">
          <textarea id="chat-input" placeholder="메시지 입력..." rows="1"></textarea>
          <div id="input-buttons">
            <button id="clear-button" title="대화 지우기">
              <span class="emoji-icon">ⓧ</span>
            </button>
            <button id="send-button" title="메시지 전송">
              <svg class="send-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
          </div>
        </div>
        <div id="model-indicator">
          <span id="model-name">LLM Model</span>
          <button id="model-selector" title="모델 변경">
            모델 변경
          </button>
        </div>
        <div id="command-suggestions"></div>
      </div>
      
      <script nonce="${nonce}">
        // Main script
        (function() {
          // Initial data
          const vscode = acquireVsCodeApi();
          const initialMessages = ${JSON.stringify(this._messages)};
          const isStreaming = ${this._isStreaming};
          let codeBlockCounter = 0;
          
          // Store messages in state
          vscode.setState({ messages: initialMessages });
          
          // Setup message handler
          window.addEventListener('message', event => {
            const message = event.data;
            
            switch (message.type) {
              case 'updateMessages': {
                updateMessages(message.messages, message.isStreaming);
                break;
              }
                
              case 'editorContent': {
                handleEditorContent(message.content);
                break;
              }
                
              case 'commandSuggestions': {
                updateCommandSuggestions(message.suggestions);
                break;
              }
                
              case 'insertCommandToInput': {
                insertCommandFromHelp(message.command);
                break;
              }
                
              case 'updateModelIndicator': {
                // Update model name display
                if (modelIndicator) {
                  modelIndicator.textContent = message.modelName;
                }
                break;
              }
            }
          });
          
          // DOM Elements - initialize as variables first, we'll get them in init()
          let chatMessages;
          let chatInput;
          let sendButton;
          let clearButton;
          let modelIndicator;
          let modelSelector;
          
          // Command suggestions container
          let commandSuggestionsContainer;
          
          // Active suggestion index
          let activeSuggestionIndex = -1;
          let suggestions = [];
          
          // Smart scroll state management
          let isUserScrolled = false;
          let isScrollNearBottom = true;
          const SCROLL_THRESHOLD = 100; // Distance from bottom to consider "near bottom"
        
          // Detect user scroll function
          function detectUserScroll() {
            if (!chatMessages) return;
            
            // Calculate scroll position
            const scrollPosition = chatMessages.scrollTop + chatMessages.clientHeight;
            const scrollThreshold = chatMessages.scrollHeight - SCROLL_THRESHOLD;
            
            // Check if scroll is near bottom
            isScrollNearBottom = scrollPosition >= scrollThreshold;
            
            // Detect user scrolling up
            if (!isScrollNearBottom) {
              isUserScrolled = true;
            }
          }
          
          // Smart scroll function
          function performSmartScroll(forceScroll = false) {
            if (!chatMessages) return;
            
            // Only scroll if user hasn't scrolled up, or a force scroll is needed
            if (forceScroll || !isUserScrolled || isScrollNearBottom) {
              chatMessages.scrollTop = chatMessages.scrollHeight;
              isUserScrolled = false;
            }
          }

          // Helper function to format date for iOS-style timestamp display
          function formatMessageDate(date) {
            if (!date) return '';
            
            // Create a date object
            const messageDate = new Date(date);
            
            // Get current date
            const now = new Date();
            
            // Check if message is from today
            const isToday = messageDate.toDateString() === now.toDateString();
            
            // Format the time (HH:MM)
            const hours = messageDate.getHours().toString().padStart(2, '0');
            const minutes = messageDate.getMinutes().toString().padStart(2, '0');
            const timeStr = \`\${hours}:\${minutes}\`;
            
            // Return appropriate format based on age
            if (isToday) {
              return timeStr;
            } else {
              // For older messages, include date
              const month = messageDate.getMonth() + 1;
              const day = messageDate.getDate();
              return \`\${month}월 \${day}일 \${timeStr}\`;
            }
          }
          
          // Get the timestamp group for a message
          function getTimestampGroup(date) {
            if (!date) return 'unknown';
            
            const messageDate = new Date(date);
            return messageDate.toDateString();
          }
          
          // Add timestamp dividers between message groups
          function addTimestampDividers(messages) {
            const result = [];
            let currentGroup = null;
            
            messages.forEach((message, index) => {
              // Determine the timestamp group for this message
              const group = getTimestampGroup(message.timestamp);
              
              // If group changed, add timestamp divider
              if (group !== currentGroup) {
                currentGroup = group;
                
                // Skip adding timestamp for welcome message
                if (index > 0) {
                  const divider = {
                    id: \`timestamp_\${Date.now()}_\${index}\`,
                    type: 'timestamp',
                    content: formatMessageDate(message.timestamp),
                    timestamp: message.timestamp
                  };
                  result.push(divider);
                }
              }
              
              // Add the actual message
              result.push(message);
            });
            
            return result;
          }
          
          // Message DOM ID converter
          function getMessageDomId(messageId) {
            return 'msg-' + messageId.replace(/\\s+/g, '-');
          }
          
          // Update messages in the UI
          function updateMessages(messages, isStreaming) {
            console.log("updateMessages called with", messages.length, "messages, isStreaming:", isStreaming);
            
            // Store in state
            vscode.setState({ messages });
            
            // Check if chatMessages exists
            if (!chatMessages) {
              console.error("Error: chatMessages element not found. Retrying initialization...");
              setTimeout(init, 100);
              return;
            }
            
            // Get current messages in the DOM
            const currentMessageIds = Array.from(chatMessages.children)
              .filter(el => el.classList.contains('message'))
              .map(el => el.getAttribute('data-message-id'))
              .filter(id => id);
            
            // Check scroll position
            detectUserScroll();
            
            // Add timestamp dividers
            const messagesWithTimestamps = addTimestampDividers(messages);
            
            // Get DOM elements that should be in the view
            const shouldContainIds = messagesWithTimestamps.map(m => m.id);

            // Add typing indicator if streaming
            if (isStreaming) {
              if (!document.querySelector('.typing-indicator')) {
                const typingIndicator = document.createElement('div');
                typingIndicator.className = 'typing-indicator';
                typingIndicator.innerHTML = \`
                  <span class="typing-dot"></span>
                  <span class="typing-dot"></span>
                  <span class="typing-dot"></span>
                \`;
                
                // Add after last message
                chatMessages.appendChild(typingIndicator);
              }
            } else {
              // Remove typing indicator if present
              const typingIndicator = document.querySelector('.typing-indicator');
              if (typingIndicator) {
                typingIndicator.remove();
              }
            }
            
            // Remove elements that should no longer be in the view
            Array.from(chatMessages.children).forEach(el => {
              const id = el.getAttribute('data-message-id');
              // Keep timestamp dividers
              if (!id || !shouldContainIds.includes(id)) {
                // Don't remove typing indicator
                if (!el.classList.contains('typing-indicator')) {
                  el.remove();
                }
              }
            });
            
            // Clear existing timestamp dividers (we'll recreate them)
            Array.from(chatMessages.querySelectorAll('.timestamp-divider')).forEach(el => {
              el.remove();
            });
            
            // Create mapping for quick element lookup
            const elementMap = {};
            Array.from(chatMessages.children).forEach(el => {
              const id = el.getAttribute('data-message-id');
              if (id) {
                elementMap[id] = el;
              }
            });
            
            // Process messages and add to DOM
            let previousElement = null;
            messagesWithTimestamps.forEach((item, index) => {
              // Handle timestamp dividers
              if (item.type === 'timestamp') {
                const dividerElement = document.createElement('div');
                dividerElement.className = 'timestamp-divider';
                dividerElement.setAttribute('data-message-id', item.id);
                
                dividerElement.innerHTML = \`
                  <span class="timestamp-text">\${item.content}</span>
                \`;
                
                // Insert divider at correct position
                if (previousElement) {
                  previousElement.after(dividerElement);
                } else {
                  chatMessages.appendChild(dividerElement);
                }
                
                previousElement = dividerElement;
                return;
              }
              
              // Handle regular messages
              const message = item;
              const messageId = message.id;
              let messageElement = elementMap[messageId];
              const isLastMessage = message.id === messages[messages.length - 1].id;
              
              // Create new message element if needed
              if (!messageElement) {
                messageElement = document.createElement('div');
                messageElement.className = 'message ' + message.role;
                messageElement.setAttribute('data-message-id', messageId);
                
                const contentElement = document.createElement('div');
                contentElement.className = 'message-content';
                messageElement.appendChild(contentElement);
                
                // Add read/delivered indicator for user messages
                if (message.role === 'user') {
                  const statusElement = document.createElement('div');
                  statusElement.className = 'message-status';
                  messageElement.appendChild(statusElement);
                }
                
                // Insert at correct position
                if (previousElement) {
                  previousElement.after(messageElement);
                } else {
                  chatMessages.appendChild(messageElement);
                }
              }
              
              // Update content if changed
              const contentElement = messageElement.querySelector('.message-content');
              const formattedContent = formatMessageContent(message.content);
              
              if (contentElement.innerHTML !== formattedContent) {
                contentElement.innerHTML = formattedContent;
              }
              
              previousElement = messageElement;
            });
            
            // Smart scroll (force scroll for new messages or when streaming ends)
            performSmartScroll(messages.length !== currentMessageIds.length || !isStreaming);
            
            // Update UI based on streaming state
            if (isStreaming) {
              sendButton.innerHTML = \`<span class="emoji-icon">■</span>\`;
              sendButton.title = '생성 중단';
              chatInput.disabled = true;
            } else {
              sendButton.innerHTML = \`
                <svg class="send-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              \`;
              sendButton.title = '메시지 전송';
              chatInput.disabled = false;
            }
          }
          
          // Format message content with code blocks and other formatting
          function formatMessageContent(content) {
            if (!content) return '';
            
            // If content is already HTML, return as is
            const trimmedContent = content.trim();
            if (trimmedContent.startsWith('<') && (
              trimmedContent.includes('</div>') || 
              trimmedContent.includes('</p>') || 
              trimmedContent.includes('</h') || 
              trimmedContent.includes('</span>') ||
              trimmedContent.includes('</ul>') ||
              trimmedContent.includes('</li>') ||
              trimmedContent.includes('</table>') ||
              trimmedContent.match(/<[a-zA-Z0-9_]+[^>]*>/)
            )) {
              return content;
            }
            
            // Format content
            let formatted = content;
            
            // Replace code blocks with modern UI
            formatted = formatted.replace(/\`\`\`(\\w*)\\n([\\s\\S]*?)\\n\`\`\`/g, function(match, language, code) {
              const codeId = 'code_' + (++codeBlockCounter);
              const escapedCode = escapeHtml(code);
              const lang = language || 'plaintext';
              
              // Generate line numbers
              const lines = code.split('\\n');
              const lineNumbers = lines.map((_, i) => (i + 1)).join('\\n');
              const showLineNumbers = lines.length > 1;
              
              // Create code block HTML
              return '<div class="code-block-container code-block-popup">' +
                '<div class="code-block-header">' +
                  '<span class="code-block-language language-' + lang + '">' + lang + '</span>' +
                  '<div class="code-block-actions">' +
                    '<button class="code-action-button copy-button" data-code-id="' + codeId + '" title="복사">' +
                      '<i class="codicon codicon-copy"></i>' +
                      '<span class="tooltip">클립보드에 복사</span>' +
                    '</button>' +
                    '<button class="code-action-button insert-code-button" data-code-id="' + codeId + '" title="에디터에 삽입">' +
                      '<i class="codicon codicon-arrow-small-right"></i>' +
                      '<span class="tooltip">현재 파일에 복사</span>' +
                    '</button>' +
                    '<button class="code-action-button new-file-button" data-code-id="' + codeId + '" title="새 파일로 생성">' +
                      '<i class="codicon codicon-new-file"></i>' +
                      '<span class="tooltip">새 파일로 생성</span>' +
                    '</button>' +
                  '</div>' +
                '</div>' +
                '<div class="code-content ' + (showLineNumbers ? 'with-line-numbers' : '') + '">' +
                  (showLineNumbers ? '<div class="line-numbers">' + lineNumbers + '</div>' : '') +
                  '<div class="code-area">' +
                    '<code class="language-' + lang + '" id="code-' + codeId + '">' + escapedCode + '</code>' +
                  '</div>' +
                '</div>' +
              '</div>';
            });
            
            // Replace inline code
            formatted = formatted.replace(/\`([^\`]+)\`/g, function(match, code) {
              return '<code class="inline-code">' + escapeHtml(code) + '</code>';
            });
            
            // Replace newlines with <br>
            formatted = formatted.replace(/\\n/g, '<br>');
            
            return formatted;
          }
          
          // HTML escape function
          function escapeHtml(unsafe) {
            return unsafe
              .replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&#039;");
          }
          
          // Handle editor content insertion
          function handleEditorContent(content) {
            if (content) {
              chatInput.value += '\`\`\`\\n' + content + '\\n\`\`\`\\n';
              resizeInput();
            }
          }
          
          // Auto-resize input based on content
          function resizeInput() {
            chatInput.style.height = 'auto';
            chatInput.style.height = (chatInput.scrollHeight) + 'px';
          }
          
          // Update command suggestions in popover
          function updateCommandSuggestions(newSuggestions) {
            suggestions = newSuggestions || [];
            activeSuggestionIndex = -1;
            
            // Clear the container
            commandSuggestionsContainer.innerHTML = '';
            
            if (suggestions.length === 0) {
              // Hide the container if no suggestions
              commandSuggestionsContainer.style.display = 'none';
              return;
            }
            
            // Position the suggestions container
            positionCommandSuggestions();
            
            // Show the container
            commandSuggestionsContainer.style.display = 'block';
            
            // Group suggestions by category
            const categorizedSuggestions = {};
            suggestions.forEach(suggestion => {
              // Add category data attribute
              suggestion.categoryAttr = suggestion.category;
              
              if (!categorizedSuggestions[suggestion.category]) {
                categorizedSuggestions[suggestion.category] = [];
              }
              categorizedSuggestions[suggestion.category].push(suggestion);
            });
            
            // Add each category and its suggestions
            Object.keys(categorizedSuggestions).forEach(category => {
              // Create category header
              const categoryHeader = document.createElement('div');
              categoryHeader.className = 'suggestion-category';
              categoryHeader.textContent = getCategoryTitle(category);
              commandSuggestionsContainer.appendChild(categoryHeader);
              
              // Add suggestions for this category
              categorizedSuggestions[category].forEach((suggestion, index) => {
                const suggestionElement = document.createElement('div');
                suggestionElement.className = 'command-suggestion';
                suggestionElement.dataset.category = suggestion.categoryAttr;
                const suggestionIndex = suggestions.findIndex(s => s.label === suggestion.label);
                suggestionElement.dataset.index = String(suggestionIndex);
                
                // Add icon
                const iconElement = document.createElement('span');
                iconElement.className = 'suggestion-icon';
                iconElement.textContent = getSvgIconForCategory(suggestion.category);
                suggestionElement.appendChild(iconElement);
                
                // Add label
                const labelElement = document.createElement('span');
                labelElement.className = 'suggestion-label';
                labelElement.textContent = suggestion.label;
                suggestionElement.appendChild(labelElement);
                
                // Add description
                const descriptionElement = document.createElement('span');
                descriptionElement.className = 'suggestion-description';
                descriptionElement.textContent = suggestion.description;
                suggestionElement.appendChild(descriptionElement);
                
                // Add click handler
                suggestionElement.addEventListener('click', () => {
                  insertSuggestion(suggestion);
                });
                
                // Add mouseover handler
                suggestionElement.addEventListener('mouseover', () => {
                  activeSuggestionIndex = Number(suggestionElement.dataset.index);
                  highlightActiveSuggestion();
                });
                
                commandSuggestionsContainer.appendChild(suggestionElement);
              });
            });
            
            // Scroll to top
            commandSuggestionsContainer.scrollTop = 0;
          }
          
          // Position command suggestions popover
          function positionCommandSuggestions() {
            if (!chatInput || !commandSuggestionsContainer) return;
            
            // Get the input container's position
            const inputContainer = document.getElementById('chat-input-container');
            if (!inputContainer) return;
            
            const inputRect = inputContainer.getBoundingClientRect();
            
            // Set the position relative to the input container
            commandSuggestionsContainer.style.position = 'absolute';
            commandSuggestionsContainer.style.bottom = (inputRect.height + 8) + 'px';
            commandSuggestionsContainer.style.left = '12px';
            commandSuggestionsContainer.style.right = '12px';
            
            // Make sure it's visible
            commandSuggestionsContainer.style.zIndex = '1000';
          }
          
          // Get category title
          function getCategoryTitle(category) {
            switch (category) {
              case 'general': return '일반 명령어';
              case 'git': return 'Git 관련 명령어';
              case 'code': return '코드 관련 명령어';
              case 'utility': return '유틸리티 명령어';
              case 'advanced': return '고급 명령어';
              default: return category;
            }
          }
          
          // Get icon for category
          function getSvgIconForCategory(category) {
            switch (category) {
              case 'general': return '✓';
              case 'git': return '⎇';
              case 'code': return '❮❯';
              case 'utility': return '⚙';
              case 'advanced': return '★';
              default: return '○';
            }
          }
          
          // Highlight active suggestion
          function highlightActiveSuggestion() {
            // Remove highlight from all suggestions
            document.querySelectorAll('.command-suggestion').forEach(el => {
              el.classList.remove('active');
            });
            
            // Highlight the active suggestion
            if (activeSuggestionIndex >= 0 && activeSuggestionIndex < suggestions.length) {
              const activeElement = document.querySelector(
                '.command-suggestion[data-index="' + activeSuggestionIndex + '"]'
              );
              
              if (activeElement) {
                activeElement.classList.add('active');
                
                // Scroll into view if needed
                const container = commandSuggestionsContainer;
                const elementTop = activeElement.offsetTop;
                const elementBottom = elementTop + activeElement.offsetHeight;
                const containerTop = container.scrollTop;
                const containerBottom = containerTop + container.offsetHeight;
                
                if (elementTop < containerTop) {
                  container.scrollTop = elementTop;
                } else if (elementBottom > containerBottom) {
                  container.scrollTop = elementBottom - container.offsetHeight;
                }
              }
            }
          }
          
          // Insert suggestion into input
          function insertSuggestion(suggestion) {
            if (!suggestion) return;
            
            chatInput.value = suggestion.insertText;
            chatInput.focus();
            
            // Position cursor at the end
            chatInput.selectionStart = chatInput.selectionEnd = chatInput.value.length;
            
            // Resize input
            resizeInput();
            
            // Clear suggestions
            updateCommandSuggestions([]);
            
            // Notify about input change
            notifyInputChanged();
          }
          
          // List of standalone commands (ones that can be auto-executed)
          const standAloneCommands = ['help', 'clear', 'settings', 'model'];
          
          // Check if a command can be executed standalone
          function isStandAloneCommand(commandText) {
            if (!commandText.startsWith('/')) return false;
            
            const commandParts = commandText.substring(1).split(/ +/);
            const baseCommand = commandParts[0];
            
            return standAloneCommands.includes(baseCommand) && commandParts.length === 1;
          }
          
          // Send message function
          function sendMessage() {
            const content = chatInput.value.trim();
            if (content) {
              vscode.postMessage({ type: 'sendMessage', content });
              chatInput.value = '';
              resizeInput();
              
              // Clear suggestions
              updateCommandSuggestions([]);
            }
          }
          
          // Navigate through suggestions
          function navigateSuggestions(direction) {
            if (suggestions.length === 0) return false;
            
            // Set active index to 0 if not set
            if (activeSuggestionIndex === -1) {
              activeSuggestionIndex = 0;
              highlightActiveSuggestion();
              return true;
            }
            
            // Navigate based on direction
            if (direction === 'up') {
              activeSuggestionIndex = activeSuggestionIndex <= 0 ? 
                suggestions.length - 1 : activeSuggestionIndex - 1;
            } else if (direction === 'down') {
              activeSuggestionIndex = activeSuggestionIndex >= suggestions.length - 1 ? 
                0 : activeSuggestionIndex + 1;
            }
            
            highlightActiveSuggestion();
            return true;
          }
          
          // Notify about input change
          function notifyInputChanged() {
            const inputValue = chatInput.value;
            
            vscode.postMessage({ 
              type: 'inputChanged', 
              content: inputValue 
            });
          }
          
          // Insert command from help panel
          function insertCommandFromHelp(command) {
            // Add slash if not present
            if (!command.startsWith('/')) {
              command = '/' + command;
            }
            
            // Set input value
            chatInput.value = command;
            chatInput.focus();
            
            // Position cursor at end
            chatInput.selectionStart = chatInput.selectionEnd = chatInput.value.length;
            
            // Resize input and notify
            resizeInput();
            notifyInputChanged();
          }
          
          // Set up event listeners for code actions
          function setupCodeBlockListeners() {
            chatMessages.addEventListener('click', event => {
              const target = event.target;
              
              // Check for copy button
              if (target.closest('.copy-button')) {
                const button = target.closest('.copy-button');
                const codeId = button.getAttribute('data-code-id');
                const codeElement = document.getElementById('code-' + codeId);
                
                if (codeElement) {
                  vscode.postMessage({ 
                    type: 'copyCode', 
                    code: codeElement.textContent 
                  });
                  
                  // Show copied feedback
                  button.classList.add('copied');
                  setTimeout(() => {
                    button.classList.remove('copied');
                  }, 2000);
                }
              }
              
              // Check for insert code button
              if (target.closest('.insert-code-button')) {
                const button = target.closest('.insert-code-button');
                const codeId = button.getAttribute('data-code-id');
                const codeElement = document.getElementById('code-' + codeId);
                
                if (codeElement) {
                  vscode.postMessage({ 
                    type: 'insertCodeToEditor', 
                    code: codeElement.textContent 
                  });
                }
              }
              
              // Check for new file button
              if (target.closest('.new-file-button')) {
                const button = target.closest('.new-file-button');
                const codeId = button.getAttribute('data-code-id');
                const codeElement = document.getElementById('code-' + codeId);
                const languageElement = button.closest('.code-block-container').querySelector('.code-block-language');
                
                if (codeElement) {
                  const language = languageElement ? 
                    languageElement.textContent.trim() || 'plaintext' : 
                    'plaintext';
                    
                  vscode.postMessage({ 
                    type: 'createFileWithCode', 
                    code: codeElement.textContent,
                    language: language
                  });
                }
              }
            });
          }
          
          // Initialize UI
          function init() {
            console.log("Initializing iOS-style chat UI");
            
            // Get DOM elements
            chatMessages = document.getElementById('chat-messages');
            chatInput = document.getElementById('chat-input');
            sendButton = document.getElementById('send-button');
            clearButton = document.getElementById('clear-button');
            modelIndicator = document.getElementById('model-name');
            modelSelector = document.getElementById('model-selector');
            commandSuggestionsContainer = document.getElementById('command-suggestions');
            
            // Check if elements are found
            if (!chatMessages || !chatInput || !sendButton || !clearButton || !commandSuggestionsContainer) {
              console.error("Critical UI elements missing");
              setTimeout(init, 500);
              return;
            }
            
            console.log("UI elements initialized successfully");
            
            // Set up smart scroll detection
            chatMessages.addEventListener('scroll', detectUserScroll);
            
            // Set up event listeners
            sendButton.addEventListener('click', () => {
              if (chatInput.disabled) {
                vscode.postMessage({ type: 'cancelStream' });
              } else {
                sendMessage();
              }
            });
            
            clearButton.addEventListener('click', () => {
              vscode.postMessage({ type: 'clearChat' });
            });
            
            chatInput.addEventListener('input', () => {
              resizeInput();
              notifyInputChanged();
              
              // Directly check for slash commands here as well
              if (chatInput.value.startsWith('/')) {
                console.log('Slash command detected:', chatInput.value);
              }
            });
            
            chatInput.addEventListener('keydown', (e) => {
              if (suggestions.length > 0) {
                if (e.key === 'ArrowUp') {
                  if (navigateSuggestions('up')) {
                    e.preventDefault();
                    return;
                  }
                } else if (e.key === 'ArrowDown') {
                  if (navigateSuggestions('down')) {
                    e.preventDefault();
                    return;
                  }
                } else if (e.key === 'Enter' && activeSuggestionIndex >= 0) {
                  if (activeSuggestionIndex >= 0 && activeSuggestionIndex < suggestions.length) {
                    const suggestion = suggestions[activeSuggestionIndex];
                    insertSuggestion(suggestion);
                    
                    if (isStandAloneCommand(suggestion.insertText)) {
                      e.preventDefault();
                      sendMessage();
                    }
                    return;
                  }
                } else if (e.key === 'Escape') {
                  updateCommandSuggestions([]);
                  e.preventDefault();
                  return;
                }
              }
              
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
              } else if (e.key === '/' && chatInput.value === '') {
                // Special handling for slash key
                setTimeout(() => {
                  notifyInputChanged();
                  console.log('Slash key pressed on empty input');
                }, 10);
              }
            });
            
            modelSelector.addEventListener('click', () => {
              vscode.postMessage({ type: 'showModelSelector' });
            });
            
            // Set up code block action listeners
            setupCodeBlockListeners();
            
            // Initialize with stored messages
            const state = vscode.getState();
            if (state && state.messages) {
              updateMessages(state.messages, isStreaming);
            } else {
              updateMessages(initialMessages, isStreaming);
            }
            
            // Set initial input height
            resizeInput();
            
            // Set focus to input
            setTimeout(() => {
              if (chatInput) {
                chatInput.focus();
              }
            }, 300);
          }
          
          // Start the app when document is ready
          if (document.readyState === 'complete' || document.readyState === 'interactive') {
            console.log('Document already ready, initializing chat view immediately');
            setTimeout(init, 0);
          } else {
            console.log('Waiting for DOMContentLoaded before initializing chat view');
            document.addEventListener('DOMContentLoaded', () => {
              console.log('DOMContentLoaded fired, initializing chat view');
              init();
            });
          }
        })();
      </script>
    </body>
    </html>`;
    }
    /**
     * Generates a random nonce for CSP
     */
    _getNonce() {
        let text = '';
        const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (let i = 0; i < 32; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    }
    /**
     * Smart Prompting UI update - required for interface compatibility
     * No-op in this implementation as we don't need this feature for the iPhone style
     */
    _updateSmartPromptingUI(enabled) {
        // No-op for this implementation
    }
    /**
     * Open attached file - required for interface compatibility
     * No-op in this implementation as we don't need this feature for the iPhone style
     */
    _openAttachedFile(filePath) {
        return Promise.resolve();
    }
}


/***/ }),

/***/ "./src/ui/tree/apeTreeDataProvider.ts":
/*!********************************************!*\
  !*** ./src/ui/tree/apeTreeDataProvider.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApeTreeDataProvider: () => (/* binding */ ApeTreeDataProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./treeNodeTypes */ "./src/ui/tree/treeNodeTypes.ts");
/* harmony import */ var _core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/services/vaultService */ "./src/core/services/vaultService.ts");
/**
 * APE Navigator 트리 데이터 제공자
 *
 * VS Code TreeView API를 사용하여 APE 확장의 주요 기능을 계층적으로 표시합니다.
 * 주요 명령어, 설정, 플러그인 정보를 트리 형태로 보여줍니다.
 */





/**
 * APE Navigator 트리 데이터 제공자 클래스
 */
class ApeTreeDataProvider {
    context;
    llmService;
    memoryService;
    todoService;
    vaultService;
    rulesService;
    jiraService;
    // 트리 데이터 변경 이벤트
    _onDidChangeTreeData = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    onDidChangeTreeData = this._onDidChangeTreeData.event;
    // 트리 데이터
    treeData = [];
    /**
     * 생성자
     * @param context 확장 프로그램 컨텍스트
     * @param llmService LLM 서비스
     * @param memoryService 메모리 서비스
     */
    constructor(context, llmService, memoryService, todoService, vaultService, rulesService, jiraService) {
        this.context = context;
        this.llmService = llmService;
        this.memoryService = memoryService;
        this.todoService = todoService;
        this.vaultService = vaultService;
        this.rulesService = rulesService;
        this.jiraService = jiraService;
        // 트리 데이터 초기화
        this.initializeTreeData();
        // 설정 변경 이벤트 구독
        vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape')) {
                this.refresh();
            }
        });
        // VAULT 서비스 변경 이벤트 구독
        if (this.vaultService) {
            this.vaultService.onDidChangeVault(() => {
                this.refresh();
            });
        }
        // Rules 서비스 변경 이벤트 구독
        if (this.rulesService) {
            this.rulesService.onDidChangeRules(() => {
                this.refresh();
            });
        }
    }
    /**
     * 트리 데이터 초기화
     */
    initializeTreeData() {
        this.treeData = [
            // Git 섹션 (최상위로 이동)
            {
                id: 'git-root',
                label: 'Git',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_ROOT,
                iconPath: this.getIconPath('git-version-control', 'git-commit'),
                contextValue: 'gitRoot',
                children: this.getGitItems()
            },
            // 채팅 내역 섹션
            {
                id: 'chat-history-root',
                label: '채팅 내역',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.CHAT_HISTORY_ROOT,
                iconPath: this.getIconPath('chat', 'history'),
                contextValue: 'chatHistoryRoot',
                children: this.getChatHistoryItems()
            },
            // 명령어 섹션
            {
                id: 'commands',
                label: '명령어',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND_ROOT,
                iconPath: this.getIconPath('command-line', 'symbol-method'),
                contextValue: 'commandRoot',
                children: this.getCommandItems()
            },
            // 설정 섹션
            {
                id: 'settings',
                label: '설정',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ROOT,
                iconPath: this.getIconPath('config', 'gear'),
                contextValue: 'settingsRoot',
                children: this.getSettingsItems()
            },
            // Rules 섹션
            {
                id: 'rules-root',
                label: 'Rules',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_ROOT,
                iconPath: this.getIconPath('notebook', 'book'),
                contextValue: 'rulesRoot',
                children: this.getRulesItems()
            },
            // VAULT 섹션
            {
                id: 'vault',
                label: 'VAULT 컨텍스트',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_ROOT,
                iconPath: this.getIconPath('brain-ai', 'library'),
                contextValue: 'vaultRoot',
                children: this.getVaultItems()
            },
            // 지라 섹션 (Mock)
            {
                id: 'jira',
                label: 'Jira 이슈',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ROOT,
                iconPath: this.getIconPath('jira', 'issues'),
                contextValue: 'jiraRoot',
                children: this.getJiraItems()
            },
            // 포켓 섹션 (Mock)
            {
                id: 'pocket',
                label: 'Pocket 저장소',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_ROOT,
                iconPath: this.getIconPath('folder', 'library'),
                contextValue: 'pocketRoot',
                children: this.getPocketItems()
            },
            // SWDP 섹션 (Mock)
            {
                id: 'swdp',
                label: 'SWDP',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_ROOT,
                iconPath: this.getIconPath('cicd', 'package'),
                contextValue: 'swdpRoot',
                children: this.getSWDPItems()
            },
            // 플러그인 섹션
            {
                id: 'plugins',
                label: '플러그인',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.PLUGIN_ROOT,
                iconPath: this.getIconPath('plugin', 'extensions'),
                contextValue: 'pluginRoot',
                children: this.getPluginItems()
            }
        ];
    }
    /**
     * Git 아이템 가져오기
     */
    getGitItems() {
        return [
            {
                id: 'git-commands',
                label: 'Git 명령어',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_CATEGORY,
                iconPath: this.getIconPath('git-version-control', 'git-commit'),
                tooltip: 'Git 관련 작업을 수행하는 명령어입니다. 커밋, 상태 확인, 자동 커밋 기능 등을 제공합니다.',
                contextValue: 'gitCategory',
                children: [
                    {
                        id: 'git-command-status',
                        label: '/git status',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: 'Git 상태 확인',
                        tooltip: '현재 Git 저장소의 상태를 확인합니다. 변경된 파일, 스테이징된 파일, 브랜치 정보 등을 보여줍니다.',
                        iconPath: this.getIconPath('git-version-control', 'git-pull-request'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['status'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-commit',
                        label: '/git commit',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: '변경사항 커밋',
                        tooltip: '변경된 파일을 Git에 커밋합니다. 자동으로 적절한 커밋 메시지를 생성합니다.',
                        iconPath: this.getIconPath('git-version-control', 'git-commit'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['commit'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-auto',
                        label: '/git auto',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: '자동 커밋 토글',
                        tooltip: '자동 커밋 기능을 켜거나 끕니다. 켜진 상태에서는 파일 저장 시 자동으로 변경사항이 커밋됩니다.',
                        iconPath: this.getIconPath('config', 'settings-gear'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['auto'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-consolidate',
                        label: '/git consolidate',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: '임시 커밋 통합',
                        tooltip: '[APE][Temporary] 접두사가 붙은 연속된 임시 커밋들을 하나의 정식 커밋으로 통합합니다.',
                        iconPath: this.getIconPath('github', 'git-merge'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['consolidate'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-pr-list',
                        label: '/git pr-list [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: 'PR 목록 조회',
                        tooltip: 'Git 저장소의 PR(Pull Request) 목록을 조회합니다.',
                        iconPath: this.getIconPath('github', 'git-pull-request'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['pr-list'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-pr-create',
                        label: '/git pr-create [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: '새 PR 생성',
                        tooltip: 'Git 저장소에 새로운 PR(Pull Request)을 생성합니다.',
                        iconPath: this.getIconPath('github', 'diff-added'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['pr-create'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-branch-list',
                        label: '/git branch-list [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: '브랜치 목록 조회',
                        tooltip: 'Git 저장소의 브랜치 목록을 조회합니다.',
                        iconPath: this.getIconPath('git-version-control', 'git-branch'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['branch-list'],
                            category: 'git'
                        }
                    }
                ]
            }
        ];
    }
    /**
     * 명령어 아이템 가져오기
     */
    getCommandItems() {
        const categories = [
            {
                id: 'commands-general',
                label: '일반 명령어',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND_CATEGORY,
                iconPath: this.getIconPath('command-line', 'info'),
                tooltip: '기본적인 채팅 및 도움말 관련 명령어입니다.',
                contextValue: 'commandCategory',
                children: [
                    {
                        id: 'command-help',
                        label: '/help',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: '도움말 표시',
                        tooltip: '사용 가능한 모든 명령어 목록과 설명을 보여줍니다. "/?" 또는 "/도움말"로도 사용 가능합니다.',
                        iconPath: this.getIconPath('message', 'question'),
                        contextValue: 'command',
                        metadata: {
                            name: 'help',
                            category: 'general'
                        }
                    },
                    {
                        id: 'command-clear',
                        label: '/clear',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: '채팅 내역 지우기',
                        tooltip: '현재 채팅 내역을 모두 삭제합니다. "/cls" 또는 "/지우기"로도 사용 가능합니다.',
                        iconPath: this.getIconPath('chat', 'clear-all'),
                        contextValue: 'command',
                        metadata: {
                            name: 'clear',
                            category: 'general'
                        }
                    },
                    {
                        id: 'command-model',
                        label: '/model',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: 'LLM 모델 변경',
                        tooltip: '사용할 LLM 모델을 선택하거나 변경합니다. "/model list"로 사용 가능한 모델 목록을 확인할 수 있습니다.',
                        iconPath: this.getIconPath('llm', 'server-process'),
                        contextValue: 'command',
                        metadata: {
                            name: 'model',
                            category: 'general'
                        }
                    }
                ]
            },
            {
                id: 'commands-code',
                label: '코드 및 유틸리티 명령어',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND_CATEGORY,
                iconPath: this.getIconPath('coding', 'symbol-class'),
                tooltip: '코드 분석 및 VS Code 기능 접근을 위한 유틸리티 명령어입니다.',
                contextValue: 'commandCategory',
                children: [
                    {
                        id: 'command-analyze',
                        label: '/analyze',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: '코드 분석',
                        tooltip: '선택한 코드를 상세히 분석합니다. 코드 기능, 개선점, 모범 사례 등을 제안합니다. "/code" 또는 "/분석"으로도 사용 가능합니다.',
                        iconPath: this.getIconPath('code-editor', 'inspect'),
                        contextValue: 'command',
                        metadata: {
                            name: 'analyze',
                            category: 'code'
                        }
                    },
                    {
                        id: 'command-settings',
                        label: '/settings',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: 'APE 설정 열기',
                        tooltip: 'VS Code 설정에서 APE 관련 설정을 열어 확인하고 수정할 수 있습니다. "/config" 또는 "/설정"으로도 사용 가능합니다.',
                        iconPath: this.getIconPath('config', 'gear'),
                        contextValue: 'command',
                        metadata: {
                            name: 'settings',
                            category: 'utility'
                        }
                    },
                    {
                        id: 'command-open',
                        label: '/open',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: '파일 열기',
                        tooltip: '지정한 파일을 VS Code에서 엽니다. "/file" 또는 "/파일열기"로도 사용 가능합니다.',
                        iconPath: this.getIconPath('code-file', 'go-to-file'),
                        contextValue: 'command',
                        metadata: {
                            name: 'open',
                            category: 'utility'
                        }
                    }
                ]
            }
        ];
        return categories;
    }
    /**
     * 설정 아이템 가져오기
     */
    getSettingsItems() {
        return [
            {
                id: 'settings-llm',
                label: 'LLM 설정',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_CATEGORY,
                iconPath: this.getIconPath('llm', 'server'),
                contextValue: 'settingsCategory',
                children: [
                    {
                        id: 'settings-llm-model',
                        label: '기본 모델',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('ai-neural-network', 'symbol-enum'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.llm.defaultModel') || 'openai/gpt-4.1-mini',
                        metadata: {
                            settingKey: 'ape.llm.defaultModel'
                        }
                    },
                    {
                        id: 'settings-llm-endpoint',
                        label: 'API 엔드포인트',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('api', 'link'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.llm.endpoint') || 'http://localhost:8000/api/chat',
                        metadata: {
                            settingKey: 'ape.llm.endpoint'
                        }
                    }
                ]
            },
            {
                id: 'settings-memory',
                label: '메모리 설정',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_CATEGORY,
                iconPath: this.getIconPath('database', 'database'),
                contextValue: 'settingsCategory',
                children: [
                    {
                        id: 'settings-memory-duration',
                        label: '세션 유지 기간',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('event', 'history'),
                        contextValue: 'settingsItem',
                        description: `${this.getConfigValue('ape.memory.sessionDuration') || '240'}분`,
                        metadata: {
                            settingKey: 'ape.memory.sessionDuration'
                        }
                    },
                    {
                        id: 'settings-memory-messages',
                        label: '최대 메시지 수',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('message', 'symbol-number'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.memory.maxMessages') || '30',
                        metadata: {
                            settingKey: 'ape.memory.maxMessages'
                        }
                    }
                ]
            },
            {
                id: 'settings-ui',
                label: 'UI 설정',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_CATEGORY,
                iconPath: this.getIconPath('code-editor', 'browser'),
                contextValue: 'settingsCategory',
                children: [
                    {
                        id: 'settings-ui-theme',
                        label: 'UI 테마',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('vscode', 'symbol-color'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.ui.theme') || 'auto',
                        metadata: {
                            settingKey: 'ape.ui.theme'
                        }
                    }
                ]
            }
        ];
    }
    /**
     * VAULT 아이템 가져오기
     */
    getVaultItems() {
        // VAULT 서비스가 없으면 스텁 반환
        if (!this.vaultService) {
            return [{
                    id: 'vault-not-initialized',
                    label: 'VAULT 서비스 초기화 필요',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_ROOT,
                    iconPath: this.getIconPath('brain-ai', 'error'),
                    contextValue: 'vaultError',
                    description: '서비스가 초기화되지 않음',
                    tooltip: 'VAULT 서비스가 초기화되지 않았습니다. 확장 설정을 확인하세요.'
                }];
        }
        // 컨텍스트 타입별 아이템 구성
        const contextTypeItems = [];
        // 시스템 컨텍스트
        const systemContexts = this.vaultService.getContextsByType(_core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__.VaultContextType.System);
        if (systemContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-system',
                label: '시스템 컨텍스트',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('brain-ai', 'server'),
                contextValue: 'vaultCategory',
                tooltip: '시스템 기본 컨텍스트입니다.',
                children: systemContexts.flatMap(context => this.createContextNode(context))
            });
        }
        // 프로젝트 컨텍스트
        const projectContexts = this.vaultService.getContextsByType(_core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__.VaultContextType.Project);
        if (projectContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-project',
                label: '프로젝트 컨텍스트',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('coding', 'git-merge'),
                contextValue: 'vaultCategory',
                tooltip: '프로젝트별 컨텍스트입니다.',
                children: projectContexts.flatMap(context => this.createContextNode(context))
            });
        }
        // 개인 컨텍스트
        const personalContexts = this.vaultService.getContextsByType(_core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__.VaultContextType.Personal);
        if (personalContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-personal',
                label: '개인 컨텍스트',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('message', 'account'),
                contextValue: 'vaultCategory',
                tooltip: '개인 사용자 컨텍스트입니다.',
                children: personalContexts.flatMap(context => this.createContextNode(context))
            });
        }
        // 공유 컨텍스트
        const sharedContexts = this.vaultService.getContextsByType(_core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__.VaultContextType.Shared);
        if (sharedContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-shared',
                label: '공유 컨텍스트',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('github', 'repo-forked'),
                contextValue: 'vaultCategory',
                tooltip: '팀원 간 공유되는 컨텍스트입니다.',
                children: sharedContexts.flatMap(context => this.createContextNode(context))
            });
        }
        // 템플릿 컨텍스트
        const templateContexts = this.vaultService.getContextsByType(_core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__.VaultContextType.Template);
        if (templateContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-template',
                label: '템플릿 컨텍스트',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('code-file', 'file-code'),
                contextValue: 'vaultCategory',
                tooltip: '재사용 가능한 템플릿 컨텍스트입니다.',
                children: templateContexts.flatMap(context => this.createContextNode(context))
            });
        }
        return contextTypeItems;
    }
    /**
     * VAULT 컨텍스트 노드 생성
     * @param context 컨텍스트
     */
    createContextNode(context) {
        if (!context || !context.items) {
            return [];
        }
        const contextNode = {
            id: `vault-context-${context.id}`,
            label: context.name,
            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CONTEXT,
            description: `${context.items.length}개 항목`,
            tooltip: context.description || context.name,
            iconPath: this.getIconPath('brain-ai', 'library'),
            contextValue: 'vaultContext',
            metadata: {
                contextId: context.id,
                contextType: context.type
            },
            children: context.items.map((item) => this.createItemNode(item, context))
        };
        return [contextNode];
    }
    /**
     * VAULT 아이템 노드 생성
     * @param item 아이템
     * @param context 컨텍스트
     */
    createItemNode(item, context) {
        let iconName = 'file-text';
        let fallbackIcon = 'symbol-string';
        // 태그에 따른 아이콘 설정
        if (item.tags) {
            if (item.tags.includes('prompt')) {
                iconName = 'brain-ai';
                fallbackIcon = 'symbol-text';
            }
            else if (item.tags.includes('code')) {
                iconName = 'code-file';
                fallbackIcon = 'file-code';
            }
            else if (item.tags.includes('architecture')) {
                iconName = 'orchestration';
                fallbackIcon = 'type-hierarchy';
            }
            else if (item.tags.includes('meeting')) {
                iconName = 'event';
                fallbackIcon = 'group';
            }
            else if (item.tags.includes('documentation')) {
                iconName = 'markdown';
                fallbackIcon = 'markdown';
            }
        }
        // 업데이트 날짜 포맷
        const updatedAtStr = item.updatedAt instanceof Date
            ? item.updatedAt.toLocaleDateString()
            : new Date(item.updatedAt).toLocaleDateString();
        return {
            id: `vault-item-${item.id}`,
            label: item.name,
            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_ITEM,
            description: updatedAtStr,
            tooltip: item.description || item.name,
            iconPath: this.getIconPath(iconName, fallbackIcon),
            contextValue: 'vaultItem',
            metadata: {
                itemId: item.id,
                contextId: context.id,
                content: item.content,
                tags: item.tags
            }
        };
    }
    /**
     * 지라 아이템 가져오기
     */
    getJiraItems() {
        // Jira 서비스가 없으면 Mock 데이터 반환
        if (!this.jiraService) {
            return [
                {
                    id: 'jira-not-initialized',
                    label: 'Jira 서비스 초기화 필요',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ROOT,
                    iconPath: this.getIconPath('jira', 'error'),
                    contextValue: 'jiraError',
                    description: '서비스가 초기화되지 않음',
                    tooltip: 'Jira 서비스가 초기화되지 않았습니다. 확장 설정을 확인하세요.'
                }
            ];
        }
        try {
            // 실제 Jira 데이터를 가져오려면 주석 해제하고 Mock 데이터 부분 주석 처리
            // 현재는 개발 환경에서 테스트를 위해 Mock 데이터 사용
            /*
            // 계정 정보 확인
            const configResult = this.jiraService.getConfig();
            if (!configResult.success || !configResult.data || !configResult.data.isConfigured) {
              return [
                {
                  id: 'jira-not-configured',
                  label: 'Jira 설정이 필요합니다',
                  type: TreeNodeType.JIRA_ROOT,
                  iconPath: this.getIconPath('jira', 'warning'),
                  contextValue: 'jiraNotConfigured',
                  description: '인증 정보 없음',
                  tooltip: 'Jira 연결을 위한 설정이 필요합니다. 확장 설정에서 Jira 인증 정보를 입력해주세요.'
                }
              ];
            }
            
            // 지라 프로젝트 가져오기
            const projectsResult = await this.jiraService.getProjects();
            if (!projectsResult.success || !projectsResult.data) {
              throw new Error(projectsResult.error?.message || 'Jira 프로젝트를 가져오는 데 실패했습니다');
            }
            
            const projects = projectsResult.data;
            
            // 각 프로젝트별 이슈 가져오기
            return projects.map(project => {
              return {
                id: `jira-project-${project.key}`,
                label: `${project.name} (${project.key})`,
                type: TreeNodeType.JIRA_PROJECT,
                iconPath: this.getIconPath('jira', 'project'),
                contextValue: 'jiraProject',
                description: `${project.issueCount || 0}개 이슈`,
                tooltip: project.description || project.name,
                children: this.getJiraIssuesForProject(project.key)
              };
            });
            */
            // Mock 데이터 (개발 환경용)
            return [
                {
                    id: 'jira-project-ape',
                    label: 'APE 프로젝트',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_PROJECT,
                    iconPath: this.getIconPath('jira', 'project'),
                    contextValue: 'jiraProject',
                    description: 'APE-001 외 10개 이슈',
                    tooltip: 'Agentic Pipeline Engine 프로젝트',
                    children: [
                        {
                            id: 'jira-issue-ape-001',
                            label: 'APE-001: 초기 설정 구현',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-closed'),
                            contextValue: 'jiraIssue',
                            description: '완료됨',
                            tooltip: '프로젝트 초기 설정 및 기본 구조 구현',
                            metadata: {
                                id: 'APE-001',
                                status: 'Done',
                                assignee: '사용자',
                                priority: 'High',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'APE-001']
                                }
                            }
                        },
                        {
                            id: 'jira-issue-ape-002',
                            label: 'APE-002: 채팅 UI 개선',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-open'),
                            contextValue: 'jiraIssue',
                            description: '진행 중',
                            tooltip: '채팅 UI 개선 및 응답성 향상',
                            metadata: {
                                id: 'APE-002',
                                status: 'In Progress',
                                assignee: '사용자',
                                priority: 'Medium',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'APE-002']
                                }
                            }
                        },
                        {
                            id: 'jira-issue-ape-003',
                            label: 'APE-003: 트리뷰 구현',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issues'),
                            contextValue: 'jiraIssue',
                            description: '진행 중',
                            tooltip: '트리뷰 구현 및 서비스 연동',
                            metadata: {
                                id: 'APE-003',
                                status: 'In Progress',
                                assignee: '사용자',
                                priority: 'High',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'APE-003']
                                }
                            }
                        }
                    ]
                },
                {
                    id: 'jira-project-int',
                    label: '통합 프로젝트',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_PROJECT,
                    iconPath: this.getIconPath('jira', 'project'),
                    contextValue: 'jiraProject',
                    description: 'INT-001 외 5개 이슈',
                    tooltip: '시스템 통합 프로젝트',
                    children: [
                        {
                            id: 'jira-issue-int-001',
                            label: 'INT-001: Git 통합',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-open'),
                            contextValue: 'jiraIssue',
                            description: '진행 중',
                            tooltip: 'Git 서비스 통합 및 자동 커밋 기능 구현',
                            metadata: {
                                id: 'INT-001',
                                status: 'In Progress',
                                assignee: '사용자',
                                priority: 'High',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'INT-001']
                                }
                            }
                        },
                        {
                            id: 'jira-issue-int-002',
                            label: 'INT-002: Jira 통합',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-draft'),
                            contextValue: 'jiraIssue',
                            description: '계획됨',
                            tooltip: 'Jira 서비스 통합 및 이슈 관리 기능 구현',
                            metadata: {
                                id: 'INT-002',
                                status: 'Planned',
                                assignee: '미할당',
                                priority: 'Medium',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'INT-002']
                                }
                            }
                        }
                    ]
                },
                {
                    id: 'jira-commands',
                    label: 'Jira 명령어',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_CATEGORY,
                    iconPath: this.getIconPath('command-line', 'terminal'),
                    contextValue: 'jiraCommands',
                    tooltip: 'Jira 관련 명령어',
                    children: [
                        {
                            id: 'jira-command-create',
                            label: '/jira create',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'add'),
                            contextValue: 'jiraCommand',
                            description: '새 이슈 생성',
                            tooltip: '새 Jira 이슈를 생성합니다',
                            metadata: {
                                name: 'jira',
                                args: ['create'],
                                category: 'utility'
                            }
                        },
                        {
                            id: 'jira-command-search',
                            label: '/jira search',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'search'),
                            contextValue: 'jiraCommand',
                            description: '이슈 검색',
                            tooltip: 'Jira 이슈를 검색합니다',
                            metadata: {
                                name: 'jira',
                                args: ['search'],
                                category: 'utility'
                            }
                        },
                        {
                            id: 'jira-command-summary',
                            label: '/jira summary',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'graph'),
                            contextValue: 'jiraCommand',
                            description: '프로젝트 요약',
                            tooltip: 'Jira 프로젝트 요약 정보를 표시합니다',
                            metadata: {
                                name: 'jira',
                                args: ['summary'],
                                category: 'utility'
                            }
                        },
                        {
                            id: 'jira-command-status',
                            label: '/jira status',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'sync'),
                            contextValue: 'jiraCommand',
                            description: '이슈 상태 변경',
                            tooltip: 'Jira 이슈의 상태를 변경합니다',
                            metadata: {
                                name: 'jira',
                                args: ['status'],
                                category: 'utility'
                            }
                        }
                    ]
                }
            ];
        }
        catch (error) {
            console.error('Jira 아이템 가져오기 오류:', error);
            return [{
                    id: 'jira-error',
                    label: 'Jira 로딩 오류',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ROOT,
                    iconPath: this.getIconPath('jira', 'error'),
                    contextValue: 'jiraError',
                    description: `오류: ${error instanceof Error ? error.message : String(error)}`,
                    tooltip: '오류 내용: ' + (error instanceof Error ? error.message : String(error))
                }];
        }
    }
    /**
     * 특정 프로젝트의 Jira 이슈 가져오기
     * @param projectKey 프로젝트 키
     */
    getJiraIssuesForProject(projectKey) {
        if (!this.jiraService) {
            return [];
        }
        try {
            /*
            // 실제 구현 (주석 처리)
            const searchCriteria = {
              projectKey: projectKey,
              maxResults: 10
            };
            
            const searchResult = await this.jiraService.searchIssues(searchCriteria);
            if (!searchResult.success || !searchResult.data) {
              throw new Error(searchResult.error?.message || '이슈 검색에 실패했습니다');
            }
            
            const issues = searchResult.data.issues;
            
            return issues.map(issue => {
              let iconName = 'jira';
              let fallbackIcon = 'issues';
              
              // 상태에 따른 아이콘 설정
              if (issue.status === JiraIssueStatus.Done ||
                  issue.status === JiraIssueStatus.Closed ||
                  issue.status === JiraIssueStatus.Resolved) {
                fallbackIcon = 'issue-closed';
              } else if (issue.status === JiraIssueStatus.InProgress) {
                fallbackIcon = 'issue-open';
              } else {
                fallbackIcon = 'issue-draft';
              }
              
              return {
                id: `jira-issue-${issue.key}`,
                label: `${issue.key}: ${issue.summary}`,
                type: TreeNodeType.JIRA_ISSUE,
                iconPath: this.getIconPath(iconName, fallbackIcon),
                contextValue: 'jiraIssue',
                description: issue.status,
                tooltip: issue.description || issue.summary,
                metadata: {
                  id: issue.key,
                  status: issue.status,
                  assignee: issue.assignee || '미할당',
                  priority: issue.priority || 'Medium',
                  command: {
                    name: 'jira',
                    args: ['show', issue.key]
                  }
                }
              };
            });
            */
            // Mock 데이터 (실제 구현 전까지 사용)
            return [];
        }
        catch (error) {
            console.error(`Jira 이슈 가져오기 오류 (${projectKey}):`, error);
            return [];
        }
    }
    /**
     * 포켓 아이템 가져오기 (Mock)
     */
    getPocketItems() {
        return [
            {
                id: 'pocket-category-code',
                label: '코드 샘플 [Mock]',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_CATEGORY,
                iconPath: this.getIconPath('code-file', 'code'),
                contextValue: 'pocketCategory',
                description: '3개 항목',
                tooltip: '유용한 코드 샘플 모음',
                children: [
                    {
                        id: 'pocket-item-code-1',
                        label: '타입스크립트 유틸리티 함수 [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_ITEM,
                        iconPath: this.getIconPath('typescript', 'symbol-method'),
                        contextValue: 'pocketItem',
                        description: '2023-05-01 저장됨',
                        tooltip: '자주 사용하는 타입스크립트 유틸리티 함수 모음',
                        metadata: {
                            id: 'code-1',
                            createdAt: '2023-05-01',
                            tags: ['typescript', 'utility']
                        }
                    },
                    {
                        id: 'pocket-item-code-2',
                        label: 'VS Code API 샘플 [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_ITEM,
                        iconPath: this.getIconPath('vscode', 'symbol-method'),
                        contextValue: 'pocketItem',
                        description: '2023-05-05 저장됨',
                        tooltip: 'VS Code API 활용 예제 코드',
                        metadata: {
                            id: 'code-2',
                            createdAt: '2023-05-05',
                            tags: ['vscode', 'api', 'extension']
                        }
                    }
                ]
            },
            {
                id: 'pocket-category-notes',
                label: '프로젝트 노트 [Mock]',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_CATEGORY,
                iconPath: this.getIconPath('markdown', 'notebook'),
                contextValue: 'pocketCategory',
                description: '2개 항목',
                tooltip: '프로젝트 관련 메모 및 노트',
                children: [
                    {
                        id: 'pocket-item-notes-1',
                        label: '아키텍처 설계 메모 [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_ITEM,
                        iconPath: this.getIconPath('markdown', 'file-text'),
                        contextValue: 'pocketItem',
                        description: '2023-04-28 저장됨',
                        tooltip: '프로젝트 아키텍처 설계 관련 메모',
                        metadata: {
                            id: 'notes-1',
                            createdAt: '2023-04-28',
                            tags: ['architecture', 'design', 'memo']
                        }
                    }
                ]
            }
        ];
    }
    /**
     * SWDP 아이템 가져오기 (Mock)
     */
    getSWDPItems() {
        return [
            {
                id: 'swdp-release',
                label: 'Release Build',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_BUILD_TYPE,
                iconPath: this.getIconPath('cicd', 'package'),
                contextValue: 'swdpBuildType',
                tooltip: 'SWDP Release Build 유형',
                children: [
                    {
                        id: 'swdp-release-info',
                        label: 'BUILD, COVERITY, SAM, ONBOARD TESTE, DOBEE, BLACKDUCK, 등등 여기에 표기 예정입니다.',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_ARTIFACT,
                        iconPath: this.getIconPath('jenkins-ci-cd', 'info'),
                        contextValue: 'swdpArtifact',
                        tooltip: 'SWDP Release Build 정보'
                    }
                ]
            },
            {
                id: 'swdp-layer',
                label: 'Layer Build',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_BUILD_TYPE,
                iconPath: this.getIconPath('orchestration', 'layers'),
                contextValue: 'swdpBuildType',
                tooltip: 'SWDP Layer Build 유형',
                children: [
                    {
                        id: 'swdp-layer-info',
                        label: 'BUILD, COVERITY, SAM, ONBOARD TESTE, DOBEE, BLACKDUCK, 등등 여기에 표기 예정입니다.',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_ARTIFACT,
                        iconPath: this.getIconPath('jenkins-ci-cd', 'info'),
                        contextValue: 'swdpArtifact',
                        tooltip: 'SWDP Layer Build 정보'
                    }
                ]
            },
            {
                id: 'swdp-local',
                label: 'Local Build',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_BUILD_TYPE,
                iconPath: this.getIconPath('docker', 'desktop-download'),
                contextValue: 'swdpBuildType',
                tooltip: 'SWDP Local Build 유형',
                children: [
                    {
                        id: 'swdp-local-info',
                        label: 'BUILD, COVERITY, SAM, ONBOARD TESTE, DOBEE, BLACKDUCK, 등등 여기에 표기 예정입니다.',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_ARTIFACT,
                        iconPath: this.getIconPath('docker-container', 'info'),
                        contextValue: 'swdpArtifact',
                        tooltip: 'SWDP Local Build 정보'
                    }
                ]
            }
        ];
    }
    /**
     * Rules 아이템 가져오기
     */
    getRulesItems() {
        // Rules 서비스가 없으면 스텁 반환
        if (!this.rulesService) {
            return [{
                    id: 'rules-not-initialized',
                    label: 'Rules 서비스 초기화 필요',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_ROOT,
                    iconPath: this.getIconPath('notebook', 'error'),
                    contextValue: 'rulesError',
                    description: '서비스가 초기화되지 않음',
                    tooltip: 'Rules 서비스가 초기화되지 않았습니다. 확장 설정을 확인하세요.'
                }];
        }
        try {
            const activeRules = this.rulesService.getActiveRules();
            const inactiveRules = this.rulesService.getAllRules().filter(rule => !activeRules.some(activeRule => activeRule.id === rule.id));
            const ruleItems = [];
            // 활성화된 Rules 카테고리
            if (activeRules.length > 0) {
                ruleItems.push({
                    id: 'rules-active',
                    label: '활성화된 Rules',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_ACTIVE,
                    iconPath: this.getIconPath('notebook', 'check'),
                    contextValue: 'rulesActive',
                    tooltip: '현재 LLM 시스템 프롬프트에 적용된 Rules',
                    description: `${activeRules.length}개 항목`,
                    children: activeRules.map(rule => this.createRuleNode(rule, true))
                });
            }
            // 비활성화된 Rules 카테고리
            if (inactiveRules.length > 0) {
                ruleItems.push({
                    id: 'rules-inactive',
                    label: '비활성화된 Rules',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_INACTIVE,
                    iconPath: this.getIconPath('notebook', 'circle-outline'),
                    contextValue: 'rulesInactive',
                    tooltip: '현재 비활성화되어 있는 Rules',
                    description: `${inactiveRules.length}개 항목`,
                    children: inactiveRules.map(rule => this.createRuleNode(rule, false))
                });
            }
            // Rules가 없는 경우
            if (ruleItems.length === 0) {
                ruleItems.push({
                    id: 'rules-empty',
                    label: 'Rules 없음',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_ROOT,
                    iconPath: this.getIconPath('notebook', 'info'),
                    contextValue: 'rulesEmpty',
                    description: '생성된 Rules 없음',
                    tooltip: '우클릭 메뉴를 통해 새 Rule을 생성하세요.'
                });
            }
            return ruleItems;
        }
        catch (error) {
            console.error('Rules 목록 가져오기 오류:', error);
            return [{
                    id: 'rules-error',
                    label: 'Rules 로딩 오류',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_ROOT,
                    iconPath: this.getIconPath('notebook', 'error'),
                    contextValue: 'rulesError',
                    description: `오류: ${error instanceof Error ? error.message : String(error)}`,
                    tooltip: '오류 내용: ' + (error instanceof Error ? error.message : String(error))
                }];
        }
    }
    /**
     * Rule 노드 생성
     * @param rule Rule 객체
     * @param isActive 활성화 여부
     */
    createRuleNode(rule, isActive) {
        const iconName = isActive ? 'notebook' : 'notebook';
        const fallbackIcon = isActive ? 'notebook-opened' : 'notebook';
        // 파일 이름만 추출
        const fileName = rule.filePath.split('/').pop();
        return {
            id: `rule-item-${rule.id}`,
            label: rule.name,
            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULE_ITEM,
            description: fileName, // 파일 이름을 설명으로 표시
            tooltip: `${rule.name} (${fileName})\n\n${rule.content.substring(0, 100)}${rule.content.length > 100 ? '...' : ''}`,
            iconPath: this.getIconPath(iconName, fallbackIcon),
            contextValue: isActive ? 'ruleActive' : 'ruleInactive',
            metadata: {
                id: rule.id,
                filePath: rule.filePath,
                isActive: isActive
            }
        };
    }
    /**
     * 채팅 내역 아이템 가져오기
     */
    getChatHistoryItems() {
        try {
            // 워크스페이스 루트 경로 가져오기
            const workspaceFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                return [this.createChatHistoryErrorNode('워크스페이스 폴더를 찾을 수 없습니다')];
            }
            // 채팅 내역 폴더 경로
            const chatHistoryDir = path__WEBPACK_IMPORTED_MODULE_1__.join(workspaceFolder.uri.fsPath, 'vault', 'chat-history');
            // 폴더 존재 확인
            if (!(0,fs__WEBPACK_IMPORTED_MODULE_2__.existsSync)(chatHistoryDir)) {
                return [this.createChatHistoryInfoNode('저장된 채팅 내역이 없습니다', '채팅 내역을 저장하려면 채팅 창에서 `/save-chat` 명령어를 사용하세요.')];
            }
            // 파일 시스템에서 메타데이터 파일 목록 가져오기
            const fs = __webpack_require__(/*! fs */ "fs");
            const metaFiles = fs.readdirSync(chatHistoryDir)
                .filter((name) => name.endsWith('.meta.json'));
            if (metaFiles.length === 0) {
                return [this.createChatHistoryInfoNode('저장된 채팅 내역이 없습니다', '채팅 내역을 저장하려면 채팅 창에서 `/save-chat` 명령어를 사용하세요.')];
            }
            // 채팅 내역 아이템 목록
            const chatItems = [];
            // 메타데이터 파일 처리
            for (const fileName of metaFiles) {
                const filePath = path__WEBPACK_IMPORTED_MODULE_1__.join(chatHistoryDir, fileName);
                const chatId = fileName.replace('.meta.json', '');
                try {
                    // 메타데이터 읽기
                    const metadata = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                    // 날짜 포맷팅
                    const createdDate = new Date(metadata.createdAt);
                    const dateStr = createdDate.toLocaleDateString();
                    const timeStr = createdDate.toLocaleTimeString();
                    // 채팅 내역 아이템 추가
                    chatItems.push({
                        id: `chat-history-${chatId}`,
                        label: metadata.title,
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.CHAT_HISTORY_ITEM,
                        description: `${dateStr} ${timeStr}`,
                        tooltip: `${metadata.title} (${dateStr} ${timeStr})\n${metadata.messageCount}개 메시지`,
                        iconPath: this.getIconPath('chat', 'comment-discussion'),
                        contextValue: 'chatHistoryItem',
                        metadata: {
                            id: chatId,
                            title: metadata.title,
                            createdAt: metadata.createdAt,
                            updatedAt: metadata.updatedAt,
                            messageCount: metadata.messageCount,
                            command: {
                                name: 'show',
                                args: [chatId]
                            }
                        }
                    });
                }
                catch (error) {
                    console.error(`채팅 내역 메타데이터 읽기 오류 (${fileName}):`, error);
                }
            }
            // 최신순 정렬
            chatItems.sort((a, b) => {
                const dateA = new Date(a.metadata.createdAt);
                const dateB = new Date(b.metadata.createdAt);
                return dateB.getTime() - dateA.getTime();
            });
            return chatItems;
        }
        catch (error) {
            console.error('채팅 내역 아이템 가져오기 오류:', error);
            return [this.createChatHistoryErrorNode(`오류: ${error instanceof Error ? error.message : String(error)}`)];
        }
    }
    /**
     * 채팅 내역 오류 노드 생성
     */
    createChatHistoryErrorNode(message) {
        return {
            id: 'chat-history-error',
            label: '채팅 내역 로딩 오류',
            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.CHAT_HISTORY_ROOT,
            iconPath: this.getIconPath('chat', 'error'),
            contextValue: 'chatHistoryError',
            description: message,
            tooltip: message
        };
    }
    /**
     * 채팅 내역 정보 노드 생성
     */
    createChatHistoryInfoNode(label, tooltip) {
        return {
            id: 'chat-history-info',
            label,
            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.CHAT_HISTORY_ROOT,
            iconPath: this.getIconPath('chat', 'info'),
            contextValue: 'chatHistoryInfo',
            tooltip
        };
    }
    /**
     * 플러그인 아이템 가져오기 - Stub 처리
     */
    getPluginItems() {
        return [
            {
                id: 'plugin-not-implemented',
                label: '플러그인 목록 로드 중...',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.PLUGIN_ROOT,
                iconPath: this.getIconPath('plugin', 'error'),
                contextValue: 'pluginStub',
                description: '구현되지 않은 기능입니다',
                tooltip: '이 기능은 아직 구현되지 않았습니다. TASK-W3-001의 다음 단계에서 구현될 예정입니다.'
            }
        ];
    }
    /**
     * 설정 값 가져오기
     */
    getConfigValue(key) {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration();
        const value = config.get(key);
        return value !== undefined ? String(value) : '';
    }
    /**
     * 아이콘 경로 가져오기
     * @param iconName 아이콘 이름
     * @param fallbackIcon 대체 테마 아이콘
     * @returns 테마 아이콘
     */
    getIconPath(iconName, fallbackIcon = 'symbol-event') {
        // ThemeIcon 사용
        return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon(fallbackIcon);
    }
    /**
     * TreeView 새로고침
     */
    refresh() {
        this.initializeTreeData();
        this._onDidChangeTreeData.fire(undefined);
    }
    /**
     * 트리 아이템 가져오기
     */
    getTreeItem(element) {
        const treeItem = new vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem(element.label, element.children && element.children.length > 0
            ? vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed
            : vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.None);
        // 아이템 속성 설정
        treeItem.description = element.description || '';
        treeItem.tooltip = element.tooltip || element.description || element.label;
        treeItem.contextValue = element.contextValue || '';
        // 아이콘 설정
        if (element.iconPath) {
            treeItem.iconPath = element.iconPath;
        }
        // 명령어 설정
        if (element.type === _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND ||
            element.type === _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND) {
            // 명령어 클릭 시 실행
            treeItem.command = {
                command: 'ape.executeCommand',
                title: '명령어 실행',
                arguments: [element.metadata]
            };
        }
        else if (element.type === _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM) {
            // 설정 클릭 시 설정 페이지 열기
            treeItem.command = {
                command: 'ape.openSettings',
                title: '설정 열기',
                arguments: [element.metadata?.settingKey]
            };
        }
        else if (element.type === _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_ITEM) {
            // VAULT 아이템 클릭 시 내용 보기
            treeItem.command = {
                command: 'ape.vaultShowItem',
                title: 'VAULT 아이템 보기',
                arguments: [element.metadata]
            };
        }
        else if (element.type === _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.CHAT_HISTORY_ITEM) {
            // 채팅 내역 아이템 클릭 시 내용 보기
            treeItem.command = {
                command: 'ape.executeCommand',
                title: '채팅 내역 보기',
                arguments: [{
                        name: 'show',
                        args: [element.metadata.id]
                    }]
            };
        }
        return treeItem;
    }
    /**
     * 자식 노드 가져오기
     */
    getChildren(element) {
        if (!element) {
            return this.treeData;
        }
        return element.children || [];
    }
    /**
     * 부모 노드 가져오기
     */
    getParent() {
        // 현재 버전에서는 부모 노드 추적이 필요하지 않음
        return null;
    }
}


/***/ }),

/***/ "./src/ui/tree/treeNodeTypes.ts":
/*!**************************************!*\
  !*** ./src/ui/tree/treeNodeTypes.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TreeNodeType: () => (/* binding */ TreeNodeType)
/* harmony export */ });
/**
 * 트리 노드 타입 정의
 *
 * APE Navigator 트리뷰의 노드 타입과 인터페이스를 정의합니다.
 */
/**
 * 트리 노드 타입 열거형
 */
var TreeNodeType;
(function (TreeNodeType) {
    // 카테고리 노드
    TreeNodeType["CATEGORY"] = "category";
    // 명령어 관련 노드
    TreeNodeType["COMMAND_ROOT"] = "command-root";
    TreeNodeType["COMMAND_CATEGORY"] = "command-category";
    TreeNodeType["COMMAND"] = "command";
    // Git 관련 노드
    TreeNodeType["GIT_ROOT"] = "git-root";
    TreeNodeType["GIT_CATEGORY"] = "git-category";
    TreeNodeType["GIT_COMMAND"] = "git-command";
    // 설정 관련 노드
    TreeNodeType["SETTINGS_ROOT"] = "settings-root";
    TreeNodeType["SETTINGS_CATEGORY"] = "settings-category";
    TreeNodeType["SETTINGS_ITEM"] = "settings-item";
    // 플러그인 관련 노드
    TreeNodeType["PLUGIN_ROOT"] = "plugin-root";
    TreeNodeType["PLUGIN_ACTIVE"] = "plugin-active";
    TreeNodeType["PLUGIN_INACTIVE"] = "plugin-inactive";
    TreeNodeType["PLUGIN"] = "plugin";
    // 지라 관련 노드
    TreeNodeType["JIRA_ROOT"] = "jira-root";
    TreeNodeType["JIRA_PROJECT"] = "jira-project";
    TreeNodeType["JIRA_ISSUE"] = "jira-issue";
    TreeNodeType["JIRA_CATEGORY"] = "jira-category";
    TreeNodeType["JIRA_COMMAND"] = "jira-command";
    // 포켓 관련 노드
    TreeNodeType["POCKET_ROOT"] = "pocket-root";
    TreeNodeType["POCKET_CATEGORY"] = "pocket-category";
    TreeNodeType["POCKET_ITEM"] = "pocket-item";
    // SWDP 관련 노드
    TreeNodeType["SWDP_ROOT"] = "swdp-root";
    TreeNodeType["SWDP_RELEASE"] = "swdp-release";
    TreeNodeType["SWDP_BUILD_TYPE"] = "swdp-build-type";
    TreeNodeType["SWDP_ARTIFACT"] = "swdp-artifact";
    // VAULT 관련 노드
    TreeNodeType["VAULT_ROOT"] = "vault-root";
    TreeNodeType["VAULT_CATEGORY"] = "vault-category";
    TreeNodeType["VAULT_CONTEXT"] = "vault-context";
    TreeNodeType["VAULT_ITEM"] = "vault-item";
    // Rules 관련 노드
    TreeNodeType["RULES_ROOT"] = "rules-root";
    TreeNodeType["RULES_ACTIVE"] = "rules-active";
    TreeNodeType["RULES_INACTIVE"] = "rules-inactive";
    TreeNodeType["RULE_ITEM"] = "rule-item";
    // 채팅 내역 관련 노드
    TreeNodeType["CHAT_HISTORY_ROOT"] = "chat-history-root";
    TreeNodeType["CHAT_HISTORY_ITEM"] = "chat-history-item";
})(TreeNodeType || (TreeNodeType = {}));


/***/ }),

/***/ "./src/ui/welcomeView.ts":
/*!*******************************!*\
  !*** ./src/ui/welcomeView.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WelcomeViewProvider: () => (/* binding */ WelcomeViewProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

/**
 * WelcomeViewProvider for luxury minimal welcome screen
 * Creates an elegant, clean welcome interface with premium aesthetics
 */
class WelcomeViewProvider {
    /**
     * Generate welcome message HTML with luxury minimal design
     * This is used for the first-run experience and when clearing chat
     */
    static getWelcomeMessageHTML() {
        try {
            console.log('Generating welcome view HTML');
            // Enhanced welcome view HTML with improved UX
            return `
      <div class="welcome-container">
        <div class="welcome-header">
          <div class="welcome-monologue">
            <h1 class="welcome-title">APE</h1>
            <div class="title-separator"></div>
            <p class="welcome-tagline">AGENTIC PIPELINE ENGINE</p>
            <p class="welcome-subtitle">Agentic Vision. Development Illuminated.</p>
          </div>
        </div>

        <div class="welcome-actions">
          <div class="action-group">
            <div class="action-button" onclick="vscode.postMessage({type: 'command', command: 'Hello, how can you help me?'})">
              <div class="action-icon">✧</div>
              <div class="action-content">
                <div class="action-title">New Conversation</div>
                <div class="action-description">Begin a dialogue with your AI assistant</div>
                <div class="action-commands">
                  <span class="command-tag" onclick="event.stopPropagation(); vscode.postMessage({type: 'insertCommand', command: '/new'});">/new</span>
                  <span class="command-tag" onclick="event.stopPropagation(); vscode.postMessage({type: 'insertCommand', command: '/clear'});">/clear</span>
                </div>
              </div>
            </div>

            <div class="action-button" onclick="vscode.postMessage({type: 'command', command: 'Analyze this code'})">
              <div class="action-icon">✦</div>
              <div class="action-content">
                <div class="action-title">Code Analysis</div>
                <div class="action-description">Understand and improve your code</div>
                <div class="action-commands">
                  <span class="command-tag" onclick="event.stopPropagation(); vscode.postMessage({type: 'insertCommand', command: '/analyze'});">/analyze</span>
                </div>
              </div>
            </div>
          </div>

          <div class="action-group">
            <div class="action-button" onclick="vscode.postMessage({type: 'command', command: 'Implement a new feature'})">
              <div class="action-icon">⟐</div>
              <div class="action-content">
                <div class="action-title">Development</div>
                <div class="action-description">Implement new features</div>
                <div class="action-commands">
                  <span class="command-tag" onclick="event.stopPropagation(); vscode.postMessage({type: 'insertCommand', command: '/create'});">/create</span>
                </div>
              </div>
            </div>

            <div class="action-button" onclick="vscode.postMessage({type: 'command', command: 'Find code in this project'})">
              <div class="action-icon">⟡</div>
              <div class="action-content">
                <div class="action-title">Code Search</div>
                <div class="action-description">Find code in your project</div>
                <div class="action-commands">
                  <span class="command-tag" onclick="event.stopPropagation(); vscode.postMessage({type: 'insertCommand', command: '/find'});">/find</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="command-palette">
          <h3>Command Palette</h3>
          <div class="command-categories">
            <button class="category-tab active" data-category="popular">Popular</button>
            <button class="category-tab" data-category="git">Git</button>
            <button class="category-tab" data-category="code">Code</button>
          </div>
          <div class="command-list" id="popular-commands">
            <div class="command-item" onclick="vscode.postMessage({type: 'insertCommand', command: '/help'})">
              <div class="command-name">/help</div>
              <div class="command-desc">Display available commands and usage</div>
            </div>
            <div class="command-item" onclick="vscode.postMessage({type: 'insertCommand', command: '/model'})">
              <div class="command-name">/model</div>
              <div class="command-desc">Change the AI model</div>
            </div>
            <div class="command-item" onclick="vscode.postMessage({type: 'insertCommand', command: '/clear'})">
              <div class="command-name">/clear</div>
              <div class="command-desc">Clear the current conversation</div>
            </div>
          </div>
        </div>

        <div class="welcome-quick-actions">
          <button class="quick-action" onclick="vscode.postMessage({type: 'command', command: '/help'})">Help</button>
          <button class="quick-action" onclick="vscode.postMessage({type: 'command', command: '/model'})">Model</button>
          <button class="quick-action" onclick="vscode.postMessage({type: 'command', command: '/clear'})">Reset</button>
        </div>
      </div>
      `;
        }
        catch (error) {
            console.error('Error generating welcome HTML:', error);
            // Fallback to ultra-minimal welcome content in case of errors
            return `
        <div class="welcome-container minimal">
          <h1>Welcome to APE</h1>
          <p>The Agentic Pipeline Engine for development</p>
          <div class="welcome-quick-actions">
            <button class="quick-action" onclick="vscode.postMessage({type: 'command', command: '/help'})">Help</button>
          </div>
        </div>
      `;
        }
    }
    /**
     * Generate HTML for the welcome webview panel
     * Extracts the HTML generation logic for better maintainability
     */
    static generateHtml(webview, extensionUri) {
        // Get WebView stylesheets
        const styleUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(extensionUri, 'media', 'chat-ape.css'));
        const customStyleUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(extensionUri, 'media', 'welcome-custom.css'));
        // Get icons for the welcome page
        const mascotIconUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(extensionUri, 'media', 'icons', 'mascot.svg'));
        const apeIconUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(extensionUri, 'media', 'icons', 'ape.svg'));
        // Generate nonce for script security
        const nonce = getNonce();
        return `<!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; font-src ${webview.cspSource}; img-src ${webview.cspSource} https: data:; script-src 'nonce-${nonce}';">
        <link href="${styleUri}" rel="stylesheet">
        <link href="${customStyleUri}" rel="stylesheet">
        <title>Welcome to APE</title>
        <style>
          body, html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: var(--ape-welcome-bg);
          }

          .welcome-standalone {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 0;
            width: 100%;
          }

          /* 더 큰 화면에 맞춰 웰컴 화면 크기 최적화 */
          .welcome-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
          }

          /* 더 넓은 화면 공간으로 액션 버튼 그리드 개선 */
          .action-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
          }

          /* 타이틀 영역 스타일 개선 */
          .welcome-title {
            font-size: 6rem;
            font-weight: 700;
            margin: 0;
            letter-spacing: -2px;
            background: linear-gradient(135deg, var(--ape-welcome-accent) 0%, #9f7aea 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
          }

          .title-separator {
            width: 80px;
            height: 4px;
            background-color: var(--ape-welcome-accent);
            margin: 12px 0;
            border-radius: 2px;
          }

          .welcome-tagline {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 2px;
            color: var(--ape-welcome-accent);
            margin: 0 0 0.5rem 0;
          }

          .welcome-subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin: 0;
            font-weight: 400;
          }

          /* 애니메이션 */
          @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
          }

          @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.03); }
            100% { opacity: 1; transform: scale(1); }
          }

          .welcome-header {
            animation: fadeIn 0.8s ease-out;
          }

          .action-group {
            animation: fadeIn 1s ease-out 0.2s both;
          }

          .command-palette {
            animation: fadeIn 1.2s ease-out 0.4s both;
          }

          .welcome-quick-actions {
            animation: fadeIn 1.3s ease-out 0.6s both;
          }
        </style>
      </head>
      <body>
        <div class="welcome-standalone">
          ${WelcomeViewProvider.getWelcomeMessageHTML()}
        </div>

        <script nonce="${nonce}">
          const vscode = acquireVsCodeApi();

          // Command category tabs
          document.querySelectorAll('.category-tab').forEach(tab => {
            tab.addEventListener('click', () => {
              // Remove active class from all tabs
              document.querySelectorAll('.category-tab').forEach(t => {
                t.classList.remove('active');
              });

              // Add active class to clicked tab
              tab.classList.add('active');

              // Show the selected category
              const category = tab.dataset.category;

              // Toggle command lists visibility
              if (category === 'popular') {
                document.getElementById('popular-commands').style.display = 'flex';
                document.getElementById('popular-commands').style.flexDirection = 'column';
                document.getElementById('popular-commands').style.gap = '8px';
              }

              // For demonstration, we're only showing the popular commands section
              // In a real implementation, you would toggle visibility of different command lists
            });
          });

          // Example card click handlers
          document.querySelectorAll('.example-card').forEach(card => {
            card.addEventListener('click', event => {
              const command = card.querySelector('.example-text').textContent;
              vscode.postMessage({ type: 'command', command });
            });
          });

          // Quick action button handlers
          document.querySelectorAll('.quick-action').forEach(button => {
            button.addEventListener('click', event => {
              event.preventDefault();
              const commandText = button.textContent.toLowerCase();

              // Add a visual feedback animation
              button.classList.add('command-executing');
              setTimeout(() => {
                button.classList.remove('command-executing');
              }, 1000);

              vscode.postMessage({
                type: 'insertCommand',
                command: '/' + commandText
              });
            });
          });

          // Enhanced hover animations for all interactive elements
          document.querySelectorAll('.action-button, .example-card, .command-item').forEach(element => {
            element.addEventListener('mouseover', () => {
              element.style.transform = 'translateY(-2px)';
              element.style.boxShadow = '0 6px 14px var(--ape-welcome-shadow)';
              element.style.borderColor = 'var(--ape-card-hover-border)';
            });

            element.addEventListener('mouseout', () => {
              element.style.transform = '';
              element.style.boxShadow = '';
              element.style.borderColor = '';
            });
          });

          // Title animation
          setTimeout(() => {
            const title = document.querySelector('.welcome-title');
            if (title) {
              title.style.animation = 'pulse 3s infinite ease-in-out';
            }
          }, 1500);

          // Command tag click handlers with animation
          document.querySelectorAll('.command-tag').forEach(tag => {
            tag.addEventListener('click', (event) => {
              event.stopPropagation();

              // Visual feedback
              tag.style.backgroundColor = 'var(--ape-welcome-accent)';
              tag.style.color = 'white';

              setTimeout(() => {
                tag.style.backgroundColor = '';
                tag.style.color = '';

                const command = tag.textContent;
                vscode.postMessage({
                  type: 'insertCommand',
                  command
                });
              }, 300);
            });
          });
        </script>
      </body>
      </html>`;
    }
    /**
     * Create standalone webview panel with welcome content
     */
    static createOrShow(context) {
        const panel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createWebviewPanel('apeWelcome', 'Welcome to APE', vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.Active, // 현재 활성화된 에디터 영역에 표시
        {
            enableScripts: true,
            localResourceRoots: [
                vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(context.extensionUri, 'media')
            ],
            retainContextWhenHidden: true // 숨겨진 상태에서도 컨텍스트 유지
        });
        // Set HTML content
        panel.webview.html = WelcomeViewProvider.generateHtml(panel.webview, context.extensionUri);
        // Set up message handler for the webview
        panel.webview.onDidReceiveMessage(message => {
            switch (message.type) {
                case 'command':
                    // Process direct command
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Executing command: ${message.command}`);
                    break;
                case 'insertCommand':
                    // Insert a command into the command palette
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Inserting command: ${message.command}`);
                    break;
            }
        }, undefined, context.subscriptions);
        return panel;
    }
}
/**
 * Generates a nonce string for Content Security Policy
 */
function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}


/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "bufferutil":
/*!*****************************!*\
  !*** external "bufferutil" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("bufferutil");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "fs/promises":
/*!******************************!*\
  !*** external "fs/promises" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "utf-8-validate":
/*!*********************************!*\
  !*** external "utf-8-validate" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("utf-8-validate");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "vscode":
/*!*************************!*\
  !*** external "vscode" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".extension.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			"main": 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**************************!*\
  !*** ./src/extension.ts ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   activate: () => (/* binding */ activate),
/* harmony export */   deactivate: () => (/* binding */ deactivate)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _core_llm_llmService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/llm/llmService */ "./src/core/llm/llmService.ts");
/* harmony import */ var _core_memory_memoryService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/memory/memoryService */ "./src/core/memory/memoryService.ts");
/* harmony import */ var _core_commands_commandManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/commands/commandManager */ "./src/core/commands/commandManager.ts");
/* harmony import */ var _core_git_autoCommitService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/git/autoCommitService */ "./src/core/git/autoCommitService.ts");
/* harmony import */ var _core_git_bitbucketService__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/git/bitbucketService */ "./src/core/git/bitbucketService.ts");
/* harmony import */ var _core_git_conflictSolver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/git/conflictSolver */ "./src/core/git/conflictSolver.ts");
/* harmony import */ var _core_completion_tabCompletionProvider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/completion/tabCompletionProvider */ "./src/core/completion/tabCompletionProvider.ts");
/* harmony import */ var _core_completion_inlineCompletionProvider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/completion/inlineCompletionProvider */ "./src/core/completion/inlineCompletionProvider.ts");
/* harmony import */ var _ui_tree_apeTreeDataProvider__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ui/tree/apeTreeDataProvider */ "./src/ui/tree/apeTreeDataProvider.ts");
/* harmony import */ var _core_services_versionManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/services/versionManager */ "./src/core/services/versionManager.ts");
/* harmony import */ var _core_llm_modelManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/llm/modelManager */ "./src/core/llm/modelManager.ts");
/* harmony import */ var _ui_chat_codeService__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ui/chat/codeService */ "./src/ui/chat/codeService.ts");
/* harmony import */ var _ui_mainChatViewProvider__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ui/mainChatViewProvider */ "./src/ui/mainChatViewProvider.ts");
/* harmony import */ var _plugins_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugins/core */ "./src/plugins/core/index.ts");
/* harmony import */ var _core_services_rulesService__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./core/services/rulesService */ "./src/core/services/rulesService.ts");
/* harmony import */ var _core_services_vaultService__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./core/services/vaultService */ "./src/core/services/vaultService.ts");
/* harmony import */ var _core_services_serviceConfig__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./core/services/serviceConfig */ "./src/core/services/serviceConfig.ts");
/* harmony import */ var _core_services_jiraService__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./core/services/jiraService */ "./src/core/services/jiraService.ts");















// 개발/테스트 환경에서만 로딩 (프로덕션에서는 조건부로 로딩)
let autoPermissionHandler = null;
if (true) {
    try {
        // 동적 임포트로 테스트 모드에서만 로드
        __webpack_require__.e(/*! import() */ "src_test_helpers_auto-permission_ts").then(__webpack_require__.bind(__webpack_require__, /*! ./test/helpers/auto-permission */ "./src/test/helpers/auto-permission.ts")).then(module => {
            autoPermissionHandler = module.autoPermissionHandler;
            console.log('자동 권한 핸들러 활성화됨 (테스트/개발 모드)');
        }).catch(error => {
            console.error('자동 권한 핸들러 로드 실패:', error);
        });
    }
    catch (error) {
        console.log('자동 권한 핸들러 초기화 중 오류 (무시됨):', error);
    }
}
// Plugin system imports





/**
 * Initialize all core services
 * @param context Extension context
 * @returns ServiceContainer with all initialized services
 */
async function initializeServices(context) {
    // Create service config manager first
    const configManager = new _core_services_serviceConfig__WEBPACK_IMPORTED_MODULE_18__.ServiceConfigManager(context);
    // Create model manager (should be initialized before LLMService)
    const modelManager = new _core_llm_modelManager__WEBPACK_IMPORTED_MODULE_12__.ModelManager(context);
    // Create core services with modelManager
    const llmService = new _core_llm_llmService__WEBPACK_IMPORTED_MODULE_2__.LLMService(context, modelManager); // Updated constructor
    const memoryService = new _core_memory_memoryService__WEBPACK_IMPORTED_MODULE_3__.MemoryService(context);
    // Create objects in the correct initialization order
    // Create chatViewProvider
    const chatViewProvider = new _ui_mainChatViewProvider__WEBPACK_IMPORTED_MODULE_14__.MainChatViewProvider(context, llmService, memoryService, null, // Will be set after CommandManager is created
    modelManager);
    // Initialize Rules service
    const rulesService = new _core_services_rulesService__WEBPACK_IMPORTED_MODULE_16__.RulesService(context, configManager);
    // Initialize VAULT service
    const vaultService = new _core_services_vaultService__WEBPACK_IMPORTED_MODULE_17__.VaultService(context, configManager);
    // Initialize Jira service
    const jiraService = new _core_services_jiraService__WEBPACK_IMPORTED_MODULE_19__.JiraService(context, configManager);
    // Apply Rules and VAULT services to LLM service
    llmService.setRulesService(rulesService);
    llmService.setVaultService(vaultService);
    // Then create CommandManager with chatViewProvider and services
    const commandManager = new _core_commands_commandManager__WEBPACK_IMPORTED_MODULE_4__.CommandManager(context, chatViewProvider, llmService, memoryService, modelManager, rulesService, vaultService, jiraService);
    // Now set the CommandManager reference in ChatViewProvider
    chatViewProvider._commandManager = commandManager;
    // Log debugging information
    console.log('ChatViewProvider 및 CommandManager 초기화 완료');
    // Initialize Git services
    const bitbucketService = new _core_git_bitbucketService__WEBPACK_IMPORTED_MODULE_6__.BitbucketService(context);
    const autoCommitService = new _core_git_autoCommitService__WEBPACK_IMPORTED_MODULE_5__.AutoCommitService(context, llmService, bitbucketService);
    const conflictSolver = new _core_git_conflictSolver__WEBPACK_IMPORTED_MODULE_7__.ConflictSolver(llmService);
    // Initialize completion providers
    const tabCompletionProvider = new _core_completion_tabCompletionProvider__WEBPACK_IMPORTED_MODULE_8__.TabCompletionProvider(llmService);
    const inlineCompletionProvider = new _core_completion_inlineCompletionProvider__WEBPACK_IMPORTED_MODULE_9__.InlineCompletionProvider(llmService, context);
    // Initialize tree view data provider
    const treeDataProvider = new _ui_tree_apeTreeDataProvider__WEBPACK_IMPORTED_MODULE_10__.ApeTreeDataProvider(context, llmService, memoryService, undefined, // todoService
    vaultService, rulesService, jiraService);
    // Initialize version manager
    const versionManager = new _core_services_versionManager__WEBPACK_IMPORTED_MODULE_11__.VersionManager(context);
    // Initialize plugin system
    const pluginEventEmitter = new _plugins_core__WEBPACK_IMPORTED_MODULE_15__.EventEmitterImpl();
    const pluginRegistry = new _plugins_core__WEBPACK_IMPORTED_MODULE_15__.PluginRegistryImpl(pluginEventEmitter);
    const pluginAPI = new _plugins_core__WEBPACK_IMPORTED_MODULE_15__.PluginAPIImpl(llmService, memoryService, pluginEventEmitter);
    const pluginLoader = new _plugins_core__WEBPACK_IMPORTED_MODULE_15__.PluginLoader(context, pluginRegistry, pluginAPI);
    const pluginSettingsManager = new _plugins_core__WEBPACK_IMPORTED_MODULE_15__.PluginSettingsManagerImpl(context);
    return {
        modelManager,
        llmService,
        memoryService,
        chatViewProvider,
        commandManager,
        bitbucketService,
        autoCommitService,
        conflictSolver,
        tabCompletionProvider,
        inlineCompletionProvider,
        treeDataProvider,
        versionManager,
        rulesService,
        vaultService,
        jiraService,
        configManager,
        pluginEventEmitter,
        pluginRegistry,
        pluginAPI,
        pluginLoader,
        pluginSettingsManager
    };
}
/**
 * Register VSCode components
 * @param context Extension context
 * @param services Service container
 */
function registerComponents(context, services) {
    // Register WebView provider
    const chatViewProviderRegistration = vscode__WEBPACK_IMPORTED_MODULE_0__.window.registerWebviewViewProvider('apeChat', services.chatViewProvider, {
        webviewOptions: {
            retainContextWhenHidden: true
        }
    });
    // 디버깅을 위한 로그 추가
    console.log('APE Chat View Provider가 등록되었습니다.');
    context.subscriptions.push(chatViewProviderRegistration);
    // 모든 명령어는 CommandManager를 통해서만 등록
    // ModelManager에서 명령어 등록하는 부분 제거 (중복 등록 방지)
    services.commandManager.registerCommands();
    // Register code block insertion commands
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.insertCodeToEditor', (options) => {
        return _ui_chat_codeService__WEBPACK_IMPORTED_MODULE_13__.CodeService.insertCodeToEditor(options);
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.createNewFileWithCode', (options) => {
        return _ui_chat_codeService__WEBPACK_IMPORTED_MODULE_13__.CodeService.insertCodeToEditor({
            ...options,
            createNewFile: true
        });
    }));
    // Register Git commands
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.git.resolveConflict', async () => {
        const resolvedCount = await services.conflictSolver.resolveAllConflicts();
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`${resolvedCount}개 파일의 충돌을 해결했습니다`);
    }));
    // Register tab completion for various languages
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.languages.registerCompletionItemProvider([
        { scheme: 'file', language: 'typescript' },
        { scheme: 'file', language: 'javascript' },
        { scheme: 'file', language: 'python' },
        { scheme: 'file', language: 'java' },
        { scheme: 'file', language: 'c' },
        { scheme: 'file', language: 'cpp' },
        { scheme: 'file', language: 'csharp' },
        { scheme: 'file', language: 'go' },
        { scheme: 'file', language: 'rust' },
        { scheme: 'file', language: 'php' },
        { scheme: 'file', language: 'ruby' },
        { scheme: 'file', language: 'html' },
        { scheme: 'file', language: 'css' },
        { scheme: 'file', language: 'json' },
        { scheme: 'file', language: 'markdown' }
    ], services.tabCompletionProvider, '\t' // Triggered by tab key
    ));
    // Register command completion
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.languages.registerCompletionItemProvider([{ scheme: 'file' }], services.tabCompletionProvider, '/' // Triggered by slash
    ));
    // Register inline completion provider
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.languages.registerInlineCompletionItemProvider([{ scheme: 'file' }], services.inlineCompletionProvider));
    // Register tree data provider with custom configuration
    const treeView = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createTreeView('apeNavigator', {
        treeDataProvider: services.treeDataProvider,
        showCollapseAll: true,
        canSelectMany: false // 다중 선택 방지로 UI 단순화
    });
    // Add command to set optimal view layout
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.setOptimalLayout', async () => {
        try {
            // 사이드바 확인
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.view.extension.ape-sidebar');
            await new Promise(r => setTimeout(r, 100));
            // 채팅 뷰 활성화
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('apeChat.focus');
            await new Promise(r => setTimeout(r, 100));
            // 사이드바 크기 줄이기 (트리뷰에 맞게)
            for (let i = 0; i < 6; i++) {
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.decreaseSideBarWidth');
                await new Promise(r => setTimeout(r, 30));
            }
            // 채팅뷰 크기 키우기
            for (let i = 0; i < 3; i++) {
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.increaseViewSize');
                await new Promise(r => setTimeout(r, 30));
            }
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('APE 최적 레이아웃이 설정되었습니다.');
        }
        catch (error) {
            console.error('최적 레이아웃 설정 실패:', error);
        }
    }));
    context.subscriptions.push(treeView);
    // Register version manager
    services.versionManager.registerCommands();
    // Register navigator commands
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.refreshNavigator', () => {
        services.treeDataProvider.refresh();
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.refreshTreeView', () => {
        services.treeDataProvider.refresh();
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.executeCommand', (commandInfo) => {
        if (!commandInfo || !commandInfo.name) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('명령어 정보가 올바르지 않습니다');
            return;
        }
        const commandText = commandInfo.args
            ? `/${commandInfo.name} ${commandInfo.args.join(' ')}`
            : `/${commandInfo.name}`;
        // 직접 SlashCommandManager로 명령 실행
        services.commandManager.slashCommandManager.executeCommand(commandText);
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.sendLlmResponse', (messageData) => {
        services.chatViewProvider.sendLlmResponse(messageData);
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.openSettings', (settingKey) => {
        if (settingKey) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', settingKey);
        }
        else {
            vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', 'ape');
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.handleChatInput', (text) => {
        services.chatViewProvider.handleChatInput(text);
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.sendChatMessage', () => {
        vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendMessage');
    }), 
    // VAULT 관련 명령어
    vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.vaultShowItem', (item) => {
        if (!item || !item.metadata) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('VAULT 아이템 정보가 올바르지 않습니다');
            return;
        }
        // 아이템 내용 표시
        const content = item.metadata.content;
        const title = `VAULT 아이템: ${item.label}`;
        // 채팅창에 내용 표시
        vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## ${title}\n\n${content}`
        });
    }));
    // Register Rules commands
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.activate', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Rule 정보가 올바르지 않습니다');
            return;
        }
        try {
            const success = await services.rulesService.activateRule(item.metadata.id);
            if (success) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Rule '${item.label}' 활성화 완료`);
                services.treeDataProvider.refresh();
            }
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule 활성화 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.deactivate', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Rule 정보가 올바르지 않습니다');
            return;
        }
        try {
            const success = await services.rulesService.deactivateRule(item.metadata.id);
            if (success) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Rule '${item.label}' 비활성화 완료`);
                services.treeDataProvider.refresh();
            }
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule 비활성화 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.openFile', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Rule 정보가 올바르지 않습니다');
            return;
        }
        try {
            await services.rulesService.openRuleFile(item.metadata.id);
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule 파일 열기 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.refresh', () => {
        try {
            services.rulesService.loadAllRules();
            services.treeDataProvider.refresh();
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rules 새로고침 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.create', async () => {
        try {
            // 규칙 이름 입력 받기
            const ruleName = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: '새로운 Rule 이름을 입력하세요',
                placeHolder: '예: 코드 작성 규칙, API 사용 지침 등',
                validateInput: (value) => {
                    if (!value || value.trim().length === 0) {
                        return '이름은 비워둘 수 없습니다';
                    }
                    return null;
                }
            });
            if (!ruleName) {
                return; // 사용자가 취소한 경우
            }
            // 새 문서 생성
            const rulePath = path__WEBPACK_IMPORTED_MODULE_1__.join(services.rulesService['rulesDir'], `${ruleName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '')}.md`);
            const ruleContent = `# ${ruleName}\n\n여기에 LLM에 적용할 규칙 내용을 작성하세요.\n\n규칙은 마크다운 형식으로 작성됩니다.\n\n## 예시\n\n1. 항상 코드에 주석을 추가해주세요.\n2. 응답은 간결하게 유지해주세요.\n3. 에러 처리를 항상 포함해주세요.`;
            // 규칙 생성
            const rule = await services.rulesService.createRule(ruleName, ruleContent, false);
            // 생성된 규칙 파일 열기
            await services.rulesService.openRuleFile(rule.id);
            // 트리뷰 새로고침
            services.treeDataProvider.refresh();
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Rule '${ruleName}' 생성 완료. 파일을 수정한 후 저장하세요.`);
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule 생성 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.delete', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Rule 정보가 올바르지 않습니다');
            return;
        }
        try {
            // 삭제 확인
            const confirmation = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage(`Rule '${item.label}'을(를) 삭제하시겠습니까?`, { modal: true }, '삭제', '취소');
            if (confirmation !== '삭제') {
                return;
            }
            // 규칙 삭제
            const success = await services.rulesService.deleteRule(item.metadata.id);
            if (success) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Rule '${item.label}' 삭제 완료`);
                services.treeDataProvider.refresh();
            }
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule 삭제 중 오류 발생: ${error instanceof Error ? error.message : String(error)}`);
        }
    }));
    // Register plugin system commands
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.plugins.list', async () => {
        const plugins = services.pluginRegistry.getAllPlugins();
        const items = plugins.map(plugin => ({
            label: `${plugin.metadata.name} (${plugin.metadata.version})`,
            description: plugin.state,
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to see details'
        });
        if (selected) {
            const actions = [];
            if (selected.plugin.state === 'active') {
                actions.push('Deactivate');
            }
            else if (selected.plugin.state === 'registered' || selected.plugin.state === 'inactive') {
                actions.push('Activate');
            }
            actions.push('View Details', 'Open Settings');
            const action = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(actions, {
                placeHolder: 'Select an action'
            });
            if (action === 'Activate') {
                await services.pluginRegistry.activatePlugin(selected.plugin.id);
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} activated`);
            }
            else if (action === 'Deactivate') {
                await services.pluginRegistry.deactivatePlugin(selected.plugin.id);
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} deactivated`);
            }
            else if (action === 'View Details') {
                // Show details in output channel
                const outputChannel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createOutputChannel(`APE Plugin: ${selected.plugin.metadata.name}`);
                outputChannel.appendLine(`ID: ${selected.plugin.id}`);
                outputChannel.appendLine(`Name: ${selected.plugin.metadata.name}`);
                outputChannel.appendLine(`Version: ${selected.plugin.metadata.version}`);
                outputChannel.appendLine(`Description: ${selected.plugin.metadata.description || 'No description'}`);
                outputChannel.appendLine(`Author: ${selected.plugin.metadata.author || 'Unknown'}`);
                outputChannel.appendLine(`State: ${selected.plugin.state}`);
                if (selected.plugin.metadata.dependencies?.length) {
                    outputChannel.appendLine(`Dependencies: ${selected.plugin.metadata.dependencies.join(', ')}`);
                }
                if (selected.plugin.error) {
                    outputChannel.appendLine(`\nError: ${selected.plugin.error.message}`);
                }
                outputChannel.show();
            }
            else if (action === 'Open Settings') {
                vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', `ape.plugins.${selected.plugin.id}`);
            }
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.plugins.activate', async () => {
        const plugins = services.pluginRegistry.getAllPlugins()
            .filter(p => p.state !== 'active');
        const items = plugins.map(plugin => ({
            label: plugin.metadata.name,
            description: plugin.state,
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to activate'
        });
        if (selected) {
            try {
                const success = await services.pluginRegistry.activatePlugin(selected.plugin.id);
                if (success) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} activated`);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Failed to activate plugin ${selected.plugin.metadata.name}`);
                }
            }
            catch (error) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Failed to activate plugin: ${error.message}`);
            }
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.plugins.deactivate', async () => {
        const plugins = services.pluginRegistry.getActivePlugins();
        const items = plugins.map(plugin => ({
            label: plugin.metadata.name,
            description: 'active',
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to deactivate'
        });
        if (selected) {
            try {
                const success = await services.pluginRegistry.deactivatePlugin(selected.plugin.id);
                if (success) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} deactivated`);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Failed to deactivate plugin ${selected.plugin.metadata.name}`);
                }
            }
            catch (error) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Failed to deactivate plugin: ${error.message}`);
            }
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.plugins.openSettings', async () => {
        const plugins = services.pluginRegistry.getAllPlugins();
        const items = plugins.map(plugin => ({
            label: plugin.metadata.name,
            description: plugin.state,
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to open settings'
        });
        if (selected) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', `ape.plugins.${selected.plugin.id}`);
        }
    }));
    // Add all services to context subscriptions for proper disposal
    context.subscriptions.push(services.modelManager, services.llmService, services.memoryService, services.bitbucketService, services.autoCommitService, services.vaultService, services.rulesService, services.jiraService, services.configManager, {
        dispose: () => {
            // Dispose plugin system
            services.pluginLoader.deactivateAllPlugins().catch(error => {
                console.error('Error deactivating plugins during extension deactivation:', error);
            });
            services.pluginSettingsManager.dispose();
            // Event emitter doesn't need explicit disposal
        }
    });
}
/**
 * Extension activation point
 * @param context Extension context
 */
async function activate(context) {
    console.log('APE Extension is now active!');
    // 테스트 모드 여부 확인 및 환경 변수 설정
    const isTestMode = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape').get('testing.enabled') ||
        process.env.APE_TEST_MODE === 'true';
    if (isTestMode) {
        process.env.APE_TEST_MODE = 'true';
        console.log('APE 테스트 모드 활성화됨: 자동 권한 허용이 활성화됩니다.');
        // 권한 요청 자동 수락 명령 등록
        context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.acceptAllPermissions', () => {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('모든 권한 요청이 자동으로 수락됩니다.');
            return true;
        }));
    }
    // 현재 버전 정보를 상태 표시줄에 표시
    try {
        const versionInfo = await context.extension.packageJSON.version;
        const statusBarItem = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createStatusBarItem(vscode__WEBPACK_IMPORTED_MODULE_0__.StatusBarAlignment.Right, 100);
        statusBarItem.text = `$(tag) APE v${versionInfo}`;
        statusBarItem.tooltip = 'APE Extension Version';
        statusBarItem.show();
        context.subscriptions.push(statusBarItem);
    }
    catch (error) {
        console.error('Failed to display version in status bar:', error);
    }
    try {
        // Initialize all services
        const services = await initializeServices(context);
        // Register VSCode components
        registerComponents(context, services);
        // Load internal plugins
        try {
            const internalPluginCount = await services.pluginLoader.loadInternalPlugins();
            console.log(`Loaded ${internalPluginCount} internal plugins`);
            // Load external plugins
            const externalPluginCount = await services.pluginLoader.loadExternalPlugins();
            console.log(`Loaded ${externalPluginCount} external plugins`);
            // Auto-activate plugins based on extension activation event
            services.pluginLoader.activatePluginsByEvent('onExtensionActivate').catch(error => {
                console.error('Error activating plugins on extension activation:', error);
            });
        }
        catch (error) {
            console.error('Failed to initialize plugin system:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Failed to initialize APE plugin system. Some features may not work properly.');
        }
        // Show welcome message on first activation
        const hasShownWelcome = context.globalState.get('ape.hasShownWelcome');
        // 앱 시작 시 채팅 화면과 트리뷰 비율(3:1)로 설정
        setTimeout(async () => {
            try {
                // VSCode 레이아웃 초기화
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.resetLayout');
                await sleep(300);
                // 사이드바 열기 (트리뷰 표시)
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.view.extension.ape-sidebar');
                console.log('APE Sidebar opened');
                await sleep(100);
                // 먼저 채팅 뷰에 직접 접근
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('apeChat.focus');
                console.log('APE Chat view activated');
                await sleep(100);
                // 채팅뷰와 트리뷰의 비율 조정 (3:1)을 위한 작업
                // 먼저 사이드바 크기 줄이기 (VSCode API는 상대적인 크기 조정만 제공)
                const decreaseCount = 6; // 사이드바를 충분히 좁게
                for (let i = 0; i < decreaseCount; i++) {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.decreaseSideBarWidth');
                    await sleep(30); // 각 명령 사이에 약간의 지연
                }
                // 에디터 영역 크기 증가 (채팅뷰를 위해)
                const increaseCount = 3; // 채팅뷰 영역 확장
                for (let i = 0; i < increaseCount; i++) {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.increaseViewSize');
                    await sleep(30);
                }
                // 채팅 뷰 포커싱 다시 한번 확인
                await sleep(100);
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('apeChat.focus');
            }
            catch (error) {
                console.error('채팅 뷰 및 트리뷰 초기화 중 오류:', error);
                // 에러 발생시 기본 액션
                try {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.view.extension.ape-sidebar');
                    console.log('APE Sidebar opened as fallback');
                }
                catch (sidebarError) {
                    console.error('사이드바 열기 실패:', sidebarError);
                }
            }
        }, 1500); // 충분한 지연 시간으로 확실히 초기화 후 실행
        // 짧은 지연을 위한 헬퍼 함수
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        if (!hasShownWelcome) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('APE Extension is now active! Open the APE sidebar to start using it.', 'Open APE Sidebar').then(selection => {
                if (selection === 'Open APE Sidebar') {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.view.extension.ape-sidebar');
                }
            });
            context.globalState.update('ape.hasShownWelcome', true);
        }
    }
    catch (error) {
        console.error('Failed to activate APE extension:', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Failed to activate APE extension: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Extension deactivation point
 *
 * 확장 프로그램 비활성화 시 호출되며, 리소스 정리 및 메모리 해제를 수행합니다.
 * - 열려있는 연결 종료 (LLM 스트리밍 등)
 * - 이벤트 리스너 제거
 * - 캐시된 데이터 정리
 * - 불필요한 메모리 해제
 */
function deactivate() {
    console.log('APE Extension is deactivated');
}

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=extension.js.map