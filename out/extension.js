/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/asynckit/index.js":
/*!****************************************!*\
  !*** ./node_modules/asynckit/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports =
{
  parallel      : __webpack_require__(/*! ./parallel.js */ "./node_modules/asynckit/parallel.js"),
  serial        : __webpack_require__(/*! ./serial.js */ "./node_modules/asynckit/serial.js"),
  serialOrdered : __webpack_require__(/*! ./serialOrdered.js */ "./node_modules/asynckit/serialOrdered.js")
};


/***/ }),

/***/ "./node_modules/asynckit/lib/abort.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/abort.js ***!
  \********************************************/
/***/ ((module) => {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),

/***/ "./node_modules/asynckit/lib/async.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/async.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defer = __webpack_require__(/*! ./defer.js */ "./node_modules/asynckit/lib/defer.js");

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),

/***/ "./node_modules/asynckit/lib/defer.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/defer.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),

/***/ "./node_modules/asynckit/lib/iterate.js":
/*!**********************************************!*\
  !*** ./node_modules/asynckit/lib/iterate.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(/*! ./async.js */ "./node_modules/asynckit/lib/async.js")
  , abort = __webpack_require__(/*! ./abort.js */ "./node_modules/asynckit/lib/abort.js")
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),

/***/ "./node_modules/asynckit/lib/state.js":
/*!********************************************!*\
  !*** ./node_modules/asynckit/lib/state.js ***!
  \********************************************/
/***/ ((module) => {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),

/***/ "./node_modules/asynckit/lib/terminator.js":
/*!*************************************************!*\
  !*** ./node_modules/asynckit/lib/terminator.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var abort = __webpack_require__(/*! ./abort.js */ "./node_modules/asynckit/lib/abort.js")
  , async = __webpack_require__(/*! ./async.js */ "./node_modules/asynckit/lib/async.js")
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),

/***/ "./node_modules/asynckit/parallel.js":
/*!*******************************************!*\
  !*** ./node_modules/asynckit/parallel.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(/*! ./lib/iterate.js */ "./node_modules/asynckit/lib/iterate.js")
  , initState  = __webpack_require__(/*! ./lib/state.js */ "./node_modules/asynckit/lib/state.js")
  , terminator = __webpack_require__(/*! ./lib/terminator.js */ "./node_modules/asynckit/lib/terminator.js")
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),

/***/ "./node_modules/asynckit/serial.js":
/*!*****************************************!*\
  !*** ./node_modules/asynckit/serial.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var serialOrdered = __webpack_require__(/*! ./serialOrdered.js */ "./node_modules/asynckit/serialOrdered.js");

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),

/***/ "./node_modules/asynckit/serialOrdered.js":
/*!************************************************!*\
  !*** ./node_modules/asynckit/serialOrdered.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(/*! ./lib/iterate.js */ "./node_modules/asynckit/lib/iterate.js")
  , initState  = __webpack_require__(/*! ./lib/state.js */ "./node_modules/asynckit/lib/state.js")
  , terminator = __webpack_require__(/*! ./lib/terminator.js */ "./node_modules/asynckit/lib/terminator.js")
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),

/***/ "./node_modules/axios/lib/adapters/adapters.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/adapters/adapters.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _http_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./http.js */ "./node_modules/axios/lib/adapters/http.js");
/* harmony import */ var _xhr_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./xhr.js */ "./node_modules/axios/lib/adapters/xhr.js");
/* harmony import */ var _fetch_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fetch.js */ "./node_modules/axios/lib/adapters/fetch.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");






const knownAdapters = {
  http: _http_js__WEBPACK_IMPORTED_MODULE_0__["default"],
  xhr: _xhr_js__WEBPACK_IMPORTED_MODULE_1__["default"],
  fetch: _fetch_js__WEBPACK_IMPORTED_MODULE_2__["default"]
}

_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(adapter) || adapter === null || adapter === false;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  getAdapter: (adapters) => {
    adapters = _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__["default"](`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_4__["default"](
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
});


/***/ }),

/***/ "./node_modules/axios/lib/adapters/fetch.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/adapters/fetch.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/composeSignals.js */ "./node_modules/axios/lib/helpers/composeSignals.js");
/* harmony import */ var _helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/trackStream.js */ "./node_modules/axios/lib/helpers/trackStream.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ "./node_modules/axios/lib/helpers/progressEventReducer.js");
/* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/resolveConfig.js */ "./node_modules/axios/lib/helpers/resolveConfig.js");
/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../core/settle.js */ "./node_modules/axios/lib/core/settle.js");










const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
}

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"](`Response type '${type}' is not supported`, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NOT_SUPPORT, config);
      })
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isBlob(body)) {
    return body.size;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isSpecCompliantForm(body)) {
    const _request = new Request(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArrayBufferView(body) || _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isURLSearchParams(body)) {
    body = body + '';
  }

  if(_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(body)) {
    return (await encodeText(body)).byteLength;
  }
}

const resolveBodyLength = async (headers, body) => {
  const length = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = (0,_helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_3__["default"])(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = (0,_helpers_composeSignals_js__WEBPACK_IMPORTED_MODULE_4__["default"])([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader)
      }

      if (_request.body) {
        const [onProgress, flush] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventDecorator)(
          requestContentLength,
          (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.asyncDecorator)(onUploadProgress))
        );

        data = (0,_helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__.trackStream)(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventDecorator)(
        responseContentLength,
        (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_5__.asyncDecorator)(onDownloadProgress), true)
      ) || [];

      response = new Response(
        (0,_helpers_trackStream_js__WEBPACK_IMPORTED_MODULE_6__.trackStream)(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_7__["default"])(resolve, reject, {
        data: responseData,
        headers: _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_8__["default"].from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      })
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Network Error', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].from(err, err && err.code, config, request);
  }
}));




/***/ }),

/***/ "./node_modules/axios/lib/adapters/http.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/adapters/http.js ***!
  \*************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   __setProxy: () => (/* binding */ __setProxy),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./../core/settle.js */ "./node_modules/axios/lib/core/settle.js");
/* harmony import */ var _core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../core/buildFullPath.js */ "./node_modules/axios/lib/core/buildFullPath.js");
/* harmony import */ var _helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./../helpers/buildURL.js */ "./node_modules/axios/lib/helpers/buildURL.js");
/* harmony import */ var proxy_from_env__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! proxy-from-env */ "./node_modules/proxy-from-env/index.js");
/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! http */ "http");
/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! https */ "https");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var follow_redirects__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! follow-redirects */ "./node_modules/follow-redirects/index.js");
/* harmony import */ var zlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zlib */ "zlib");
/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../env/data.js */ "./node_modules/axios/lib/env/data.js");
/* harmony import */ var _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ../defaults/transitional.js */ "./node_modules/axios/lib/defaults/transitional.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _helpers_fromDataURI_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../helpers/fromDataURI.js */ "./node_modules/axios/lib/helpers/fromDataURI.js");
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _helpers_AxiosTransformStream_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ../helpers/AxiosTransformStream.js */ "./node_modules/axios/lib/helpers/AxiosTransformStream.js");
/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! events */ "events");
/* harmony import */ var _helpers_formDataToStream_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ../helpers/formDataToStream.js */ "./node_modules/axios/lib/helpers/formDataToStream.js");
/* harmony import */ var _helpers_readBlob_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ../helpers/readBlob.js */ "./node_modules/axios/lib/helpers/readBlob.js");
/* harmony import */ var _helpers_ZlibHeaderTransformStream_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ../helpers/ZlibHeaderTransformStream.js */ "./node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js");
/* harmony import */ var _helpers_callbackify_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../helpers/callbackify.js */ "./node_modules/axios/lib/helpers/callbackify.js");
/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ "./node_modules/axios/lib/helpers/progressEventReducer.js");




























const zlibOptions = {
  flush: zlib__WEBPACK_IMPORTED_MODULE_5__.constants.Z_SYNC_FLUSH,
  finishFlush: zlib__WEBPACK_IMPORTED_MODULE_5__.constants.Z_SYNC_FLUSH
};

const brotliOptions = {
  flush: zlib__WEBPACK_IMPORTED_MODULE_5__.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib__WEBPACK_IMPORTED_MODULE_5__.constants.BROTLI_OPERATION_FLUSH
}

const isBrotliSupported = _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isFunction(zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress);

const {http: httpFollow, https: httpsFollow} = follow_redirects__WEBPACK_IMPORTED_MODULE_4__;

const isHttps = /https:?/;

const supportedProtocols = _platform_index_js__WEBPACK_IMPORTED_MODULE_9__["default"].protocols.map(protocol => {
  return protocol + ':';
});

const flushOnFinish = (stream, [throttled, flush]) => {
  stream
    .on('end', flush)
    .on('error', flush);

  return throttled;
}

/**
 * If the proxy or config beforeRedirects functions are defined, call them with the options
 * object.
 *
 * @param {Object<string, any>} options - The options object that was passed to the request.
 *
 * @returns {Object<string, any>}
 */
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}

/**
 * If the proxy or config afterRedirects functions are defined, call them with the options
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
 * @param {string} location
 *
 * @returns {http.ClientRequestArgs}
 */
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxy_from_env__WEBPACK_IMPORTED_MODULE_0__.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    // Basic proxy authorization
    if (proxy.username) {
      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
    }

    if (proxy.auth) {
      // Support proxy auth object form
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
      }
      const base64 = Buffer
        .from(proxy.auth, 'utf8')
        .toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }

    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    // Replace 'host' since options is not a URL object
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;
    }
  }

  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    // Configure proxy for redirected request, passing the original config proxy to apply
    // the exact same logic as if the redirected request was performed by axios directly.
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}

const isHttpAdapterSupported = typeof process !== 'undefined' && _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].kindOf(process) === 'process';

// temporary hotfix

const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;

    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    }

    const _resolve = (value) => {
      done(value);
      resolve(value);
    };

    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    }

    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);
  })
};

const resolveFamily = ({address, family}) => {
  if (!_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isString(address)) {
    throw TypeError('address must be a string');
  }
  return ({
    address,
    family: family || (address.indexOf('.') < 0 ? 6 : 4)
  });
}

const buildAddressEntry = (address, family) => resolveFamily(_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isObject(address) ? address : {address, family});

/*eslint consistent-return:0*/
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let {data, lookup, family} = config;
    const {responseType, responseEncoding} = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;

    if (lookup) {
      const _lookup = (0,_helpers_callbackify_js__WEBPACK_IMPORTED_MODULE_10__["default"])(lookup, (value) => _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isArray(value) ? value : [value]);
      // hotfix to support opt.all option which is required for node 20.x
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }

          const addresses = _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];

          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      }
    }

    // temporary internal emitter until the AxiosRequest class will be implemented
    const emitter = new events__WEBPACK_IMPORTED_MODULE_7__.EventEmitter();

    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', abort);
      }

      emitter.removeAllListeners();
    }

    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });

    function abort(reason) {
      emitter.emit('abort', !reason || reason.type ? new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_11__["default"](null, config, req) : reason);
    }

    emitter.once('abort', reject);

    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
      }
    }

    // Parse url
    const fullPath = (0,_core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_12__["default"])(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, _platform_index_js__WEBPACK_IMPORTED_MODULE_9__["default"].hasBrowserEnv ? _platform_index_js__WEBPACK_IMPORTED_MODULE_9__["default"].origin : undefined);
    const protocol = parsed.protocol || supportedProtocols[0];

    if (protocol === 'data:') {
      let convertedData;

      if (method !== 'GET') {
        return (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_13__["default"])(resolve, reject, {
          status: 405,
          statusText: 'method not allowed',
          headers: {},
          config
        });
      }

      try {
        convertedData = (0,_helpers_fromDataURI_js__WEBPACK_IMPORTED_MODULE_14__["default"])(config.url, responseType === 'blob', {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].from(err, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_REQUEST, config);
      }

      if (responseType === 'text') {
        convertedData = convertedData.toString(responseEncoding);

        if (!responseEncoding || responseEncoding === 'utf8') {
          convertedData = _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].stripBOM(convertedData);
        }
      } else if (responseType === 'stream') {
        convertedData = stream__WEBPACK_IMPORTED_MODULE_6__.Readable.from(convertedData);
      }

      return (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_13__["default"])(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: 'OK',
        headers: new _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_16__["default"](),
        config
      });
    }

    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
        'Unsupported protocol ' + protocol,
        _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_REQUEST,
        config
      ));
    }

    const headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_16__["default"].from(config.headers).normalize();

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    // User-Agent is specified; handle case where no UA header is desired
    // Only set header if it hasn't been set in config
    headers.set('User-Agent', 'axios/' + _env_data_js__WEBPACK_IMPORTED_MODULE_17__.VERSION, false);

    const {onUploadProgress, onDownloadProgress} = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;

    // support for spec compliant FormData objects
    if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);

      data = (0,_helpers_formDataToStream_js__WEBPACK_IMPORTED_MODULE_18__["default"])(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${_env_data_js__WEBPACK_IMPORTED_MODULE_17__.VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
      // support for https://www.npmjs.com/package/form-data api
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isFormData(data) && _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());

      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util__WEBPACK_IMPORTED_MODULE_3__.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          /*eslint no-empty:0*/
        } catch (e) {
        }
      }
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isBlob(data) || _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isFile(data)) {
      data.size && headers.setContentType(data.type || 'application/octet-stream');
      headers.setContentLength(data.size || 0);
      data = stream__WEBPACK_IMPORTED_MODULE_6__.Readable.from((0,_helpers_readBlob_js__WEBPACK_IMPORTED_MODULE_19__["default"])(data));
    } else if (data && !_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isStream(data)) {
      if (Buffer.isBuffer(data)) {
        // Nothing to do...
      } else if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_REQUEST,
          config
        ));
      }

      // Add Content-Length header if data exists
      headers.setContentLength(data.length, false);

      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
          'Request body larger than maxBodyLength limit',
          _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_REQUEST,
          config
        ));
      }
    }

    const contentLength = _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].toFiniteNumber(headers.getContentLength());

    if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }

    if (data && (onUploadProgress || maxUploadRate)) {
      if (!_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isStream(data)) {
        data = stream__WEBPACK_IMPORTED_MODULE_6__.Readable.from(data, {objectMode: false});
      }

      data = stream__WEBPACK_IMPORTED_MODULE_6__.pipeline([data, new _helpers_AxiosTransformStream_js__WEBPACK_IMPORTED_MODULE_20__["default"]({
        maxRate: _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].toFiniteNumber(maxUploadRate)
      })], _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].noop);

      onUploadProgress && data.on('progress', flushOnFinish(
        data,
        (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.progressEventDecorator)(
          contentLength,
          (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.asyncDecorator)(onUploadProgress), false, 3)
        )
      ));
    }

    // HTTP basic authentication
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password || '';
      auth = username + ':' + password;
    }

    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ':' + urlPassword;
    }

    auth && headers.delete('authorization');

    let path;

    try {
      path = (0,_helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_22__["default"])(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, '');
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }

    headers.set(
      'Accept-Encoding',
      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false
      );

    const options = {
      path,
      method: method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };

    // cacheable-lookup integration hotfix
    !_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isUndefined(lookup) && (options.lookup = lookup);

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https__WEBPACK_IMPORTED_MODULE_2__ : http__WEBPACK_IMPORTED_MODULE_1__;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
      options.maxBodyLength = Infinity;
    }

    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }

    // Create the request
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;

      const streams = [res];

      const responseLength = +res.headers['content-length'];

      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new _helpers_AxiosTransformStream_js__WEBPACK_IMPORTED_MODULE_20__["default"]({
          maxRate: _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].toFiniteNumber(maxDownloadRate)
        });

        onDownloadProgress && transformStream.on('progress', flushOnFinish(
          transformStream,
          (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.progressEventDecorator)(
            responseLength,
            (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.progressEventReducer)((0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_21__.asyncDecorator)(onDownloadProgress), true, 3)
          )
        ));

        streams.push(transformStream);
      }

      // decompress the response body transparently if required
      let responseStream = res;

      // return the last request in case of redirects
      const lastRequest = res.req || req;

      // if decompress disabled we should not decompress
      if (config.decompress !== false && res.headers['content-encoding']) {
        // if no content, but headers still say that it is encoded,
        // remove the header not confuse downstream operations
        if (method === 'HEAD' || res.statusCode === 204) {
          delete res.headers['content-encoding'];
        }

        switch ((res.headers['content-encoding'] || '').toLowerCase()) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'x-gzip':
        case 'compress':
        case 'x-compress':
          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__WEBPACK_IMPORTED_MODULE_5__.createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'deflate':
          streams.push(new _helpers_ZlibHeaderTransformStream_js__WEBPACK_IMPORTED_MODULE_23__["default"]());

          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__WEBPACK_IMPORTED_MODULE_5__.createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'br':
          if (isBrotliSupported) {
            streams.push(zlib__WEBPACK_IMPORTED_MODULE_5__.createBrotliDecompress(brotliOptions));
            delete res.headers['content-encoding'];
          }
        }
      }

      responseStream = streams.length > 1 ? stream__WEBPACK_IMPORTED_MODULE_6__.pipeline(streams, _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].noop) : streams[0];

      const offListeners = stream__WEBPACK_IMPORTED_MODULE_6__.finished(responseStream, () => {
        offListeners();
        onFinished();
      });

      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_16__["default"](res.headers),
        config,
        request: lastRequest
      };

      if (responseType === 'stream') {
        response.data = responseStream;
        (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_13__["default"])(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;

        responseStream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destroy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            responseStream.destroy();
            reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"]('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_RESPONSE, config, lastRequest));
          }
        });

        responseStream.on('aborted', function handlerStreamAborted() {
          if (rejected) {
            return;
          }

          const err = new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
            'stream has been aborted',
            _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });

        responseStream.on('error', function handleStreamError(err) {
          if (req.destroyed) return;
          reject(_core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].from(err, null, config, lastRequest));
        });

        responseStream.on('end', function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== 'arraybuffer') {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === 'utf8') {
                responseData = _utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(_core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].from(err, null, config, response.request, response));
          }
          (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_13__["default"])(resolve, reject, response);
        });
      }

      emitter.once('abort', err => {
        if (!responseStream.destroyed) {
          responseStream.emit('error', err);
          responseStream.destroy();
        }
      });
    });

    emitter.once('abort', err => {
      reject(err);
      req.destroy(err);
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      // @todo remove
      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
      reject(_core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].from(err, null, config, req));
    });

    // set tcp keep alive to prevent drop connection by peer
    req.on('socket', function handleRequestSocket(socket) {
      // default interval of sending ack packet is 1 minute
      socket.setKeepAlive(true, 1000 * 60);
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      const timeout = parseInt(config.timeout, 10);

      if (Number.isNaN(timeout)) {
        reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
          'error trying to parse `config.timeout` to int',
          _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ERR_BAD_OPTION_VALUE,
          config,
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devouring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_24__["default"];
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"](
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ETIMEDOUT : _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_15__["default"].ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }


    // Send the request
    if (_utils_js__WEBPACK_IMPORTED_MODULE_8__["default"].isStream(data)) {
      let ended = false;
      let errored = false;

      data.on('end', () => {
        ended = true;
      });

      data.once('error', err => {
        errored = true;
        req.destroy(err);
      });

      data.on('close', () => {
        if (!ended && !errored) {
          abort(new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_11__["default"]('Request stream has been aborted', config, req));
        }
      });

      data.pipe(req);
    } else {
      req.end(data);
    }
  });
});

const __setProxy = setProxy;


/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_settle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../core/settle.js */ "./node_modules/axios/lib/core/settle.js");
/* harmony import */ var _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defaults/transitional.js */ "./node_modules/axios/lib/defaults/transitional.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../helpers/parseProtocol.js */ "./node_modules/axios/lib/helpers/parseProtocol.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../helpers/progressEventReducer.js */ "./node_modules/axios/lib/helpers/progressEventReducer.js");
/* harmony import */ var _helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/resolveConfig.js */ "./node_modules/axios/lib/helpers/resolveConfig.js");











const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = (0,_helpers_resolveConfig_js__WEBPACK_IMPORTED_MODULE_0__["default"])(config);
    let requestData = _config.data;
    const requestHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      (0,_core_settle_js__WEBPACK_IMPORTED_MODULE_2__["default"])(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Request aborted', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Network Error', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || _defaults_transitional_js__WEBPACK_IMPORTED_MODULE_4__["default"];
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"](
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ETIMEDOUT : _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      _utils_js__WEBPACK_IMPORTED_MODULE_5__["default"].forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_5__["default"].isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = (0,_helpers_progressEventReducer_js__WEBPACK_IMPORTED_MODULE_6__.progressEventReducer)(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_7__["default"](null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = (0,_helpers_parseProtocol_js__WEBPACK_IMPORTED_MODULE_8__["default"])(_config.url);

    if (protocol && _platform_index_js__WEBPACK_IMPORTED_MODULE_9__["default"].protocols.indexOf(protocol) === -1) {
      reject(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"]('Unsupported protocol ' + protocol + ':', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_3__["default"].ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
});


/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/bind.js */ "./node_modules/axios/lib/helpers/bind.js");
/* harmony import */ var _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./core/Axios.js */ "./node_modules/axios/lib/core/Axios.js");
/* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./helpers/formDataToJSON.js */ "./node_modules/axios/lib/helpers/formDataToJSON.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cancel/CancelToken.js */ "./node_modules/axios/lib/cancel/CancelToken.js");
/* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cancel/isCancel.js */ "./node_modules/axios/lib/cancel/isCancel.js");
/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./env/data.js */ "./node_modules/axios/lib/env/data.js");
/* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./helpers/toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _helpers_spread_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./helpers/spread.js */ "./node_modules/axios/lib/helpers/spread.js");
/* harmony import */ var _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./helpers/isAxiosError.js */ "./node_modules/axios/lib/helpers/isAxiosError.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./adapters/adapters.js */ "./node_modules/axios/lib/adapters/adapters.js");
/* harmony import */ var _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./helpers/HttpStatusCode.js */ "./node_modules/axios/lib/helpers/HttpStatusCode.js");




















/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"](defaultConfig);
  const instance = (0,_helpers_bind_js__WEBPACK_IMPORTED_MODULE_1__["default"])(_core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype.request, context);

  // Copy axios.prototype to instance
  _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(instance, _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"].prototype, context, {allOwnKeys: true});

  // Copy context to instance
  _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance((0,_core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__["default"])(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(_defaults_index_js__WEBPACK_IMPORTED_MODULE_4__["default"]);

// Expose Axios class to allow class inheritance
axios.Axios = _core_Axios_js__WEBPACK_IMPORTED_MODULE_0__["default"];

// Expose Cancel & CancelToken
axios.CanceledError = _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_5__["default"];
axios.CancelToken = _cancel_CancelToken_js__WEBPACK_IMPORTED_MODULE_6__["default"];
axios.isCancel = _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_7__["default"];
axios.VERSION = _env_data_js__WEBPACK_IMPORTED_MODULE_8__.VERSION;
axios.toFormData = _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_9__["default"];

// Expose AxiosError class
axios.AxiosError = _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_10__["default"];

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = _helpers_spread_js__WEBPACK_IMPORTED_MODULE_11__["default"];

// Expose isAxiosError
axios.isAxiosError = _helpers_isAxiosError_js__WEBPACK_IMPORTED_MODULE_12__["default"];

// Expose mergeConfig
axios.mergeConfig = _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_3__["default"];

axios.AxiosHeaders = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_13__["default"];

axios.formToJSON = thing => (0,_helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_14__["default"])(_utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_15__["default"].getAdapter;

axios.HttpStatusCode = _helpers_HttpStatusCode_js__WEBPACK_IMPORTED_MODULE_16__["default"];

axios.default = axios;

// this module should only have a default export
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (axios);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");




/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new _CanceledError_js__WEBPACK_IMPORTED_MODULE_0__["default"](message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CancelToken);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/CanceledError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CanceledError.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");





/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].call(this, message == null ? 'canceled' : message, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].inherits(CanceledError, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"], {
  __CANCEL__: true
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CanceledError);


/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isCancel)
/* harmony export */ });


function isCancel(value) {
  return !!(value && value.__CANCEL__);
}


/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../helpers/buildURL.js */ "./node_modules/axios/lib/helpers/buildURL.js");
/* harmony import */ var _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./InterceptorManager.js */ "./node_modules/axios/lib/core/InterceptorManager.js");
/* harmony import */ var _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./dispatchRequest.js */ "./node_modules/axios/lib/core/dispatchRequest.js");
/* harmony import */ var _mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _buildFullPath_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./buildFullPath.js */ "./node_modules/axios/lib/core/buildFullPath.js");
/* harmony import */ var _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/validator.js */ "./node_modules/axios/lib/helpers/validator.js");
/* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");











const validators = _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__["default"](),
      response: new _InterceptorManager_js__WEBPACK_IMPORTED_MODULE_1__["default"]()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};

        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = (0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        }
      } else {
        _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) {
      // do nothing
    } else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }

    _helpers_validator_js__WEBPACK_IMPORTED_MODULE_0__["default"].assertOptions(config, {
      baseUrl: validators.spelling('baseURL'),
      withXsrfToken: validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].merge(
      headers.common,
      headers[config.method]
    );

    headers && _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_4__["default"].concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [_dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__["default"].bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = _dispatchRequest_js__WEBPACK_IMPORTED_MODULE_5__["default"].call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = (0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this.defaults, config);
    const fullPath = (0,_buildFullPath_js__WEBPACK_IMPORTED_MODULE_6__["default"])(config.baseURL, config.url, config.allowAbsoluteUrls);
    return (0,_helpers_buildURL_js__WEBPACK_IMPORTED_MODULE_7__["default"])(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request((0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request((0,_mergeConfig_js__WEBPACK_IMPORTED_MODULE_2__["default"])(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Axios);


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosError.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosError.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);

  _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosError);


/***/ }),

/***/ "./node_modules/axios/lib/core/AxiosHeaders.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/AxiosHeaders.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/parseHeaders.js */ "./node_modules/axios/lib/helpers/parseHeaders.js");





const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(value)) return;

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders((0,_helpers_parseHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"])(header), valueOrRewrite);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(header) && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(entry)) {
          throw TypeError('Object iterator must return a key-value pair');
        }

        obj[key = entry[0]] = (dest = obj[key]) ?
          (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
      }

      setHeaders(obj, valueOrRewrite)
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this, (value, header) => {
      const key = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  getSetCookie() {
    return this.get("set-cookie") || [];
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].freezeMethods(AxiosHeaders);

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosHeaders);


/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (InterceptorManager);


/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildFullPath)
/* harmony export */ });
/* harmony import */ var _helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/isAbsoluteURL.js */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");
/* harmony import */ var _helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/combineURLs.js */ "./node_modules/axios/lib/helpers/combineURLs.js");





/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !(0,_helpers_isAbsoluteURL_js__WEBPACK_IMPORTED_MODULE_0__["default"])(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return (0,_helpers_combineURLs_js__WEBPACK_IMPORTED_MODULE_1__["default"])(baseURL, requestedURL);
  }
  return requestedURL;
}


/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ dispatchRequest)
/* harmony export */ });
/* harmony import */ var _transformData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./transformData.js */ "./node_modules/axios/lib/core/transformData.js");
/* harmony import */ var _cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../cancel/isCancel.js */ "./node_modules/axios/lib/cancel/isCancel.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../adapters/adapters.js */ "./node_modules/axios/lib/adapters/adapters.js");









/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_0__["default"](null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(config.headers);

  // Transform request data
  config.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = _adapters_adapters_js__WEBPACK_IMPORTED_MODULE_3__["default"].getAdapter(config.adapter || _defaults_index_js__WEBPACK_IMPORTED_MODULE_4__["default"].adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(
      config,
      config.transformResponse,
      response
    );

    response.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!(0,_cancel_isCancel_js__WEBPACK_IMPORTED_MODULE_5__["default"])(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = _transformData_js__WEBPACK_IMPORTED_MODULE_2__["default"].call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}


/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeConfig)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");





const headersToObject = (thing) => thing instanceof _AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, prop, caseless) {
    if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isPlainObject(target) && _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isPlainObject(source)) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].merge.call({caseless}, target, source);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isPlainObject(source)) {
      return _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].merge({}, source);
    } else if (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop , caseless) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(b)) {
      return getMergedValue(a, b, prop , caseless);
    } else if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(a)) {
      return getMergedValue(undefined, a, prop , caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
  };

  _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}


/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ settle)
/* harmony export */ });
/* harmony import */ var _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");




/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"](
      'Request failed with status code ' + response.status,
      [_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_BAD_REQUEST, _AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}


/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ transformData)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _defaults_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../defaults/index.js */ "./node_modules/axios/lib/defaults/index.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");






/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || _defaults_index_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  const context = response || config;
  const headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(context.headers);
  let data = context.data;

  _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}


/***/ }),

/***/ "./node_modules/axios/lib/defaults/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/defaults/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _transitional_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transitional.js */ "./node_modules/axios/lib/defaults/transitional.js");
/* harmony import */ var _helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../helpers/toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../helpers/toURLEncodedForm.js */ "./node_modules/axios/lib/helpers/toURLEncodedForm.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../helpers/formDataToJSON.js */ "./node_modules/axios/lib/helpers/formDataToJSON.js");










/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: _transitional_js__WEBPACK_IMPORTED_MODULE_1__["default"],

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(data);

    if (isObjectPayload && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify((0,_helpers_formDataToJSON_js__WEBPACK_IMPORTED_MODULE_2__["default"])(data)) : data;
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBuffer(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBuffer(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isStream(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFile(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBlob(data) ||
      _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isReadableStream(data)
    ) {
      return data;
    }
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBufferView(data)) {
      return data.buffer;
    }
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return (0,_helpers_toURLEncodedForm_js__WEBPACK_IMPORTED_MODULE_3__["default"])(data, this.formSerializer).toString();
      }

      if ((isFileList = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return (0,_helpers_toFormData_js__WEBPACK_IMPORTED_MODULE_4__["default"])(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isResponse(data) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isReadableStream(data)) {
      return data;
    }

    if (data && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__["default"].from(e, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_5__["default"].ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: _platform_index_js__WEBPACK_IMPORTED_MODULE_6__["default"].classes.FormData,
    Blob: _platform_index_js__WEBPACK_IMPORTED_MODULE_6__["default"].classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (defaults);


/***/ }),

/***/ "./node_modules/axios/lib/defaults/transitional.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/defaults/transitional.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
});


/***/ }),

/***/ "./node_modules/axios/lib/env/data.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/env/data.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
const VERSION = "1.9.0";

/***/ }),

/***/ "./node_modules/axios/lib/helpers/AxiosTransformStream.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/AxiosTransformStream.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");





const kInternals = Symbol('internals');

class AxiosTransformStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform{
  constructor(options) {
    options = _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !_utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isUndefined(source[prop]);
    });

    super({
      readableHighWaterMark: options.chunkSize
    });

    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };

    this.on('newListener', event => {
      if (event === 'progress') {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }

  _read(size) {
    const internals = this[kInternals];

    if (internals.onReadCallback) {
      internals.onReadCallback();
    }

    return super._read(size);
  }

  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;

    const readableHighWaterMark = this.readableHighWaterMark;

    const timeWindow = internals.timeWindow;

    const divider = 1000 / timeWindow;
    const bytesThreshold = (maxRate / divider);
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;

    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;

      internals.isCaptured && this.emit('progress', internals.bytesSeen);

      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    }

    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;

      if (maxRate) {
        const now = Date.now();

        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }

        bytesLeft = bytesThreshold - internals.bytes;
      }

      if (maxRate) {
        if (bytesLeft <= 0) {
          // next time window
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }

        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }

      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }

      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };

    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }

      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosTransformStream);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/AxiosURLSearchParams.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");




/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && (0,_toFormData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AxiosURLSearchParams);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/HttpStatusCode.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/HttpStatusCode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HttpStatusCode);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js":
/*!*********************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! stream */ "stream");




class ZlibHeaderTransformStream extends stream__WEBPACK_IMPORTED_MODULE_0__.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }

  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;

      // Add Default Compression headers if no zlib headers are present
      if (chunk[0] !== 120) { // Hex: 78
        const header = Buffer.alloc(2);
        header[0] = 120; // Hex: 78
        header[1] = 156; // Hex: 9C 
        this.push(header, encoding);
      }
    }

    this.__transform(chunk, encoding, callback);
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ZlibHeaderTransformStream);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ bind)
/* harmony export */ });


function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ buildURL)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../helpers/AxiosURLSearchParams.js */ "./node_modules/axios/lib/helpers/AxiosURLSearchParams.js");





/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(options)) {
    options = {
      serialize: options
    };
  } 

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isURLSearchParams(params) ?
      params.toString() :
      new _helpers_AxiosURLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__["default"](params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/callbackify.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/callbackify.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");


const callbackify = (fn, reducer) => {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isAsyncFn(fn) ? function (...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (callbackify);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ combineURLs)
/* harmony export */ });


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/composeSignals.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/composeSignals.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../cancel/CanceledError.js */ "./node_modules/axios/lib/cancel/CanceledError.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"] ? err : new _cancel_CanceledError_js__WEBPACK_IMPORTED_MODULE_1__["default"](err instanceof Error ? err.message : err));
      }
    }

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"](`timeout ${timeout} of ms exceeded`, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_0__["default"].ETIMEDOUT))
    }, timeout)

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    }

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].asap(unsubscribe);

    return signal;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (composeSignals);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(path) && cookie.push('path=' + path);

      _utils_js__WEBPACK_IMPORTED_MODULE_1__["default"].isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  });



/***/ }),

/***/ "./node_modules/axios/lib/helpers/formDataToJSON.js":
/*!**********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/formDataToJSON.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(target) ? target.length : name;

    if (isLast) {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFormData(formData) && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(formData.entries)) {
    const obj = {};

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formDataToJSON);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/formDataToStream.js":
/*!************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/formDataToStream.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var stream__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! stream */ "stream");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _readBlob_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./readBlob.js */ "./node_modules/axios/lib/helpers/readBlob.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");






const BOUNDARY_ALPHABET = _platform_index_js__WEBPACK_IMPORTED_MODULE_2__["default"].ALPHABET.ALPHA_DIGIT + '-_';

const textEncoder = typeof TextEncoder === 'function' ? new TextEncoder() : new util__WEBPACK_IMPORTED_MODULE_0__.TextEncoder();

const CRLF = '\r\n';
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const {escapeName} = this.constructor;
    const isStringValue = _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isString(value);

    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${
      !isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''
    }${CRLF}`;

    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`
    }

    this.headers = textEncoder.encode(headers + CRLF);

    this.contentLength = isStringValue ? value.byteLength : value.size;

    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;

    this.name = name;
    this.value = value;
  }

  async *encode(){
    yield this.headers;

    const {value} = this;

    if(_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isTypedArray(value)) {
      yield value;
    } else {
      yield* (0,_readBlob_js__WEBPACK_IMPORTED_MODULE_4__["default"])(value);
    }

    yield CRLF_BYTES;
  }

  static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        '\r' : '%0D',
        '\n' : '%0A',
        '"' : '%22',
      }[match]));
  }
}

const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = 'form-data-boundary',
    size = 25,
    boundary = tag + '-' + _platform_index_js__WEBPACK_IMPORTED_MODULE_2__["default"].generateString(size, BOUNDARY_ALPHABET)
  } = options || {};

  if(!_utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].isFormData(form)) {
    throw TypeError('FormData instance required');
  }

  if (boundary.length < 1 || boundary.length > 70) {
    throw Error('boundary must be 10-70 characters long')
  }

  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);
  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF);
  let contentLength = footerBytes.byteLength;

  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });

  contentLength += boundaryBytes.byteLength * parts.length;

  contentLength = _utils_js__WEBPACK_IMPORTED_MODULE_3__["default"].toFiniteNumber(contentLength);

  const computedHeaders = {
    'Content-Type': `multipart/form-data; boundary=${boundary}`
  }

  if (Number.isFinite(contentLength)) {
    computedHeaders['Content-Length'] = contentLength;
  }

  headersHandler && headersHandler(computedHeaders);

  return stream__WEBPACK_IMPORTED_MODULE_1__.Readable.from((async function *() {
    for(const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }

    yield footerBytes;
  })());
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (formDataToStream);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/fromDataURI.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/fromDataURI.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ fromDataURI)
/* harmony export */ });
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _parseProtocol_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parseProtocol.js */ "./node_modules/axios/lib/helpers/parseProtocol.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");






const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

/**
 * Parse data uri to a Buffer or Blob
 *
 * @param {String} uri
 * @param {?Boolean} asBlob
 * @param {?Object} options
 * @param {?Function} options.Blob
 *
 * @returns {Buffer|Blob}
 */
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || _platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].classes.Blob;
  const protocol = (0,_parseProtocol_js__WEBPACK_IMPORTED_MODULE_1__["default"])(uri);

  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }

  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;

    const match = DATA_URL_PATTERN.exec(uri);

    if (!match) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Invalid URL', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_INVALID_URL);
    }

    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');

    if (asBlob) {
      if (!_Blob) {
        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Blob is not supported', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NOT_SUPPORT);
      }

      return new _Blob([buffer], {type: mime});
    }

    return buffer;
  }

  throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Unsupported protocol ' + protocol, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"].ERR_NOT_SUPPORT);
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAbsoluteURL)
/* harmony export */ });


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isAxiosError)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(payload) && (payload.isAxiosError === true);
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
  url = new URL(url, _platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin);

  return (
    origin.protocol === url.protocol &&
    origin.host === url.host &&
    (isMSIE || origin.port === url.port)
  );
})(
  new URL(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].origin),
  _platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].navigator && /(msie|trident)/i.test(_platform_index_js__WEBPACK_IMPORTED_MODULE_0__["default"].navigator.userAgent)
) : () => true);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./../utils.js */ "./node_modules/axios/lib/utils.js");




// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
});


/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseProtocol.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseProtocol.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseProtocol)
/* harmony export */ });


function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/progressEventReducer.js":
/*!****************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/progressEventReducer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   asyncDecorator: () => (/* binding */ asyncDecorator),
/* harmony export */   progressEventDecorator: () => (/* binding */ progressEventDecorator),
/* harmony export */   progressEventReducer: () => (/* binding */ progressEventReducer)
/* harmony export */ });
/* harmony import */ var _speedometer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./speedometer.js */ "./node_modules/axios/lib/helpers/speedometer.js");
/* harmony import */ var _throttle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./throttle.js */ "./node_modules/axios/lib/helpers/throttle.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");




const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = (0,_speedometer_js__WEBPACK_IMPORTED_MODULE_0__["default"])(50, 250);

  return (0,_throttle_js__WEBPACK_IMPORTED_MODULE_1__["default"])(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
}

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
}

const asyncDecorator = (fn) => (...args) => _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].asap(() => fn(...args));


/***/ }),

/***/ "./node_modules/axios/lib/helpers/readBlob.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/readBlob.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const {asyncIterator} = Symbol;

const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream()
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer()
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (readBlob);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/resolveConfig.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/resolveConfig.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./isURLSameOrigin.js */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");
/* harmony import */ var _cookies_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cookies.js */ "./node_modules/axios/lib/helpers/cookies.js");
/* harmony import */ var _core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../core/buildFullPath.js */ "./node_modules/axios/lib/core/buildFullPath.js");
/* harmony import */ var _core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../core/mergeConfig.js */ "./node_modules/axios/lib/core/mergeConfig.js");
/* harmony import */ var _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosHeaders.js */ "./node_modules/axios/lib/core/AxiosHeaders.js");
/* harmony import */ var _buildURL_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./buildURL.js */ "./node_modules/axios/lib/helpers/buildURL.js");









/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((config) => {
  const newConfig = (0,_core_mergeConfig_js__WEBPACK_IMPORTED_MODULE_0__["default"])({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = _core_AxiosHeaders_js__WEBPACK_IMPORTED_MODULE_1__["default"].from(headers);

  newConfig.url = (0,_buildURL_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_core_buildFullPath_js__WEBPACK_IMPORTED_MODULE_3__["default"])(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (_utils_js__WEBPACK_IMPORTED_MODULE_4__["default"].isFormData(data)) {
    if (_platform_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].hasStandardBrowserEnv || _platform_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (_platform_index_js__WEBPACK_IMPORTED_MODULE_5__["default"].hasStandardBrowserEnv) {
    withXSRFToken && _utils_js__WEBPACK_IMPORTED_MODULE_4__["default"].isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && (0,_isURLSameOrigin_js__WEBPACK_IMPORTED_MODULE_6__["default"])(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && _cookies_js__WEBPACK_IMPORTED_MODULE_7__["default"].read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
});



/***/ }),

/***/ "./node_modules/axios/lib/helpers/speedometer.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/speedometer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });


/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (speedometer);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ spread)
/* harmony export */ });


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/throttle.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/throttle.js ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  }

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs)
        }, threshold - passed);
      }
    }
  }

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (throttle);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toFormData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toFormData.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");
/* harmony import */ var _platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/node/classes/FormData.js */ "./node_modules/axios/lib/platform/node/classes/FormData.js");




// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored


/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isPlainObject(thing) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(arr) && !arr.some(isVisitable);
}

const predicates = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"], {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (_platform_node_classes_FormData_js__WEBPACK_IMPORTED_MODULE_1__["default"] || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isSpecCompliantForm(formData);

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isBlob(value)) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_2__["default"]('Blob is not supported. Use a Buffer instead.');
    }

    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArrayBuffer(value) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isArray(value) && isFlatArray(value)) ||
        ((_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isFileList(value) || _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].endsWith(key, '[]')) && (arr = _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].forEach(value, function each(el, key) {
      const result = !(_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isUndefined(el) || el === null) && visitor.call(
        formData, el, _utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!_utils_js__WEBPACK_IMPORTED_MODULE_0__["default"].isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (toFormData);


/***/ }),

/***/ "./node_modules/axios/lib/helpers/toURLEncodedForm.js":
/*!************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/toURLEncodedForm.js ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toURLEncodedForm)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils.js */ "./node_modules/axios/lib/utils.js");
/* harmony import */ var _toFormData_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toFormData.js */ "./node_modules/axios/lib/helpers/toFormData.js");
/* harmony import */ var _platform_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../platform/index.js */ "./node_modules/axios/lib/platform/index.js");






function toURLEncodedForm(data, options) {
  return (0,_toFormData_js__WEBPACK_IMPORTED_MODULE_0__["default"])(data, new _platform_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (_platform_index_js__WEBPACK_IMPORTED_MODULE_1__["default"].isNode && _utils_js__WEBPACK_IMPORTED_MODULE_2__["default"].isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/trackStream.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/trackStream.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   readBytes: () => (/* binding */ readBytes),
/* harmony export */   streamChunk: () => (/* binding */ streamChunk),
/* harmony export */   trackStream: () => (/* binding */ trackStream)
/* harmony export */ });

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
}

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
}

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
}

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  }

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
}


/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _env_data_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../env/data.js */ "./node_modules/axios/lib/env/data.js");
/* harmony import */ var _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../core/AxiosError.js */ "./node_modules/axios/lib/core/AxiosError.js");





const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + _env_data_js__WEBPACK_IMPORTED_MODULE_0__.VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"](
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  }
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('options must be an object', _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('option ' + opt + ' must be ' + result, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"]('Unknown option ' + opt, _core_AxiosError_js__WEBPACK_IMPORTED_MODULE_1__["default"].ERR_BAD_OPTION);
    }
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  assertOptions,
  validators
});


/***/ }),

/***/ "./node_modules/axios/lib/platform/common/utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/platform/common/utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   hasBrowserEnv: () => (/* binding */ hasBrowserEnv),
/* harmony export */   hasStandardBrowserEnv: () => (/* binding */ hasStandardBrowserEnv),
/* harmony export */   hasStandardBrowserWebWorkerEnv: () => (/* binding */ hasStandardBrowserWebWorkerEnv),
/* harmony export */   navigator: () => (/* binding */ _navigator),
/* harmony export */   origin: () => (/* binding */ origin)
/* harmony export */ });
const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';




/***/ }),

/***/ "./node_modules/axios/lib/platform/index.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/platform/index.js ***!
  \**************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node/index.js */ "./node_modules/axios/lib/platform/node/index.js");
/* harmony import */ var _common_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./common/utils.js */ "./node_modules/axios/lib/platform/common/utils.js");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  ..._common_utils_js__WEBPACK_IMPORTED_MODULE_0__,
  ..._node_index_js__WEBPACK_IMPORTED_MODULE_1__["default"]
});


/***/ }),

/***/ "./node_modules/axios/lib/platform/node/classes/FormData.js":
/*!******************************************************************!*\
  !*** ./node_modules/axios/lib/platform/node/classes/FormData.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var form_data__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! form-data */ "./node_modules/form-data/lib/form_data.js");


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (form_data__WEBPACK_IMPORTED_MODULE_0__);


/***/ }),

/***/ "./node_modules/axios/lib/platform/node/classes/URLSearchParams.js":
/*!*************************************************************************!*\
  !*** ./node_modules/axios/lib/platform/node/classes/URLSearchParams.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! url */ "url");



/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (url__WEBPACK_IMPORTED_MODULE_0__.URLSearchParams);


/***/ }),

/***/ "./node_modules/axios/lib/platform/node/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/platform/node/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! crypto */ "crypto");
/* harmony import */ var _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/URLSearchParams.js */ "./node_modules/axios/lib/platform/node/classes/URLSearchParams.js");
/* harmony import */ var _classes_FormData_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./classes/FormData.js */ "./node_modules/axios/lib/platform/node/classes/FormData.js");




const ALPHA = 'abcdefghijklmnopqrstuvwxyz'

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  const randomValues = new Uint32Array(size);
  crypto__WEBPACK_IMPORTED_MODULE_0__.randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }

  return str;
}


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  isNode: true,
  classes: {
    URLSearchParams: _classes_URLSearchParams_js__WEBPACK_IMPORTED_MODULE_1__["default"],
    FormData: _classes_FormData_js__WEBPACK_IMPORTED_MODULE_2__["default"],
    Blob: typeof Blob !== 'undefined' && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: [ 'http', 'https', 'file', 'data' ]
});


/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/bind.js */ "./node_modules/axios/lib/helpers/bind.js");




// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;
const {iterator, toStringTag} = Symbol;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
}

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = (0,_helpers_bind_js__WEBPACK_IMPORTED_MODULE_0__["default"])(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];

  const _iterator = generator.call(obj);

  let result;

  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  }

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
}

const noop = () => {}

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
}

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  }

  return visit(obj, 0);
}

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************


const isIterable = (thing) => thing != null && isFunction(thing[iterator]);


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
});


/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/actualApply.js":
/*!*************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/actualApply.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

var $apply = __webpack_require__(/*! ./functionApply */ "./node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__(/*! ./functionCall */ "./node_modules/call-bind-apply-helpers/functionCall.js");
var $reflectApply = __webpack_require__(/*! ./reflectApply */ "./node_modules/call-bind-apply-helpers/reflectApply.js");

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/functionApply.js":
/*!***************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/functionApply.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/functionCall.js":
/*!**************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/functionCall.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/index.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");

var $call = __webpack_require__(/*! ./functionCall */ "./node_modules/call-bind-apply-helpers/functionCall.js");
var $actualApply = __webpack_require__(/*! ./actualApply */ "./node_modules/call-bind-apply-helpers/actualApply.js");

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),

/***/ "./node_modules/call-bind-apply-helpers/reflectApply.js":
/*!**************************************************************!*\
  !*** ./node_modules/call-bind-apply-helpers/reflectApply.js ***!
  \**************************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),

/***/ "./node_modules/combined-stream/lib/combined_stream.js":
/*!*************************************************************!*\
  !*** ./node_modules/combined-stream/lib/combined_stream.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(/*! util */ "util");
var Stream = (__webpack_require__(/*! stream */ "stream").Stream);
var DelayedStream = __webpack_require__(/*! delayed-stream */ "./node_modules/delayed-stream/lib/delayed_stream.js");

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	// eslint-disable-next-line no-return-assign
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ "./node_modules/debug/src/common.js":
/*!******************************************!*\
  !*** ./node_modules/debug/src/common.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/ms/index.js");
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		const split = (typeof namespaces === 'string' ? namespaces : '')
			.trim()
			.replace(' ', ',')
			.split(',')
			.filter(Boolean);

		for (const ns of split) {
			if (ns[0] === '-') {
				createDebug.skips.push(ns.slice(1));
			} else {
				createDebug.names.push(ns);
			}
		}
	}

	/**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */
	function matchesTemplate(search, template) {
		let searchIndex = 0;
		let templateIndex = 0;
		let starIndex = -1;
		let matchIndex = 0;

		while (searchIndex < search.length) {
			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
				// Match character or proceed with wildcard
				if (template[templateIndex] === '*') {
					starIndex = templateIndex;
					matchIndex = searchIndex;
					templateIndex++; // Skip the '*'
				} else {
					searchIndex++;
					templateIndex++;
				}
			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
				// Backtrack to the last '*' and try to match more characters
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else {
				return false; // No match
			}
		}

		// Handle trailing '*' in template
		while (templateIndex < template.length && template[templateIndex] === '*') {
			templateIndex++;
		}

		return templateIndex === template.length;
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names,
			...createDebug.skips.map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		for (const skip of createDebug.skips) {
			if (matchesTemplate(name, skip)) {
				return false;
			}
		}

		for (const ns of createDebug.names) {
			if (matchesTemplate(name, ns)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ "./node_modules/debug/src/index.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(/*! ./browser.js */ "./node_modules/debug/src/browser.js");
} else {
	module.exports = __webpack_require__(/*! ./node.js */ "./node_modules/debug/src/node.js");
}


/***/ }),

/***/ "./node_modules/debug/src/node.js":
/*!****************************************!*\
  !*** ./node_modules/debug/src/node.js ***!
  \****************************************/
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(/*! tty */ "tty");
const util = __webpack_require__(/*! util */ "util");

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(/*! supports-color */ "./node_modules/supports-color/index.js");

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/debug/src/common.js")(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ "./node_modules/delayed-stream/lib/delayed_stream.js":
/*!***********************************************************!*\
  !*** ./node_modules/delayed-stream/lib/delayed_stream.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(/*! stream */ "stream").Stream);
var util = __webpack_require__(/*! util */ "util");

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),

/***/ "./node_modules/dunder-proto/get.js":
/*!******************************************!*\
  !*** ./node_modules/dunder-proto/get.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(/*! call-bind-apply-helpers */ "./node_modules/call-bind-apply-helpers/index.js");
var gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),

/***/ "./node_modules/es-define-property/index.js":
/*!**************************************************!*\
  !*** ./node_modules/es-define-property/index.js ***!
  \**************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ "./node_modules/es-errors/eval.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/eval.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ "./node_modules/es-errors/index.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/index.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ "./node_modules/es-errors/range.js":
/*!*****************************************!*\
  !*** ./node_modules/es-errors/range.js ***!
  \*****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ "./node_modules/es-errors/ref.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/ref.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ "./node_modules/es-errors/syntax.js":
/*!******************************************!*\
  !*** ./node_modules/es-errors/syntax.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ "./node_modules/es-errors/type.js":
/*!****************************************!*\
  !*** ./node_modules/es-errors/type.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ "./node_modules/es-errors/uri.js":
/*!***************************************!*\
  !*** ./node_modules/es-errors/uri.js ***!
  \***************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ "./node_modules/es-object-atoms/index.js":
/*!***********************************************!*\
  !*** ./node_modules/es-object-atoms/index.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),

/***/ "./node_modules/es-set-tostringtag/index.js":
/*!**************************************************!*\
  !*** ./node_modules/es-set-tostringtag/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(/*! get-intrinsic */ "./node_modules/get-intrinsic/index.js");

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasToStringTag = __webpack_require__(/*! has-tostringtag/shams */ "./node_modules/has-tostringtag/shams.js")();
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/hasown/index.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");

var toStringTag = hasToStringTag ? Symbol.toStringTag : null;

/** @type {import('.')} */
module.exports = function setToStringTag(object, value) {
	var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
	var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
	if (
		(typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean')
		|| (typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean')
	) {
		throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
	}
	if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
		if ($defineProperty) {
			$defineProperty(object, toStringTag, {
				configurable: !nonConfigurable,
				enumerable: false,
				value: value,
				writable: false
			});
		} else {
			object[toStringTag] = value; // eslint-disable-line no-param-reassign
		}
	}
};


/***/ }),

/***/ "./node_modules/follow-redirects/debug.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/debug.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var debug;

module.exports = function () {
  if (!debug) {
    try {
      /* eslint global-require: off */
      debug = __webpack_require__(/*! debug */ "./node_modules/debug/src/index.js")("follow-redirects");
    }
    catch (error) { /* */ }
    if (typeof debug !== "function") {
      debug = function () { /* */ };
    }
  }
  debug.apply(null, arguments);
};


/***/ }),

/***/ "./node_modules/follow-redirects/index.js":
/*!************************************************!*\
  !*** ./node_modules/follow-redirects/index.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var url = __webpack_require__(/*! url */ "url");
var URL = url.URL;
var http = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var Writable = (__webpack_require__(/*! stream */ "stream").Writable);
var assert = __webpack_require__(/*! assert */ "assert");
var debug = __webpack_require__(/*! ./debug */ "./node_modules/follow-redirects/debug.js");

// Preventive platform detection
// istanbul ignore next
(function detectUnsupportedEnvironment() {
  var looksLikeNode = typeof process !== "undefined";
  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var looksLikeV8 = isFunction(Error.captureStackTrace);
  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
    console.warn("The follow-redirects package should be excluded from browser builds.");
  }
}());

// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
  assert(new URL(""));
}
catch (error) {
  useNativeURL = error.code === "ERR_INVALID_URL";
}

// URL fields to preserve in copy operations
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash",
];

// Create handlers that pass events from native requests
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = Object.create(null);
events.forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    try {
      self._processResponse(response);
    }
    catch (cause) {
      self.emit("error", cause instanceof RedirectionError ?
        cause : new RedirectionError({ cause: cause }));
    }
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

RedirectableRequest.prototype.abort = function () {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};

RedirectableRequest.prototype.destroy = function (error) {
  destroyRequest(this._currentRequest, error);
  destroy.call(this, error);
  return this;
};

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  }
  else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  var self = this;

  // Destroys the socket on timeout
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }

  // Sets up a timer to trigger a timeout event
  function startTimer(socket) {
    if (self._timeout) {
      clearTimeout(self._timeout);
    }
    self._timeout = setTimeout(function () {
      self.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }

  // Stops a timeout from triggering
  function clearTimer() {
    // Clear the timeout
    if (self._timeout) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }

    // Clean up all attached listeners
    self.removeListener("abort", clearTimer);
    self.removeListener("error", clearTimer);
    self.removeListener("response", clearTimer);
    self.removeListener("close", clearTimer);
    if (callback) {
      self.removeListener("timeout", callback);
    }
    if (!self.socket) {
      self._currentRequest.removeListener("socket", startTimer);
    }
  }

  // Attach callback if passed
  if (callback) {
    this.on("timeout", callback);
  }

  // Start the timer if or when the socket is opened
  if (this.socket) {
    startTimer(this.socket);
  }
  else {
    this._currentRequest.once("socket", startTimer);
  }

  // Clean up on events
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);

  return this;
};

// Proxy all other public ClientRequest methods
[
  "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request and set up its event handlers
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  request._redirectable = this;
  for (var event of events) {
    request.on(event, eventHandlers[event]);
  }

  // RFC72305.3.1: When making a request directly to an origin server, []
  // a client MUST send only the absolute path [] as the request-target.
  this._currentUrl = /^\//.test(this._options.path) ?
    url.format(this._options) :
    // When making a request to a proxy, []
    // a client MUST send the target URI in absolute-form [].
    this._options.path;

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      // istanbul ignore else
      if (request === self._currentRequest) {
        // Report any write errors
        // istanbul ignore if
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          // istanbul ignore else
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC72316.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.

  // If the response is not a redirect; return it as-is
  var location = response.headers.location;
  if (!location || this._options.followRedirects === false ||
      statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
    return;
  }

  // The response is a redirect, so abort the current request
  destroyRequest(this._currentRequest);
  // Discard the remainder of the response to avoid waiting for data
  response.destroy();

  // RFC72316.4: A client SHOULD detect and intervene
  // in cyclical redirections (i.e., "infinite" redirection loops).
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }

  // Store the request headers if applicable
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host"),
    }, this._options.headers);
  }

  // RFC72316.4: Automatic redirection needs to done with
  // care for methods not known to be safe, []
  // RFC72316.4.23: For historical reasons, a user agent MAY change
  // the request method from POST to GET for the subsequent request.
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
      // RFC72316.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource []
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) []
      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    // Drop a possible entity and headers related to it
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }

  // Drop the Host header, as the redirect might lead to a different host
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

  // If the redirect is relative, carry over the host of the last request
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
    url.format(Object.assign(currentUrlParts, { host: currentHost }));

  // Create the redirected request
  var redirectUrl = resolveUrl(location, currentUrl);
  debug("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);

  // Drop confidential headers when redirecting to a less secure protocol
  // or to a different domain that is not a superdomain
  if (redirectUrl.protocol !== currentUrlParts.protocol &&
     redirectUrl.protocol !== "https:" ||
     redirectUrl.host !== currentHost &&
     !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }

  // Evaluate the beforeRedirect callback
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode: statusCode,
    };
    var requestDetails = {
      url: currentUrl,
      method: method,
      headers: requestHeaders,
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }

  // Perform the redirected request
  this._performRequest();
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    function request(input, options, callback) {
      // Parse parameters, ensuring that input is an object
      if (isURL(input)) {
        input = spreadUrlObject(input);
      }
      else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      }
      else {
        callback = options;
        options = validateUrl(input);
        input = { protocol: protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }

    // Executes a GET request, following redirects
    function get(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }

    // Expose the properties on the wrapped protocol
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true },
    });
  });
  return exports;
}

function noop() { /* empty */ }

function parseUrl(input) {
  var parsed;
  // istanbul ignore else
  if (useNativeURL) {
    parsed = new URL(input);
  }
  else {
    // Ensure the URL is valid and absolute
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}

function resolveUrl(relative, base) {
  // istanbul ignore next
  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}

function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}

function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }

  // Fix IPv6 hostname
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  // Ensure port is a number
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  // Concatenate path
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

  return spread;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return (lastValue === null || typeof lastValue === "undefined") ?
    undefined : String(lastValue).trim();
}

function createErrorType(code, message, baseClass) {
  // Create constructor
  function CustomError(properties) {
    // istanbul ignore else
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    }
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }

  // Attach constructor and set default properties
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false,
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false,
    },
  });
  return CustomError;
}

function destroyRequest(request, error) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop);
  request.destroy(error);
}

function isSubdomain(subdomain, domain) {
  assert(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}

function isString(value) {
  return typeof value === "string" || value instanceof String;
}

function isFunction(value) {
  return typeof value === "function";
}

function isBuffer(value) {
  return typeof value === "object" && ("length" in value);
}

function isURL(value) {
  return URL && value instanceof URL;
}

// Exports
module.exports = wrap({ http: http, https: https });
module.exports.wrap = wrap;


/***/ }),

/***/ "./node_modules/form-data/lib/form_data.js":
/*!*************************************************!*\
  !*** ./node_modules/form-data/lib/form_data.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CombinedStream = __webpack_require__(/*! combined-stream */ "./node_modules/combined-stream/lib/combined_stream.js");
var util = __webpack_require__(/*! util */ "util");
var path = __webpack_require__(/*! path */ "path");
var http = __webpack_require__(/*! http */ "http");
var https = __webpack_require__(/*! https */ "https");
var parseUrl = (__webpack_require__(/*! url */ "url").parse);
var fs = __webpack_require__(/*! fs */ "fs");
var Stream = (__webpack_require__(/*! stream */ "stream").Stream);
var mime = __webpack_require__(/*! mime-types */ "./node_modules/mime-types/index.js");
var asynckit = __webpack_require__(/*! asynckit */ "./node_modules/asynckit/index.js");
var setToStringTag = __webpack_require__(/*! es-set-tostringtag */ "./node_modules/es-set-tostringtag/index.js");
var populate = __webpack_require__(/*! ./populate.js */ "./node_modules/form-data/lib/populate.js");

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (Array.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response or not a stream
  if (!value || ( !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) && !(value instanceof Stream))) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {
  if (Object.prototype.hasOwnProperty.call(value, 'fd')) {

    // take read range into a account
    // `end` = Infinity > read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (Object.prototype.hasOwnProperty.call(value, 'httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, prop)) {
      header = headers[prop];

      // skip nullish headers.
      if (header == null) {
        continue;
      }

      // convert all headers to arrays.
      if (!Array.isArray(header)) {
        header = [header];
      }

      // add non-empty headers.
      if (header.length) {
        contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
      }
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc(0);
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err && err !== 'Unknown stream') {
      this._error(err);
      return;
    }

    // add content length
    if (length) {
      request.setHeader('Content-Length', length);
    }

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};
setToStringTag(FormData, 'FormData');


/***/ }),

/***/ "./node_modules/form-data/lib/populate.js":
/*!************************************************!*\
  !*** ./node_modules/form-data/lib/populate.js ***!
  \************************************************/
/***/ ((module) => {

// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};


/***/ }),

/***/ "./node_modules/function-bind/implementation.js":
/*!******************************************************!*\
  !*** ./node_modules/function-bind/implementation.js ***!
  \******************************************************/
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ "./node_modules/function-bind/index.js":
/*!*********************************************!*\
  !*** ./node_modules/function-bind/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(/*! ./implementation */ "./node_modules/function-bind/implementation.js");

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ "./node_modules/get-intrinsic/index.js":
/*!*********************************************!*\
  !*** ./node_modules/get-intrinsic/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/es-object-atoms/index.js");

var $Error = __webpack_require__(/*! es-errors */ "./node_modules/es-errors/index.js");
var $EvalError = __webpack_require__(/*! es-errors/eval */ "./node_modules/es-errors/eval.js");
var $RangeError = __webpack_require__(/*! es-errors/range */ "./node_modules/es-errors/range.js");
var $ReferenceError = __webpack_require__(/*! es-errors/ref */ "./node_modules/es-errors/ref.js");
var $SyntaxError = __webpack_require__(/*! es-errors/syntax */ "./node_modules/es-errors/syntax.js");
var $TypeError = __webpack_require__(/*! es-errors/type */ "./node_modules/es-errors/type.js");
var $URIError = __webpack_require__(/*! es-errors/uri */ "./node_modules/es-errors/uri.js");

var abs = __webpack_require__(/*! math-intrinsics/abs */ "./node_modules/math-intrinsics/abs.js");
var floor = __webpack_require__(/*! math-intrinsics/floor */ "./node_modules/math-intrinsics/floor.js");
var max = __webpack_require__(/*! math-intrinsics/max */ "./node_modules/math-intrinsics/max.js");
var min = __webpack_require__(/*! math-intrinsics/min */ "./node_modules/math-intrinsics/min.js");
var pow = __webpack_require__(/*! math-intrinsics/pow */ "./node_modules/math-intrinsics/pow.js");
var round = __webpack_require__(/*! math-intrinsics/round */ "./node_modules/math-intrinsics/round.js");
var sign = __webpack_require__(/*! math-intrinsics/sign */ "./node_modules/math-intrinsics/sign.js");

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(/*! gopd */ "./node_modules/gopd/index.js");
var $defineProperty = __webpack_require__(/*! es-define-property */ "./node_modules/es-define-property/index.js");

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(/*! has-symbols */ "./node_modules/has-symbols/index.js")();

var getProto = __webpack_require__(/*! get-proto */ "./node_modules/get-proto/index.js");
var $ObjectGPO = __webpack_require__(/*! get-proto/Object.getPrototypeOf */ "./node_modules/get-proto/Object.getPrototypeOf.js");
var $ReflectGPO = __webpack_require__(/*! get-proto/Reflect.getPrototypeOf */ "./node_modules/get-proto/Reflect.getPrototypeOf.js");

var $apply = __webpack_require__(/*! call-bind-apply-helpers/functionApply */ "./node_modules/call-bind-apply-helpers/functionApply.js");
var $call = __webpack_require__(/*! call-bind-apply-helpers/functionCall */ "./node_modules/call-bind-apply-helpers/functionCall.js");

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");
var hasOwn = __webpack_require__(/*! hasown */ "./node_modules/hasown/index.js");
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ "./node_modules/get-proto/Object.getPrototypeOf.js":
/*!*********************************************************!*\
  !*** ./node_modules/get-proto/Object.getPrototypeOf.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(/*! es-object-atoms */ "./node_modules/es-object-atoms/index.js");

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),

/***/ "./node_modules/get-proto/Reflect.getPrototypeOf.js":
/*!**********************************************************!*\
  !*** ./node_modules/get-proto/Reflect.getPrototypeOf.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),

/***/ "./node_modules/get-proto/index.js":
/*!*****************************************!*\
  !*** ./node_modules/get-proto/index.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(/*! ./Reflect.getPrototypeOf */ "./node_modules/get-proto/Reflect.getPrototypeOf.js");
var originalGetProto = __webpack_require__(/*! ./Object.getPrototypeOf */ "./node_modules/get-proto/Object.getPrototypeOf.js");

var getDunderProto = __webpack_require__(/*! dunder-proto/get */ "./node_modules/dunder-proto/get.js");

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),

/***/ "./node_modules/gopd/gOPD.js":
/*!***********************************!*\
  !*** ./node_modules/gopd/gOPD.js ***!
  \***********************************/
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),

/***/ "./node_modules/gopd/index.js":
/*!************************************!*\
  !*** ./node_modules/gopd/index.js ***!
  \************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(/*! ./gOPD */ "./node_modules/gopd/gOPD.js");

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ "./node_modules/has-flag/index.js":
/*!****************************************!*\
  !*** ./node_modules/has-flag/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ "./node_modules/has-symbols/index.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(/*! ./shams */ "./node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ "./node_modules/has-symbols/shams.js":
/*!*******************************************!*\
  !*** ./node_modules/has-symbols/shams.js ***!
  \*******************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ "./node_modules/has-tostringtag/shams.js":
/*!***********************************************!*\
  !*** ./node_modules/has-tostringtag/shams.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(/*! has-symbols/shams */ "./node_modules/has-symbols/shams.js");

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ "./node_modules/hasown/index.js":
/*!**************************************!*\
  !*** ./node_modules/hasown/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(/*! function-bind */ "./node_modules/function-bind/index.js");

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),

/***/ "./node_modules/math-intrinsics/abs.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/abs.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),

/***/ "./node_modules/math-intrinsics/floor.js":
/*!***********************************************!*\
  !*** ./node_modules/math-intrinsics/floor.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),

/***/ "./node_modules/math-intrinsics/isNaN.js":
/*!***********************************************!*\
  !*** ./node_modules/math-intrinsics/isNaN.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),

/***/ "./node_modules/math-intrinsics/max.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/max.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),

/***/ "./node_modules/math-intrinsics/min.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/min.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),

/***/ "./node_modules/math-intrinsics/pow.js":
/*!*********************************************!*\
  !*** ./node_modules/math-intrinsics/pow.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),

/***/ "./node_modules/math-intrinsics/round.js":
/*!***********************************************!*\
  !*** ./node_modules/math-intrinsics/round.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),

/***/ "./node_modules/math-intrinsics/sign.js":
/*!**********************************************!*\
  !*** ./node_modules/math-intrinsics/sign.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(/*! ./isNaN */ "./node_modules/math-intrinsics/isNaN.js");

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),

/***/ "./node_modules/mime-db/db.json":
/*!**************************************!*\
  !*** ./node_modules/mime-db/db.json ***!
  \**************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),

/***/ "./node_modules/mime-db/index.js":
/*!***************************************!*\
  !*** ./node_modules/mime-db/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(/*! ./db.json */ "./node_modules/mime-db/db.json")


/***/ }),

/***/ "./node_modules/mime-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/mime-types/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(/*! mime-db */ "./node_modules/mime-db/index.js")
var extname = (__webpack_require__(/*! path */ "path").extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ "./node_modules/proxy-from-env/index.js":
/*!**********************************************!*\
  !*** ./node_modules/proxy-from-env/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var parseUrl = (__webpack_require__(/*! url */ "url").parse);

var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443,
};

var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length &&
    this.indexOf(s, this.length - s.length) !== -1;
};

/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */
function getProxyForUrl(url) {
  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
    return '';  // Don't proxy URLs without a valid scheme or host.
  }

  proto = proto.split(':', 1)[0];
  // Stripping ports in this way instead of using parsedUrl.hostname to make
  // sure that the brackets around IPv6 addresses are kept.
  hostname = hostname.replace(/:\d*$/, '');
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return '';  // Don't proxy URLs that match NO_PROXY.
  }

  var proxy =
    getEnv('npm_config_' + proto + '_proxy') ||
    getEnv(proto + '_proxy') ||
    getEnv('npm_config_proxy') ||
    getEnv('all_proxy');
  if (proxy && proxy.indexOf('://') === -1) {
    // Missing scheme in proxy, default to the requested URL's scheme.
    proxy = proto + '://' + proxy;
  }
  return proxy;
}

/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */
function shouldProxy(hostname, port) {
  var NO_PROXY =
    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
  if (!NO_PROXY) {
    return true;  // Always proxy if NO_PROXY is not set.
  }
  if (NO_PROXY === '*') {
    return false;  // Never proxy if wildcard is set.
  }

  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;  // Skip zero-length hosts.
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;  // Skip if ports don't match.
    }

    if (!/^[.*]/.test(parsedProxyHostname)) {
      // No wildcards, so stop proxying if there is an exact match.
      return hostname !== parsedProxyHostname;
    }

    if (parsedProxyHostname.charAt(0) === '*') {
      // Remove leading wildcard.
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    // Stop proxying if the hostname ends with the no_proxy host.
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}

/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}

exports.getProxyForUrl = getProxyForUrl;


/***/ }),

/***/ "./node_modules/supports-color/index.js":
/*!**********************************************!*\
  !*** ./node_modules/supports-color/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(/*! os */ "os");
const tty = __webpack_require__(/*! tty */ "tty");
const hasFlag = __webpack_require__(/*! has-flag */ "./node_modules/has-flag/index.js");

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const FastBuffer = Buffer[Symbol.species];

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) {
    return new FastBuffer(target.buffer, target.byteOffset, offset);
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

module.exports = {
  concat,
  mask: _mask,
  toArrayBuffer,
  toBuffer,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = __webpack_require__(/*! bufferutil */ "bufferutil");

    module.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    module.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";


const BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
const hasBlob = typeof Blob !== 'undefined';

if (hasBlob) BINARY_TYPES.push('blob');

module.exports = {
  BINARY_TYPES,
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  hasBlob,
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute] &&
        listener[kListener] === handler &&
        !listener[kForOnEventAttribute]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}


/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const zlib = __webpack_require__(/*! zlib */ "zlib");

const bufferUtil = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const Limiter = __webpack_require__(/*! ./limiter */ "./node_modules/ws/lib/limiter.js");
const { kStatusCode } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const FastBuffer = Buffer[Symbol.species];
const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) {
        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
      }

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);

  //
  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the
  // fact that in Node.js versions prior to 13.10.0, the callback for
  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing
  // `zlib.reset()` ensures that either the callback is invoked or an error is
  // emitted.
  //
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;

  if (this[kError]) {
    this[kCallback](this[kError]);
    return;
  }

  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Writable } = __webpack_require__(/*! stream */ "stream");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

const FastBuffer = Buffer[Symbol.species];

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._allowSynchronousEvents =
      options.allowSynchronousEvents !== undefined
        ? options.allowSynchronousEvents
        : true;
    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n,
        buf.length - n
      );

      return new FastBuffer(buf.buffer, buf.byteOffset, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n,
          buf.length - n
        );
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);

    if (!this._errored) cb();
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      const error = this.createError(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );

      cb(error);
      return;
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      const error = this.createError(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );

      cb(error);
      return;
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (!this._fragmented) {
        const error = this.createError(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        const error = this.createError(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );

        cb(error);
        return;
      }

      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (
        this._payloadLength > 0x7d ||
        (this._opcode === 0x08 && this._payloadLength === 1)
      ) {
        const error = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );

        cb(error);
        return;
      }
    } else {
      const error = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );

      cb(error);
      return;
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );

        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );

      cb(error);
      return;
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );

      cb(error);
      return;
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }

  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );

        cb(error);
        return;
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) {
      this.controlMessage(data, cb);
      return;
    }

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    this.dataMessage(cb);
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            'Max payload size exceeded',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
          );

          cb(error);
          return;
        }

        this._fragments.push(buf);
      }

      this.dataMessage(cb);
      if (this._state === GET_INFO) this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }

    const messageLength = this._messageLength;
    const fragments = this._fragments;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];

    if (this._opcode === 2) {
      let data;

      if (this._binaryType === 'nodebuffer') {
        data = concat(fragments, messageLength);
      } else if (this._binaryType === 'arraybuffer') {
        data = toArrayBuffer(concat(fragments, messageLength));
      } else if (this._binaryType === 'blob') {
        data = new Blob(fragments);
      } else {
        data = fragments;
      }

      if (this._allowSynchronousEvents) {
        this.emit('message', data, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', data, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat(fragments, messageLength);

      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error = this.createError(
          Error,
          'invalid UTF-8 sequence',
          true,
          1007,
          'WS_ERR_INVALID_UTF8'
        );

        cb(error);
        return;
      }

      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit('message', buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 0x08) {
      if (data.length === 0) {
        this._loop = false;
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          const error = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );

          cb(error);
          return;
        }

        const buf = new FastBuffer(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );

          cb(error);
          return;
        }

        this._loop = false;
        this.emit('conclude', code, buf);
        this.end();
      }

      this._state = GET_INFO;
      return;
    }

    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      setImmediate(() => {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }

  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;

    const err = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );

    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  }
}

module.exports = Receiver;


/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */



const { Duplex } = __webpack_require__(/*! stream */ "stream");
const { randomFillSync } = __webpack_require__(/*! crypto */ "crypto");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");
const { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);
const RANDOM_POOL_SIZE = 8 * 1024;
let randomPool;
let randomPoolPointer = RANDOM_POOL_SIZE;

const DEFAULT = 0;
const DEFLATING = 1;
const GET_BLOB_DATA = 2;

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._queue = [];
    this._state = DEFAULT;
    this.onerror = NOOP;
    this[kWebSocket] = undefined;
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        if (randomPoolPointer === RANDOM_POOL_SIZE) {
          /* istanbul ignore else  */
          if (randomPool === undefined) {
            //
            // This is lazily initialized because server-sent frames must not
            // be masked so it may never be used.
            //
            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
          }

          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
          randomPoolPointer = 0;
        }

        mask[0] = randomPool[randomPoolPointer++];
        mask[1] = randomPool[randomPoolPointer++];
        mask[2] = randomPool[randomPoolPointer++];
        mask[3] = randomPool[randomPoolPointer++];
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    const opts = {
      [kByteLength]: byteLength,
      fin: options.fin,
      generateMask: this._generateMask,
      mask: options.mask,
      maskBuffer: this._maskBuffer,
      opcode,
      readOnly,
      rsv1
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
      } else {
        this.getBlobData(data, this._compress, opts, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
    } else {
      this.dispatch(data, this._compress, opts, cb);
    }
  }

  /**
   * Gets the contents of a blob as binary data.
   *
   * @param {Blob} blob The blob
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     the data
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  getBlobData(blob, compress, options, cb) {
    this._bufferedBytes += options[kByteLength];
    this._state = GET_BLOB_DATA;

    blob
      .arrayBuffer()
      .then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error(
            'The socket was closed while the blob was being read'
          );

          //
          // `callCallbacks` is called in the next tick to ensure that errors
          // that might be thrown in the callbacks behave like errors thrown
          // outside the promise chain.
          //
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }

        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);

        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      })
      .catch((err) => {
        //
        // `onError` is called in the next tick for the same reason that
        // `callCallbacks` above is.
        //
        process.nextTick(onError, this, err, cb);
      });
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._state = DEFLATING;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        callCallbacks(this, err, cb);
        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._state = DEFAULT;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (this._state === DEFAULT && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {(Buffer | String)[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;

/**
 * Calls queued callbacks with an error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error to call the callbacks with
 * @param {Function} [cb] The first callback
 * @private
 */
function callCallbacks(sender, err, cb) {
  if (typeof cb === 'function') cb(err);

  for (let i = 0; i < sender._queue.length; i++) {
    const params = sender._queue[i];
    const callback = params[params.length - 1];

    if (typeof callback === 'function') callback(err);
  }
}

/**
 * Handles a `Sender` error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error
 * @param {Function} [cb] The first pending callback
 * @private
 */
function onError(sender, err, cb) {
  callCallbacks(sender, err, cb);
  sender.onerror(err);
}


/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^WebSocket$" }] */


const WebSocket = __webpack_require__(/*! ./websocket */ "./node_modules/ws/lib/websocket.js");
const { Duplex } = __webpack_require__(/*! stream */ "stream");

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ "./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isUtf8 } = __webpack_require__(/*! buffer */ "buffer");

const { hasBlob } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

/**
 * Determines whether a value is a `Blob`.
 *
 * @param {*} value The value to be tested
 * @return {Boolean} `true` if `value` is a `Blob`, else `false`
 * @private
 */
function isBlob(value) {
  return (
    hasBlob &&
    typeof value === 'object' &&
    typeof value.arrayBuffer === 'function' &&
    typeof value.type === 'string' &&
    typeof value.stream === 'function' &&
    (value[Symbol.toStringTag] === 'Blob' ||
      value[Symbol.toStringTag] === 'File')
  );
}

module.exports = {
  isBlob,
  isValidStatusCode,
  isValidUTF8: _isValidUTF8,
  tokenChars
};

if (isUtf8) {
  module.exports.isValidUTF8 = function (buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ "utf-8-validate");

    module.exports.isValidUTF8 = function (buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(/*! events */ "events");
const http = __webpack_require__(/*! http */ "http");
const { Duplex } = __webpack_require__(/*! stream */ "stream");
const { createHash } = __webpack_require__(/*! crypto */ "crypto");

const extension = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const subprotocol = __webpack_require__(/*! ./subprotocol */ "./node_modules/ws/lib/subprotocol.js");
const WebSocket = __webpack_require__(/*! ./websocket */ "./node_modules/ws/lib/websocket.js");
const { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      allowSynchronousEvents: true,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const upgrade = req.headers.upgrade;
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (key === undefined || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null, undefined, this.options);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message);
  }
}


/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(/*! events */ "events");
const https = __webpack_require__(/*! https */ "https");
const http = __webpack_require__(/*! http */ "http");
const net = __webpack_require__(/*! net */ "net");
const tls = __webpack_require__(/*! tls */ "tls");
const { randomBytes, createHash } = __webpack_require__(/*! crypto */ "crypto");
const { Duplex, Readable } = __webpack_require__(/*! stream */ "stream");
const { URL } = __webpack_require__(/*! url */ "url");

const PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");
const Receiver = __webpack_require__(/*! ./receiver */ "./node_modules/ws/lib/receiver.js");
const Sender = __webpack_require__(/*! ./sender */ "./node_modules/ws/lib/sender.js");
const { isBlob } = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js");

const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js");
const {
  EventTarget: { addEventListener, removeEventListener }
} = __webpack_require__(/*! ./event-target */ "./node_modules/ws/lib/event-target.js");
const { format, parse } = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");
const { toBuffer } = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._errorEmitted = false;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._isServer = true;
    }
  }

  /**
   * For historical reasons, the custom "nodebuffer" type is used by the default
   * instead of "blob".
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    const sender = new Sender(socket, this._extensions, options.generateMask);

    this._receiver = receiver;
    this._sender = sender;
    this._socket = socket;

    receiver[kWebSocket] = this;
    sender[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    sender.onerror = senderOnError;

    //
    // These methods may not be available if `socket` is just a `Duplex`.
    //
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    setCloseTimer(this);
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  websocket._autoPong = opts.autoPong;

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }

  if (parsedUrl.protocol === 'http:') {
    parsedUrl.protocol = 'ws:';
  } else if (parsedUrl.protocol === 'https:') {
    parsedUrl.protocol = 'wss:';
  }

  websocket._url = parsedUrl.href;

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", ' +
      '"http:", "https:", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection =
    opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
          ? false
          : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const upgrade = res.headers.upgrade;

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      abortHandshake(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  if (opts.finishRequest) {
    opts.finishRequest(req, websocket);
  } else {
    req.end();
  }
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  //
  // The following assignment is practically useless and is done only for
  // consistency.
  //
  websocket._errorEmitted = true;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = isBlob(data) ? data.size : toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The `Sender` error event handler.
 *
 * @param {Error} The error
 * @private
 */
function senderOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket.readyState === WebSocket.CLOSED) return;
  if (websocket.readyState === WebSocket.OPEN) {
    websocket._readyState = WebSocket.CLOSING;
    setCloseTimer(websocket);
  }

  //
  // `socket.end()` is used instead of `socket.destroy()` to allow the other
  // peer to finish sending queued data. There is no need to set a timer here
  // because `CLOSING` means that it is already set or not needed.
  //
  this._socket.end();

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * Set a timer to destroy the underlying raw socket of a WebSocket.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @private
 */
function setCloseTimer(websocket) {
  websocket._closeTimer = setTimeout(
    websocket._socket.destroy.bind(websocket._socket),
    closeTimeout
  );
}

/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ "./node_modules/ws/wrapper.mjs":
/*!*************************************!*\
  !*** ./node_modules/ws/wrapper.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),
/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),
/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),
/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),
/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ "./node_modules/ws/lib/stream.js");
/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ "./node_modules/ws/lib/receiver.js");
/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ "./node_modules/ws/lib/sender.js");
/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ "./node_modules/ws/lib/websocket.js");
/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ "./node_modules/ws/lib/websocket-server.js");







/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);


/***/ }),

/***/ "./src/core/commands/commandManager.ts":
/*!*********************************************!*\
  !*** ./src/core/commands/commandManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CommandManager: () => (/* binding */ CommandManager)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _slashCommandManager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./slashCommandManager */ "./src/core/commands/slashCommandManager.ts");


/**
 * Manages all commands for the extension
 */
class CommandManager {
    _context;
    _chatViewProvider;
    _llmService;
    _memoryService;
    _modelManager;
    _rulesService;
    _vaultService;
    _jiraService;
    _slashCommandManager;
    constructor(_context, _chatViewProvider, _llmService, _memoryService, _modelManager, _rulesService, // Rules 
    _vaultService, // Vault 
    _jiraService // Jira 
    ) {
        this._context = _context;
        this._chatViewProvider = _chatViewProvider;
        this._llmService = _llmService;
        this._memoryService = _memoryService;
        this._modelManager = _modelManager;
        this._rulesService = _rulesService;
        this._vaultService = _vaultService;
        this._jiraService = _jiraService;
        // Initialize slash command manager with LLMService for smart help and services
        const services = {
            llmService: this._llmService,
            memoryService: this._memoryService,
            modelManager: this._modelManager,
            rulesService: this._rulesService,
            vaultService: this._vaultService,
            jiraService: this._jiraService
        };
        this._slashCommandManager = new _slashCommandManager__WEBPACK_IMPORTED_MODULE_1__.SlashCommandManager(this._context, this._llmService, services);
    }
    /**
     * Gets the slash command manager instance
     */
    get slashCommandManager() {
        return this._slashCommandManager;
    }
    /**
     * Registers all commands for the extension
     */
    registerCommands() {
        // Chat commands
        this._registerCommand('ape.openChat', this._openChat.bind(this));
        this._registerCommand('ape.clearChat', this._clearChat.bind(this));
        this._registerCommand('ape.sendMessage', this._sendMessage.bind(this));
        // Model commands
        this._registerCommand('ape.selectModel', this.selectModel.bind(this));
        this._registerCommand('ape.switchModel', this.switchModel.bind(this));
        // Code commands
        this._registerCommand('ape.analyzeCode', this._analyzeCode.bind(this));
        // Slash commands
        this._registerCommand('ape.executeSlashCommand', this._executeSlashCommand.bind(this));
    }
    /**
     * Registers a single command
     */
    _registerCommand(commandId, handler) {
        const disposable = vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand(commandId, handler);
        this._context.subscriptions.push(disposable);
    }
    /**
     * Opens the chat view
     */
    async _openChat() {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.view.extension.ape-sidebar');
    }
    /**
     * Clears the chat history
     */
    async _clearChat() {
        await this._chatViewProvider.clearChat();
    }
    /**
     * Sends a message to the chat
     */
    async _sendMessage(content) {
        if (!content) {
            // If no content provided, prompt the user
            const message = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: 'Enter message to send to APE',
                placeHolder: 'Type your message here...'
            });
            if (message) {
                await this._chatViewProvider.sendMessage(message);
            }
        }
        else {
            await this._chatViewProvider.sendMessage(content);
        }
    }
    /**
     * Opens model selection dialog
     */
    async selectModel() {
        const models = this._modelManager.getAvailableModels();
        const activeModel = this._modelManager.getActiveModel();
        // Create friendly display names for models
        const selectedModel = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(models.map(model => ({
            label: this._modelManager.getModelDisplayName(model),
            description: model === activeModel ? '(active)' : '',
            detail: this._modelManager.getModelDescription(model),
            model: model // Keep original model ID
        })), {
            placeHolder: 'Select a model to use',
            title: 'APE Model Selection'
        });
        if (selectedModel) {
            await this.switchModel(selectedModel.model);
        }
    }
    /**
     * Switches to a specific model
     */
    async switchModel(modelName) {
        try {
            // Use the ModelManager to switch models
            const success = await this._modelManager.setActiveModel(modelName);
            if (success) {
                // Update the UI to reflect the model change
                this._chatViewProvider.updateModelIndicator();
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`${this._modelManager.getModelDisplayName(modelName)}  `);
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`  :        `);
            }
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`  : ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Gets user-friendly display name for a model - Deprecated, use ModelManager.getModelDisplayName instead
     * @param modelId The model ID
     * @returns User-friendly display name
     * @deprecated This method is kept for backward compatibility. Use ModelManager.getModelDisplayName instead
     */
    _getModelDisplayName(modelId) {
        return this._modelManager.getModelDisplayName(modelId);
    }
    /**
     * Executes a slash command
     */
    async _executeSlashCommand(commandText) {
        const executed = await this._slashCommandManager.executeCommand(commandText);
        if (!executed) {
            // If not a slash command, treat as regular message
            await this._sendMessage(commandText);
        }
    }
    /**
     * Gets description for a model - Deprecated, use ModelManager.getModelDescription instead
     * @param model The model ID
     * @returns Model description
     * @deprecated This method is kept for backward compatibility. Use ModelManager.getModelDescription instead
     */
    _getModelDescription(model) {
        return this._modelManager.getModelDescription(model);
    }
    /**
     * Analyzes selected code with APE
     */
    async _analyzeCode() {
        const editor = vscode__WEBPACK_IMPORTED_MODULE_0__.window.activeTextEditor;
        if (!editor) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('No active editor');
            return;
        }
        const selection = editor.selection;
        if (selection.isEmpty) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('Please select code to analyze');
            return;
        }
        const selectedText = editor.document.getText(selection);
        const filePath = editor.document.fileName;
        const fileExtension = filePath.split('.').pop() || '';
        const fileName = filePath.split('/').pop() || '';
        // Create analysis prompt with improved message for APE analysis
        const prompt = `Please analyze this ${fileExtension} code from ${fileName}:\n\n\`\`\`${fileExtension}\n${selectedText}\n\`\`\`\n\nProvide a detailed APE analysis including:\n1. Code functionality\n2. Potential issues or improvements\n3. Best practices recommendations`;
        // Show notification that analysis is starting
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('Analyzing selected code with APE...');
        // Open chat and send the prompt
        await this._openChat();
        await this._sendMessage(prompt);
    }
}


/***/ }),

/***/ "./src/core/commands/defaultCommands.ts":
/*!**********************************************!*\
  !*** ./src/core/commands/defaultCommands.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDefaultCommands: () => (/* binding */ createDefaultCommands)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _git_commands__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../git/commands */ "./src/core/git/commands.ts");
/* harmony import */ var _vaultCommands__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vaultCommands */ "./src/core/commands/vaultCommands.ts");
/* harmony import */ var _rulesCommands__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rulesCommands */ "./src/core/commands/rulesCommands.ts");
/* harmony import */ var _jiraCommands__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./jiraCommands */ "./src/core/commands/jiraCommands.ts");
/**
 *    
 */






/**
 *     
 */
function createDefaultCommands(services) {
    const commands = [];
    // VAULT   (VAULT   )
    if (services?.vaultService) {
        const vaultCommands = (0,_vaultCommands__WEBPACK_IMPORTED_MODULE_3__.createVaultCommands)(services.vaultService);
        commands.push(...vaultCommands);
    }
    // Rules   (Rules   )
    if (services?.rulesService) {
        const rulesCommands = (0,_rulesCommands__WEBPACK_IMPORTED_MODULE_4__.createRulesCommands)(services.rulesService);
        commands.push(...rulesCommands);
    }
    // Jira   (Jira   )
    if (services?.jiraService) {
        const jiraCommands = (0,_jiraCommands__WEBPACK_IMPORTED_MODULE_5__.createJiraCommands)(services.jiraService);
        commands.push(...jiraCommands);
    }
    // Todo   
    //  
    commands.push({
        name: 'help',
        aliases: ['?', 'commands', '', '', '', '', 'search', ''],
        description: '     ',
        examples: ['/help', '/help git', '/help search  ', '/', '/   '],
        category: 'general',
        priority: 1,
        execute: async (context) => {
            //    SlashCommandManager 
            const firstArg = context.args[0]?.toLowerCase();
            if (firstArg === 'search' || firstArg === '' || firstArg === 'find' || firstArg === '') {
                //  :   
                const searchQuery = context.args.slice(1).join(' ');
                if (searchQuery) {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp', `search ${searchQuery}`);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(' ');
                }
            }
            else if (firstArg === 'faq' || firstArg === '') {
                // FAQ 
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp', 'faq');
            }
            else if (firstArg === 'guide' || firstArg === 'guides' || firstArg === '' || firstArg === '') {
                //   
                if (context.args.length > 1) {
                    //   
                    const guideId = context.args[1];
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp', `guide ${guideId}`);
                }
                else {
                    //  
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp', 'guides');
                }
            }
            else {
                //    /  
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp', firstArg);
            }
        },
        provideCompletions: (partialArgs) => {
            const parts = partialArgs.split(' ');
            //    
            if (parts.length <= 1) {
                const options = ['general', 'git', 'code', 'utility', 'advanced', 'search', 'find', 'faq', 'guide', 'guides', '', '', '', ''];
                return options.filter(option => option.toLowerCase().startsWith(parts[0].toLowerCase()));
            }
            //     ( )
            if ((parts[0] === 'guide' || parts[0] === 'guides' || parts[0] === '') && parts.length === 2) {
                const guideOptions = ['auto-commit', 'git-integration', 'slash-commands', 'plugins'];
                return guideOptions.filter(option => option.toLowerCase().startsWith(parts[1].toLowerCase()));
            }
            return [];
        }
    });
    //   
    commands.push({
        name: 'clear',
        aliases: ['cls', 'clean', '', '', ''],
        description: '  ',
        category: 'general',
        priority: 2,
        execute: async () => {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.clearChat');
        }
    });
    //  
    commands.push({
        name: 'model',
        aliases: ['use', '', '', ''],
        description: ' LLM  ',
        examples: ['/model list', '/model use LLAMA4-MAVERICK', '/ '],
        category: 'advanced',
        priority: 10,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand || subCommand === 'list' || subCommand === '') {
                //   
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.selectModel');
            }
            else if (subCommand === 'use' || subCommand === 'switch' || subCommand === '' || subCommand === '') {
                //   
                const modelName = context.args[1];
                if (modelName) {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.switchModel', modelName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('  ');
                }
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ');
            }
        },
        provideCompletions: (partialArgs) => {
            //    
            const models = [
                'openai/gpt-4.1-mini',
                'anthropic/claude-3-haiku-20240307',
                'anthropic/claude-3-sonnet-20240229',
                'perplexity/sonar-small-online',
                'mistralai/mistral-large-latest',
                'google/gemma-7b-it'
            ];
            const subCommands = ['list', 'use', 'switch', '', '', ''];
            const parts = partialArgs.split(' ');
            //    
            if (parts.length <= 1) {
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(partialArgs.toLowerCase()));
            }
            //     ( )
            if (parts[0] === 'use' || parts[0] === 'switch' || parts[0] === '' || parts[0] === '') {
                const modelQuery = parts[1] || '';
                return models.filter((model) => model.toLowerCase().startsWith(modelQuery.toLowerCase()));
            }
            return [];
        }
    });
    //  
    commands.push({
        name: 'analyze',
        aliases: ['code', '', '', ''],
        description: '   APE ',
        examples: ['/analyze', '/code', '/'],
        category: 'code',
        priority: 5,
        execute: async () => {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.analyzeCode');
        }
    });
    // Git  
    const gitCommands = (0,_git_commands__WEBPACK_IMPORTED_MODULE_2__.createGitCommands)();
    commands.push(...gitCommands);
    // 
    commands.push({
        name: 'settings',
        aliases: ['config', 'preferences', '', '', ''],
        description: 'APE  ',
        category: 'utility',
        priority: 15,
        execute: async () => {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', 'ape');
        }
    });
    //  
    commands.push({
        name: 'open',
        aliases: ['file', '', '', ''],
        description: ' ',
        examples: ['/open package.json', '/open src/index.ts', '/ package.json'],
        category: 'utility',
        priority: 20,
        execute: async (context) => {
            const filePath = context.args.join(' ');
            if (!filePath) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('   ');
                return;
            }
            try {
                const document = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument(filePath);
                await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showTextDocument(document);
            }
            catch {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`   : ${filePath}`);
            }
        }
    });
    //   
    commands.push({
        name: 'chat',
        aliases: ['', '', 'c'],
        description: '   ',
        examples: ['/chat save', '/chat list', '/chat show ID', '/ ', '/ '],
        category: 'utility',
        priority: 25,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand || subCommand === 'help' || subCommand === '') {
                //  
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: `##    

     :

- \`/chat save\`:    .
- \`/chat list\`:     .
- \`/chat show [ID]\`:    .

: \`/chat save\`, \`/chat list\`, \`/chat show chat_12345\``
                });
                return;
            }
            if (subCommand === 'save' || subCommand === '') {
                //    
                try {
                    //   
                    const memoryService = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape-team.ape-extension')?.exports?.memoryService;
                    if (!memoryService) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ');
                        return;
                    }
                    // VAULT  
                    const vaultService = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape-team.ape-extension')?.exports?.vaultService;
                    if (!vaultService) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('VAULT    ');
                        return;
                    }
                    // LLM  
                    const llmService = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape-team.ape-extension')?.exports?.llmService;
                    //    
                    const messagesResult = await memoryService.getMessages();
                    if (!messagesResult.success || !messagesResult.data) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ');
                        return;
                    }
                    const messages = messagesResult.data;
                    //     
                    let markdown = '';
                    //   
                    const now = new Date();
                    const dateStr = now.toISOString().split('T')[0];
                    const timeStr = now.toTimeString().split(' ')[0];
                    const timestamp = now.toISOString();
                    markdown += `## ${dateStr} ${timeStr}\n\n`;
                    //    (   )
                    for (let i = messages.length - 1; i >= 0; i--) {
                        const message = messages[i];
                        //     
                        if (message.role === 'system' && message.content.includes('welcome-container')) {
                            continue;
                        }
                        //    
                        if (message.role === 'user' || message.role === 'assistant') {
                            const role = message.role === 'user' ? '' : 'Claude';
                            // HTML   ( )
                            const contentStr = message.content.replace(/<[^>]*>/g, '');
                            markdown += `**${role}**: ${contentStr}\n\n`;
                            //   (  )
                            if (i > 0) {
                                markdown += '---\n\n';
                            }
                        }
                    }
                    //     (LLM  )
                    let chatTitle = `  ${dateStr} ${timeStr}`;
                    if (llmService && messages.length > 0) {
                        try {
                            //     
                            const firstUserMessage = messages.find((m) => m.role === 'user');
                            if (firstUserMessage) {
                                // LLM  
                                const summaryPrompt = `   20    : "${firstUserMessage.content.replace(/<[^>]*>/g, '').slice(0, 200)}${firstUserMessage.content.length > 200 ? '...' : ''}"`;
                                const summaryResult = await llmService.getSingleCompletion(summaryPrompt);
                                if (summaryResult && summaryResult.trim()) {
                                    //     
                                    chatTitle = summaryResult.trim().replace(/^["']|["']$/g, '');
                                }
                            }
                        }
                        catch (error) {
                            console.error('   :', error);
                            //       ( )
                        }
                    }
                    // UUID 
                    const uuid = `chat_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
                    //    
                    const workspaceFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0];
                    if (!workspaceFolder) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ');
                        return;
                    }
                    // Vault       
                    const chatHistoryDir = path__WEBPACK_IMPORTED_MODULE_1__.join(workspaceFolder.uri.fsPath, 'vault', 'chat-history');
                    const chatHistoryUri = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.file(chatHistoryDir);
                    try {
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(chatHistoryUri);
                    }
                    catch {
                        //   
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.createDirectory(chatHistoryUri);
                    }
                    //     (UUID )
                    const chatHistoryPath = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(chatHistoryUri, `${uuid}.md`);
                    //   
                    const metadataPath = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(chatHistoryUri, `${uuid}.meta.json`);
                    //  
                    const metadata = {
                        id: uuid,
                        title: chatTitle,
                        createdAt: timestamp,
                        updatedAt: timestamp,
                        messageCount: messages.length
                    };
                    //   ( )
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.writeFile(chatHistoryPath, Buffer.from(markdown, 'utf8'));
                    //   ()
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.writeFile(metadataPath, Buffer.from(JSON.stringify(metadata, null, 2), 'utf8'));
                    //   
                    try {
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.refreshTreeView');
                    }
                    catch (error) {
                        console.error('   :', error);
                    }
                    //   
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: `  **${chatTitle}** .  ${messages.length}  .

     \`/chat list\`    .`
                    });
                }
                catch (error) {
                    console.error('   :', error);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`     : ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            else if (subCommand === 'list' || subCommand === 'ls' || subCommand === '') {
                //      
                try {
                    //    
                    const workspaceFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0];
                    if (!workspaceFolder) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ');
                        return;
                    }
                    //    
                    const chatHistoryDir = path__WEBPACK_IMPORTED_MODULE_1__.join(workspaceFolder.uri.fsPath, 'vault', 'chat-history');
                    const chatHistoryUri = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.file(chatHistoryDir);
                    //   
                    try {
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(chatHistoryUri);
                    }
                    catch {
                        //   
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                            role: 'assistant',
                            content: '   . `/chat save`      .'
                        });
                        return;
                    }
                    //      
                    await showChatList(chatHistoryUri);
                }
                catch (error) {
                    console.error('    :', error);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`      : ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            else if (subCommand === 'show' || subCommand === 'view' || subCommand === '') {
                try {
                    //    
                    const workspaceFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0];
                    if (!workspaceFolder) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ');
                        return;
                    }
                    //    
                    const chatHistoryDir = path__WEBPACK_IMPORTED_MODULE_1__.join(workspaceFolder.uri.fsPath, 'vault', 'chat-history');
                    const chatHistoryUri = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.file(chatHistoryDir);
                    //   
                    try {
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(chatHistoryUri);
                    }
                    catch {
                        //   
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                            role: 'assistant',
                            content: '   . `/chat save`      .'
                        });
                        return;
                    }
                    //  ID  
                    const chatId = context.args[1];
                    if (chatId) {
                        //    
                        await showSpecificChat(chatId, chatHistoryUri);
                    }
                    else {
                        //      
                        await showChatList(chatHistoryUri);
                    }
                }
                catch (error) {
                    console.error('   :', error);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`     : ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`    : ${subCommand}.   : save, list, show`);
            }
        },
        provideCompletions: (partialArgs) => {
            const subCommands = ['save', 'list', 'show', 'help', '', '', '', ''];
            const parts = partialArgs.split(' ');
            //     ()
            if (parts.length <= 1) {
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(parts[0]?.toLowerCase() || ''));
            }
            return [];
        }
    });
    /**
     *    
     * @param chatId  ID
     * @param chatHistoryUri    URI
     */
    async function showSpecificChat(chatId, chatHistoryUri) {
        //   
        const metadataPath = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(chatHistoryUri, `${chatId}.meta.json`);
        //    
        const chatHistoryPath = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(chatHistoryUri, `${chatId}.md`);
        //   
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(metadataPath);
            await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(chatHistoryPath);
        }
        catch {
            //   
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `ID '${chatId}'     .`
            });
            return;
        }
        //  
        const metadataData = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(metadataPath);
        const metadata = JSON.parse(Buffer.from(metadataData).toString('utf8'));
        //   
        const fileData = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(chatHistoryPath);
        const content = Buffer.from(fileData).toString('utf8');
        //   
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## ${metadata.title}\n\n\`\`\`markdown\n${content}\n\`\`\``
        });
    }
    /**
     *     
     * @param chatHistoryUri    URI
     */
    async function showChatList(chatHistoryUri) {
        //    
        const files = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readDirectory(chatHistoryUri);
        const metaFiles = files.filter(([name]) => name.endsWith('.meta.json'));
        if (metaFiles.length === 0) {
            //     
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: '   . `/save-chat`      .'
            });
            return;
        }
        //  
        const chatList = [];
        for (const [fileName] of metaFiles) {
            const metadataPath = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(chatHistoryUri, fileName);
            const metadataData = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(metadataPath);
            const metadata = JSON.parse(Buffer.from(metadataData).toString('utf8'));
            //  
            const createdDate = new Date(metadata.createdAt);
            const dateStr = createdDate.toLocaleDateString();
            const timeStr = createdDate.toLocaleTimeString();
            chatList.push({
                id: metadata.id,
                title: metadata.title,
                createdAt: `${dateStr} ${timeStr}`,
                messageCount: metadata.messageCount
            });
        }
        //  
        chatList.sort((a, b) => b.id.localeCompare(a.id));
        //   
        let output = '##    \n\n';
        output += '|  |   |   |  |\n';
        output += '|------|-------|----------|--------|\n';
        for (const chat of chatList) {
            output += `| ${chat.title} | ${chat.createdAt} | ${chat.messageCount} | \`/show ${chat.id}\` |\n`;
        }
        output += '\n      .';
        //   
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: output
        });
    }
    return commands;
}


/***/ }),

/***/ "./src/core/commands/helpRenderer.ts":
/*!*******************************************!*\
  !*** ./src/core/commands/helpRenderer.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateCommandDetailHtml: () => (/* binding */ generateCommandDetailHtml),
/* harmony export */   generateFaqHtml: () => (/* binding */ generateFaqHtml),
/* harmony export */   generateGuideHtml: () => (/* binding */ generateGuideHtml),
/* harmony export */   generateGuidesListHtml: () => (/* binding */ generateGuidesListHtml),
/* harmony export */   generateHelpHtml: () => (/* binding */ generateHelpHtml),
/* harmony export */   generateSmartHelpHtml: () => (/* binding */ generateSmartHelpHtml),
/* harmony export */   generateToolsHelpHtml: () => (/* binding */ generateToolsHelpHtml),
/* harmony export */   getCommandData: () => (/* binding */ getCommandData),
/* harmony export */   getCommandsByCategory: () => (/* binding */ getCommandsByCategory),
/* harmony export */   loadHelpData: () => (/* binding */ loadHelpData),
/* harmony export */   setExtensionContext: () => (/* binding */ setExtensionContext)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _data_helpSystemPrompt__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/helpSystemPrompt */ "./src/data/helpSystemPrompt.ts");
/**
 *  
 *
 *      HTML .
 */



// vscode   
//         
// let _extensionContext: vscode.ExtensionContext | undefined;
/**
 *   
 */
function setExtensionContext() {
    //       
    //  
}
/**
 *    
 * @param category  ID
 * @returns  
 */
/*          
function getCategorySimpleIcon(category: string): string {
  switch (category) {
    case 'general':
      return '';  //   -  
    case 'git':
      return '';  // Git  - 
    case 'code':
      return '';  //   - 
    case 'utility':
      return '';  //  -  
    case 'advanced':
      return '';  //   -  
    default:
      return '';  //  -  
  }
}
*/
/**
 * Codicon CSS   URI 
 */
function getCodiconCssUri() {
    const extension = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape-team.ape-extension');
    if (!extension) {
        throw new Error('APE    ');
    }
    return vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(extension.extensionUri, 'media', 'codicon', 'codicon.css');
}

//   
let helpDataCache = null;
/**
 *   
 * @returns   
 */
async function loadHelpData() {
    if (helpDataCache) {
        return helpDataCache;
    }
    try {
        const extensionPath = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape-team.ape-extension')?.extensionPath;
        if (!extensionPath) {
            throw new Error('     .');
        }
        const helpFilePath = path__WEBPACK_IMPORTED_MODULE_1__.join(extensionPath, 'src', 'data', 'help.json');
        const helpDataStr = fs__WEBPACK_IMPORTED_MODULE_2__.readFileSync(helpFilePath, 'utf8');
        helpDataCache = JSON.parse(helpDataStr);
        return helpDataCache;
    }
    catch (error) {
        console.error('   :', error);
        throw new Error('    .');
    }
}
/**
 *    
 * @param commandName  
 * @returns   
 */
async function getCommandData(commandName) {
    try {
        const helpData = await loadHelpData();
        //   
        for (const category of helpData.categories) {
            //    
            for (const command of category.commands) {
                //     
                if (command.name === commandName || (command.aliases && command.aliases.includes(commandName))) {
                    return {
                        ...command,
                        category: category.id,
                        categoryName: category.name
                    };
                }
            }
        }
        return null;
    }
    catch (error) {
        console.error('   :', error);
        return null;
    }
}
/**
 *    
 * @param categoryId  ID ()
 * @returns   
 */
async function getCommandsByCategory(categoryId) {
    try {
        const helpData = await loadHelpData();
        //    
        if (categoryId) {
            const category = helpData.categories.find((c) => c.id === categoryId);
            return category ? [category] : [];
        }
        //   
        return helpData.categories;
    }
    catch (error) {
        console.error('    :', error);
        return [];
    }
}
/**
 *  HTML  (  )
 * @param categoryId  ID ()
 * @returns HTML 
 */
async function generateHelpHtml(categoryId) {
    try {
        const categories = await getCommandsByCategory(categoryId);
        let content = `
      <h1>APE </h1>
      <p>   .        .</p>
      
      <div class="quick-actions">
        <h2>  </h2>
        <div class="quick-buttons">
          <button class="quick-button git" onclick="sendCommandToVSCode('git status')">
            <span class="codicon codicon-git-commit"></span>Git 
          </button>
          <button class="quick-button code" onclick="sendCommandToVSCode('analyze')">
            <span class="codicon codicon-code"></span> 
          </button>
          <button class="quick-button utility" onclick="sendCommandToVSCode('clear')">
            <span class="codicon codicon-clear-all"></span> 
          </button>
          <button class="quick-button model" onclick="sendCommandToVSCode('model list')">
            <span class="codicon codicon-settings-gear"></span> 
          </button>
        </div>
      </div>
    `;
        //   
        for (const category of categories) {
            content += `
        <div class="help-category">
          <h2>${category.name}</h2>
          <p>${category.description || ''}</p>
          <div class="command-grid">
      `;
            //   
            for (const command of category.commands) {
                //   
                const iconName = getCategoryIcon(category.id);
                //   
                content += `
          <div class="command-card" onclick="sendCommandToVSCode('${command.name}')">
            <div class="command-name">
              <span class="command-icon codicon codicon-${iconName}"></span>
              <span class="command-text">/${command.name}</span>
            </div>
            <div class="command-description">${command.description}</div>
            ${command.examples && command.examples.length > 0 ?
                    `<div class="command-examples">: ${command.examples[0]}</div>` : ''}
            ${command.aliases && command.aliases.length > 0 ?
                    `<div class="command-aliases">: ${command.aliases.map((a) => `/${a}`).join(', ')}</div>` : ''}
          </div>
        `;
            }
            content += `
          </div>
        </div>
      `;
        }
        //  HTML 
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error(' HTML  :', error);
        return getHelpPageHtml(`
      <h1>  </h1>
      <p>     : ${error}</p>
    `);
    }
}
/**
 *    HTML 
 * @param commandName  
 * @returns HTML 
 */
async function generateCommandDetailHtml(commandName) {
    try {
        const commandData = await getCommandData(commandName);
        if (!commandData) {
            return getHelpPageHtml(`
        <h1>   </h1>
        <p>'${commandName}'    .</p>
        <p><a href="#" onclick="sendCommandToVSCode('help')">  </a></p>
      `);
        }
        let content = `
      <div class="command-detail">
        <h1>/${commandData.name}</h1>
        <div class="command-description">${commandData.description}</div>
        
        <h2> </h2>
        <p>${commandData.longDescription || commandData.description}</p>
        
        <h2></h2>
        <div class="command-usage">
          <code>${commandData.usage || `/${commandData.name}`}</code>
        </div>
    `;
        // 
        if (commandData.examples && commandData.examples.length > 0) {
            content += `
        <h2></h2>
        <ul class="command-examples-list">
          ${commandData.examples.map((example) => `<li><code>${example}</code></li>`).join('')}
        </ul>
      `;
        }
        // 
        if (commandData.aliases && commandData.aliases.length > 0) {
            content += `
        <h2></h2>
        <div class="command-aliases">
          ${commandData.aliases.map((alias) => `<code>/${alias}</code>`).join(', ')}
        </div>
      `;
        }
        //  
        if (commandData.related && commandData.related.length > 0) {
            content += `
        <h2> </h2>
        <div class="related-commands">
          ${commandData.related.map((cmd) => `<a href="#" class="related-command" onclick="sendCommandToVSCode('${cmd}')">${cmd}</a>`).join(', ')}
        </div>
      `;
        }
        content += `
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">   </a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('   HTML  :', error);
        return getHelpPageHtml(`
      <h1>   </h1>
      <p>     : ${error}</p>
    `);
    }
}
/**
 * FAQ HTML 
 * @returns HTML 
 */
async function generateFaqHtml() {
    try {
        const helpData = await loadHelpData();
        const faqs = helpData.faq || [];
        let content = `
      <h1>APE    (FAQ)</h1>
      <div class="faq-list">
    `;
        for (const faq of faqs) {
            content += `
        <div class="faq-item">
          <div class="faq-question">${faq.question}</div>
          <div class="faq-answer">${faq.answer}</div>
        </div>
      `;
        }
        content += `
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">  </a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('FAQ HTML  :', error);
        return getHelpPageHtml(`
      <h1>FAQ  </h1>
      <p>FAQ     : ${error}</p>
    `);
    }
}
/**
 *   HTML 
 * @param guideId  ID
 * @returns HTML 
 */
async function generateGuideHtml(guideId) {
    try {
        const helpData = await loadHelpData();
        const guides = helpData.guides || [];
        const guide = guides.find((g) => g.id === guideId);
        if (!guide) {
            return getHelpPageHtml(`
        <h1>   </h1>
        <p>'${guideId}'    .</p>
        <p><a href="#" onclick="sendCommandToVSCode('help guides')">  </a></p>
      `);
        }
        //    
        const content = `
      <div class="guide-content markdown-body">
        ${guide.content}
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help guides')">   </a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error(' HTML  :', error);
        return getHelpPageHtml(`
      <h1>  </h1>
      <p>     : ${error}</p>
    `);
    }
}
/**
 *    HTML 
 * @returns HTML 
 */
async function generateGuidesListHtml() {
    try {
        const helpData = await loadHelpData();
        const guides = helpData.guides || [];
        let content = `
      <h1>APE  </h1>
      <p>    .        .</p>
      <div class="guides-list">
    `;
        for (const guide of guides) {
            content += `
        <div class="guide-item">
          <h2 class="guide-title">
            <a href="#" onclick="sendCommandToVSCode('help guide ${guide.id}')">${guide.title}</a>
          </h2>
          <div class="guide-description">
            ${guide.content.split('\n')[0].replace(/^#+\s+.*$/, '')}
          </div>
        </div>
      `;
        }
        content += `
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">  </a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('  HTML  :', error);
        return getHelpPageHtml(`
      <h1>   </h1>
      <p>     : ${error}</p>
    `);
    }
}
/**
 * LLM    
 * @param query  
 * @param llmService LLM  
 * @returns HTML 
 */
async function generateSmartHelpHtml(query, llmService) {
    try {
        const helpData = await loadHelpData();
        // LLM  
        const prompt = (0,_data_helpSystemPrompt__WEBPACK_IMPORTED_MODULE_3__.generateHelpSystemPrompt)(helpData, query);
        // LLM  
        const result = await llmService.getCompletion(prompt);
        if (!result.success || !result.data) {
            throw new Error(result.error?.message || 'LLM    .');
        }
        //   HTML 
        const markdownResponse = result.data;
        const content = `
      <div class="smart-help">
        <h1>APE  - ${escapeHtml(query)}</h1>
        <div class="markdown-body">
          ${markdownToHtml(markdownResponse)}
        </div>
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">  </a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('   :', error);
        return getHelpPageHtml(`
      <h1>  </h1>
      <p>    : ${error}</p>
      <p><a href="#" onclick="sendCommandToVSCode('help')"> </a></p>
    `);
    }
}
/**
 *   HTML 
 * @param content  HTML
 * @returns  HTML 
 */
function getHelpPageHtml(content) {
    return `
    <!DOCTYPE html>
    <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>APE </title>
      <link rel="stylesheet" href="${getCodiconCssUri().toString()}" />
      <style>
        :root {
          /*    */
          --bg-color: var(--vscode-editor-background, #ffffff);
          --text-color: var(--vscode-editor-foreground, #333333);
          --link-color: var(--vscode-textLink-foreground, #3794ff);
          --heading-color: var(--vscode-editor-foreground, #333333);
          --border-color: var(--vscode-panel-border, #e7e7e7);
          --accent-color: var(--vscode-button-background, #0e639c);
          --accent-hover-color: var(--vscode-button-hoverBackground, #1177bb);
          --card-bg-color: var(--vscode-editor-inactiveSelectionBackground, #f5f5f5);
          --code-bg-color: var(--vscode-textBlockQuote-background, #f1f1f1);

          /*  &     */
          --gucci-green: #006837;
          --gucci-green-light: #007f45;
          --gucci-green-dark: #004d27;
          --hermes-orange: #ff6600;
          --hermes-orange-light: #ff8533;
          --hermes-orange-dark: #cc5200;
          --luxury-gold: #d4af37;
          --luxury-silver: #c0c0c0;
          --luxury-bg-dark: #1a1a1a;
          --luxury-bg-light: #f5f5f5;

          /*    */
          --luxury-shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.06);
          --luxury-shadow-md: 0 6px 16px rgba(0, 0, 0, 0.1);
          --luxury-shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.12);
          --luxury-glow: 0 0 20px rgba(0, 104, 55, 0.08);

          /*    */
          --luxury-transition: 400ms cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
          line-height: 1.6;
          color: var(--text-color);
          background-color: var(--bg-color);
          margin: 0;
          padding: 20px;
          max-width: 1000px;
          margin: 0 auto;
          letter-spacing: -0.01em;
        }

        h1, h2, h3, h4, h5, h6 {
          color: var(--heading-color);
          margin-top: 24px;
          margin-bottom: 16px;
          font-weight: 600;
          line-height: 1.25;
          letter-spacing: -0.02em;
        }

        h1 {
          font-size: 2em;
          padding-bottom: 0.3em;
          border-bottom: 1px solid var(--gucci-green);
          position: relative;
        }

        h1::after {
          content: '';
          position: absolute;
          bottom: -1px;
          left: 0;
          width: 80px;
          height: 3px;
          background-color: var(--hermes-orange);
        }

        h2 {
          font-size: 1.5em;
          padding-bottom: 0.3em;
          color: var(--gucci-green);
        }

        a {
          color: var(--hermes-orange);
          text-decoration: none;
          transition: color var(--luxury-transition), transform var(--luxury-transition);
          display: inline-block;
        }

        a:hover {
          color: var(--hermes-orange-light);
          transform: translateY(-1px);
        }

        p {
          margin-top: 0;
          margin-bottom: 16px;
        }

        code {
          font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, Courier, monospace;
          padding: 0.2em 0.4em;
          margin: 0;
          font-size: 85%;
          background-color: var(--code-bg-color);
          border-radius: 3px;
        }

        pre {
          background-color: var(--code-bg-color);
          border-radius: 3px;
          padding: 16px;
          overflow: auto;
        }

        pre code {
          background-color: transparent;
          padding: 0;
          margin: 0;
          font-size: 100%;
          word-break: normal;
          white-space: pre;
        }

        ul, ol {
          margin-top: 0;
          margin-bottom: 16px;
          padding-left: 2em;
        }

        li {
          margin-top: 0.25em;
        }

        .help-category {
          margin-bottom: 40px;
        }

        .command-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
          gap: 16px;
          margin-bottom: 30px;
        }

        .command-card {
          background-color: var(--card-bg-color);
          border-radius: 8px;
          padding: 20px;
          cursor: pointer;
          transition: all var(--luxury-transition);
          border: 1px solid transparent;
          box-shadow: var(--luxury-shadow-sm);
          position: relative;
          overflow: hidden;
        }

        .command-card:hover {
          transform: translateY(-3px);
          box-shadow: var(--luxury-shadow-md);
          border-color: var(--gucci-green-light);
        }

        .command-card::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 4px;
          height: 100%;
          background-color: var(--gucci-green);
          opacity: 0;
          transition: opacity var(--luxury-transition);
        }

        .command-card:hover::before {
          opacity: 1;
        }

        .command-card::after {
          content: '';
          position: absolute;
          bottom: 0;
          right: 0;
          width: 30px;
          height: 1px;
          background-color: var(--hermes-orange);
          transition: width var(--luxury-transition);
        }

        .command-card:hover::after {
          width: 60px;
        }

        .clickable-command {
          cursor: pointer;
          transition: all var(--luxury-transition);
          padding: 2px 6px;
          border-radius: 3px;
        }

        .clickable-command:hover {
          color: var(--hermes-orange);
          background-color: rgba(255, 102, 0, 0.1);
        }

        .command-name {
          font-weight: bold;
          margin-bottom: 12px;
          color: var(--gucci-green);
          font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, Courier, monospace;
          font-size: 1.1em;
          display: flex;
          align-items: center;
          letter-spacing: 0.02em;
        }

        .command-description {
          margin-bottom: 12px;
          color: var(--text-color);
          line-height: 1.5;
        }

        .command-examples {
          font-size: 0.85em;
          color: var(--vscode-descriptionForeground, #747474);
          font-style: italic;
          padding: 4px 0;
          border-left: 2px solid rgba(0, 104, 55, 0.2);
          padding-left: 8px;
          margin-top: 8px;
        }

        .command-aliases {
          font-size: 0.85em;
          color: var(--vscode-descriptionForeground, #747474);
          background-color: rgba(0, 104, 55, 0.08);
          border-radius: 4px;
          padding: 3px 8px;
          display: inline-block;
          margin-top: 6px;
          transition: background-color var(--luxury-transition);
        }

        .command-card:hover .command-aliases {
          background-color: rgba(0, 104, 55, 0.15);
        }

        .command-icon {
          font-size: 1.1em;
          margin-right: 8px;
          position: relative;
          top: 1px;
          color: var(--gucci-green-dark);
          transition: transform var(--luxury-transition);
        }

        .command-card:hover .command-icon {
          transform: scale(1.1);
        }

        .command-text {
          font-weight: bold;
          position: relative;
        }

        .command-usage {
          margin-bottom: 18px;
          background-color: rgba(0, 104, 55, 0.05);
          padding: 8px 12px;
          border-radius: 6px;
          border-left: 3px solid var(--gucci-green);
        }

        .command-aliases, .related-commands {
          margin-bottom: 18px;
        }

        .related-command {
          margin-right: 10px;
          background-color: rgba(255, 102, 0, 0.08);
          padding: 4px 10px;
          border-radius: 4px;
          transition: all var(--luxury-transition);
          display: inline-block;
        }

        .related-command:hover {
          background-color: rgba(255, 102, 0, 0.15);
          transform: translateY(-2px);
          text-decoration: none;
        }

        .back-link {
          margin-top: 30px;
          padding-top: 20px;
          border-top: 1px solid var(--border-color);
        }

        .back-link a {
          display: inline-flex;
          align-items: center;
          color: var(--gucci-green);
          font-weight: 500;
          padding: 6px 14px;
          border-radius: 4px;
          background-color: rgba(0, 104, 55, 0.05);
          transition: all var(--luxury-transition);
        }

        .back-link a:hover {
          background-color: rgba(0, 104, 55, 0.1);
          transform: translateY(-2px);
          box-shadow: var(--luxury-shadow-sm);
          text-decoration: none;
        }

        .back-link a::before {
          content: '';
          margin-right: 8px;
          font-size: 1.1em;
          transition: transform var(--luxury-transition);
        }

        .back-link a:hover::before {
          transform: translateX(-3px);
        }

        .faq-list {
          margin-top: 30px;
        }

        .faq-item {
          margin-bottom: 28px;
          border-bottom: 1px solid rgba(0, 104, 55, 0.1);
          padding-bottom: 20px;
          transition: transform var(--luxury-transition);
        }

        .faq-item:hover {
          transform: translateY(-2px);
        }

        .faq-question {
          font-weight: 600;
          font-size: 1.2em;
          margin-bottom: 10px;
          color: var(--gucci-green);
          position: relative;
          padding-left: 16px;
        }

        .faq-question::before {
          content: '';
          position: absolute;
          left: 0;
          top: 50%;
          transform: translateY(-50%);
          width: 6px;
          height: 6px;
          background-color: var(--hermes-orange);
          border-radius: 50%;
        }

        .faq-answer {
          padding-left: 16px;
        }

        .guides-list {
          margin-top: 30px;
        }

        .guide-item {
          margin-bottom: 28px;
          border-bottom: 1px solid rgba(0, 104, 55, 0.1);
          padding-bottom: 20px;
          transition: all var(--luxury-transition);
        }

        .guide-item:hover {
          border-bottom-color: var(--gucci-green-light);
          transform: translateY(-2px);
        }

        .guide-title {
          margin-bottom: 10px;
          color: var(--gucci-green);
        }

        .guide-title a {
          text-decoration: none;
          color: var(--gucci-green);
          transition: color var(--luxury-transition);
          font-weight: 600;
          display: inline-block;
          padding-bottom: 2px;
          border-bottom: 1px solid transparent;
        }

        .guide-title a:hover {
          color: var(--gucci-green-light);
          border-bottom-color: var(--hermes-orange-light);
        }

        .guide-description {
          margin-bottom: 10px;
          color: var(--text-color);
        }

        .markdown-body {
          line-height: 1.6;
        }

        .markdown-body img {
          max-width: 100%;
          box-sizing: content-box;
          border-radius: 6px;
          box-shadow: var(--luxury-shadow-sm);
        }

        .markdown-body blockquote {
          padding: 0.5em 1em;
          color: var(--vscode-editor-foreground, #6a737d);
          border-left: 3px solid var(--gucci-green-light);
          margin: 0 0 16px 0;
          background-color: rgba(0, 104, 55, 0.05);
          border-radius: 0 4px 4px 0;
        }

        .markdown-body table {
          display: block;
          width: 100%;
          overflow: auto;
          border-collapse: collapse;
          margin-bottom: 16px;
          border-radius: 6px;
          overflow: hidden;
          box-shadow: var(--luxury-shadow-sm);
        }

        .markdown-body table th,
        .markdown-body table td {
          padding: 8px 16px;
          border: 1px solid var(--vscode-panel-border, #dfe2e5);
        }

        .markdown-body table th {
          background-color: rgba(0, 104, 55, 0.1);
          font-weight: 600;
        }

        .markdown-body table tr {
          background-color: var(--bg-color);
          border-top: 1px solid var(--vscode-panel-border, #c6cbd1);
          transition: background-color var(--luxury-transition);
        }

        .markdown-body table tr:hover {
          background-color: rgba(0, 104, 55, 0.03);
        }

        .markdown-body table tr:nth-child(2n) {
          background-color: var(--vscode-editor-inactiveSelectionBackground, #f6f8fa);
        }

        .markdown-body table tr:nth-child(2n):hover {
          background-color: rgba(0, 104, 55, 0.05);
        }

        /*    */
        .quick-actions {
          margin: 30px 0 40px;
          background-color: rgba(0, 104, 55, 0.04);
          border-radius: 10px;
          padding: 24px;
          border: 1px solid rgba(0, 104, 55, 0.1);
          position: relative;
          box-shadow: var(--luxury-shadow-sm);
          transition: box-shadow var(--luxury-transition), transform var(--luxury-transition);
        }

        .quick-actions:hover {
          box-shadow: var(--luxury-shadow-md);
          transform: translateY(-2px);
        }

        .quick-actions::after {
          content: '';
          position: absolute;
          top: 0;
          right: 0;
          width: 40px;
          height: 3px;
          background-color: var(--hermes-orange);
          border-radius: 0 10px 0 10px;
        }

        .quick-actions h2 {
          margin-top: 0;
          font-size: 1.4em;
          color: var(--gucci-green);
          margin-bottom: 20px;
          letter-spacing: -0.01em;
        }

        .quick-buttons {
          display: flex;
          flex-wrap: wrap;
          gap: 14px;
        }

        .quick-button {
          display: flex;
          align-items: center;
          padding: 10px 18px;
          border-radius: 6px;
          cursor: pointer;
          font-weight: 500;
          border: none;
          min-width: 130px;
          font-size: 0.95em;
          transition: all var(--luxury-transition);
          color: white;
          letter-spacing: 0.01em;
          box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .quick-button:hover {
          transform: translateY(-3px);
          box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .quick-button .codicon {
          margin-right: 10px;
          font-size: 1.2em;
          transition: transform var(--luxury-transition);
        }

        .quick-button:hover .codicon {
          transform: scale(1.1);
        }

        .quick-button.git {
          background: linear-gradient(135deg, var(--gucci-green) 0%, var(--gucci-green-dark) 100%);
          border: 1px solid rgba(0, 104, 55, 0.3);
        }

        .quick-button.code {
          background: linear-gradient(135deg, var(--hermes-orange) 0%, var(--hermes-orange-dark) 100%);
          border: 1px solid rgba(255, 102, 0, 0.3);
        }

        .quick-button.utility {
          background: linear-gradient(135deg, var(--gucci-green-light) 0%, var(--gucci-green) 100%);
          border: 1px solid rgba(0, 104, 55, 0.3);
        }

        .quick-button.model {
          background: linear-gradient(135deg, var(--hermes-orange-light) 0%, var(--hermes-orange) 100%);
          border: 1px solid rgba(255, 102, 0, 0.3);
        }
      </style>
    </head>
    <body>
      <div class="help-content">
        ${content}
      </div>
      
      <script>
        // VS Code API 
        const vscode = acquireVsCodeApi();
        
        //  VS Code 
        function sendCommandToVSCode(command) {
          vscode.postMessage({
            type: 'command',
            command: command
          });
        }
        
        //   
        function insertCommandToChatInput(command) {
          vscode.postMessage({
            type: 'insertCommand',
            command: command
          });
        }
        
        //      
        document.addEventListener('click', (event) => {
          const target = event.target;
          
          //    
          const commandCard = target.closest('.command-card');
          if (commandCard) {
            const cmdName = commandCard.querySelector('.command-name')?.textContent;
            if (cmdName) {
              insertCommandToChatInput(cmdName);
            }
          }
          
          // A   
          if (target.tagName === 'A' && target.getAttribute('href') === '#') {
            event.preventDefault();
            //     onclick 
          }
        });
        
        //      
        document.querySelectorAll('code').forEach(codeElement => {
          if (codeElement.textContent.startsWith('/')) {
            codeElement.classList.add('clickable-command');
            codeElement.addEventListener('click', () => {
              insertCommandToChatInput(codeElement.textContent);
            });
          }
        });
      </script>
    </body>
    </html>
  `;
}
/**
 * HTML 
 * @param unsafe  
 * @returns  
 */
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}
/**
 *  Codicon   
 * @param category  ID
 * @returns Codicon  
 */
function getCategoryIcon(category) {
    switch (category) {
        case 'general':
            return 'info';
        case 'git':
            return 'git-commit';
        case 'code':
            return 'code';
        case 'utility':
            return 'tools';
        case 'advanced':
            return 'settings-gear';
        default:
            return 'symbol-event';
    }
}
/**
 *    
 * @param toolName  
 * @returns  
 */
function getToolEmoji(toolName) {
    switch (toolName) {
        case 'Bash':
            return ''; //  
        case 'Batch':
            return ''; //  
        case 'Glob':
            return ''; //  
        case 'Grep':
            return ''; //  
        case 'LS':
            return ''; //  
        case 'Read':
            return ''; //  
        case 'Edit':
            return ''; // 
        case 'MultiEdit':
            return ''; //  
        case 'Write':
            return ''; //   
        case 'TodoRead':
            return ''; //  
        case 'TodoWrite':
            return ''; //  
        case 'WebFetch':
            return ''; //  
        case 'WebSearch':
            return ''; //  
        case 'Task':
            return ''; //  
        default:
            return ''; //  
    }
}
/**
 *  HTML  ( )
 */
function markdownToHtml(markdown) {
    return markdown
        //  
        .replace(/^# (.+)$/gm, '<h1>$1</h1>')
        .replace(/^## (.+)$/gm, '<h2>$1</h2>')
        .replace(/^### (.+)$/gm, '<h3>$1</h3>')
        .replace(/^#### (.+)$/gm, '<h4>$1</h4>')
        .replace(/^##### (.+)$/gm, '<h5>$1</h5>')
        .replace(/^###### (.+)$/gm, '<h6>$1</h6>')
        //   
        .replace(/```([a-z]*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>')
        //   
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        //   
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/__([^_]+)__/g, '<strong>$1</strong>')
        //   
        .replace(/\*([^*]+)\*/g, '<em>$1</em>')
        .replace(/_([^_]+)_/g, '<em>$1</em>')
        //  
        .replace(/^- (.+)$/gm, '<li>$1</li>')
        .replace(/^([0-9]+)\. (.+)$/gm, '<li>$2</li>')
        .replace(/(<li>.*<\/li>\n)+/g, '<ul>$&</ul>')
        //  
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
        //  
        .replace(/\n\n/g, '</p><p>')
        .replace(/\n/g, '<br>')
        //  
        .replace(/^(.+?)(?=<\/p>|<h[1-6]|<ul>|$)/s, '<p>$1</p>');
}
/**
 * Agent   HTML 
 * @returns HTML 
 */
async function generateToolsHelpHtml() {
    try {
        //   
        const toolsPageStyle = `
      .tools-page {
        max-width: 900px;
        margin: 0 auto;
        padding: 10px 0;
      }
      
      .tools-page h1 {
        text-align: center;
        margin-bottom: 30px;
        color: var(--vscode-editor-foreground);
        font-size: 32px;
      }
      
      .tools-page p {
        text-align: center;
        margin-bottom: 40px;
        line-height: 1.6;
        color: var(--text-color);
        opacity: 0.8;
      }
      
      .tools-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 24px;
        margin-bottom: 40px;
      }
      
      .tool-card {
        background-color: var(--bg-color);
        border-radius: var(--modern-radius);
        padding: 24px;
        box-shadow: var(--modern-card-shadow);
        transition: var(--modern-transition);
        border: 1px solid rgba(0, 0, 0, 0.05);
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      
      .tool-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(90deg, var(--modern-accent), #7C4DFF);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .tool-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
      }
      
      .tool-card:hover::before {
        opacity: 1;
      }
      
      .tool-header {
        display: flex;
        align-items: center;
        margin-bottom: 16px;
      }
      
      .tool-icon {
        margin-right: 12px;
        font-size: 24px;
        color: var(--modern-accent);
        background-color: var(--modern-accent-light);
        width: 40px;
        height: 40px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: var(--modern-transition);
      }
      
      .tool-card:hover .tool-icon {
        transform: scale(1.1);
        background-color: var(--modern-accent);
        color: white;
      }
      
      .tool-icon-svg {
        width: 24px;
        height: 24px;
        filter: var(--vscode-editor-foreground-filter, none);
      }
      
      .tool-name {
        font-size: 18px;
        font-weight: 600;
        color: var(--heading-color);
      }
      
      .tool-description {
        font-size: 14px;
        color: var(--text-color);
        opacity: 0.8;
        line-height: 1.6;
        margin-bottom: 16px;
      }
      
      .tool-examples {
        background-color: var(--card-bg-color);
        border-radius: 8px;
        padding: 10px;
      }
      
      .tool-examples-title {
        font-size: 13px;
        font-weight: 600;
        color: var(--heading-color);
        margin-bottom: 8px;
      }
      
      .tool-examples-list {
        font-size: 12px;
        color: var(--text-color);
        opacity: 0.8;
        line-height: 1.5;
      }
      
      .tool-examples-list li {
        margin-bottom: 4px;
      }
      
      /*    */
      .vscode-dark .tool-card {
        background-color: var(--bg-color);
        border-color: rgba(255, 255, 255, 0.1);
      }
      
      .vscode-dark .tool-examples {
        background-color: rgba(30, 30, 30, 0.6);
      }
      
      /*  */
      @media (max-width: 768px) {
        .tools-grid {
          grid-template-columns: 1fr;
        }
      }
    `;
        //   
        const tools = [
            {
                name: 'Bash',
                description: '        .',
                icon: 'terminal',
                examples: ['  ', '   ', '  ']
            },
            {
                name: 'Batch',
                description: '       .',
                icon: 'layers',
                examples: ['   ', ' Bash  ', '  ']
            },
            {
                name: 'Glob',
                description: '      .',
                icon: 'filter',
                examples: ['.js  ', '    ', '  ']
            },
            {
                name: 'Grep',
                description: '    .',
                icon: 'search',
                examples: ['  ', '  ', '  ']
            },
            {
                name: 'LS',
                description: '     .',
                icon: 'folder-opened',
                examples: ['  ', '  ', '  ']
            },
            {
                name: 'Read',
                description: '    .',
                icon: 'preview',
                examples: ['  ', '  ', '  ']
            },
            {
                name: 'Edit',
                description: '     .',
                icon: 'edit',
                examples: ['  ', '  ', ' ']
            },
            {
                name: 'MultiEdit',
                description: '      .',
                icon: 'multiple-edit',
                examples: ['   ', '/  ', '    ']
            },
            {
                name: 'Write',
                description: '     .',
                icon: 'new-file',
                examples: ['   ', '  ', '  ']
            },
            {
                name: 'WebFetch',
                description: ' URL   .',
                icon: 'globe',
                examples: ['API  ', '   ', '  ']
            },
            {
                name: 'WebSearch',
                description: '   .',
                icon: 'web-search',
                examples: ['  ', '  ', '  ']
            },
            {
                name: 'TodoRead',
                description: '     .',
                icon: 'list-selection',
                examples: ['   ', '  ', '  ']
            },
            {
                name: 'TodoWrite',
                description: '      .',
                icon: 'checklist',
                examples: ['  ', '  ', '  ']
            },
            {
                name: 'Task',
                description: '     .',
                icon: 'agent',
                examples: [' ', '  ', '  ']
            }
        ];
        // HTML 
        let content = `
      <div class="tools-page">
        <h1>APE  </h1>
        <p>APE     Agent  .     , ,       .</p>
        
        <div class="tools-grid">
    `;
        //    
        for (const tool of tools) {
            //   
            const iconEmoji = getToolEmoji(tool.name);
            const iconHtml = `<div class="tool-icon minimal-icon">${iconEmoji}</div>`;
            content += `
        <div class="tool-card">
          <div class="tool-header">
            ${iconHtml}
            <div class="tool-name">${tool.name}</div>
          </div>
          <div class="tool-description">${tool.description}</div>
          
          <div class="tool-examples">
            <div class="tool-examples-title">  </div>
            <ul class="tool-examples-list">
              ${tool.examples.map(ex => `<li>${ex}</li>`).join('')}
            </ul>
          </div>
        </div>
      `;
        }
        content += `
        </div>
        
        <div class="back-link">
          <a href="#" onclick="sendCommandToVSCode('help')">  </a>
        </div>
      </div>
    `;
        //  HTML 
        return getHelpPageHtml(toolsPageStyle + content);
    }
    catch (error) {
        console.error('Agent  HTML  :', error);
        return getHelpPageHtml(`
      <h1>   </h1>
      <p>     : ${error}</p>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">  </a>
      </div>
    `);
    }
}


/***/ }),

/***/ "./src/core/commands/jiraCommands.ts":
/*!*******************************************!*\
  !*** ./src/core/commands/jiraCommands.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createJiraCommands: () => (/* binding */ createJiraCommands)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _services_jiraService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/jiraService */ "./src/core/services/jiraService.ts");
/**
 * Jira    
 */


/**
 * Jira  
 */
function createJiraCommands(jiraService) {
    const commands = [];
    // Jira  
    commands.push({
        name: 'jira',
        aliases: ['j', '', ''],
        description: 'Jira    ',
        examples: ['/jira search', '/jira create', '/jira summary', '/jira status', '/ '],
        category: 'utility',
        priority: 8,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand) {
                //      
                const helpMessage = `
## Jira  

Jira     .       :

- **/jira create** -  Jira  
- **/jira search** - Jira  
- **/jira summary** -    
- **/jira status** - Jira   

 : \`/jira search APE-\`, \`/jira create\`, \`/jira summary APE\`, \`/jira status APE-123 in-progress\`
        `;
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: helpMessage
                });
                return;
            }
            //   
            switch (subCommand) {
                case 'create':
                case '':
                case '':
                    await handleJiraCreate(jiraService);
                    break;
                case 'search':
                case '':
                case '':
                    await handleJiraSearch(jiraService, context);
                    break;
                case 'summary':
                case '':
                case '':
                    await handleJiraSummary(jiraService, context);
                    break;
                case 'status':
                case '':
                case '':
                case 'update':
                    await handleJiraStatus(jiraService, context);
                    break;
                default:
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`   Jira  : ${subCommand}`);
                    break;
            }
        },
        provideCompletions: (partialArgs) => {
            const parts = partialArgs.split(' ');
            //     ( )
            if (parts.length <= 1) {
                const subCommands = ['create', 'search', 'summary', 'status', '', '', '', '', ''];
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(parts[0]?.toLowerCase() || ''));
            }
            //    
            const subCommand = parts[0].toLowerCase();
            if (subCommand === 'search' || subCommand === '') {
                //    
                return [];
            }
            else if (subCommand === 'summary' || subCommand === '') {
                //      (   )
                return [];
            }
            else if (subCommand === 'status' || subCommand === '' || subCommand === '') {
                //     
                if (parts.length === 3) {
                    //   
                    const statusValues = ['todo', 'in-progress', 'in-review', 'done', 'blocked'];
                    return statusValues.filter(status => status.startsWith(parts[2].toLowerCase()));
                }
            }
            return [];
        }
    });
    return commands;
}
/**
 * Jira    
 */
async function handleJiraStatus(jiraService, context) {
    if (!jiraService) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Jira    ');
        return;
    }
    try {
        //      (   )
        const statusArgs = context?.args.slice(1) || [];
        if (statusArgs.length < 1) {
            //    
            const issueKey = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: 'Jira   ',
                placeHolder: ': APE-123, PROJ-456 '
            });
            if (!issueKey)
                return; // 
            //  
            const status = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick([
                { label: '', value: 'todo' },
                { label: '', value: 'in-progress' },
                { label: '', value: 'in-review' },
                { label: '', value: 'done' },
                { label: '', value: 'blocked' }
            ], { placeHolder: '  ' });
            if (!status)
                return; // 
            //   
            return await executeStatusChange(jiraService, issueKey, status.value);
        }
        else {
            const issueKey = statusArgs[0];
            let status;
            if (statusArgs.length < 2) {
                //  
                const selectedStatus = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick([
                    { label: '', value: 'todo' },
                    { label: '', value: 'in-progress' },
                    { label: '', value: 'in-review' },
                    { label: '', value: 'done' },
                    { label: '', value: 'blocked' }
                ], { placeHolder: '  ' });
                if (!selectedStatus)
                    return; // 
                status = selectedStatus.value;
            }
            else {
                status = statusArgs[1].toLowerCase();
            }
            //   
            return await executeStatusChange(jiraService, issueKey, status);
        }
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Jira    : ${error instanceof Error ? error.message : String(error)}`);
        //   
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira    \n\n     : ${error instanceof Error ? error.message : String(error)}`
        });
    }
}
/**
 *    
 */
async function executeStatusChange(jiraService, issueKey, statusStr) {
    //    
    let status;
    //   JiraIssueStatus  
    switch (statusStr.toLowerCase()) {
        case 'todo':
        case 'to-do':
        case 'to_do':
        case '':
        case '':
            status = _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.ToDo;
            break;
        case 'in-progress':
        case 'in_progress':
        case 'inprogress':
        case '':
        case '':
            status = _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.InProgress;
            break;
        case 'in-review':
        case 'in_review':
        case 'inreview':
        case '':
        case '':
            status = _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.InReview;
            break;
        case 'done':
        case 'complete':
        case 'completed':
        case '':
        case '':
            status = _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.Done;
            break;
        case 'blocked':
        case 'block':
        case '':
        case '':
            status = _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.Blocked;
            break;
        default:
            throw new Error(`  : ${statusStr}.  : todo, in-progress, in-review, done, blocked`);
    }
    //    
    const issueResult = await jiraService.getIssue(issueKey);
    if (!issueResult.success || !issueResult.data) {
        throw new Error(`   : ${issueKey}`);
    }
    const issue = issueResult.data;
    const currentStatus = issue.status;
    //     
    if (currentStatus === status) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira   \n\n **${issueKey}** (${issue.summary})  **${getStatusDisplayName(status)}** .`
        });
        return;
    }
    //   
    const result = await jiraService.updateIssueStatus(issueKey, status);
    if (result.success) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Jira   : ${issueKey}`);
        //   
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira    \n\n **${issueKey}** (${issue.summary})  **${getStatusDisplayName(currentStatus)}** **${getStatusDisplayName(status)}**() .`
        });
    }
    else {
        throw new Error(result.error?.message || '   ');
    }
}
/**
 *   
 */
function getStatusDisplayName(status) {
    switch (status) {
        case _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.ToDo:
            return '';
        case _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.InProgress:
            return '';
        case _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.InReview:
            return '';
        case _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.Done:
            return '';
        case _services_jiraService__WEBPACK_IMPORTED_MODULE_1__.JiraIssueStatus.Blocked:
            return '';
        default:
            return '  ';
    }
}
/**
 * Jira   
 */
async function handleJiraCreate(jiraService) {
    if (!jiraService) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Jira    ');
        return;
    }
    try {
        //    
        const projectKey = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: 'Jira   ',
            placeHolder: ': APE, DEV, TEST '
        });
        if (!projectKey)
            return; // 
        //    
        const issueType = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(['Task', 'Bug', 'Story', 'Epic'], { placeHolder: '  ' });
        if (!issueType)
            return; // 
        //    
        const summary = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: '  ',
            placeHolder: ' '
        });
        if (!summary)
            return; // 
        //    
        const description = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: '   ()',
            placeHolder: ' '
        });
        //  
        const result = await jiraService.createIssue({
            projectKey,
            issueType,
            summary,
            description: description || ''
        });
        if (result.success && result.data) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Jira  : ${result.data.key}`);
            //   
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `## Jira   \n\n **${result.data.key}**  .\n\n- ****: ${summary}\n- ****: ${issueType}\n- ****: ${projectKey}`
            });
        }
        else {
            throw new Error(result.error?.message || '  ');
        }
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Jira   : ${error instanceof Error ? error.message : String(error)}`);
        //   
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira   \n\n    : ${error instanceof Error ? error.message : String(error)}`
        });
    }
}
/**
 * Jira   
 */
async function handleJiraSearch(jiraService, context) {
    if (!jiraService) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Jira    ');
        return;
    }
    try {
        //   
        const searchArgs = context?.args.slice(1) || [];
        const searchText = searchArgs.join(' ');
        //     
        let finalSearchText = searchText;
        if (!finalSearchText) {
            finalSearchText = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: 'Jira  ',
                placeHolder: ' ,  ,   (: APE-123, Bug, )'
            });
            if (!finalSearchText)
                return; // 
        }
        //    ( )
        const searchCriteria = {};
        //    
        const projectKeyMatch = finalSearchText.match(/^([A-Z0-9]+-\d+|[A-Z0-9]+)$/);
        if (projectKeyMatch) {
            if (projectKeyMatch[0].includes('-')) {
                //   
                const result = await jiraService.getIssue(projectKeyMatch[0]);
                if (result.success && result.data) {
                    //   
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: `## Jira   \n\n### ${result.data.key}: ${result.data.summary}\n\n****: ${result.data.status}\n****: ${result.data.assignee?.displayName || ''}\n****: ${result.data.reporter?.displayName || ''}\n\n${result.data.description || ' '}`
                    });
                    return;
                }
            }
            else {
                //    
                searchCriteria.projectKey = projectKeyMatch[0];
            }
        }
        else {
            //  
            searchCriteria.text = finalSearchText;
        }
        //    
        searchCriteria.maxResults = 10;
        //  
        const result = await jiraService.searchIssues(searchCriteria);
        if (result.success && result.data) {
            if (result.data.issues.length === 0) {
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: `## Jira   \n\n \`${finalSearchText}\`     .`
                });
                return;
            }
            //  
            let content = `## Jira   \n\n: \`${finalSearchText}\`\n\n **${result.data.total}**   **${result.data.issues.length}** \n\n`;
            //   
            result.data.issues.forEach(issue => {
                content += `### ${issue.key}: ${issue.summary}\n\n`;
                content += `****: ${issue.status} | ****: ${issue.assignee?.displayName || ''}\n\n`;
            });
            //      
            if (result.data.hasMore) {
                content += `\n>    .    Jira   .`;
            }
            //   
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content
            });
        }
        else {
            throw new Error(result.error?.message || '  ');
        }
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Jira   : ${error instanceof Error ? error.message : String(error)}`);
        //   
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira   \n\n    : ${error instanceof Error ? error.message : String(error)}`
        });
    }
}
/**
 * Jira   
 */
async function handleJiraSummary(jiraService, context) {
    if (!jiraService) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Jira    ');
        return;
    }
    try {
        //   
        const summaryArgs = context?.args.slice(1) || [];
        const projectKey = summaryArgs.join(' ');
        //     
        let finalProjectKey = projectKey;
        if (!finalProjectKey) {
            finalProjectKey = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: 'Jira   ',
                placeHolder: ': APE, DEV, TEST '
            });
            if (!finalProjectKey)
                return; // 
        }
        //  
        const result = await jiraService.getProjectSummary(finalProjectKey);
        if (result.success && result.data) {
            const summary = result.data;
            //    
            let statusDistribution = '';
            for (const [status, count] of Object.entries(summary.issuesByStatus)) {
                statusDistribution += `- **${status}**: ${count}\n`;
            }
            //    
            let assigneeDistribution = '';
            for (const [assignee, count] of Object.entries(summary.issuesByAssignee)) {
                assigneeDistribution += `- **${assignee || ''}**: ${count}\n`;
            }
            //    
            let priorityDistribution = '';
            for (const [priority, count] of Object.entries(summary.issuesByPriority)) {
                priorityDistribution += `- **${priority || ''}**: ${count}\n`;
            }
            //    
            let recentIssues = '';
            summary.recentIssues.forEach(issue => {
                recentIssues += `- **${issue.key}**: ${issue.summary} (${issue.status})\n`;
            });
            //     
            let oldestUnresolvedIssues = '';
            summary.oldestUnresolvedIssues.forEach(issue => {
                oldestUnresolvedIssues += `- **${issue.key}**: ${issue.summary} (${issue.status}, : ${issue.created?.split('T')[0] || ' '})\n`;
            });
            //   
            let content = `## Jira  : ${finalProjectKey}\n\n`;
            if (summary.projectStats) {
                content += `###  \n\n`;
                content += `- **  **: ${summary.projectStats.totalIssues}\n`;
                content += `- **  **: ${summary.projectStats.openIssues}\n`;
                content += `- ****: ${summary.projectStats.percentComplete.toFixed(1)}%\n\n`;
            }
            content += `###   \n\n${statusDistribution}\n`;
            content += `###   \n\n${assigneeDistribution}\n`;
            content += `###   \n\n${priorityDistribution}\n`;
            if (recentIssues) {
                content += `###  \n\n${recentIssues}\n`;
            }
            if (oldestUnresolvedIssues) {
                content += `###    \n\n${oldestUnresolvedIssues}\n`;
            }
            if (summary.averageResolutionTime !== undefined) {
                content += `###  \n\n`;
                content += `- **  **: ${Math.round(summary.averageResolutionTime / 24)}\n`;
            }
            //   
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content
            });
        }
        else {
            throw new Error(result.error?.message || '     ');
        }
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Jira   : ${error instanceof Error ? error.message : String(error)}`);
        //   
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira   \n\n      : ${error instanceof Error ? error.message : String(error)}`
        });
    }
}


/***/ }),

/***/ "./src/core/commands/rulesCommands.ts":
/*!********************************************!*\
  !*** ./src/core/commands/rulesCommands.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createRulesCommands: () => (/* binding */ createRulesCommands)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Rules   
 */

/**
 * Rules    
 */
function createRulesCommands(rulesService) {
    if (!rulesService) {
        return [];
    }
    const commands = [];
    // rules : Rules   
    commands.push({
        name: 'rules',
        aliases: ['rule', 'ape-rules', '', '', ''],
        description: 'APE Rules  (, , , , )',
        examples: [
            '/rules list',
            '/rules active',
            '/rules inactive',
            '/rules activate ',
            '/rules deactivate ',
            '/rules create ',
            '/rules delete ',
            '/rules open ',
            '/rules info'
        ],
        category: 'advanced',
        priority: 15,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand || subCommand === 'list' || subCommand === '') {
                // Rules  
                await listRules(rulesService);
            }
            else if (subCommand === 'active' || subCommand === '' || subCommand === '') {
                //  Rules  
                await listActiveRules(rulesService);
            }
            else if (subCommand === 'inactive' || subCommand === '' || subCommand === '') {
                //  Rules  
                await listInactiveRules(rulesService);
            }
            else if (subCommand === 'activate' || subCommand === '') {
                // Rule 
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await activateRule(rulesService, ruleName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(' Rule  ');
                }
            }
            else if (subCommand === 'deactivate' || subCommand === '') {
                // Rule 
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await deactivateRule(rulesService, ruleName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(' Rule  ');
                }
            }
            else if (subCommand === 'create' || subCommand === '' || subCommand === '') {
                // Rule 
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await createRule(rulesService, ruleName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(' Rule  ');
                }
            }
            else if (subCommand === 'delete' || subCommand === '') {
                // Rule 
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await deleteRule(rulesService, ruleName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(' Rule  ');
                }
            }
            else if (subCommand === 'open' || subCommand === '') {
                // Rule  
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await openRuleFile(rulesService, ruleName);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(' Rule  ');
                }
            }
            else if (subCommand === 'info' || subCommand === '') {
                // Rules  
                await showRulesInfo(rulesService);
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`   Rules  : ${subCommand}`);
            }
        },
        provideCompletions: (partialArgs) => {
            const subCommands = [
                'list', 'active', 'inactive', 'activate', 'deactivate', 'create', 'delete', 'open', 'info',
                '', '', '', '', '', '', '', '', '', ''
            ];
            const parts = partialArgs.split(' ');
            //     ( )
            if (parts.length <= 1) {
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(parts[0]?.toLowerCase() || ''));
            }
            //     (Rule )
            if (parts.length === 2 && ['activate', 'deactivate', 'delete', 'open', '', '', '', ''].includes(parts[0])) {
                //    
                //  / Rule      
                return [];
            }
            return [];
        }
    });
    // r : rules 
    commands.push({
        name: 'r',
        description: 'rules   (APE Rules )',
        category: 'advanced',
        aliases: [],
        priority: 0,
        execute: async (context) => {
            // rules  
            const rulesCommand = commands.find(cmd => cmd.name === 'rules');
            if (rulesCommand && rulesCommand.execute) {
                await rulesCommand.execute(context);
            }
        },
        provideCompletions: (partialArgs) => {
            // rules   
            const rulesCommand = commands.find(cmd => cmd.name === 'rules');
            if (rulesCommand && rulesCommand.provideCompletions) {
                return rulesCommand.provideCompletions(partialArgs);
            }
            return [];
        }
    });
    return commands;
}
/**
 * Rules  
 */
async function listRules(rulesService) {
    try {
        const rules = rulesService.getAllRules();
        if (rules.length === 0) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: ' Rule . `/rules create `  Rule .'
            });
            return;
        }
        let content = '## APE Rules \n\n';
        //  Rules  
        const activeRules = rules.filter(rule => rule.status === 'active');
        const inactiveRules = rules.filter(rule => rule.status === 'inactive');
        if (activeRules.length > 0) {
            content += '###   Rules\n\n';
            activeRules.forEach(rule => {
                content += `- **${rule.name}** - \`${rule.id}.md\`\n`;
            });
            content += '\n';
        }
        if (inactiveRules.length > 0) {
            content += '###   Rules\n\n';
            inactiveRules.forEach(rule => {
                content += `- **${rule.name}** - \`${rule.id}.md\`\n`;
            });
            content += '\n';
        }
        content += '\n**Rules  **:\n';
        content += '- `/rules activate ` - Rule \n';
        content += '- `/rules deactivate ` - Rule \n';
        content += '- `/rules create ` -  Rule \n';
        content += '- `/rules delete ` - Rule \n';
        content += '- `/rules open ` - Rule  \n';
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rules     : ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 *  Rules  
 */
async function listActiveRules(rulesService) {
    try {
        const activeRules = rulesService.getActiveRules();
        if (activeRules.length === 0) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: '  Rule . `/rules activate ` Rule .'
            });
            return;
        }
        let content = '##   APE Rules\n\n';
        activeRules.forEach(rule => {
            //  100  
            const previewContent = rule.content.length > 100
                ? rule.content.substring(0, 100) + '...'
                : rule.content;
            content += `### ${rule.name}\n\n`;
            content += `- **ID**: \`${rule.id}\`\n`;
            content += `- ****: \`${rule.filePath.split('/').pop()}\`\n`;
            content += `- ** **:\n\n\`\`\`\n${previewContent}\n\`\`\`\n\n`;
        });
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(` Rules     : ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 *  Rules  
 */
async function listInactiveRules(rulesService) {
    try {
        const allRules = rulesService.getAllRules();
        const activeRules = rulesService.getActiveRules();
        const inactiveRules = allRules.filter(rule => !activeRules.some(activeRule => activeRule.id === rule.id));
        if (inactiveRules.length === 0) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: '  Rule .  Rules  .'
            });
            return;
        }
        let content = '##   APE Rules\n\n';
        inactiveRules.forEach(rule => {
            //  100  
            const previewContent = rule.content.length > 100
                ? rule.content.substring(0, 100) + '...'
                : rule.content;
            content += `### ${rule.name}\n\n`;
            content += `- **ID**: \`${rule.id}\`\n`;
            content += `- ****: \`${rule.filePath.split('/').pop()}\`\n`;
            content += `- ** **:\n\n\`\`\`\n${previewContent}\n\`\`\`\n\n`;
        });
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(` Rules     : ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule 
 */
async function activateRule(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        //   ID Rule 
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}'   ID  Rule   . '/rules list'   Rules .`
            });
            return;
        }
        //   
        if (rule.status === 'active') {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${rule.name}' Rule   .`
            });
            return;
        }
        // Rule 
        await rulesService.activateRule(rule.id);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Rule .  LLM   .`
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule    : ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule 
 */
async function deactivateRule(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        //   ID Rule 
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}'   ID  Rule   . '/rules list'   Rules .`
            });
            return;
        }
        //   
        if (rule.status === 'inactive') {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${rule.name}' Rule   .`
            });
            return;
        }
        // Rule 
        await rulesService.deactivateRule(rule.id);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Rule .   LLM    .`
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule    : ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 *  Rule 
 */
async function createRule(rulesService, ruleName) {
    try {
        // Rule  
        const ruleContent = `# ${ruleName}\n\n LLM    .\n\n   .\n\n## \n\n1.    .\n2.   .\n3.    .`;
        // Rule 
        const rule = await rulesService.createRule(ruleName, ruleContent, false);
        // Rule  
        await rulesService.openRuleFile(rule.id);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Rule .    , '/rules activate ${rule.name}'   .`
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule    : ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule 
 */
async function deleteRule(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        //   ID Rule 
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}'   ID  Rule   . '/rules list'   Rules .`
            });
            return;
        }
        //   (  )
        const confirmation = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage(`'${rule.name}' Rule ?`, { modal: true }, '', '');
        if (confirmation !== '') {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${rule.name}' Rule  .`
            });
            return;
        }
        // Rule 
        await rulesService.deleteRule(rule.id);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Rule .`
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule    : ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule  
 */
async function openRuleFile(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        //   ID Rule 
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}'   ID  Rule   . '/rules list'   Rules .`
            });
            return;
        }
        // Rule  
        await rulesService.openRuleFile(rule.id);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Rule  .`
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule     : ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rules  
 */
async function showRulesInfo(rulesService) {
    try {
        const rules = rulesService.getAllRules();
        const activeRules = rulesService.getActiveRules();
        let content = '## APE Rules \n\n';
        content += `- ** Rules **: ${rules.length}\n`;
        content += `- ** Rules**: ${activeRules.length}\n`;
        content += `- ** Rules**: ${rules.length - activeRules.length}\n\n`;
        content += '### Rules  \n\n';
        content += 'APE Rules LLM    .  Rule    ,  Rules LLM    .\n\n';
        content += '###  \n\n';
        content += '- ** **: `/rules list` -  Rules  \n';
        content += '- ** Rules**: `/rules active` -  Rules  \n';
        content += '- ** Rules**: `/rules inactive` -  Rules  \n';
        content += '- **Rule **: `/rules activate ` -  Rule \n';
        content += '- **Rule **: `/rules deactivate ` -  Rule \n';
        content += '- **Rule **: `/rules create ` -  Rule \n';
        content += '- **Rule **: `/rules delete ` -  Rule \n';
        content += '- **Rule  **: `/rules open ` -  Rule  \n';
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rules     : ${error instanceof Error ? error.message : String(error)}`);
    }
}


/***/ }),

/***/ "./src/core/commands/slashCommandManager.ts":
/*!**************************************************!*\
  !*** ./src/core/commands/slashCommandManager.ts ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   SlashCommandManager: () => (/* binding */ SlashCommandManager)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _defaultCommands__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./defaultCommands */ "./src/core/commands/defaultCommands.ts");
/* harmony import */ var _helpRenderer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpRenderer */ "./src/core/commands/helpRenderer.ts");
/**
 *   
 *
 *   (/)    
 */





/**
 *    
 */
class SlashCommandManager {
    context;
    llmService;
    services;
    //   
    commands = new Map();
    //   
    aliasMap = new Map();
    //    (  ->   )
    koreanCommandMap = new Map();
    //    ( intentMap)
    intentMap = {};
    //  
    _onDidSuggestCommands = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    /**
     *   
     */
    onDidSuggestCommands = this._onDidSuggestCommands.event;
    /**
     * 
     */
    constructor(context, llmService, services) {
        this.context = context;
        this.llmService = llmService;
        this.services = services;
        //    (  )
        (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.setExtensionContext)();
        //   
        this.registerDefaultCommands();
        //  
        this.registerVSCodeCommands();
    }
    /**
     *   
     */
    registerDefaultCommands() {
        (0,_defaultCommands__WEBPACK_IMPORTED_MODULE_3__.createDefaultCommands)(this.services).forEach(command => {
            this.registerCommand(command);
        });
    }
    /**
     * VS Code  
     */
    registerVSCodeCommands() {
        //   
        const showHelpCommand = vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.showCommandHelp', (category) => {
            this.showCommandHelp(category);
        });
        // 'executeSlashCommand' CommandManager    
        //     
        // Git   
        const showGitStatus = vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.git.showStatus', () => {
            this.showGitStatus();
        });
        //   
        this.context.subscriptions.push(showHelpCommand, showGitStatus);
    }
    /**
     *  
     */
    registerCommand(command) {
        //   
        this.commands.set(command.name, command);
        //  
        if (command.aliases) {
            command.aliases.forEach(alias => {
                this.aliasMap.set(alias, command.name);
            });
        }
        // BilingualCommand    
        if (this.isBilingualCommand(command)) {
            this.registerBilingualCommand(command);
        }
    }
    /**
     *    
     * BilingualCommand       .
     */
    registerBilingualCommand(command) {
        //     ( )
        if (command.koreanName) {
            this.koreanCommandMap.set(command.koreanName, command.name);
            //   
            this.intentMap[command.koreanName] = command.name;
        }
        //   
        if (command.koreanAliases) {
            command.koreanAliases.forEach(alias => {
                this.koreanCommandMap.set(alias, command.name);
                //   
                this.intentMap[alias] = command.name;
            });
        }
        //    ( )
        if (command.intentMap) {
            //     
            Object.entries(command.intentMap).forEach(([intent, cmd]) => {
                this.intentMap[intent] = cmd;
            });
        }
    }
    /**
     *  BilingualCommand   
     */
    isBilingualCommand(command) {
        return ('koreanName' in command ||
            'koreanAliases' in command ||
            'koreanDescription' in command ||
            'koreanExamples' in command ||
            'intentMap' in command);
    }
    /**
     *   
     */
    getAllCommands() {
        return Array.from(this.commands.values());
    }
    /**
     *   
     */
    getCommand(name) {
        //    
        if (this.commands.has(name)) {
            return this.commands.get(name);
        }
        //  
        const originalName = this.aliasMap.get(name);
        if (originalName) {
            return this.commands.get(originalName);
        }
        return undefined;
    }
    /**
     *   
     *
     *          .
     * @param name   
     * @param maxDistance    (: 2)
     * @returns     ( )
     */
    findSimilarCommands(name, maxDistance = 2) {
        const result = [];
        //     
        for (const command of this.getAllCommands()) {
            //   
            const distance = this.levenshteinDistance(name, command.name);
            if (distance <= maxDistance) {
                result.push({ command, distance });
            }
            //  
            if (command.aliases) {
                for (const alias of command.aliases) {
                    const aliasDistance = this.levenshteinDistance(name, alias);
                    if (aliasDistance <= maxDistance && aliasDistance < distance) {
                        //      
                        const existing = result.findIndex(r => r.command === command);
                        if (existing >= 0) {
                            result[existing].distance = aliasDistance;
                        }
                        else {
                            result.push({ command, distance: aliasDistance });
                        }
                    }
                }
            }
        }
        //    (  )
        return result.sort((a, b) => a.distance - b.distance);
    }
    /**
     *   
     *
     *      .    .
     * @param a   
     * @param b   
     * @returns  
     */
    levenshteinDistance(a, b) {
        //     
        a = a.toLowerCase().trim();
        b = b.toLowerCase().trim();
        if (a === b)
            return 0;
        if (a.length === 0)
            return b.length;
        if (b.length === 0)
            return a.length;
        //  
        const matrix = Array(a.length + 1).fill(null).map(() => Array(b.length + 1).fill(null));
        //    
        for (let i = 0; i <= a.length; i++) {
            matrix[i][0] = i;
        }
        for (let j = 0; j <= b.length; j++) {
            matrix[0][j] = j;
        }
        //  
        for (let i = 1; i <= a.length; i++) {
            for (let j = 1; j <= b.length; j++) {
                const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // 
                matrix[i][j - 1] + 1, // 
                matrix[i - 1][j - 1] + cost // 
                );
            }
        }
        return matrix[a.length][b.length];
    }
    /**
     *      ( )
     *
     *        .
     *        .
     * @param input   ( )
     * @returns    undefined
     */
    matchCommandByIntent(input) {
        //     
        const intentMap = {
            //  
            '': 'help', //      
            '': 'help', //     
            '': 'help', //   
            '': 'help', //    
            '': 'help', //    
            '': 'help', //   
            '': 'help', //   
            '': 'help', //   
            '': 'help', //   
            '': 'help', //   
            '': 'help', //    
            '': 'help', //    
            '': 'help', //   
            '': 'help', //   
            '': 'help', //   
            '': 'help', //   
            '': 'help', //    
            '': 'help', //    
            '': 'help', //   
            '': 'help', //   
            '': 'help', //     ()
            '': 'help', //     ()
            '': 'help', //     ()
            '': 'help', //     ()
            '': 'help', //     ()
            //  
            '': 'memory', //    
            '': 'memory', //    
            '': 'memory', //    
            '': 'memory', //    
            '': 'memory', //    
            '': 'memory', //    
            '': 'memory', //     
            '': 'memory', //     
            '': 'memory', //    
            '': 'memory', //    
            '': 'memory', //    
            '': 'memory', //    
            '': 'memory', //    
            '': 'memory', //    
            '': 'memory', //    
            '': 'memory', //     
            // VAULT  ( )
            '': 'vault', //   vault
            '': 'vault', //   vault
            '': 'vault', //   vault
            '': 'vault', //   vault
            '': 'vault', //   vault
            '': 'vault', //   vault
            '': 'vault save', //   vault save
            '': 'vault list', //   vault list
            '': 'vault list', //   vault list
            '': 'vault show', //   vault show
            '': 'vault save', //   vault save
            '': 'vault search', //   vault search
            '': 'vault search', //   vault search
            '': 'vault search', //   vault search
            '': 'vault create', //   vault create
            '': 'vault create', //   vault create
            '': 'vault create', //   vault create
            '': 'vault delete', //   vault delete
            '': 'vault delete', //   vault delete
            '': 'vault delete', //   vault delete
            '': 'vault use', //   vault use
            '': 'vault use', //   vault use
            '': 'vault use', //   vault use
            // Git 
            '': 'git status', //    git status
            '': 'git status', //   git status
            '': 'git commit', //    git commit
            '': 'git commit', //   git commit
            '': 'git push', //   git push
            '': 'git pull', //   git pull
            '': 'git solve', //   git solve
            '': 'git auto', //   git auto
            '': 'git status', //   git status
            '': 'git status', //    git status
            '': 'git commit', //    git commit
            '': 'git push', //    git push
            '': 'git pull', //    git pull
            '': 'git solve', //    git solve
            '': 'git push', //    git push
            '': 'git merge', //    git merge
            '': 'git branch', //    git branch
            '': 'git checkout', //    git checkout
            '': 'git log', //    git log
            '': 'git log', //    git log
            '': 'git log', //    git log
            '': 'git add', //    git add
            '': 'git add', //    git add
            '': 'git status', //     git status ()
            '': 'git status', //     git status ()
            '': 'git status', //    git status ()
            '': 'git commit', //    git commit ()
            '': 'git commit', //    git commit ()
            '': 'git commit', //    git commit ()
            '': 'git branch', //    git branch ()
            '': 'git branch', //    git branch ()
            '': 'git solve', //    git solve ()
            '': 'git push', //     git push ()
            //  
            '': 'open', //    open
            '': 'open', //   open
            '': 'open', //   open
            '': 'open', //    open
            '': 'open', //    open
            '': 'open', //    open
            '': 'open', //    open
            '': 'open', //    open
            '': 'open', //    open
            '': 'open', //   open
            '': 'open', //    open
            '': 'open', //     open
            '': 'open', //     open
            '': 'open', //    open
            '': 'open', //    open
            '': 'open', //     open ()
            '': 'open', //    open ()
            '': 'open', //     open ()
            '': 'open', //    open ()
            '': 'open', //    open ()
            '': 'open', //    open ()
            '': 'open', //    open ()
            //  
            '': 'execute', //   execute
            '': 'execute', //   execute
            '': 'execute', //   execute
            '': 'execute', //    execute
            '': 'execute', //   execute
            '': 'execute', //   execute
            '': 'execute', //   execute
            '': 'execute', //   execute
            '': 'execute', //   execute
            '': 'execute', //    execute
            '': 'execute', //    execute
            '': 'execute', //    execute
            '': 'execute', //    execute
            '': 'execute', //    execute
            //  
            '': 'analyze', //   analyze
            '': 'analyze', //   analyze
            '': 'analyze', //   analyze
            '': 'analyze', //   analyze
            '': 'analyze', //   analyze
            '': 'analyze', //   analyze
            '': 'analyze', //    analyze
            '': 'analyze', //   analyze
            '': 'analyze', //   analyze
            '': 'analyze', //   analyze
            '': 'analyze', //   analyze
            '': 'analyze', //    analyze
            '': 'analyze', //    analyze
            '': 'analyze', //   analyze
            '': 'analyze', //   analyze
            '': 'analyze', //   analyze
            '': 'analyze', //   analyze
            '': 'analyze', //    analyze
            '': 'analyze', //   analyze
            '': 'analyze', //    analyze ()
            '': 'analyze', //    analyze ()
            '': 'analyze', //    analyze ()
            '': 'analyze', //    analyze ()
            '': 'analyze', //    analyze ()
            '': 'analyze', //     analyze ()
            '': 'analyze', //    analyze ()
            '': 'analyze', //    analyze ()
            '': 'analyze', //    analyze ()
            '': 'analyze', //    analyze ()
            //    
            '': 'model', //    model
            '': 'model', //   model
            '': 'settings', //    settings
            '': 'settings', //   settings
            '': 'settings', //   settings
            '': 'settings', //   settings
            '': 'model', //    model
            '': 'model list', //    model list
            '': 'settings', //    settings
            '': 'model', //    model
            '': 'model', // AI   model
            '': 'model', //    model
            '': 'model', //    model
            '': 'settings', //    settings
            '': 'settings', //    settings
            '': 'settings', //    settings
            '': 'settings', //    settings
            '': 'settings', //   settings
            '': 'model list', //    model list
            '': 'model list', //    model list
            '': 'model', //    model
            //  
            '': 'search', //   search
            '': 'search', //   search
            '': 'search', //   search
            '': 'search', //   search
            '': 'search', //   search
            '': 'search', //    search
            '': 'search', //   search
            '': 'search', //    search
            '': 'search', //   search
            '': 'search', //    search
            '': 'search', //    search
            '': 'search', //    search
            '': 'search', //    search
            '': 'search', //    search
            '': 'search', //    search
            '': 'search', //   search
            '': 'search', //    search
            '': 'search', //   search
            //   
            '': 'status', //    status
            '': 'status', //   status
            '': 'clear', //   clear
            '': 'clear', //   clear
            '': 'clear', //   clear
            '': 'status', //    status
            '': 'status', //    status
            '': 'status', //    status
            '': 'clear', //    clear
            '': 'clear', //    clear
            '': 'clear', //    clear
            '': 'status', //    status
            '': 'status', //    status
            '': 'status', //    status
            '': 'status', //    status
            '': 'status', //    status
            '': 'status', //    status
            '': 'clear', //   clear
            '': 'clear', //   clear
            '': 'clear', //    clear
            '': 'clear', //    clear
            '': 'clear', //   clear
            '': 'clear', //   clear
            // JIRA 
            '': 'jira', //   jira
            '': 'jira issue', //    jira issue
            '': 'jira issue', //   jira issue
            '': 'jira search', //    jira search
            '': 'jira list', //    jira list
            '': 'jira status', //    jira status
            '': 'jira update', //    jira update
            '': 'jira create', //    jira create
            '': 'jira create', //    jira create
            '': 'jira info', //    jira info
            // Todo 
            '': 'todo', //   todo
            '': 'todo', //   todo
            '': 'todo', //   todo
            '': 'todo', //   todo
            '': 'todo add', //    todo add
            '': 'todo list', //    todo list
            '': 'todo list', //    todo list
            '': 'todo list', //    todo list
            '': 'todo list', //    todo list
            '': 'todo', //    todo
            '': 'todo', //    todo
            '': 'todo', //    todo
            '': 'todo', //    todo
            '': 'todo add', //    todo add ()
            '': 'todo add', //    todo add ()
            '': 'todo add', //    todo add ()
            '': 'todo add', //    todo add ()
            '': 'todo delete', //    todo delete ()
            '': 'todo delete', //    todo delete ()
            '': 'todo delete', //    todo delete ()
            '': 'todo status', //    todo status ()
            '': 'todo status', //    todo status ()
            '': 'todo status', //    todo status ()
            '': 'todo status', //    todo status ()
            '': 'todo status', //    todo status ()
            '': 'todo status', //    todo status ()
            '': 'todo priority', //    todo priority ()
            '': 'todo priority', //    todo priority ()
            '': 'todo priority', //    todo priority ()
            //  /
            '': 'stack', //    stack
            '': 'stack', //    stack
            '': 'stack', //    stack
            '': 'stack', //    stack
            '': 'show', //    show
            '': 'show', //    show
            '': 'show', //    show
            '': 'show', //    show
            '': 'show', //    show
            '': 'show', //    show
            '': 'show', //    show
        };
        //   (    )
        const normalizedInput = input.substring(1).trim().toLowerCase();
        // 1.     
        for (const [intent, commandName] of Object.entries(intentMap)) {
            if (normalizedInput === intent) {
                return this.getCommand(commandName.split(' ')[0]);
            }
        }
        // 2.    (     )
        for (const [intent, commandName] of Object.entries(intentMap)) {
            if (normalizedInput.includes(intent)) {
                return this.getCommand(commandName.split(' ')[0]);
            }
        }
        // 3.     (: "  "  "")
        const normalizedWithoutSpaces = normalizedInput.replace(/\s+/g, '');
        for (const [intent, commandName] of Object.entries(intentMap)) {
            if (normalizedWithoutSpaces === intent || normalizedWithoutSpaces.includes(intent)) {
                return this.getCommand(commandName.split(' ')[0]);
            }
        }
        // 4.   - /    ( )
        if (/[\uAC00-\uD7AF]/.test(normalizedInput)) {
            //    
            const calculateSimilarity = (a, b) => {
                //   
                if (a === b)
                    return 1.0;
                if (a.length === 0 || b.length === 0)
                    return 0.0;
                //   
                const charsA = Array.from(a);
                const charsB = Array.from(b);
                //     
                //   
                const getInitialConsonant = (char) => {
                    if (!/^[-]$/.test(char))
                        return char;
                    const code = char.charCodeAt(0) - 0xAC00;
                    const consonantIndex = Math.floor(code / 28 / 21);
                    const consonants = [
                        '', '', '', '', '', '', '', '', '', '',
                        '', '', '', '', '', '', '', '', ''
                    ];
                    return consonants[consonantIndex];
                };
                //  
                const initialA = charsA.map(getInitialConsonant).join('');
                const initialB = charsB.map(getInitialConsonant).join('');
                //    (: 0.3)
                const initialScore = initialA === initialB ? 0.3 : 0;
                //   n-gram  (1-gram, 2-gram)
                const generateNgrams = (str, n) => {
                    const ngrams = [];
                    for (let i = 0; i <= str.length - n; i++) {
                        ngrams.push(str.substring(i, i + n));
                    }
                    return ngrams;
                };
                // 1-gram ()  (: 0.3)
                const chars1A = new Set(charsA);
                const chars1B = new Set(charsB);
                const charIntersection = new Set([...chars1A].filter(x => chars1B.has(x)));
                const charUnion = new Set([...chars1A, ...chars1B]);
                const charScore = charIntersection.size / charUnion.size * 0.3;
                // 2-gram ( )  (: 0.4)
                const bigrams2A = new Set(generateNgrams(a, 2));
                const bigrams2B = new Set(generateNgrams(b, 2));
                const bigramIntersection = new Set([...bigrams2A].filter(x => bigrams2B.has(x)));
                const bigramUnion = new Set([...bigrams2A, ...bigrams2B]);
                const bigramScore = bigrams2A.size > 0 && bigrams2B.size > 0 ?
                    bigramIntersection.size / bigramUnion.size * 0.4 : 0;
                //   -     (: 0.2)
                const lengthScore = 1 - (Math.abs(a.length - b.length) / Math.max(a.length, b.length, 1)) * 0.2;
                //   -     
                const prefixBonus = a.startsWith(b.charAt(0)) || b.startsWith(a.charAt(0)) ? 0.1 : 0;
                //   
                return Math.min(1.0, initialScore + charScore + bigramScore + lengthScore + prefixBonus);
            };
            const similarityThreshold = 0.45; //   ( )
            let bestMatch = null;
            for (const [intent, commandName] of Object.entries(intentMap)) {
                const similarity = calculateSimilarity(normalizedInput, intent);
                if (similarity >= similarityThreshold && (!bestMatch || similarity > bestMatch.similarity)) {
                    bestMatch = { intent, command: commandName, similarity };
                }
            }
            if (bestMatch) {
                console.log(`   (): "${normalizedInput}"  "${bestMatch.intent}" (${bestMatch.similarity.toFixed(2)})`);
                return this.getCommand(bestMatch.command.split(' ')[0]);
            }
        }
        return undefined;
    }
    /**
     *  
     */
    async executeCommand(input) {
        //   
        if (!input.startsWith('/') && !input.startsWith('@')) {
            return false;
        }
        //   
        const trimmedInput = input.trim();
        const parts = trimmedInput.split(' ');
        // @   ( )
        if (trimmedInput.startsWith('@')) {
            const specialCommand = parts[0].substring(1); // @ 
            //   @ 
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`'@${specialCommand}'    .`);
            return false;
        }
        //    
        const commandName = parts[0].substring(1); //  
        const args = parts.slice(1);
        // 1.    
        let command = this.getCommand(commandName);
        // 2.        
        if (!command && /[\uAC00-\uD7AF]/.test(commandName)) {
            command = this.matchCommandByIntent(trimmedInput);
        }
        // 3.    
        if (!command) {
            //   
            const similarCommands = this.findSimilarCommands(commandName);
            if (similarCommands.length > 0 && similarCommands[0].distance <= 1) {
                //      ( )
                const closestCommand = similarCommands[0].command;
                const result = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(` '/${commandName}'   . '/${closestCommand.name}' ?`, '', '');
                if (result === '') {
                    //     
                    try {
                        await closestCommand.execute({
                            extensionContext: this.context,
                            args,
                            originalInput: `/${closestCommand.name} ${args.join(' ')}`.trim()
                        });
                        return true;
                    }
                    catch (error) {
                        console.error(`Error executing command /${closestCommand.name}:`, error);
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`  : /${closestCommand.name}`);
                        return true; //   ( )
                    }
                }
                else {
                    //   - LLM     
                    if (this.llmService) {
                        await this.handleUnknownCommandWithSuggestions(commandName, trimmedInput, similarCommands);
                        return true; //   ( )
                    }
                    else {
                        this.showSimilarCommandSuggestions(commandName, similarCommands);
                        return false;
                    }
                }
            }
            else {
                //       
                if (this.llmService) {
                    await this.handleUnknownCommandWithSuggestions(commandName, trimmedInput, similarCommands);
                    return true; //   ( )
                }
                else {
                    if (similarCommands.length > 0) {
                        this.showSimilarCommandSuggestions(commandName, similarCommands);
                    }
                    else {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`   : /${commandName}`);
                    }
                    return false;
                }
            }
        }
        //  
        try {
            await command.execute({
                extensionContext: this.context,
                args,
                originalInput: trimmedInput
            });
            return true;
        }
        catch (error) {
            console.error(`Error executing command /${commandName}:`, error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`  : /${commandName}`);
            return true; //   ( )
        }
    }
    /**
     *     
     */
    showSimilarCommandSuggestions(commandName, similarCommands) {
        if (similarCommands.length === 0) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`   : /${commandName}`);
            return;
        }
        //  3 
        const suggestionsLimit = Math.min(3, similarCommands.length);
        const suggestions = similarCommands.slice(0, suggestionsLimit);
        //  
        const message = ` '/${commandName}'   .  ?`;
        //  
        const buttons = suggestions.map(s => `/${s.command.name}`);
        //  
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(message, ...buttons)
            .then(selected => {
            if (selected) {
                //   
                this.executeCommand(selected);
            }
        });
    }
    /**
     *      - LLM    
     * @param commandName     
     * @param originalInput  
     */
    async handleUnknownCommand(commandName, originalInput) {
        try {
            // 1.   
            const helpData = await this.loadHelpData();
            // 2.   
            const guideData = await this.loadGuideData();
            // 3. LLM  
            const prompt = this.generateUnknownCommandPrompt(commandName, originalInput, helpData, guideData);
            // 4. LLM  
            const result = await this.llmService.getCompletion(prompt);
            if (!result.success || !result.data) {
                throw new Error(result.error?.message || 'LLM    .');
            }
            // 5. LLM    UI  (WebView  )
            await this.showLlmResponsePanel(' ', result.data);
        }
        catch (error) {
            console.error('     :', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`'/${commandName}'     .   .`);
            //      
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.showCommandHelp');
        }
    }
    /**
     *      -     LLM 
     * @param commandName     
     * @param originalInput  
     * @param similarCommands   
     */
    async handleUnknownCommandWithSuggestions(commandName, originalInput, similarCommands) {
        try {
            // 1.   
            const helpData = await this.loadHelpData();
            // 2.   
            const guideData = await this.loadGuideData();
            // 3. LLM   (   )
            const prompt = this.generateUnknownCommandPromptWithSuggestions(commandName, originalInput, helpData, guideData, similarCommands);
            // 4. LLM  
            const result = await this.llmService.getCompletion(prompt);
            if (!result.success || !result.data) {
                throw new Error(result.error?.message || 'LLM    .');
            }
            // 5. LLM    UI  (WebView  )
            await this.showLlmResponsePanel(' ', result.data);
        }
        catch (error) {
            console.error('     :', error);
            //        
            this.showSimilarCommandSuggestions(commandName, similarCommands);
            //     
            // await vscode.commands.executeCommand('ape.showCommandHelp');
        }
    }
    /**
     *   
     */
    async loadHelpData() {
        try {
            const extensionPath = this.context.extensionPath;
            const helpFilePath = path__WEBPACK_IMPORTED_MODULE_1__.join(extensionPath, 'src', 'data', 'help.json');
            const helpDataStr = fs__WEBPACK_IMPORTED_MODULE_2__.readFileSync(helpFilePath, 'utf8');
            return JSON.parse(helpDataStr);
        }
        catch (error) {
            console.error('   :', error);
            return {};
        }
    }
    /**
     *   
     */
    async loadGuideData() {
        try {
            const extensionPath = this.context.extensionPath;
            const guideFilePath = path__WEBPACK_IMPORTED_MODULE_1__.join(extensionPath, 'src', 'data', 'guide.json');
            const guideDataStr = fs__WEBPACK_IMPORTED_MODULE_2__.readFileSync(guideFilePath, 'utf8');
            return JSON.parse(guideDataStr);
        }
        catch (error) {
            console.error('   :', error);
            return {};
        }
    }
    /**
     *       LLM  
     */
    generateUnknownCommandPrompt(commandName, originalInput, helpData, guideData) {
        return `
# APE     

 APE(Agentic Pipeline Extension)  .             .

##  

     : \`${originalInput}\`

##  

${JSON.stringify(helpData, null, 2)}

##  

${JSON.stringify(guideData, null, 2)}

##  

1.     .       .
2.      . 
3.    "", ""       .
4.       (: "Git  ?", "Jira  ?" ).
5.    :

---
###  

[      -       ]

###  

- **[1]**: []
- **[2]**: []
- **[3]**: []

###  

- [1]
- [2]
- [3]

---

 .
`;
    }
    /**
     *           
     */
    generateUnknownCommandPromptWithSuggestions(commandName, originalInput, helpData, guideData, similarCommands) {
        //    
        const similarCommandsInfo = similarCommands.map(sc => ({
            name: sc.command.name,
            description: sc.command.description,
            category: sc.command.category,
            aliases: sc.command.aliases || [],
            examples: sc.command.examples || [],
            distance: sc.distance
        }));
        return `
# APE      ( )

 APE(Agentic Pipeline Extension)  .             .

##  

     : \`${originalInput}\`

##  

${JSON.stringify(helpData, null, 2)}

##  

${JSON.stringify(guideData, null, 2)}

##   (  )

${JSON.stringify(similarCommandsInfo, null, 2)}

##  

1.     .       .
2.           .
3.        . (: "/gti status" "/git status"  )
4.    "", ""       .
5.        ,     .
6.      .
7.      .
8.    :

---
###  

[      -       ]

###  

- **[1]**: [] [     ]
- **[2]**: []
- **[3]**: []

###  

- [1]
- [2]
- [3]

---

 .
`;
    }
    /**
     * LLM  WebView  
     */
    async showLlmResponsePanel(title, content) {
        // WebView  
        const panel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createWebviewPanel('apeLlmResponse', title, vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.One, {
            enableScripts: true,
            localResourceRoots: [vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this.context.extensionUri, 'media')]
        });
        // LLM    (  )
        const commandRegex = /\*\*\/([\p{L}\p{N}-]+)(?:\s+[\p{L}\p{N}-]+)*\*\*/gu;
        const extractedCommands = [];
        let match;
        while ((match = commandRegex.exec(content)) !== null) {
            extractedCommands.push(`/${match[1]}`);
        }
        //  
        const questionRegex = /- ([^-\n]+)/g;
        const extractedQuestions = [];
        match = null;
        while ((match = questionRegex.exec(content)) !== null) {
            const question = match[1].trim();
            if (question && !question.startsWith('/')) {
                extractedQuestions.push(question);
            }
        }
        //  HTML 
        panel.webview.html = this.getLlmResponseHtml(content, extractedCommands, extractedQuestions);
        //   
        panel.webview.onDidReceiveMessage(async (message) => {
            if (message.type === 'executeCommand') {
                //  
                await this.executeCommand(message.command);
            }
            else if (message.type === 'insertToChat') {
                //     ( )
                vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.insertToChatInput', message.text);
            }
        });
    }
    /**
     * LLM  HTML 
     */
    getLlmResponseHtml(content, commands, questions) {
        //  HTML 
        const markdownContent = content
            //  
            .replace(/^### (.*$)/gm, '<h3>$1</h3>')
            .replace(/^## (.*$)/gm, '<h2>$1</h2>')
            .replace(/^# (.*$)/gm, '<h1>$1</h1>')
            //    
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/`(.*?)`/g, '<code>$1</code>')
            //  
            .replace(/^- (.*$)/gm, '<li>$1</li>')
            .replace(/(<li>.*<\/li>\n)+/g, '<ul>$&</ul>');
        //     HTML 
        let commandsHtml = '';
        if (commands.length > 0) {
            commandsHtml = `
        <div class="command-buttons">
          <h3>  </h3>
          <div class="button-container">
            ${commands.map(cmd => `
              <button class="command-button" onclick="executeCommand('${cmd}')">${cmd}</button>
            `).join('')}
          </div>
        </div>
      `;
        }
        let questionsHtml = '';
        if (questions.length > 0) {
            questionsHtml = `
        <div class="question-buttons">
          <h3> </h3>
          <div class="button-container">
            ${questions.map(q => `
              <button class="question-button" onclick="insertToChat('${q.replace(/'/g, "\\'")}')">${q}</button>
            `).join('')}
          </div>
        </div>
      `;
        }
        return `
      <!DOCTYPE html>
      <html lang="ko">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>APE  </title>
        <style>
          :root {
            --bg-color: var(--vscode-editor-background, #1e1e1e);
            --text-color: var(--vscode-editor-foreground, #d4d4d4);
            --link-color: var(--vscode-textLink-foreground, #3794ff);
            --button-bg: var(--vscode-button-background, #0e639c);
            --button-fg: var(--vscode-button-foreground, white);
            --button-hover-bg: var(--vscode-button-hoverBackground, #1177bb);
            --code-bg: var(--vscode-textBlockQuote-background, #2a2d2e);
          }
          
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
          }
          
          h1, h2, h3 {
            margin-top: 20px;
            margin-bottom: 10px;
          }
          
          ul {
            margin-bottom: 20px;
          }
          
          code {
            background-color: var(--code-bg);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
          }
          
          .content {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
          }
          
          .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
          }
          
          .command-button, .question-button {
            background-color: var(--button-bg);
            color: var(--button-fg);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
          }
          
          .command-button:hover, .question-button:hover {
            background-color: var(--button-hover-bg);
          }
          
          .question-button {
            background-color: var(--vscode-badge-background, #4d4d4d);
          }
          
          .question-button:hover {
            background-color: var(--vscode-list-hoverBackground, #2a2d2e);
          }
        </style>
      </head>
      <body>
        <div class="content">
          ${markdownContent}
        </div>
        
        ${commandsHtml}
        ${questionsHtml}
        
        <script>
          const vscode = acquireVsCodeApi();
          
          function executeCommand(command) {
            vscode.postMessage({
              type: 'executeCommand',
              command: command
            });
          }
          
          function insertToChat(text) {
            vscode.postMessage({
              type: 'insertToChat',
              text: text
            });
          }
        </script>
      </body>
      </html>
    `;
    }
    /**
     *    
     */
    getCommandSuggestions(input = '') {
        //   
        const trimmedInput = input.trim();
        const isSlashCommand = trimmedInput.startsWith('/');
        //     
        if (!isSlashCommand && trimmedInput !== '') {
            return [];
        }
        //    
        const searchText = isSlashCommand ? trimmedInput.substring(1).toLowerCase() : '';
        //  
        return this.filterCommands(searchText);
    }
    /**
     *  
     */
    filterCommands(searchText) {
        const suggestions = [];
        for (const command of this.getAllCommands()) {
            //  
            if (searchText && !command.name.toLowerCase().includes(searchText)) {
                //  
                const hasMatchingAlias = command.aliases?.some(alias => alias.toLowerCase().includes(searchText));
                //    
                if (!hasMatchingAlias) {
                    continue;
                }
            }
            //   
            suggestions.push({
                label: `/${command.name}`,
                description: command.description,
                detail: command.examples ? `: ${command.examples.join(', ')}` : undefined,
                category: command.category,
                insertText: `/${command.name} `,
                iconPath: this.getIconForCategory(command.category)
            });
        }
        //    
        return suggestions.sort((a, b) => {
            //   
            const commandA = this.getCommand(a.label.substring(1));
            const commandB = this.getCommand(b.label.substring(1));
            //  
            const priorityA = commandA?.priority || 100;
            const priorityB = commandB?.priority || 100;
            if (priorityA !== priorityB) {
                return priorityA - priorityB;
            }
            //  
            return a.label.localeCompare(b.label);
        });
    }
    /**
     *   
     */
    getIconForCategory(category) {
        //    ThemeIcon 
        switch (category) {
            case 'general':
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('info');
            case 'git':
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('git-commit');
            case 'code':
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('code');
            case 'utility':
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('tools');
            case 'advanced':
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('settings-gear');
            default:
                return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon('symbol-event');
        }
    }
    /**
     *   
     */
    provideCompletions(input) {
        //   
        const trimmedInput = input.trim();
        if (!trimmedInput.startsWith('/')) {
            return [];
        }
        const parts = trimmedInput.split(' ');
        const commandName = parts[0].substring(1); //  
        const partialArg = parts.length > 1 ? parts[parts.length - 1] : '';
        //  
        const command = this.getCommand(commandName);
        if (!command || !command.provideCompletions) {
            return [];
        }
        //   
        return command.provideCompletions(partialArg);
    }
    /**
     *   
     *
     *       .
     */
    updateSuggestions(input) {
        const suggestions = this.getCommandSuggestions(input);
        this._onDidSuggestCommands.fire(suggestions);
    }
    /**
     *   
     *
     *  JSON    
     */
    async showCommandHelp(arg) {
        //   
        const helpPanel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createWebviewPanel('apeCommandHelp', 'APE ', vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.One, {
            enableScripts: true, //   (  )
            localResourceRoots: [vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this.context.extensionUri, 'media')]
        });
        //   
        helpPanel.webview.onDidReceiveMessage(async (message) => {
            if (message.type === 'command') {
                //    
                if (message.command.startsWith('help ')) {
                    //    
                    const helpArg = message.command.substring(5);
                    await this.processHelpCommand(helpPanel, helpArg);
                }
                else {
                    //     
                    await this.executeCommand(`/${message.command}`);
                }
            }
            else if (message.type === 'expandTreeView') {
                //    
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.focusTreeView');
            }
        });
        //    
        if (!arg) {
            //        
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)();
        }
        else if (arg.startsWith('guide ')) {
            //   
            const guideId = arg.substring(6);
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateGuideHtml)(guideId);
        }
        else if (arg === 'guides' || arg === 'guide') {
            //   
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateGuidesListHtml)();
        }
        else if (arg === 'faq') {
            // FAQ 
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateFaqHtml)();
        }
        else if (arg === 'tools') {
            // Agent   
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateToolsHelpHtml)();
        }
        else if (this.getCommand(arg)) {
            //    
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateCommandDetailHtml)(arg);
        }
        else if (arg.startsWith('search ')) {
            //   
            const query = arg.substring(7);
            if (this.llmService) {
                // LLM      
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateSmartHelpHtml)(query, this.llmService);
            }
            else {
                // LLM       
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)();
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage('    LLM    .');
            }
        }
        else {
            //       
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)(arg);
        }
    }
    /**
     *   
     *
     *       
     */
    async processHelpCommand(helpPanel, arg) {
        //     
        if (!arg) {
            //      
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)();
        }
        else if (arg.startsWith('guide ')) {
            //   
            const guideId = arg.substring(6);
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateGuideHtml)(guideId);
        }
        else if (arg === 'guides' || arg === 'guide') {
            //   
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateGuidesListHtml)();
        }
        else if (arg === 'faq') {
            // FAQ 
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateFaqHtml)();
        }
        else if (arg === 'tools') {
            // Agent   
            helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateToolsHelpHtml)();
        }
        else if (arg.startsWith('search ')) {
            //   
            const query = arg.substring(7);
            if (this.llmService) {
                // LLM      
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateSmartHelpHtml)(query, this.llmService);
            }
            else {
                // LLM       
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)();
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage('    LLM    .');
            }
        }
        else {
            //   
            const command = this.getCommand(arg);
            if (command) {
                //    
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateCommandDetailHtml)(arg);
            }
            else {
                //  
                helpPanel.webview.html = await (0,_helpRenderer__WEBPACK_IMPORTED_MODULE_4__.generateHelpHtml)(arg);
            }
        }
    }
    /**
     *   
     */
    getCategoryTitle(category) {
        switch (category) {
            case 'general':
                return ' ';
            case 'git':
                return 'Git  ';
            case 'code':
                return '  ';
            case 'utility':
                return ' ';
            case 'advanced':
                return ' ';
            default:
                return category;
        }
    }
    /**
     *   HTML 
     */
    getHelpPanelHtml(content) {
        return `
      <!DOCTYPE html>
      <html lang="ko">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>  </title>
        <style>
          body {
            font-family: var(--vscode-font-family, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif);
            padding: 0 20px;
            color: var(--vscode-foreground);
            font-size: var(--vscode-font-size);
            background-color: var(--vscode-editor-background);
          }
          h1 {
            border-bottom: 1px solid var(--vscode-panel-border);
            padding-bottom: 10px;
            color: var(--vscode-symbolIcon-classForeground);
          }
          h2 {
            margin-top: 20px;
            color: var(--vscode-symbolIcon-constantForeground);
            border-left: 3px solid var(--vscode-activityBarBadge-background);
            padding-left: 10px;
          }
          code {
            font-family: var(--vscode-editor-font-family, monospace);
            background-color: var(--vscode-textBlockQuote-background);
            padding: 2px 4px;
            border-radius: 3px;
          }
          .command-name {
            font-weight: bold;
            color: var(--vscode-symbolIcon-functionForeground);
          }
        </style>
      </head>
      <body>
        ${this.markdownToHtml(content)}
      </body>
      </html>
    `;
    }
    /**
     *  HTML  ( )
     */
    markdownToHtml(markdown) {
        return markdown
            //  
            .replace(/^# (.+)$/gm, '<h1>$1</h1>')
            .replace(/^## (.+)$/gm, '<h2>$1</h2>')
            .replace(/^### (.+)$/gm, '<h3>$1</h3>')
            //   
            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
            //   (,   )
            .replace(/\/([\p{L}\p{N}-]+)/gu, '<code>/$1</code>')
            //  
            .replace(/^- (.+)$/gm, '<li>$1</li>')
            .replace(/(<li>.*<\/li>\n)+/g, '<ul>$&</ul>')
            //  
            .replace(/\n\n/g, '</p><p>')
            .replace(/\n/g, '<br>')
            //  
            .replace(/^(.+?)(?=<\/p>|<h[1-6]|<ul>|$)/s, '<p>$1</p>');
    }
    /**
     * Git  
     */
    async showGitStatus() {
        try {
            // Git  API 
            const gitExtension = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('vscode.git')?.exports;
            if (!gitExtension) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Git   .');
                return;
            }
            const git = gitExtension.getAPI(1);
            if (!git) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Git API   .');
                return;
            }
            //   
            const repositories = git.repositories;
            if (repositories.length === 0) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('Git  .');
                return;
            }
            //    
            const repo = repositories[0];
            const state = repo.state;
            //   
            const changes = state.workingTreeChanges.length;
            const staged = state.indexChanges.length;
            const untracked = state.untrackedChanges.length;
            const statusMessage = `# Git  \n\n` +
                `- : **${state.HEAD?.name || 'detached HEAD'}**\n` +
                `- : **${changes}** \n` +
                `- : **${staged}** \n` +
                `-  : **${untracked}** \n\n` +
                `##  \n\n` +
                state.workingTreeChanges.map((c) => `- ${c.uri.fsPath.split('/').pop()} (${this.getChangeTypeLabel(c.status)})`).join('\n');
            //   
            const statusPanel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createWebviewPanel('apeGitStatus', 'Git ', vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.One, {
                enableScripts: false,
                localResourceRoots: []
            });
            statusPanel.webview.html = this.getHelpPanelHtml(statusMessage);
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Git   : ${error}`);
        }
    }
    /**
     *    
     */
    getChangeTypeLabel(status) {
        // Git   
        switch (status) {
            case 0: return ''; // Added
            case 1: return ''; // Modified
            case 2: return ''; // Deleted
            case 3: return ' '; // Renamed
            case 4: return ''; // Copied
            default: return '  ';
        }
    }
}


/***/ }),

/***/ "./src/core/commands/vaultCommands.ts":
/*!********************************************!*\
  !*** ./src/core/commands/vaultCommands.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createVaultCommands: () => (/* binding */ createVaultCommands)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _services_vaultService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/vaultService */ "./src/core/services/vaultService.ts");
/**
 * VAULT    
 */


/**
 * VAULT  
 * @param vaultService VAULT  
 */
function createVaultCommands(vaultService) {
    const commands = [];
    // VAULT  
    commands.push({
        name: 'vault',
        aliases: ['', '', 'ctx', 'context'],
        description: 'VAULT    ',
        examples: ['/vault list', '/vault show system-context', '/vault use system-item-1', '/vault create personal   '],
        category: 'utility',
        priority: 5,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand || subCommand === 'list' || subCommand === '') {
                //   
                await showContextList(vaultService);
            }
            else if (subCommand === 'show' || subCommand === '' || subCommand === 'view') {
                //     
                const id = context.args[1];
                if (!id) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ID ');
                    return;
                }
                await showContextOrItem(vaultService, id);
            }
            else if (subCommand === 'use' || subCommand === '') {
                //   (  )
                const itemId = context.args[1];
                if (!itemId) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('  ID ');
                    return;
                }
                await useVaultItem(vaultService, itemId);
            }
            else if (subCommand === 'create' || subCommand === '' || subCommand === 'new' || subCommand === '') {
                //     
                const type = context.args[1]?.toLowerCase();
                const name = context.args.slice(2).join(' ');
                if (!type || !name) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('   ');
                    return;
                }
                await createContextOrItem(vaultService, type, name);
            }
            else if (subCommand === 'delete' || subCommand === '' || subCommand === 'remove') {
                //    
                const id = context.args[1];
                if (!id) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ID ');
                    return;
                }
                await deleteContextOrItem(vaultService, id);
            }
            else if (subCommand === 'search' || subCommand === '') {
                //  
                const query = context.args.slice(1).join(' ');
                if (!query) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(' ');
                    return;
                }
                await searchVaultItems(vaultService, query);
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`   VAULT  : ${subCommand}`);
            }
        },
        provideCompletions: (partialArgs) => {
            const parts = partialArgs.split(' ');
            //     ( )
            if (parts.length <= 1) {
                const options = ['list', 'show', 'use', 'create', 'delete', 'search', '', '', '', '', '', ''];
                return options.filter(option => option.toLowerCase().startsWith(parts[0].toLowerCase() || ''));
            }
            //    
            if (parts.length === 2) {
                const subCommand = parts[0].toLowerCase();
                if (subCommand === 'create' || subCommand === '' || subCommand === 'new' || subCommand === '') {
                    //   
                    const typeOptions = ['system', 'project', 'personal', 'shared', 'template', '', '', '', '', ''];
                    return typeOptions.filter(option => option.toLowerCase().startsWith(parts[1].toLowerCase() || ''));
                }
                else if (subCommand === 'show' || subCommand === '' || subCommand === 'view' ||
                    subCommand === 'use' || subCommand === '' ||
                    subCommand === 'delete' || subCommand === '' || subCommand === 'remove') {
                    // / ID  -  vaultService  
                    //   
                    const idOptions = ['system-context', 'project-context', 'personal-context', 'shared-context', 'template-context',
                        'system-item-1', 'system-item-2', 'project-item-1', 'project-item-2', 'personal-item-1'];
                    return idOptions.filter(option => option.toLowerCase().startsWith(parts[1].toLowerCase() || ''));
                }
            }
            return [];
        }
    });
    return commands;
}
/**
 *   
 */
async function showContextList(vaultService, context) {
    try {
        const allContexts = vaultService.getAllContexts();
        if (allContexts.length === 0) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: 'VAULT   .'
            });
            return;
        }
        let content = '## VAULT  \n\n';
        //   
        const groupedContexts = {
            'system': [],
            'project': [],
            'personal': [],
            'shared': [],
            'template': []
        };
        allContexts.forEach((ctx) => {
            groupedContexts[ctx.type].push(ctx);
        });
        //  
        for (const [type, contexts] of Object.entries(groupedContexts)) {
            if (contexts.length > 0) {
                //   
                let typeKorean = '';
                switch (type) {
                    case 'system':
                        typeKorean = '';
                        break;
                    case 'project':
                        typeKorean = '';
                        break;
                    case 'personal':
                        typeKorean = '';
                        break;
                    case 'shared':
                        typeKorean = '';
                        break;
                    case 'template':
                        typeKorean = '';
                        break;
                    default: typeKorean = type;
                }
                content += `### ${typeKorean} \n\n`;
                contexts.forEach(context => {
                    content += `- **${context.name}** (ID: \`${context.id}\`): ${context.items.length} `;
                    if (context.description) {
                        content += ` - ${context.description}`;
                    }
                    content += '\n';
                    //    
                    if (context.items.length > 0) {
                        content += '  -  :\n';
                        context.items.forEach((item) => {
                            content += `    - ${item.name} (ID: \`${item.id}\`)`;
                            if (item.description) {
                                content += ` - ${item.description}`;
                            }
                            content += '\n';
                        });
                    }
                    content += '\n';
                });
            }
        }
        //    
        content += '\n###  \n\n';
        content += '-    : `/vault show [ID]`\n';
        content += '-   : `/vault show [ID]`\n';
        content += '-  : `/vault use [ID]`\n';
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        console.error('   :', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('     ');
    }
}
/**
 *     
 */
async function showContextOrItem(vaultService, id) {
    try {
        //   
        const context = vaultService.getContextById(id);
        if (context) {
            //   
            let content = `## : ${context.name}\n\n`;
            content += `- **ID**: \`${context.id}\`\n`;
            content += `- ****: ${getContextTypeKorean(context.type)}\n`;
            if (context.description) {
                content += `- ****: ${context.description}\n`;
            }
            content += `- ****: ${formatDate(context.createdAt)}\n`;
            content += `- ****: ${formatDate(context.updatedAt)}\n`;
            content += `- ** **: ${context.items.length}\n\n`;
            if (context.items.length > 0) {
                content += '###  \n\n';
                context.items.forEach((item) => {
                    content += `- **${item.name}** (ID: \`${item.id}\`)`;
                    if (item.description) {
                        content += ` - ${item.description}`;
                    }
                    content += '\n';
                });
            }
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content
            });
            return;
        }
        //  
        const allContexts = vaultService.getAllContexts();
        for (const context of allContexts) {
            const item = context.items.find((item) => item.id === id);
            if (item) {
                //   
                let content = `## : ${item.name}\n\n`;
                content += `- **ID**: \`${item.id}\`\n`;
                content += `- ****: ${context.name} (${getContextTypeKorean(context.type)})\n`;
                if (item.description) {
                    content += `- ****: ${item.description}\n`;
                }
                content += `- ****: ${formatDate(item.createdAt)}\n`;
                content += `- ****: ${formatDate(item.updatedAt)}\n`;
                if (item.tags && item.tags.length > 0) {
                    content += `- ****: ${item.tags.join(', ')}\n`;
                }
                content += '\n### \n\n';
                content += '```\n' + item.content + '\n```\n\n';
                content += '   `/vault use ' + item.id + '`  .';
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content
                });
                return;
            }
        }
        //     
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `ID \`${id}\`     .`
        });
    }
    catch (error) {
        console.error('/  :', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('       ');
    }
}
/**
 *   (  )
 */
async function useVaultItem(vaultService, itemId) {
    try {
        //  
        const allContexts = vaultService.getAllContexts();
        for (const context of allContexts) {
            const item = context.items.find((item) => item.id === itemId);
            if (item) {
                //   LLM 
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendUserMessage', {
                    content: item.content
                });
                return;
            }
        }
        //    
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `ID \`${itemId}\`    .`
        });
    }
    catch (error) {
        console.error('  :', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ');
    }
}
/**
 *     
 */
async function createContextOrItem(vaultService, typeStr, name) {
    try {
        //   
        let contextType;
        switch (typeStr.toLowerCase()) {
            case 'system':
            case '':
                contextType = _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.System;
                break;
            case 'project':
            case '':
                contextType = _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Project;
                break;
            case 'personal':
            case '':
                contextType = _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Personal;
                break;
            case 'shared':
            case '':
                contextType = _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Shared;
                break;
            case 'template':
            case '':
                contextType = _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Template;
                break;
            default:
                //  ID  (  )
                const context = vaultService.getContextById(typeStr);
                if (context) {
                    //   
                    await createItem(vaultService, context, name);
                    return;
                }
                //   
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ID');
                return;
        }
        //  
        await createContext(vaultService, contextType, name);
    }
    catch (error) {
        console.error('/  :', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('      ');
    }
}
/**
 *   
 */
async function createContext(vaultService, type, name) {
    try {
        //   
        const description = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: '   ()',
            placeHolder: '  '
        });
        //  
        const newContext = await vaultService.createContext(name, type, description);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `${getContextTypeKorean(type)}  "${name}" . (ID: \`${newContext.id}\`)`
        });
    }
    catch (error) {
        console.error('  :', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ');
    }
}
/**
 *   
 */
async function createItem(vaultService, context, name) {
    try {
        //   
        const description = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: '   ()',
            placeHolder: '  '
        });
        //   
        const tagsInput = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
            prompt: '  ( , )',
            placeHolder: 'tag1, tag2, tag3'
        });
        const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()) : undefined;
        //    ( )
        const document = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument({
            content: '',
            language: 'markdown'
        });
        const editor = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showTextDocument(document);
        //      
        const content = await new Promise(resolve => {
            const disposable = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidCloseTextDocument(closedDoc => {
                if (closedDoc === document) {
                    resolve(document.getText());
                    disposable.dispose();
                }
            });
        });
        if (!content.trim()) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('   .   .');
            return;
        }
        //  
        const newItem = await vaultService.createItem(context.id, {
            name,
            description,
            content,
            tags,
            contextType: context.type
        });
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `"${context.name}"  "${name}"  . (ID: \`${newItem.id}\`)`
        });
    }
    catch (error) {
        console.error('  :', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ');
    }
}
/**
 *    
 */
async function deleteContextOrItem(vaultService, id) {
    try {
        //  
        const context = vaultService.getContextById(id);
        if (context) {
            //   
            const confirmed = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage(`"${context.name}"  ?     ,     .`, { modal: true }, '');
            if (confirmed !== '') {
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: '  .'
                });
                return;
            }
            //  
            await vaultService.deleteContext(id);
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `"${context.name}"  .`
            });
            return;
        }
        //  
        const allContexts = vaultService.getAllContexts();
        for (const ctx of allContexts) {
            const itemIndex = ctx.items.findIndex((item) => item.id === id);
            if (itemIndex !== -1) {
                const item = ctx.items[itemIndex];
                //   
                const confirmed = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage(`"${item.name}"  ?     .`, { modal: true }, '');
                if (confirmed !== '') {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: '  .'
                    });
                    return;
                }
                //  
                await vaultService.deleteItem(ctx.id, id);
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: `"${item.name}"  .`
                });
                return;
            }
        }
        //     
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `ID \`${id}\`     .`
        });
    }
    catch (error) {
        console.error('/  :', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('      ');
    }
}
/**
 *  
 */
async function searchVaultItems(vaultService, query) {
    try {
        //  
        const items = vaultService.searchItems(query);
        if (items.length === 0) {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `"${query}"    .`
            });
            return;
        }
        //  
        let content = `## "${query}"  \n\n`;
        content += ` ${items.length}  .\n\n`;
        //   ()
        const groupedItems = {};
        items.forEach((item) => {
            if (!groupedItems[item.contextId || 'unknown']) {
                groupedItems[item.contextId || 'unknown'] = [];
            }
            groupedItems[item.contextId || 'unknown'].push(item);
        });
        //  
        for (const [contextId, ctxItems] of Object.entries(groupedItems)) {
            const context = vaultService.getContextById(contextId);
            if (context) {
                content += `### ${context.name} (${getContextTypeKorean(context.type)})\n\n`;
                ctxItems.forEach((item) => {
                    content += `- **${item.name}** (ID: \`${item.id}\`)`;
                    if (item.description) {
                        content += ` - ${item.description}`;
                    }
                    content += '\n';
                    if (item.tags && item.tags.length > 0) {
                        content += `  - : ${item.tags.join(', ')}\n`;
                    }
                    //    ( 100)
                    const previewContent = item.content.length > 100
                        ? item.content.substring(0, 100) + '...'
                        : item.content;
                    content += `  -  : ${previewContent.replace(/\n/g, ' ')}\n\n`;
                });
            }
        }
        content += '  `/vault show [ID]`  .';
        await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        console.error('  :', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    ');
    }
}
/**
 *     
 */
function getContextTypeKorean(type) {
    switch (type) {
        case _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.System: return '';
        case _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Project: return '';
        case _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Personal: return '';
        case _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Shared: return '';
        case _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Template: return '';
        default: return String(type);
    }
}
/**
 *  
 */
function formatDate(date) {
    const d = typeof date === 'string' ? new Date(date) : date;
    return d.toLocaleDateString() + ' ' + d.toLocaleTimeString();
}


/***/ }),

/***/ "./src/core/completion/inlineCompletionProvider.ts":
/*!*********************************************************!*\
  !*** ./src/core/completion/inlineCompletionProvider.ts ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InlineCompletionProvider: () => (/* binding */ InlineCompletionProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/**
 *   
 *
 * VS Code         
 */


/**
 *    
 */
class InlineCompletionProvider {
    llmService;
    context;
    completionCache = new Map();
    cacheTimeout = 5 * 60 * 1000; // 5
    requestQueue = new Map();
    completionConfig = {
        enabled: true,
        triggerLength: 3,
        debounceDelay: 300,
        maxLineContext: 10
    };
    //  
    debounceTimer = null;
    /**
     * 
     */
    constructor(llmService, context) {
        this.llmService = llmService;
        this.context = context;
        //  
        this.loadConfiguration();
        //   
        vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.completion')) {
                this.loadConfiguration();
            }
        });
    }
    /**
     *  
     */
    loadConfiguration() {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.completion');
        this.completionConfig = {
            enabled: config.get('inlineEnabled', true),
            triggerLength: config.get('triggerLength', 3),
            debounceDelay: config.get('debounceDelay', 300),
            maxLineContext: config.get('maxLineContext', 10)
        };
    }
    /**
     *   
     */
    async provideInlineCompletionItems(document, position, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _context, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _token) {
        //  
        if (!this.completionConfig.enabled) {
            return null;
        }
        //   
        const lineText = document.lineAt(position.line).text;
        const linePrefix = lineText.substring(0, position.character);
        //   (  )
        if (linePrefix.trim().length < this.completionConfig.triggerLength) {
            return null;
        }
        //     (  )
        if (this.shouldSkipCompletion(document, position)) {
            return null;
        }
        //   
        const cacheKey = `${document.fileName}:${position.line}:${position.character}:${lineText}`;
        //     
        const cachedResult = this.completionCache.get(cacheKey);
        if (cachedResult && Date.now() - cachedResult.timestamp < this.cacheTimeout) {
            return cachedResult.completions;
        }
        //        
        if (this.requestQueue.has(cacheKey)) {
            try {
                return await this.requestQueue.get(cacheKey);
            }
            catch (error) {
                console.error('     :', error);
                return null;
            }
        }
        //  
        if (this.debounceTimer) {
            clearTimeout(this.debounceTimer);
        }
        const completionPromise = new Promise((resolve) => {
            this.debounceTimer = setTimeout(async () => {
                try {
                    //  
                    const context = await this.getCompletionContext(document, position);
                    // LLM    
                    const completions = await this.requestInlineCompletions(context.precedingText, context.followingText, document.languageId);
                    //  
                    this.completionCache.set(cacheKey, {
                        completions,
                        timestamp: Date.now()
                    });
                    //   
                    this.requestQueue.delete(cacheKey);
                    resolve(completions);
                }
                catch (error) {
                    console.error('   :', error);
                    this.requestQueue.delete(cacheKey);
                    resolve([]);
                }
            }, this.completionConfig.debounceDelay);
        });
        //   
        this.requestQueue.set(cacheKey, completionPromise);
        return completionPromise;
    }
    /**
     *   
     */
    shouldSkipCompletion(document, position) {
        //      
        const lineText = document.lineAt(position.line).text;
        //       
        const isMdCodeBlock = document.languageId === 'markdown' &&
            (lineText.trim().startsWith('```') ||
                document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(Math.max(0, position.line - 3), 0), position)).includes('```'));
        //  
        const isInComment = this.isPositionInComment(document, position);
        return isMdCodeBlock || isInComment;
    }
    /**
     *      
     */
    isPositionInComment(document, position) {
        const lineText = document.lineAt(position.line).text;
        //    
        switch (document.languageId) {
            case 'typescript':
            case 'javascript':
            case 'typescriptreact':
            case 'javascriptreact':
            case 'csharp':
            case 'java':
            case 'cpp':
            case 'c': {
                //    
                if (lineText.substring(0, position.character).includes('//')) {
                    return true;
                }
                //     ( )
                const prevText = document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(0, 0), position));
                const commentStarts = (prevText.match(/\/\*/g) || []).length;
                const commentEnds = (prevText.match(/\*\//g) || []).length;
                return commentStarts > commentEnds;
            }
            case 'python':
                // Python 
                return lineText.substring(0, position.character).includes('#');
            case 'html':
            case 'xml': {
                // HTML/XML 
                const htmlPrev = document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(0, 0), position));
                const htmlCommentStarts = (htmlPrev.match(/<!--/g) || []).length;
                const htmlCommentEnds = (htmlPrev.match(/-->/g) || []).length;
                return htmlCommentStarts > htmlCommentEnds;
            }
        }
        return false;
    }
    /**
     *   
     */
    async getCompletionContext(document, position) {
        //   (  )
        const startLine = Math.max(0, position.line - this.completionConfig.maxLineContext);
        const precedingText = document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(startLine, 0), position));
        //   (    +   )
        const endLine = Math.min(document.lineCount - 1, position.line + 5);
        const followingText = document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(position, new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(endLine, document.lineAt(endLine).text.length)));
        return { precedingText, followingText };
    }
    /**
     * LLM    
     */
    async requestInlineCompletions(precedingText, followingText, languageId) {
        try {
            //  
            const prompt = `
    .  ${languageId}.
        .
         .
    .

  :
\`\`\`${languageId}
${precedingText}
\`\`\`

    ():
\`\`\`${languageId}
${followingText}
\`\`\`

    ( 3):
`;
            // LLM 
            const messages = [
                {
                    id: `msg_inline_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            const result = await this.llmService.sendRequest(messages);
            if (result.success && result.data) {
                //   InlineCompletionItem  
                return this.parseInlineCompletionResponse(result.data.content || '');
            }
            else {
                throw new Error('LLM  ');
            }
        }
        catch (error) {
            console.error('LLM    :', error);
            return [];
        }
    }
    /**
     * LLM  InlineCompletionItem 
     */
    parseInlineCompletionResponse(responseContent) {
        const completions = [];
        try {
            //   
            const codeBlockRegex = /```(?:\w+)?\n([\s\S]*?)```/g;
            const codeBlocks = [];
            let match;
            while ((match = codeBlockRegex.exec(responseContent)) !== null) {
                codeBlocks.push(match[1]);
            }
            if (codeBlocks.length > 0) {
                //   
                for (const block of codeBlocks) {
                    const lines = block.split('\n').filter(line => line.trim() !== '');
                    lines.forEach(line => {
                        if (line.trim()) {
                            completions.push({
                                insertText: line.trim(),
                                range: undefined
                            });
                        }
                    });
                }
            }
            else {
                //       
                const lines = responseContent.split('\n')
                    .filter(line => line.trim() !== '')
                    .filter(line => !line.startsWith('#') && !line.startsWith('-') && !line.startsWith('*'));
                lines.forEach(line => {
                    const cleanedLine = line.replace(/^\d+\.\s+/, '').trim();
                    if (cleanedLine) {
                        completions.push({
                            insertText: cleanedLine,
                            range: undefined
                        });
                    }
                });
            }
        }
        catch (error) {
            console.error('    :', error);
        }
        //  
        const uniqueCompletions = this.removeDuplicates(completions);
        return uniqueCompletions.slice(0, 3); //  3 
    }
    /**
     *  
     */
    removeDuplicates(completions) {
        const seen = new Set();
        return completions.filter(item => {
            if (item.insertText && !seen.has(item.insertText.toString())) {
                seen.add(item.insertText.toString());
                return true;
            }
            return false;
        });
    }
}


/***/ }),

/***/ "./src/core/completion/tabCompletionProvider.ts":
/*!******************************************************!*\
  !*** ./src/core/completion/tabCompletionProvider.ts ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TabCompletionProvider: () => (/* binding */ TabCompletionProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/**
 * Tab Completion Provider
 *
 *      
 */


/**
 *    
 */
class TabCompletionProvider {
    llmService;
    cachedCompletions = new Map();
    cacheTimeout = 30 * 60 * 1000; // 30
    suggestionCache = new Map();
    contextAwareCommands = new Map();
    /**
     * 
     */
    constructor(llmService) {
        this.llmService = llmService;
        //    
        this.initializeContextAwareCommands();
    }
    /**
     *    
     */
    initializeContextAwareCommands() {
        // Git  
        this.contextAwareCommands.set('git', [
            'commit',
            'push',
            'pull',
            'status',
            'solve',
            'branch',
            'auto',
            'consolidate'
        ]);
        // Jira  
        this.contextAwareCommands.set('jira', [
            'create',
            'list',
            'update',
            'comment',
            'assign'
        ]);
        //   
        this.contextAwareCommands.set('code', [
            'analyze',
            'review',
            'optimize',
            'refactor',
            'format'
        ]);
        // SWDP  
        this.contextAwareCommands.set('swdp', [
            'build',
            'deploy',
            'status',
            'verify',
            'list'
        ]);
    }
    /**
     *   
     */
    async provideCompletionItems(document, position, token, context) {
        //   TAB  
        if (context.triggerKind !== vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionTriggerKind.TriggerCharacter &&
            context.triggerKind !== vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionTriggerKind.Invoke) {
            return [];
        }
        //   
        const lineText = document.lineAt(position.line).text;
        const linePrefix = lineText.substring(0, position.character);
        //      
        if (this.isCommandCompletion(linePrefix)) {
            return this.provideCommandCompletions(linePrefix);
        }
        else {
            //   
            return this.provideCodeCompletions(document, position, linePrefix);
        }
    }
    /**
     *    
     */
    isCommandCompletion(linePrefix) {
        //  '/'  
        return linePrefix.trim().startsWith('/');
    }
    /**
     *    
     */
    provideCommandCompletions(linePrefix) {
        const commands = [
            { name: 'git', description: 'Git  ' },
            { name: 'commit', description: '  ' },
            { name: 'push', description: '  ' },
            { name: 'pull', description: '  ' },
            { name: 'status', description: 'Git  ' },
            { name: 'jira', description: 'JIRA  ' },
            { name: 'issue', description: 'JIRA  /' },
            { name: 'ticket', description: 'JIRA  ' },
            { name: 'help', description: ' ' },
            { name: 'todo', description: '  ' },
            { name: 'code', description: '   ' },
            { name: 'analyze', description: ' ' },
            { name: 'settings', description: ' ' },
            { name: 'theme', description: ' ' },
            { name: 'model', description: 'LLM  ' },
            { name: 'clear', description: '  ' },
            { name: 'swdp', description: 'SWDP  ' }
        ];
        //    
        const commandParts = linePrefix.trim().substring(1).split(/\s+/);
        const currentCommand = commandParts[0];
        //    
        const activeContext = this.getActiveContext();
        //   
        if (commandParts.length > 1 && !commandParts[1].startsWith('-')) {
            //      
            if (this.contextAwareCommands.has(currentCommand)) {
                const subCommands = this.contextAwareCommands.get(currentCommand) || [];
                return subCommands.map(subCmd => this.createCompletionItem(subCmd, `${currentCommand} ${subCmd} `, `/${currentCommand} ${subCmd}`));
            }
            //   
            switch (currentCommand) {
                case 'git':
                    return [
                        this.createCompletionItem('commit', '  ', '/git commit'),
                        this.createCompletionItem('push', '  ', '/git push'),
                        this.createCompletionItem('pull', '  ', '/git pull'),
                        this.createCompletionItem('status', ' Git  ', '/git status'),
                        this.createCompletionItem('solve', '  ', '/git solve'),
                        this.createCompletionItem('branch', ' //', '/git branch'),
                        this.createCompletionItem('auto', '  ', '/git auto'),
                        this.createCompletionItem('consolidate', '  ', '/git consolidate')
                    ];
                case 'jira':
                    return [
                        this.createCompletionItem('create', '  ', '/jira create'),
                        this.createCompletionItem('list', '  ', '/jira list'),
                        this.createCompletionItem('assign', ' ', '/jira assign'),
                        this.createCompletionItem('update', ' ', '/jira update'),
                        this.createCompletionItem('comment', '  ', '/jira comment')
                    ];
                case 'code':
                    return [
                        this.createCompletionItem('analyze', ' ', '/code analyze'),
                        this.createCompletionItem('review', ' ', '/code review'),
                        this.createCompletionItem('optimize', ' ', '/code optimize'),
                        this.createCompletionItem('refactor', ' ', '/code refactor'),
                        this.createCompletionItem('format', '  ', '/code format')
                    ];
                case 'swdp':
                    return [
                        this.createCompletionItem('build', ' ', '/swdp build'),
                        this.createCompletionItem('deploy', ' ', '/swdp deploy'),
                        this.createCompletionItem('status', ' ', '/swdp status'),
                        this.createCompletionItem('verify', ' ', '/swdp verify'),
                        this.createCompletionItem('list', ' ', '/swdp list')
                    ];
                case 'todo':
                    return [
                        this.createCompletionItem('add', '  ', '/todo add'),
                        this.createCompletionItem('list', '  ', '/todo list'),
                        this.createCompletionItem('done', '  ', '/todo done'),
                        this.createCompletionItem('delete', '  ', '/todo delete'),
                        this.createCompletionItem('prioritize', ' ', '/todo prioritize')
                    ];
            }
        }
        //      
        let filteredCommands = [...commands];
        if (activeContext) {
            //    : code   
            const codeRelatedCommands = ['code', 'analyze', 'review', 'optimize', 'refactor'];
            if (activeContext.hasTextSelection) {
                filteredCommands = [
                    ...filteredCommands.filter(cmd => codeRelatedCommands.includes(cmd.name)),
                    ...filteredCommands.filter(cmd => !codeRelatedCommands.includes(cmd.name))
                ];
            }
            // Git  : git   
            const gitRelatedCommands = ['git', 'commit', 'push', 'pull', 'status'];
            if (activeContext.isGitRepo) {
                filteredCommands = [
                    ...filteredCommands.filter(cmd => gitRelatedCommands.includes(cmd.name)),
                    ...filteredCommands.filter(cmd => !gitRelatedCommands.includes(cmd.name))
                ];
            }
        }
        //    
        return filteredCommands.map(cmd => this.createCompletionItem(cmd.name, cmd.description, '/' + cmd.name));
    }
    /**
     *   
     */
    getActiveContext() {
        try {
            const editor = vscode__WEBPACK_IMPORTED_MODULE_0__.window.activeTextEditor;
            return {
                hasTextSelection: !!(editor && !editor.selection.isEmpty),
                isGitRepo: this.isGitRepository()
            };
        }
        catch (error) {
            console.error('  :', error);
            return null;
        }
    }
    /**
     * Git  
     */
    isGitRepository() {
        try {
            //   
            const workspaceFolders = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                return false;
            }
            //  true  ( )
            //  .git     ,    
            return true;
        }
        catch (error) {
            console.error('Git   :', error);
            return false;
        }
    }
    /**
     *    
     */
    async provideCodeCompletions(document, position, linePrefix) {
        //    (  +  )
        const cacheKey = `${document.fileName}:${position.line}:${position.character}`;
        //     
        const cachedResult = this.suggestionCache.get(cacheKey);
        if (cachedResult && Date.now() - cachedResult.timestamp < this.cacheTimeout) {
            return cachedResult.suggestions;
        }
        try {
            //  
            //      ()
            // // const fileContent = document.getText();
            // // const cursorOffset = document.offsetAt(position);
            //     
            const precedingLines = document.getText(new vscode__WEBPACK_IMPORTED_MODULE_0__.Range(new vscode__WEBPACK_IMPORTED_MODULE_0__.Position(Math.max(0, position.line - 10), 0), position));
            //   
            const fileType = document.fileName.split('.').pop() || '';
            // LLM   
            const suggestions = await this.requestCodeCompletions(precedingLines, linePrefix, fileType);
            //  
            this.suggestionCache.set(cacheKey, {
                suggestions,
                timestamp: Date.now()
            });
            return suggestions;
        }
        catch (error) {
            console.error('  :', error);
            return [];
        }
    }
    /**
     * LLM    
     */
    async requestCodeCompletions(context, currentLine, fileType) {
        try {
            //  
            const prompt = `
    .   ${fileType}.
         .
    ,    .
 5   .

 :
\`\`\`${fileType}
${context}
\`\`\`

  (  |  ):
\`\`\`
${currentLine}|
\`\`\`

 :`;
            // LLM 
            const messages = [
                {
                    id: `msg_completion_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            const result = await this.llmService.sendRequest(messages);
            if (result.success && result.data) {
                //   CompletionItem  
                return this.parseCompletionResponse(result.data.content || '', currentLine);
            }
            else {
                throw new Error('LLM  ');
            }
        }
        catch (error) {
            console.error('LLM    :', error);
            return [];
        }
    }
    /**
     * LLM  CompletionItem 
     */
    parseCompletionResponse(responseContent, currentLine) {
        const completions = [];
        try {
            //    
            const codeBlockMatch = responseContent.match(/```(?:.*?)?\n([\s\S]*?)```/);
            const suggestions = codeBlockMatch
                ? codeBlockMatch[1].split('\n').filter(line => line.trim() !== '')
                : responseContent.split('\n').filter(line => line.trim() !== '');
            //    CompletionItem 
            suggestions.forEach((suggestion, index) => {
                //     
                suggestion = suggestion.replace(/^\d+\.\s+|^-\s+/, '').trim();
                if (suggestion) {
                    //     
                    const overlap = this.findOverlap(currentLine, suggestion);
                    const insertText = overlap > 0 ? suggestion.substring(overlap) : suggestion;
                    if (insertText.trim()) {
                        const item = new vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionItem(suggestion, vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionItemKind.Snippet);
                        item.insertText = insertText;
                        item.sortText = String(index).padStart(5, '0');
                        item.detail = '  ';
                        completions.push(item);
                    }
                }
            });
        }
        catch (error) {
            console.error('  :', error);
        }
        return completions;
    }
    /**
     *       
     */
    findOverlap(currentLine, suggestion) {
        let overlap = 0;
        //       
        for (let i = 1; i <= currentLine.length; i++) {
            const suffix = currentLine.substring(currentLine.length - i);
            if (suggestion.startsWith(suffix)) {
                overlap = suffix.length;
            }
        }
        return overlap;
    }
    /**
     * CompletionItem   
     */
    createCompletionItem(label, detail, insertText) {
        const item = new vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionItem(label, vscode__WEBPACK_IMPORTED_MODULE_0__.CompletionItemKind.Keyword);
        item.detail = detail;
        item.insertText = insertText;
        item.command = {
            command: 'editor.action.triggerSuggest',
            title: 'Re-trigger completions...'
        };
        return item;
    }
}


/***/ }),

/***/ "./src/core/git/autoCommitService.ts":
/*!*******************************************!*\
  !*** ./src/core/git/autoCommitService.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AutoCommitService: () => (/* binding */ AutoCommitService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);
/**
 * Auto Commit Service
 *
 *  ,   ,     
 */




const execAsync = (0,util__WEBPACK_IMPORTED_MODULE_3__.promisify)(child_process__WEBPACK_IMPORTED_MODULE_2__.exec);
/**
 *    
 */
class AutoCommitService {
    context;
    llmService;
    bitbucketService;
    workspaceRoot;
    statusBarItem;
    commitInProgress = false;
    disposables = [];
    gitWatcher;
    /**
     * 
     */
    constructor(context, llmService, bitbucketService) {
        this.context = context;
        this.llmService = llmService;
        this.bitbucketService = bitbucketService;
        //   
        this.workspaceRoot = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0]?.uri.fsPath;
        //    
        this.statusBarItem = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createStatusBarItem(vscode__WEBPACK_IMPORTED_MODULE_0__.StatusBarAlignment.Left, 100);
        this.statusBarItem.text = "$(git-commit)   ";
        this.statusBarItem.tooltip = "APE   ";
        this.statusBarItem.command = "ape.git.toggleAutoCommit";
        this.statusBarItem.show();
        //  
        this.registerCommands();
        // Git   
        this.setupGitWatcher();
    }
    /**
     *  
     */
    registerCommands() {
        //   
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.git.toggleAutoCommit', () => this.toggleAutoCommit()));
        //  
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.git.commit', () => this.createCommit()));
        //   
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.git.consolidateTemporaryCommits', () => this.consolidateTemporaryCommits()));
    }
    /**
     * Git   
     */
    setupGitWatcher() {
        if (!this.workspaceRoot) {
            return;
        }
        try {
            // .git/index   
            const gitIndexPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this.workspaceRoot, '.git', 'index');
            this.gitWatcher = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.createFileSystemWatcher(gitIndexPath);
            //     
            this.gitWatcher.onDidChange(() => {
                this.updateStatusBar();
            });
            this.disposables.push(this.gitWatcher);
            //   
            this.updateStatusBar();
            //    
            vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidSaveTextDocument(() => {
                //          
                void this.handleFileSaved();
            }, this, this.disposables);
        }
        catch (error) {
            // Git    
            console.log('Git  :', error);
        }
    }
    /**
     *   
     */
    async updateStatusBar() {
        if (!this.workspaceRoot) {
            this.statusBarItem.hide();
            return;
        }
        try {
            // Git  
            const { stdout } = await execAsync('git status --porcelain', { cwd: this.workspaceRoot });
            if (stdout.trim() === '') {
                //   
                this.statusBarItem.text = "$(git-commit)   ";
                this.statusBarItem.tooltip = "  ";
            }
            else {
                //    
                const changedFiles = stdout.split('\n').filter(line => line.trim() !== '').length;
                this.statusBarItem.text = `$(git-commit)   (${changedFiles})`;
                this.statusBarItem.tooltip = `${changedFiles}  `;
            }
            this.statusBarItem.show();
        }
        catch {
            // Git   
            this.statusBarItem.text = "$(git-commit) Git  ";
            this.statusBarItem.tooltip = "  Git  ";
            this.statusBarItem.show();
        }
    }
    /**
     *   
     */
    toggleAutoCommit() {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git');
        const current = config.get('autoCommit', false);
        //  
        config.update('autoCommit', !current, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Workspace).then(() => {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`  ${!current ? '' : ''}`);
            //   
            if (!current) {
                this.statusBarItem.text = "$(git-commit)   ";
                this.statusBarItem.backgroundColor = new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeColor('statusBarItem.warningBackground');
            }
            else {
                this.statusBarItem.text = "$(git-commit)   ";
                this.statusBarItem.backgroundColor = undefined;
            }
        });
    }
    /**
     *   
     */
    async handleFileSaved() {
        if (this.commitInProgress) {
            return;
        }
        //    
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git');
        const autoCommitEnabled = config.get('autoCommit', false);
        if (!autoCommitEnabled) {
            return;
        }
        //     (  )
        setTimeout(async () => {
            try {
                //   
                const { stdout } = await execAsync('git status --porcelain', { cwd: this.workspaceRoot });
                if (stdout.trim() !== '') {
                    //    
                    await this.createCommit();
                }
            }
            catch (error) {
                console.error('  :', error);
            }
        }, 2000); // 2 
    }
    /**
     *  
     */
    async createCommit() {
        if (!this.workspaceRoot || this.commitInProgress) {
            return;
        }
        this.commitInProgress = true;
        try {
            // Git  
            const { stdout: statusOutput } = await execAsync('git status --porcelain', { cwd: this.workspaceRoot });
            if (statusOutput.trim() === '') {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('   ');
                this.commitInProgress = false;
                return;
            }
            //   
            const changedFiles = statusOutput
                .split('\n')
                .filter(line => line.trim() !== '')
                .map(line => {
                const status = line.substring(0, 2).trim();
                const file = line.substring(3).trim();
                return { status, file };
            });
            //   
            const { stdout: diffOutput } = await execAsync('git diff --staged', { cwd: this.workspaceRoot });
            const unstaged = await execAsync('git diff', { cwd: this.workspaceRoot });
            try {
                //    
                let commitMessage = await this.generateCommitMessage(changedFiles, diffOutput + unstaged.stdout);
                //     
                const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git');
                const autoCommitEnabled = config.get('autoCommit', false);
                if (autoCommitEnabled) {
                    //    [APE][Temporary]  
                    commitMessage = `[APE][Temporary] ${commitMessage}`;
                }
                //   
                await execAsync('git add .', { cwd: this.workspaceRoot });
                //  
                await execAsync(`git commit -m "${commitMessage}"`, { cwd: this.workspaceRoot });
                //  
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(` : ${commitMessage}`);
                //  
                this.updateStatusBar();
            }
            catch (error) {
                //     
                const errorMessage = error.message || '   ';
                // BitBucket  Jira    API     
                if (errorMessage.includes('BitBucket') || errorMessage.includes('Jira')) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`  : ${errorMessage}.  .`);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(` : ${errorMessage}`);
                }
                // API  
                const openSettings = ' ';
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(' API    .  .', openSettings).then(selection => {
                    if (selection === openSettings) {
                        vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', 'ape.bitbucket');
                    }
                });
            }
        }
        catch (error) {
            // Git     (status , diff  )
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Git  : ${error.message}`);
        }
        finally {
            this.commitInProgress = false;
        }
    }
    /**
     *    
     */
    async generateCommitMessage(changedFiles, diff) {
        try {
            //  LLM   
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git');
            const useLLM = config.get('useLLMForCommitMessages', false);
            // LLM      
            if (useLLM && diff.length > 0) {
                try {
                    return await this.generateLLMCommitMessage(changedFiles, diff);
                }
                catch (error) {
                    console.error('LLM    :', error);
                    // LLM        
                }
            }
            //      
            let messagePrefix = '';
            //     
            const newFiles = changedFiles.filter(file => file.status.includes('A') || file.status.includes('?'));
            const modifiedFiles = changedFiles.filter(file => file.status.includes('M'));
            const deletedFiles = changedFiles.filter(file => file.status.includes('D'));
            if (newFiles.length > 0 && modifiedFiles.length === 0 && deletedFiles.length === 0) {
                messagePrefix = 'Add';
            }
            else if (modifiedFiles.length > 0 && newFiles.length === 0 && deletedFiles.length === 0) {
                messagePrefix = 'Update';
            }
            else if (deletedFiles.length > 0 && newFiles.length === 0 && modifiedFiles.length === 0) {
                messagePrefix = 'Remove';
            }
            else if (deletedFiles.length > 0 || newFiles.length > 0) {
                messagePrefix = 'Refactor';
            }
            else {
                messagePrefix = 'Fix';
            }
            //       
            const fileComponents = [];
            for (const file of changedFiles) {
                const ext = path__WEBPACK_IMPORTED_MODULE_1__.extname(file.file);
                const dir = path__WEBPACK_IMPORTED_MODULE_1__.dirname(file.file);
                //     
                if (ext && !fileComponents.includes(ext.substring(1))) {
                    fileComponents.push(ext.substring(1));
                }
                //    
                const mainDir = dir.split('/')[0];
                if (mainDir && mainDir !== '.' && !fileComponents.includes(mainDir)) {
                    fileComponents.push(mainDir);
                }
            }
            //    
            let fileList = '';
            if (changedFiles.length <= 3) {
                fileList = changedFiles.map(f => path__WEBPACK_IMPORTED_MODULE_1__.basename(f.file)).join(', ');
            }
            else {
                fileList = `${changedFiles.length} files`;
            }
            //    
            const component = fileComponents.length > 0 ? fileComponents.join(', ') : 'code';
            const baseMessage = `${messagePrefix} ${component}: `;
            return `${baseMessage}${fileList}`;
        }
        catch (error) {
            console.error('   :', error);
            throw new Error(`   : ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * LLM     
     * @throws Error       
     */
    async generateLLMCommitMessage(changedFiles, diff) {
        //    
        let commitExamples = '';
        try {
            // BitBucket   
            if (this.bitbucketService) {
                try {
                    // BitBucket API    
                    const userName = await this.bitbucketService.getGitUsername();
                    if (userName) {
                        // BitBucket API      
                        const commits = await this.bitbucketService.getCommitHistory(userName, 20);
                        if (commits && commits.length > 0) {
                            //     
                            const formattedHistory = commits.map(commit => `${commit.displayId} - ${commit.message}`).join('\n');
                            //      
                            commitExamples = `Here are some example commit messages to follow the style:\n${formattedHistory}\n\n`;
                        }
                    }
                }
                catch (error) {
                    console.error('BitBucket  :', error);
                    // BitBucket     Git   
                    await this.fallbackToLocalGitHistory();
                }
            }
            else {
                // BitBucket      Git  
                await this.fallbackToLocalGitHistory();
            }
        }
        catch (error) {
            console.error('   :', error);
            //      
            const defaultExamples = [
                "feat(ui): add slash command suggestions to chat interface",
                "fix(core): resolve memory leak in service initialization",
                "docs(api): update API documentation with examples",
                "refactor(git): improve auto-commit change detection",
                "style(ui): update chat interface styling",
                "test(llm): add integration tests for LLM service",
                "perf(stream): optimize streaming response handling",
                "chore(deps): update dependencies to latest versions"
            ];
            commitExamples = `Here are some example commit messages to follow the style:\n${defaultExamples.join('\n')}\n\n`;
        }
        // diff   
        const maxDiffLength = 5000; //  5000
        const truncatedDiff = diff.length > maxDiffLength ?
            diff.substring(0, maxDiffLength) + '\n... (truncated)' : diff;
        //   
        const fileChangeList = changedFiles.map(file => {
            return `${file.status} ${file.file}`;
        }).join('\n');
        // Conventional Commits  
        const prompt = `Please generate a concise and meaningful Git commit message for the following changes. 
Use the Conventional Commits format: <type>(<scope>): <description>

Types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert

${commitExamples}
Changed files:
${fileChangeList}

Diff:
${truncatedDiff}

Generate ONLY the commit message without any explanation. Keep it under 72 characters if possible.`;
        try {
            // LLM  
            const result = await this.llmService.getCompletion(prompt);
            if (result.success && result.data) {
                //    
                const message = result.data.trim();
                //     
                if (message.length > 0 && message.length < 200) {
                    return message;
                }
            }
            // LLM      
            throw new Error('LLM    ');
        }
        catch (error) {
            // LLM   
            console.error('LLM    :', error);
            //   -      
            throw new Error(`LLM    : ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     *  Git      (BitBucket )
     * @private
     */
    async fallbackToLocalGitHistory() {
        try {
            const { stdout: userName } = await execAsync('git config --get user.name', { cwd: this.workspaceRoot });
            if (userName.trim()) {
                //     
                const { stdout: commitHistory } = await execAsync(`git log --author="${userName.trim()}" -n 20 --pretty=format:"%h - %s"`, { cwd: this.workspaceRoot });
                if (commitHistory.trim()) {
                    //      
                    return `Here are some example commit messages to follow the style:\n${commitHistory.trim()}\n\n`;
                }
            }
            //  Git     
            return '';
        }
        catch (error) {
            console.error(' Git   :', error);
            return '';
        }
    }
    /**
     *   
     *
     * [APE][Temporary]      
     *      .
     */
    async consolidateTemporaryCommits() {
        if (!this.workspaceRoot) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Git  .');
            return;
        }
        try {
            //   
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.withProgress({
                location: vscode__WEBPACK_IMPORTED_MODULE_0__.ProgressLocation.Notification,
                title: "   ...",
                cancellable: false
            }, async (progress) => {
                progress.report({ message: "   ..." });
                // [APE][Temporary]    
                const { stdout: logOutput } = await execAsync('git log --pretty=format:"%H %s" -n 30', { cwd: this.workspaceRoot });
                //    
                const allCommits = logOutput.split('\n')
                    .map(line => {
                    const space = line.indexOf(' ');
                    return {
                        hash: line.substring(0, space),
                        message: line.substring(space + 1),
                        isTemporary: line.substring(space + 1).includes('[APE][Temporary]')
                    };
                });
                //     
                const temporaryGroups = [];
                let currentGroup = [];
                //         
                for (const commit of allCommits) {
                    if (commit.isTemporary) {
                        currentGroup.push(commit);
                    }
                    else {
                        //         
                        if (currentGroup.length > 0) {
                            temporaryGroups.push([...currentGroup]);
                            currentGroup = [];
                        }
                    }
                }
                //    
                if (currentGroup.length > 0) {
                    temporaryGroups.push(currentGroup);
                }
                //    
                if (temporaryGroups.length === 0 || temporaryGroups[0].length === 0) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('   .');
                    return;
                }
                //        (  )
                const commits = temporaryGroups[0];
                //     
                const oldestTempCommitHash = commits[commits.length - 1].hash;
                //     
                const { stdout: parentHash } = await execAsync(`git rev-parse ${oldestTempCommitHash}^`, { cwd: this.workspaceRoot });
                //    
                const commitCount = commits.length;
                //  
                progress.report({ message: "   ..." });
                //      
                let commitDescription = '';
                try {
                    //   diff 
                    const { stdout: diffOutput } = await execAsync(`git diff ${parentHash.trim()} HEAD`, { cwd: this.workspaceRoot });
                    //    
                    const messages = commits.map(c => c.message.replace('[APE][Temporary] ', '')).join('\n');
                    //   (LLM )
                    progress.report({ message: "   ..." });
                    // LLM   
                    const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git');
                    const useLLM = config.get('useLLMForCommitMessages', false);
                    if (useLLM) {
                        // LLM    
                        const prompt = `      .

  :
${messages}

   (diff):
${diffOutput.length > 5000 ? diffOutput.substring(0, 5000) + '\n... ()' : diffOutput}

        .
Conventional Commits  : <type>(<scope>): <description>
: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert
     .  72  .`;
                        const result = await this.llmService.getCompletion(prompt);
                        if (result.success && result.data) {
                            commitDescription = result.data.trim();
                        }
                    }
                    // LLM       
                    if (!commitDescription) {
                        commitDescription = `chore(git): consolidate ${commitCount} temporary commits`;
                    }
                }
                catch (error) {
                    console.error('   :', error);
                    commitDescription = `chore(git): consolidate ${commitCount} temporary commits`;
                }
                //    
                progress.report({ message: "  ..." });
                const result = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`${commitCount}   ?`, { modal: true }, '', '');
                if (result !== '') {
                    return;
                }
                // git reset --soft     
                progress.report({ message: "   ..." });
                await execAsync(`git reset --soft ${parentHash.trim()}`, { cwd: this.workspaceRoot });
                //   
                progress.report({ message: "   ..." });
                await execAsync(`git commit -m "${commitDescription.replace(/"/g, '\\"')}"`, { cwd: this.workspaceRoot });
                //  
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`${commitCount}    .`);
                //  
                this.updateStatusBar();
            });
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`   : ${error.message}`);
        }
    }
    /**
     *  
     */
    dispose() {
        this.statusBarItem.dispose();
        for (const disposable of this.disposables) {
            disposable.dispose();
        }
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/git/bitbucketService.ts":
/*!******************************************!*\
  !*** ./src/core/git/bitbucketService.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BitbucketErrorType: () => (/* binding */ BitbucketErrorType),
/* harmony export */   BitbucketService: () => (/* binding */ BitbucketService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! axios */ "./node_modules/axios/lib/axios.js");
/* harmony import */ var _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/serviceConfig */ "./src/core/services/serviceConfig.ts");
/**
 * BitBucket 
 *
 * BitBucket API  Git     .
 *  BitBucket  ,       Mock  .
 */



/**
 * BitBucket   
 */
var BitbucketErrorType;
(function (BitbucketErrorType) {
    BitbucketErrorType["ConnectionFailed"] = "connection_failed";
    BitbucketErrorType["AuthenticationFailed"] = "authentication_failed";
    BitbucketErrorType["PermissionDenied"] = "permission_denied";
    BitbucketErrorType["ResourceNotFound"] = "resource_not_found";
    BitbucketErrorType["ServerError"] = "server_error";
    BitbucketErrorType["Unknown"] = "unknown";
})(BitbucketErrorType || (BitbucketErrorType = {}));
/**
 * BitBucket  
 */
class BitbucketService {
    context;
    serviceConfigManager;
    baseUrl = '';
    projectKey = '';
    repoSlug = '';
    username = '';
    password = '';
    token = '';
    authType = _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic;
    useMock = true;
    disposables = [];
    _lastError = null;
    /**
     * BitBucket  
     * @param context VSCode  
     * @param serviceConfigManager    ()
     */
    constructor(context, serviceConfigManager) {
        this.context = context;
        this.serviceConfigManager = serviceConfigManager;
        //  
        this.loadConfiguration();
        //   
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.bitbucket')) {
                this.loadConfiguration();
            }
        }));
    }
    /**
     *   
     */
    loadConfiguration() {
        if (this.serviceConfigManager) {
            //      
            const config = this.serviceConfigManager.getServiceConfig(_services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Bitbucket);
            this.baseUrl = config.url;
            this.authType = config.authType;
            this.username = config.username || '';
            this.password = config.password || '';
            this.token = config.token || '';
            this.useMock = config.useMock;
            //       
            const additionalParams = config.additionalParams || {};
            this.projectKey = additionalParams.projectKey || '';
            this.repoSlug = additionalParams.repositorySlug || '';
        }
        else {
            //  VSCode  
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.bitbucket');
            this.baseUrl = config.get('url', '');
            this.projectKey = config.get('projectKey', '');
            this.repoSlug = config.get('repositorySlug', '');
            this.username = config.get('username', '');
            this.password = config.get('password', '');
            this.token = config.get('token', '');
            this.authType = config.get('authType', _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic);
            this.useMock = config.get('useMock', false);
        }
        //       
        if (!this.baseUrl || (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) ||
            (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token)) {
            this.useMock = true;
        }
    }
    /**
     *   
     */
    get lastError() {
        return this._lastError;
    }
    /**
     *      
     * @param authorName   (    )
     * @param limit    (: 20)
     * @returns  
     * @throws Error        
     */
    async getCommitHistory(authorName, limit = 20) {
        try {
            //   
            this._lastError = null;
            //      
            if (this.useMock) {
                return this.getMockCommitHistory(authorName, limit);
            }
            //   
            if (!this.baseUrl) {
                throw new Error('BitBucket  URL  .  .');
            }
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('BitBucket    .    .');
            }
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('BitBucket    .   .');
            }
            if (!this.projectKey || !this.repoSlug) {
                throw new Error('BitBucket       .  .');
            }
            // BitBucket REST API 
            const url = `${this.baseUrl}/rest/api/1.0/projects/${this.projectKey}/repos/${this.repoSlug}/commits`;
            //  
            const params = {
                limit: limit
            };
            //  
            if (authorName) {
                // BitBucket Server API 'until'       
                params.until = 'HEAD';
                // 'since'   ( )
            }
            // API  
            const config = {};
            //    
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            //   
            config.params = params;
            // API  
            const response = await axios__WEBPACK_IMPORTED_MODULE_2__["default"].get(url, config);
            //   
            const commits = response.data.values.filter((commit) => {
                //   (     )
                return !authorName || commit.author.name === authorName;
            }).map((commit) => ({
                id: commit.id,
                displayId: commit.displayId,
                message: commit.message,
                author: {
                    name: commit.author.name,
                    emailAddress: commit.author.emailAddress
                },
                authorTimestamp: commit.authorTimestamp
            }));
            return commits;
        }
        catch (error) {
            //    
            this.handleError(error);
            //  
            console.error('BitBucket    :', error);
            //      
            if (this._lastError) {
                throw new Error(`BitBucket  (${this._lastError.type}): ${this._lastError.message}`);
            }
            else {
                throw error; //   
            }
        }
    }
    /**
     *    
     * @param error  
     * @private
     */
    handleError(error) {
        if (axios__WEBPACK_IMPORTED_MODULE_2__["default"].isAxiosError(error)) {
            const axiosError = error;
            if (!axiosError.response) {
                //  
                this.setError(BitbucketErrorType.ConnectionFailed, `BitBucket   : ${error.message}.  URL : ${this.baseUrl}`);
            }
            else {
                // HTTP     
                const status = axiosError.response.status;
                if (status === 401 || status === 403) {
                    this.setError(BitbucketErrorType.AuthenticationFailed, `BitBucket  : ${error.message}.    .`);
                }
                else if (status === 404) {
                    this.setError(BitbucketErrorType.ResourceNotFound, `BitBucket    : ${error.message}.     .`);
                }
                else if (status >= 500) {
                    this.setError(BitbucketErrorType.ServerError, `BitBucket  : ${error.message}.   .`);
                }
                else {
                    this.setError(BitbucketErrorType.Unknown, `BitBucket : ${error.message}`);
                }
            }
        }
        else {
            //  
            this.setError(BitbucketErrorType.Unknown, `BitBucket : ${error.message}`);
        }
    }
    /**
     *  
     * @param type  
     * @param message  
     * @param details   
     * @private
     */
    setError(type, message, details) {
        this._lastError = {
            type,
            message,
            details
        };
        //   
        console.error(`BitBucket  (${type}):`, message, details || '');
    }
    /**
     *  Git    (BitBucket     )
     * @returns Git  
     * @throws Error        
     */
    async getGitUsername() {
        try {
            //   
            this._lastError = null;
            //      
            if (this.useMock) {
                return 'TestUser';
            }
            //   
            if (!this.baseUrl) {
                throw new Error('BitBucket  URL  .  .');
            }
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('BitBucket    .    .');
            }
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('BitBucket    .   .');
            }
            // BitBucket REST API     
            const url = `${this.baseUrl}/rest/api/1.0/users/~`;
            // API  
            const config = {};
            //    
            if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _services_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API  
            const response = await axios__WEBPACK_IMPORTED_MODULE_2__["default"].get(url, config);
            return response.data.displayName || response.data.name || this.username;
        }
        catch (error) {
            //    
            this.handleError(error);
            //  
            console.error('BitBucket    :', error);
            //      
            if (this._lastError) {
                throw new Error(`BitBucket  (${this._lastError.type}): ${this._lastError.message}`);
            }
            else {
                throw error; //   
            }
        }
    }
    /**
     *    
     * @param authorName  
     * @param limit   
     * @returns   
     */
    getMockCommitHistory(authorName, limit = 20) {
        //   
        const mockCommits = [
            {
                id: 'abcdef1234567890abcdef1234567890abcdef12',
                displayId: 'abcdef1',
                message: 'feat(ui): add slash command suggestions to chat interface',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 1
            },
            {
                id: 'bcdef1234567890abcdef1234567890abcdef123',
                displayId: 'bcdef12',
                message: 'fix(core): resolve memory leak in service initialization',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 2
            },
            {
                id: 'cdef1234567890abcdef1234567890abcdef1234',
                displayId: 'cdef123',
                message: 'docs(api): update API documentation with examples',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 3
            },
            {
                id: 'def1234567890abcdef1234567890abcdef12345',
                displayId: 'def1234',
                message: 'refactor(git): improve auto-commit change detection',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 4
            },
            {
                id: 'ef1234567890abcdef1234567890abcdef123456',
                displayId: 'ef12345',
                message: 'style(ui): update chat interface styling',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 5
            },
            {
                id: 'f1234567890abcdef1234567890abcdef1234567',
                displayId: 'f123456',
                message: 'test(llm): add integration tests for LLM service',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 6
            },
            {
                id: '1234567890abcdef1234567890abcdef12345678',
                displayId: '1234567',
                message: 'perf(stream): optimize streaming response handling',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 7
            },
            {
                id: '234567890abcdef1234567890abcdef123456789',
                displayId: '2345678',
                message: 'chore(deps): update dependencies to latest versions',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 8
            },
            {
                id: '34567890abcdef1234567890abcdef1234567890',
                displayId: '3456789',
                message: 'feat(commands): add support for keyboard shortcuts',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 9
            },
            {
                id: '4567890abcdef1234567890abcdef12345678901',
                displayId: '4567890',
                message: 'fix(ui): correct positioning of dropdown menu',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 10
            },
            {
                id: '567890abcdef1234567890abcdef123456789012',
                displayId: '567890a',
                message: 'docs(readme): update installation instructions',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 11
            },
            {
                id: '67890abcdef1234567890abcdef1234567890123',
                displayId: '67890ab',
                message: 'refactor(core): simplify service initialization logic',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 12
            },
            {
                id: '7890abcdef1234567890abcdef12345678901234',
                displayId: '7890abc',
                message: 'style(icons): update icon set for better visibility',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 13
            },
            {
                id: '890abcdef1234567890abcdef123456789012345',
                displayId: '890abcd',
                message: 'test(core): improve test coverage for core services',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 14
            },
            {
                id: '90abcdef1234567890abcdef1234567890123456',
                displayId: '90abcde',
                message: 'perf(memory): optimize memory usage in large operations',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 15
            },
            {
                id: '0abcdef1234567890abcdef12345678901234567',
                displayId: '0abcdef',
                message: 'chore(build): update build configuration',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 16
            },
            {
                id: 'abcdef1234567890abcdef123456789012345678',
                displayId: 'abcdef1',
                message: 'feat(git): enhance commit message generation',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 17
            },
            {
                id: 'bcdef1234567890abcdef1234567890123456789',
                displayId: 'bcdef12',
                message: 'fix(auth): resolve authentication token refresh issue',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 18
            },
            {
                id: 'cdef1234567890abcdef12345678901234567890',
                displayId: 'cdef123',
                message: 'docs(api): add examples for new API endpoints',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 19
            },
            {
                id: 'def1234567890abcdef123456789012345678901',
                displayId: 'def1234',
                message: 'refactor(ui): reorganize component hierarchy',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 20
            }
        ];
        //  
        const filteredCommits = authorName
            ? mockCommits.filter(commit => commit.author.name === authorName)
            : mockCommits;
        //   
        return filteredCommits.slice(0, limit);
    }
    /**
     *  
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/git/commands.ts":
/*!**********************************!*\
  !*** ./src/core/git/commands.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createGitCommands: () => (/* binding */ createGitCommands)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/**
 * Git  
 *
 * Git   .
 */

/**
 * Git   
 */
function createGitCommands() {
    const commands = [];
    // Git  
    commands.push({
        name: 'git',
        aliases: ['g', '', ''],
        description: 'Git  ',
        examples: ['/git status', '/git commit', '/git auto', '/git consolidate', '/ ', '/ '],
        category: 'git',
        priority: 3,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand || subCommand === 'status' || subCommand === '') {
                // Git  
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.git.showStatus');
            }
            else if (subCommand === 'commit' || subCommand === '' || subCommand === '') {
                // Git 
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.git.commit');
            }
            else if (subCommand === 'auto' || subCommand === '' || subCommand === '') {
                //       
                const secondArg = context.args[1]?.toLowerCase();
                if (secondArg === 'on' || secondArg === '' || secondArg === 'true') {
                    //   
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git')
                        .update('autoCommit', true, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Workspace);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('  ');
                }
                else if (secondArg === 'off' || secondArg === '' || secondArg === 'false') {
                    //   
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.git')
                        .update('autoCommit', false, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Workspace);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('  ');
                }
                else {
                    //  (  )
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.git.toggleAutoCommit');
                }
            }
            else if (subCommand === 'consolidate' || subCommand === 'squash' || subCommand === '' || subCommand === '' || subCommand === '') {
                //   
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.git.consolidateTemporaryCommits');
            }
            else {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('   Git  ');
            }
        },
        provideCompletions: (partialArgs) => {
            const subCommands = ['status', 'commit', 'auto', 'consolidate', 'squash',
                '', '', '', '', '', '', '', ''];
            //    
            if (!partialArgs.includes(' ')) {
                return subCommands.filter(cmd => cmd.startsWith(partialArgs.toLowerCase()));
            }
            return [];
        }
    });
    return commands;
}


/***/ }),

/***/ "./src/core/git/conflictSolver.ts":
/*!****************************************!*\
  !*** ./src/core/git/conflictSolver.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConflictSolver: () => (/* binding */ ConflictSolver),
/* harmony export */   ConflictStrategy: () => (/* binding */ ConflictStrategy)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! util */ "util");
/* harmony import */ var util__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(util__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! child_process */ "child_process");
/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/**
 * Git Conflict Solver
 *
 * Git     
 */






const execAsync = (0,util__WEBPACK_IMPORTED_MODULE_3__.promisify)(child_process__WEBPACK_IMPORTED_MODULE_4__.exec);
/**
 *    
 */
var ConflictStrategy;
(function (ConflictStrategy) {
    ConflictStrategy["AUTO"] = "auto";
    ConflictStrategy["OURS"] = "ours";
    ConflictStrategy["THEIRS"] = "theirs";
    ConflictStrategy["MERGE"] = "merge";
    ConflictStrategy["LLM"] = "llm"; // LLM   
})(ConflictStrategy || (ConflictStrategy = {}));
/**
 * Git  
 */
class ConflictSolver {
    llmService;
    workspaceRoot;
    /**
     * 
     */
    constructor(llmService) {
        this.llmService = llmService;
        //   
        this.workspaceRoot = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0]?.uri.fsPath;
    }
    /**
     *      
     */
    async getConflictingFiles() {
        if (!this.workspaceRoot) {
            return [];
        }
        try {
            // Git    
            const { stdout } = await execAsync('git diff --name-only --diff-filter=U', {
                cwd: this.workspaceRoot
            });
            return stdout.trim().split('\n').filter(file => file.trim() !== '');
        }
        catch (error) {
            console.error('   :', error);
            return [];
        }
    }
    /**
     *     
     */
    async resolveAllConflicts(strategy = ConflictStrategy.AUTO) {
        const conflictFiles = await this.getConflictingFiles();
        if (conflictFiles.length === 0) {
            return 0;
        }
        let resolvedCount = 0;
        //   UI
        const progressOptions = {
            location: vscode__WEBPACK_IMPORTED_MODULE_0__.ProgressLocation.Notification,
            title: '  ...',
            cancellable: true
        };
        await vscode__WEBPACK_IMPORTED_MODULE_0__.window.withProgress(progressOptions, async (progress, token) => {
            let i = 0;
            for (const file of conflictFiles) {
                if (token.isCancellationRequested) {
                    break;
                }
                progress.report({
                    message: `${file} (${i + 1}/${conflictFiles.length})`,
                    increment: 100 / conflictFiles.length
                });
                const resolveSuccess = await this.resolveConflictsInFile(path__WEBPACK_IMPORTED_MODULE_1__.join(this.workspaceRoot, file), strategy);
                if (resolveSuccess) {
                    resolvedCount++;
                }
                i++;
            }
            return resolvedCount;
        });
        return resolvedCount;
    }
    /**
     *    
     */
    async resolveConflictsInFile(filePath, strategy = ConflictStrategy.AUTO) {
        try {
            //   
            const content = fs__WEBPACK_IMPORTED_MODULE_2__.readFileSync(filePath, 'utf-8');
            //   
            const conflictInfo = this.parseConflicts(filePath, content);
            if (conflictInfo.conflicts.length === 0) {
                return false;
            }
            //   
            const fileExt = path__WEBPACK_IMPORTED_MODULE_1__.extname(filePath).substring(1);
            //  
            const resolvedContent = await this.resolveContent(content, conflictInfo, strategy, fileExt);
            //   
            fs__WEBPACK_IMPORTED_MODULE_2__.writeFileSync(filePath, resolvedContent, 'utf-8');
            // Git 
            if (this.workspaceRoot) {
                await execAsync(`git add "${filePath}"`, { cwd: this.workspaceRoot });
            }
            return true;
        }
        catch (error) {
            console.error(`    (${filePath}):`, error);
            return false;
        }
    }
    /**
     *   
     */
    parseConflicts(filePath, content) {
        const result = {
            filePath,
            conflicts: []
        };
        //  
        const conflictPattern = /<<<<<<< HEAD\r?\n([\s\S]*?)\r?\n=======\r?\n([\s\S]*?)\r?\n>>>>>>> (.*?)(\r?\n|$)/g;
        //       
        let match;
        while ((match = conflictPattern.exec(content)) !== null) {
            const fullMatch = match[0];
            const ours = match[1];
            const theirs = match[2];
            const branch = match[3];
            //      
            const startPos = content.substring(0, match.index).split(/\r?\n/).length - 1;
            const endPos = startPos + fullMatch.split(/\r?\n/).length - 1;
            result.conflicts.push({
                ours,
                theirs,
                marker: fullMatch,
                branch,
                startLine: startPos,
                endLine: endPos
            });
        }
        return result;
    }
    /**
     *   
     */
    async resolveContent(content, conflictInfo, strategy, fileType) {
        let resolvedContent = content;
        //     
        for (const conflict of conflictInfo.conflicts) {
            //   AUTO         
            const actualStrategy = strategy === ConflictStrategy.AUTO
                ? this.determineStrategy(conflict, fileType)
                : strategy;
            //    
            const mergeResult = await this.applyStrategy(conflict, actualStrategy, fileType);
            if (mergeResult.success && mergeResult.resolvedContent) {
                //     
                resolvedContent = resolvedContent.replace(conflict.marker, mergeResult.resolvedContent);
            }
        }
        return resolvedContent;
    }
    /**
     *     
     */
    determineStrategy(conflict, fileType) {
        //     
        if (conflict.ours.trim() === conflict.theirs.trim()) {
            return ConflictStrategy.OURS;
        }
        //     
        if (conflict.ours.includes(conflict.theirs)) {
            return ConflictStrategy.OURS;
        }
        if (conflict.theirs.includes(conflict.ours)) {
            return ConflictStrategy.THEIRS;
        }
        //    
        const oursLines = conflict.ours.split(/\r?\n/).length;
        const theirsLines = conflict.theirs.split(/\r?\n/).length;
        //      
        if (oursLines > theirsLines * 2) {
            return ConflictStrategy.OURS;
        }
        if (theirsLines > oursLines * 2) {
            return ConflictStrategy.THEIRS;
        }
        //      
        if (['js', 'ts', 'jsx', 'tsx', 'py', 'java', 'c', 'cpp', 'cs', 'go', 'rb', 'php'].includes(fileType)) {
            return ConflictStrategy.LLM;
        }
        //     
        return ConflictStrategy.MERGE;
    }
    /**
     *    
     */
    async applyStrategy(conflict, strategy, fileType) {
        switch (strategy) {
            case ConflictStrategy.OURS:
                return {
                    success: true,
                    resolvedContent: conflict.ours
                };
            case ConflictStrategy.THEIRS:
                return {
                    success: true,
                    resolvedContent: conflict.theirs
                };
            case ConflictStrategy.MERGE:
                return this.mergeChanges(conflict);
            case ConflictStrategy.LLM:
                return await this.llmBasedMerge(conflict, fileType);
            default:
                return {
                    success: false,
                    message: '  '
                };
        }
    }
    /**
     *   
     */
    mergeChanges(conflict) {
        //    
        const oursLines = conflict.ours.split(/\r?\n/);
        const theirsLines = conflict.theirs.split(/\r?\n/);
        //   
        const commonLines = oursLines.filter(line => theirsLines.includes(line));
        //     
        const uniqueOurs = oursLines.filter(line => !theirsLines.includes(line));
        const uniqueTheirs = theirsLines.filter(line => !oursLines.includes(line));
        //     
        const combinedLines = [...commonLines, ...uniqueOurs, ...uniqueTheirs];
        return {
            success: true,
            resolvedContent: combinedLines.join('\n')
        };
    }
    /**
     * LLM   
     */
    async llmBasedMerge(conflict, fileType) {
        try {
            // LLM   
            const prompt = `
    .   ${fileType}.
        .
       .

  :
\`\`\`${fileType}
${conflict.ours}
\`\`\`

  (${conflict.branch}) :
\`\`\`${fileType}
${conflict.theirs}
\`\`\`

   .       .`;
            // LLM 
            const messages = [
                {
                    id: `msg_conflict_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_5__.MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            const response = await this.llmService.sendRequest(messages);
            if (response.success && response.data) {
                //    
                const codeBlockRegex = /```(?:[a-z]*\n)?([\s\S]*?)```/;
                const content = response.data.content || '';
                const contentMatch = content.match(codeBlockRegex);
                const resolvedContent = contentMatch
                    ? contentMatch[1].trim()
                    : content.trim();
                return {
                    success: true,
                    resolvedContent
                };
            }
            else {
                throw new Error('LLM   ');
            }
        }
        catch (error) {
            console.error('LLM   :', error);
            // LLM      
            return this.mergeChanges(conflict);
        }
    }
}


/***/ }),

/***/ "./src/core/llm/llmService.ts":
/*!************************************!*\
  !*** ./src/core/llm/llmService.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ConnectionType: () => (/* binding */ ConnectionType),
/* harmony export */   LLMService: () => (/* binding */ LLMService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! axios */ "./node_modules/axios/lib/axios.js");
/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ws */ "./node_modules/ws/wrapper.mjs");
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/* harmony import */ var _vaultIntegration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./vaultIntegration */ "./src/core/llm/vaultIntegration.ts");
/* harmony import */ var _rulesIntegration__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./rulesIntegration */ "./src/core/llm/rulesIntegration.ts");






// Define constants for WebSocket states
const WS_OPEN = 1;
/**
 * UUID   -    
 */
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}
/**
 *      -     
 */
class LogUtil {
    //       
    static LOG_LEVEL = {
        DEBUG: 0,
        INFO: 1,
        WARN: 2,
        ERROR: 3
    };
    static CURRENT_LOG_LEVEL = LogUtil.LOG_LEVEL.INFO;
    static logCounter = 0;
    static getLogId() {
        return `log_${Date.now()}_${++LogUtil.logCounter}`;
    }
    //     JSON 
    static getCircularReplacer() {
        const seen = new WeakSet();
        return (key, value) => {
            // undefined  
            if (value === undefined)
                return '[undefined]';
            //   null  
            if (typeof value !== 'object' || value === null)
                return value;
            //   
            if (seen.has(value)) {
                return '[Circular Reference]';
            }
            // Error   
            if (value instanceof Error) {
                return {
                    name: value.name,
                    message: value.message,
                    stack: value.stack
                };
            }
            //    ( )
            seen.add(value);
            return value;
        };
    }
    //      (  )
    static formatObject(obj, depth = 2) {
        try {
            return JSON.stringify(obj, this.getCircularReplacer(), 2);
        }
        catch (error) {
            console.error('   :', error);
            return '[  ]';
        }
    }
    //    API  
    static logRequest(endpoint, headers, body) {
        const logId = LogUtil.getLogId();
        if (LogUtil.CURRENT_LOG_LEVEL <= LogUtil.LOG_LEVEL.DEBUG) {
            console.log(`

 API  [ID:${logId}] (${new Date().toISOString()})

 : ${endpoint}
 
  :
${LogUtil.formatObject(headers).split('\n').map((line) => ` ${line}`).join('\n')}

  :
${LogUtil.formatObject(body).split('\n').map((line) => ` ${line}`).join('\n')}

      `);
        }
    }
    //     
    static logResponse(responseData) {
        const logId = LogUtil.getLogId();
        if (LogUtil.CURRENT_LOG_LEVEL <= LogUtil.LOG_LEVEL.DEBUG) {
            console.log(`

 API  [ID:${logId}] (${new Date().toISOString()})

  :
${LogUtil.formatObject(responseData).split('\n').map((line) => ` ${line}`).join('\n')}

      `);
        }
    }
    //    
    static logError(operation, error) {
        const logId = LogUtil.getLogId();
        if (LogUtil.CURRENT_LOG_LEVEL <= LogUtil.LOG_LEVEL.ERROR) {
            //        
            let errorDetails = '';
            try {
                //    
                errorDetails = `
  : ${operation}
  : ${error?.code || 'N/A'}
  : ${error?.response?.status || 'N/A'}
  : ${error?.message || '   '}`;
                //     
                if (error?.response?.data) {
                    try {
                        const safeResponseData = typeof error.response.data === 'object' ?
                            JSON.stringify(error.response.data, this.getCircularReplacer()) :
                            String(error.response.data);
                        errorDetails += `\n  : ${safeResponseData}`;
                    }
                    catch (formatError) {
                        errorDetails += '\n  : [     ]';
                    }
                }
                else {
                    errorDetails += '\n  : N/A';
                }
                //    
                errorDetails += '\n \n  :';
                if (error?.stack) {
                    errorDetails += `\n${error.stack.split('\n').map((line) => ` ${line}`).join('\n')}`;
                }
                else {
                    try {
                        const safeErrorString = JSON.stringify(error, this.getCircularReplacer());
                        errorDetails += `\n${safeErrorString.split('\n').map((line) => ` ${line}`).join('\n')}`;
                    }
                    catch (stringifyError) {
                        errorDetails += '\n [       ]';
                    }
                }
            }
            catch (loggingError) {
                //      
                errorDetails = `
  : ${operation}
   :        
  : ${error?.message || '   '}`;
            }
            //   
            console.error(`

    [ID:${logId}] (${new Date().toISOString()})
${errorDetails}

      `);
        }
    }
    //    
    static logStreamChunk(chunk, parsed) {
        // Skip logging empty chunks or when only structural content exists
        const isEmpty = !chunk ||
            (typeof chunk === 'string' && !chunk.trim()) ||
            (parsed && Object.keys(parsed).length === 0);
        if (isEmpty) {
            return;
        }
        // Check if content is empty (to reduce logging noise)
        const hasContent = parsed &&
            (parsed.content || parsed.text || parsed.delta?.content ||
                parsed.choices?.[0]?.delta?.content || parsed.choices?.[0]?.message?.content);
        // Only log if DEBUG level is enabled and content exists
        const logId = LogUtil.getLogId();
        if (LogUtil.CURRENT_LOG_LEVEL <= LogUtil.LOG_LEVEL.DEBUG && hasContent) {
            console.log(`

    [ID:${logId}] (${new Date().toISOString()})

  :
${(typeof chunk === 'string' ? chunk : LogUtil.formatObject(chunk)).split('\n').map((line) => ` ${line}`).join('\n')}

  :
${LogUtil.formatObject(parsed).split('\n').map((line) => ` ${line}`).join('\n')}

      `);
        }
    }
    //      
    static logInfo(message, data) {
        const logId = LogUtil.getLogId();
        if (LogUtil.CURRENT_LOG_LEVEL <= LogUtil.LOG_LEVEL.INFO) {
            try {
                const safeData = data ? LogUtil.formatObject(data) : '';
                console.log(`

   [ID:${logId}] (${new Date().toISOString()})

 ${message}
${data ? ` 
${safeData.split('\n').map((line) => ` ${line}`).join('\n')}` : ''}

        `);
            }
            catch (error) {
                //      
                console.log(`

   [ID:${logId}] (${new Date().toISOString()})

 ${message}
 [  :     ]

        `);
            }
        }
    }
}
/**
 * LLM connection type
 */
var ConnectionType;
(function (ConnectionType) {
    ConnectionType["HTTP"] = "http";
    ConnectionType["WebSocket"] = "websocket";
})(ConnectionType || (ConnectionType = {}));
/**
 * Service for interacting with LLM APIs
 */
class LLMService {
    _context;
    _modelManager;
    _endpoint;
    _connectionType;
    _wsConnection = null;
    _cancelTokenSource = null;
    _configListener;
    _modelChangeListener;
    /**
     * Creates a new LLMService instance
     * @param _context The VSCode extension context
     * @param _modelManager The model manager service
     */
    _vaultService = null;
    _rulesService = null;
    /**
     * 
     * @param _context VSCode  
     * @param _modelManager  
     */
    constructor(_context, _modelManager) {
        this._context = _context;
        this._modelManager = _modelManager;
        // Initialize properties
        this._endpoint = '';
        this._connectionType = ConnectionType.HTTP;
        LogUtil.logInfo('LLMService  ...');
        // Load configuration
        this._loadConfiguration();
        // Listen for configuration changes
        this._configListener = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration('ape.llm') &&
                !event.affectsConfiguration('ape.llm.defaultModel')) { // Only handle non-model configs
                LogUtil.logInfo('LLM   :', event);
                this._loadConfiguration();
            }
        });
        // Listen for model changes from ModelManager
        this._modelChangeListener = this._modelManager.onDidChangeModel(event => {
            LogUtil.logInfo(`  : ${event.oldModel} -> ${event.newModel}`);
            // No need to update internal state as we'll always use modelManager.getActiveModel()
        });
        LogUtil.logInfo('LLMService  ,  :', this.getActiveModel());
    }
    /**
     * VAULT  
     * @param vaultService VAULT  
     */
    setVaultService(vaultService) {
        this._vaultService = vaultService;
        LogUtil.logInfo('VAULT  ');
    }
    /**
     * Rules  
     * @param rulesService Rules  
     */
    setRulesService(rulesService) {
        this._rulesService = rulesService;
        LogUtil.logInfo('Rules  ');
    }
    /**
     * Reloads configuration from VSCode settings
     */
    _apiKey = '';
    _loadConfiguration() {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.llm');
        const newEndpoint = config.get('endpoint', 'https://openrouter.ai/api/v1/chat/completions');
        const newApiKey = config.get('apiKey', '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');
        // Only update endpoint and API key if changed
        if (this._endpoint !== newEndpoint) {
            this._endpoint = newEndpoint;
            LogUtil.logInfo('  ', { endpoint: this._endpoint });
        }
        if (this._apiKey !== newApiKey) {
            this._apiKey = newApiKey;
            LogUtil.logInfo('API   ', { keyLength: this._apiKey.length });
        }
        // Update connection type
        const newConnectionType = this._endpoint && this._endpoint.startsWith('ws')
            ? ConnectionType.WebSocket
            : ConnectionType.HTTP;
        if (this._connectionType !== newConnectionType) {
            this._connectionType = newConnectionType;
            LogUtil.logInfo('  ', { connectionType: this._connectionType });
            // Handle WebSocket connection changes
            if (this._connectionType === ConnectionType.WebSocket && this._wsConnection) {
                this._wsConnection.close();
                this._wsConnection = null;
                LogUtil.logInfo(' WebSocket  ');
            }
        }
    }
    /**
     * Gets the currently active LLM model
     * @returns The active LLM model
     */
    getActiveModel() {
        return this._modelManager.getActiveModel();
    }
    /**
     * Changes the active LLM model
     * @param model The model to switch to
     */
    async setActiveModel(model) {
        LogUtil.logInfo('  ', { newModel: model });
        return this._modelManager.setActiveModel(model);
    }
    /**
     * Gets all available LLM models
     * @returns Array of available LLM models
     */
    getAvailableModels() {
        return this._modelManager.getAvailableModels();
    }
    /**
     * Gets a user-friendly display name for a model
     * @param modelId The model ID
     * @returns A formatted display name
     */
    getModelDisplayName(modelId) {
        return this._modelManager.getModelDisplayName(modelId);
    }
    /**
     * Sends a request to the LLM and gets a response
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to LLMResult containing the LLM response
     */
    async sendRequest(messages, options) {
        try {
            LogUtil.logInfo('LLM  ', {
                messageCount: messages.length,
                options: options
            });
            //   (  )
            // options?.model || this.getActiveModel();
            if (this._connectionType === ConnectionType.WebSocket) {
                LogUtil.logInfo('WebSocket  ', {
                    model: options?.model || this.getActiveModel()
                });
                const response = await this._sendWebSocketRequest(messages, options);
                return { success: true, data: response };
            }
            else {
                LogUtil.logInfo('HTTP  ', {
                    model: options?.model || this.getActiveModel()
                });
                const response = await this._sendHttpRequest(messages, options);
                return { success: true, data: response };
            }
        }
        catch (error) {
            LogUtil.logError('LLM    ', error);
            return {
                success: false,
                error: error instanceof Error
                    ? error
                    : new Error(`Failed to communicate with LLM service: ${String(error)}`)
            };
        }
    }
    /**
     * Streams a response from the LLM
     * @param messages Messages to send
     * @param streamCallback Callback for streaming chunks and completion
     * @param options Request options
     * @returns Promise that resolves to LLMResult indicating streaming success or failure
     */
    async streamResponse(messages, streamCallback, options) {
        try {
            LogUtil.logInfo('LLM   ', {
                messageCount: messages.length,
                options: options
            });
            //   (  )
            // options?.model || this.getActiveModel();
            if (this._connectionType === ConnectionType.WebSocket) {
                LogUtil.logInfo('WebSocket  ', {
                    model: options?.model || this.getActiveModel()
                });
                await this._streamWebSocketResponse(messages, streamCallback, options);
                return { success: true };
            }
            else {
                LogUtil.logInfo('HTTP  ', {
                    model: options?.model || this.getActiveModel()
                });
                await this._streamHttpResponse(messages, streamCallback, options);
                return { success: true };
            }
        }
        catch (error) {
            LogUtil.logError('LLM    ', error);
            //        UI    
            //       
            const errorMessage = error instanceof Error
                ? ` : ${error.message}`
                : ` : LLM    (${String(error)})`;
            //      (true) 
            streamCallback(errorMessage, true);
            return {
                success: false,
                error: error instanceof Error
                    ? error
                    : new Error(`Failed to stream from LLM service: ${String(error)}`)
            };
        }
    }
    /**
     * Cancels an ongoing streaming response
     * @param streamCallback Optional callback to notify about cancellation
     */
    cancelStream(streamCallback) {
        LogUtil.logInfo('  ');
        if (this._connectionType === ConnectionType.HTTP && this._cancelTokenSource) {
            this._cancelTokenSource.cancel('Operation canceled by user');
            this._cancelTokenSource = null;
            LogUtil.logInfo('HTTP  ');
            //     ()
            if (streamCallback) {
                streamCallback('\n\n* .*', true);
            }
        }
        else if (this._connectionType === ConnectionType.WebSocket && this._wsConnection) {
            // Send cancel message if supported
            try {
                this._wsConnection.send(JSON.stringify({ type: 'cancel' }));
                LogUtil.logInfo('WebSocket   ');
                //     ()
                if (streamCallback) {
                    streamCallback('\n\n* .*', true);
                }
            }
            catch (error) {
                LogUtil.logError('WebSocket    ', error);
                //    ()
                if (streamCallback) {
                    streamCallback('\n\n*    .*', true);
                }
            }
        }
    }
    /**
     * HTTP implementation of sendRequest
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to the LLM response
     */
    async _sendHttpRequest(messages, options) {
        const formattedMessages = this._formatMessagesForAPI(messages, options);
        const requestId = generateUUID();
        // OpenRouter API   
        const openRouterMessages = formattedMessages.map(msg => ({
            role: msg.role,
            content: msg.content
        }));
        const request = {
            model: options?.model || this.getActiveModel(),
            messages: openRouterMessages,
            temperature: options?.temperature || 0.7,
            max_tokens: options?.maxTokens || 1000,
            stream: false
        };
        // OpenRouter API    
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this._apiKey}`,
            'HTTP-Referer': 'APE-Extension',
            'X-Title': 'APE (Agentic Pipeline Engine)'
        };
        LogUtil.logRequest(this._endpoint, headers, request);
        try {
            const response = await axios__WEBPACK_IMPORTED_MODULE_5__["default"].post(this._endpoint, request, { headers });
            LogUtil.logResponse(response.data);
            return this._processHttpResponse(response.data);
        }
        catch (error) {
            LogUtil.logError('HTTP    ', error);
            throw error;
        }
    }
    /**
     * WebSocket implementation of sendRequest
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to the LLM response
     */
    async _sendWebSocketRequest(messages, options) {
        return new Promise((resolve, reject) => {
            this._ensureWebSocketConnection();
            if (!this._wsConnection) {
                const error = new Error('Failed to establish WebSocket connection');
                LogUtil.logError('WebSocket  ', error);
                reject(error);
                return;
            }
            const formattedMessages = this._formatMessagesForAPI(messages, options);
            const request = {
                messages: formattedMessages,
                model: options?.model || this.getActiveModel(),
                temperature: options?.temperature,
                maxTokens: options?.maxTokens,
                stream: false,
                parameters: options?.modelParameters
            };
            // Generate a unique request ID
            const requestId = generateUUID();
            LogUtil.logInfo('WebSocket   ', { requestId });
            // Set up one-time message handler for this request
            const messageHandler = (data) => {
                try {
                    const dataStr = data.toString();
                    LogUtil.logInfo('WebSocket  ', {
                        dataPreview: dataStr.substring(0, 100) + (dataStr.length > 100 ? '...' : '')
                    });
                    const response = JSON.parse(dataStr);
                    // Check if this is the response to our request
                    if (response.requestId === requestId) {
                        // Remove the listener once we get our response
                        if (this._wsConnection) {
                            this._wsConnection.removeListener('message', messageHandler);
                        }
                        if (response.error) {
                            LogUtil.logError('WebSocket  ', new Error(response.error));
                            reject(new Error(response.error));
                        }
                        else {
                            LogUtil.logInfo('WebSocket   ');
                            resolve(this._processWebSocketResponse(response));
                        }
                    }
                }
                catch (error) {
                    LogUtil.logError('WebSocket    ', error);
                    reject(error);
                }
            };
            // Add the message handler
            this._wsConnection.on('message', messageHandler);
            // Send the request with the request ID
            try {
                this._wsConnection.send(JSON.stringify({
                    ...request,
                    requestId
                }));
                LogUtil.logInfo('WebSocket   ', { requestId });
            }
            catch (error) {
                LogUtil.logError('WebSocket   ', error);
                reject(error);
                return;
            }
            // Set a timeout in case of no response
            const timeoutId = setTimeout(() => {
                if (this._wsConnection) {
                    this._wsConnection.removeListener('message', messageHandler);
                }
                const timeoutError = new Error('Request timed out');
                LogUtil.logError('WebSocket  ', timeoutError);
                reject(timeoutError);
            }, 30000); // 30 seconds timeout
            // Also set up an error handler
            const errorHandler = (error) => {
                clearTimeout(timeoutId);
                this._wsConnection?.removeListener('message', messageHandler);
                this._wsConnection?.removeListener('error', errorHandler);
                LogUtil.logError('WebSocket  ', error);
                reject(error);
            };
            this._wsConnection.on('error', errorHandler);
        });
    }
    /**
     * HTTP implementation of streamResponse
     * @param messages Messages to send
     * @param streamCallback Callback for streaming chunks and completion
     * @param options Request options
     */
    async _streamHttpResponse(messages, streamCallback, options) {
        const formattedMessages = this._formatMessagesForAPI(messages, options);
        const requestId = generateUUID();
        // OpenRouter API   
        const openRouterMessages = formattedMessages.map(msg => ({
            role: msg.role,
            content: msg.content
        }));
        const request = {
            model: options?.model || this.getActiveModel(),
            messages: openRouterMessages,
            temperature: options?.temperature || 0.7,
            max_tokens: options?.maxTokens || 1000,
            stream: true
        };
        // OpenRouter API    
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this._apiKey}`,
            'HTTP-Referer': 'APE-Extension',
            'X-Title': 'APE (Agentic Pipeline Engine)'
        };
        // Create a cancellation token
        this._cancelTokenSource = axios__WEBPACK_IMPORTED_MODULE_5__["default"].CancelToken.source();
        LogUtil.logRequest(this._endpoint, headers, request);
        LogUtil.logInfo('HTTP   ', { requestId });
        try {
            //       
            let chunkCount = 0;
            let accumulatedText = '';
            const response = await axios__WEBPACK_IMPORTED_MODULE_5__["default"].post(this._endpoint, request, {
                responseType: 'stream',
                cancelToken: this._cancelTokenSource.token,
                headers: headers
            });
            LogUtil.logInfo('  ', {
                status: response.status,
                statusText: response.statusText
            });
            response.data.on('data', (chunk) => {
                const chunkStr = chunk.toString();
                LogUtil.logInfo(`   #${++chunkCount} `, {
                    chunkSize: chunkStr.length,
                    chunkPreview: chunkStr.substring(0, 100) + (chunkStr.length > 100 ? '...' : '')
                });
                const lines = chunkStr.split('\n').filter(Boolean);
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.substring('data: '.length);
                        if (data === '[DONE]') {
                            LogUtil.logInfo('   [DONE] ');
                            streamCallback('', true); //   
                        }
                        else {
                            try {
                                const parsed = JSON.parse(data);
                                LogUtil.logStreamChunk(data, parsed);
                                if (parsed.choices && parsed.choices.length > 0) {
                                    const content = parsed.choices[0].delta?.content ||
                                        parsed.choices[0].message?.content || '';
                                    if (content) {
                                        accumulatedText += content;
                                        LogUtil.logInfo('  ', {
                                            contentLength: content.length,
                                            contentPreview: content.substring(0, 50) + (content.length > 50 ? '...' : ''),
                                            totalAccumulated: accumulatedText.length
                                        });
                                        streamCallback(content, false);
                                    }
                                }
                                else if (parsed.error) {
                                    //   API  
                                    const errorContent = `\n\n** **: ${parsed.error.message || '    .'}`;
                                    LogUtil.logError('API   ', new Error(parsed.error.message));
                                    streamCallback(errorContent, true); //       
                                    throw new Error(parsed.error.message || 'API error during streaming');
                                }
                            }
                            catch (err) {
                                LogUtil.logError('   ', err);
                                // JSON      (   )
                            }
                        }
                    }
                }
            });
            response.data.on('end', () => {
                this._cancelTokenSource = null;
                LogUtil.logInfo(' ', {
                    totalChunks: chunkCount,
                    totalAccumulatedLength: accumulatedText.length
                });
                streamCallback('', true); //   
            });
            response.data.on('error', (err) => {
                this._cancelTokenSource = null;
                //    (TLS     )
                let errorMessage = ' .';
                try {
                    errorMessage = err.message || errorMessage;
                }
                catch (serializationError) {
                    //      -   
                }
                LogUtil.logError(' ', {
                    message: errorMessage,
                    name: err.name || 'Unknown Error'
                });
                //           
                const errorContent = `\n\n**  **: ${errorMessage}`;
                streamCallback(errorContent, true);
            });
        }
        catch (error) {
            this._cancelTokenSource = null;
            if (axios__WEBPACK_IMPORTED_MODULE_5__["default"].isCancel(error)) {
                // Request was canceled intentionally
                LogUtil.logInfo('  ');
                streamCallback('\n\n* .*', true); //   
            }
            else {
                // Real error -    
                let errorMessage = ' ';
                try {
                    errorMessage = error instanceof Error ? error.message : String(error);
                }
                catch (serializationError) {
                    //      -   
                }
                LogUtil.logError('     ', {
                    message: errorMessage,
                    name: error instanceof Error ? error.name : 'Unknown Error'
                });
                const errorContent = `\n\n**API  **: ${errorMessage}`;
                streamCallback(errorContent, true); //       
                throw error;
            }
        }
    }
    /**
     * WebSocket implementation of streamResponse
     * @param messages Messages to send
     * @param streamCallback Callback for streaming chunks and completion
     * @param options Request options
     */
    async _streamWebSocketResponse(messages, streamCallback, options) {
        return new Promise((resolve, reject) => {
            this._ensureWebSocketConnection();
            if (!this._wsConnection) {
                //          
                const errorMessage = '\n\n**WebSocket  **:    .';
                LogUtil.logError('WebSocket  ', new Error('Failed to establish WebSocket connection'));
                streamCallback(errorMessage, true);
                reject(new Error('Failed to establish WebSocket connection'));
                return;
            }
            const formattedMessages = this._formatMessagesForAPI(messages, options);
            const request = {
                messages: formattedMessages,
                model: options?.model || this.getActiveModel(),
                temperature: options?.temperature,
                maxTokens: options?.maxTokens,
                stream: true,
                parameters: options?.modelParameters
            };
            // Generate a unique request ID
            const requestId = generateUUID();
            LogUtil.logInfo('WebSocket    ', { requestId });
            let chunkCount = 0;
            let accumulatedText = '';
            // Set up message handler for streaming
            const messageHandler = (data) => {
                try {
                    const dataStr = data.toString();
                    const response = JSON.parse(dataStr);
                    // Check if this is a response to our request
                    if (response.requestId === requestId) {
                        if (response.error) {
                            // Error response -    
                            const errorMessage = `\n\n**WebSocket  **: ${response.error}`;
                            LogUtil.logError('WebSocket   ', new Error(response.error));
                            streamCallback(errorMessage, true); //       
                            if (this._wsConnection) {
                                this._wsConnection.removeListener('message', messageHandler);
                            }
                            reject(new Error(response.error));
                        }
                        else if (response.type === 'chunk') {
                            // Streaming chunk
                            chunkCount++;
                            const content = response.content || '';
                            if (content) {
                                accumulatedText += content;
                                LogUtil.logInfo(`WebSocket   #${chunkCount}`, {
                                    contentLength: content.length,
                                    contentPreview: content.substring(0, 50) + (content.length > 50 ? '...' : ''),
                                    totalAccumulated: accumulatedText.length
                                });
                            }
                            streamCallback(content, false);
                        }
                        else if (response.type === 'complete') {
                            // Stream complete
                            LogUtil.logInfo('WebSocket  ', {
                                totalChunks: chunkCount,
                                totalAccumulatedLength: accumulatedText.length
                            });
                            if (this._wsConnection) {
                                this._wsConnection.removeListener('message', messageHandler);
                            }
                            streamCallback('', true); // Signal completion
                            resolve();
                        }
                    }
                }
                catch (error) {
                    // JSON     
                    let errorMessage = '   ';
                    try {
                        errorMessage = error instanceof Error ? error.message : String(error);
                    }
                    catch (serializationError) {
                        //      -   
                    }
                    LogUtil.logError('WebSocket   ', {
                        message: errorMessage,
                        name: error instanceof Error ? error.name : 'Unknown Error'
                    });
                    const wsErrorMessage = `\n\n**WebSocket   **: ${errorMessage}`;
                    streamCallback(wsErrorMessage, true);
                    if (this._wsConnection) {
                        this._wsConnection.removeListener('message', messageHandler);
                    }
                    reject(error);
                }
            };
            // Add the message handler
            this._wsConnection.on('message', messageHandler);
            // Send the streaming request
            try {
                this._wsConnection.send(JSON.stringify({
                    ...request,
                    requestId
                }));
                LogUtil.logInfo('WebSocket    ', { requestId });
            }
            catch (error) {
                //     
                let errorMessage = '   ';
                try {
                    errorMessage = error instanceof Error ? error.message : String(error);
                }
                catch (serializationError) {
                    //      -   
                }
                LogUtil.logError('WebSocket    ', {
                    message: errorMessage,
                    name: error instanceof Error ? error.name : 'Unknown Error'
                });
                const wsErrorMessage = `\n\n**WebSocket   **: ${errorMessage}`;
                streamCallback(wsErrorMessage, true);
                reject(error);
                return;
            }
            // Set a timeout for the entire streaming session
            const timeoutId = setTimeout(() => {
                if (this._wsConnection) {
                    this._wsConnection.removeListener('message', messageHandler);
                }
                //      
                const timeoutError = new Error('Streaming request timed out');
                LogUtil.logError('WebSocket   ', timeoutError);
                const timeoutMessage = '\n\n**  **:     .';
                streamCallback(timeoutMessage, true);
                reject(timeoutError);
            }, 300000); // 5 minutes timeout for streaming
            // Also set up an error handler
            const errorHandler = (error) => {
                clearTimeout(timeoutId);
                // WebSocket      
                let errorMessage = '   .';
                try {
                    errorMessage = error.message || errorMessage;
                }
                catch (serializationError) {
                    //      -   
                }
                LogUtil.logError('WebSocket  ', {
                    message: errorMessage,
                    name: error.name || 'Unknown Error'
                });
                const wsErrorMessage = `\n\n**WebSocket  **: ${errorMessage}`;
                streamCallback(wsErrorMessage, true);
                this._wsConnection?.removeListener('message', messageHandler);
                this._wsConnection?.removeListener('error', errorHandler);
                reject(error);
            };
            this._wsConnection.on('error', errorHandler);
        });
    }
    /**
     * Ensures a WebSocket connection is established
     */
    _ensureWebSocketConnection() {
        if (this._connectionType !== ConnectionType.WebSocket) {
            LogUtil.logInfo('WebSocket    - HTTP   ');
            return;
        }
        if (!this._wsConnection || this._wsConnection.readyState !== WS_OPEN) {
            LogUtil.logInfo(' WebSocket  ', { endpoint: this._endpoint });
            try {
                // Create a new WebSocket connection
                this._wsConnection = new ws__WEBPACK_IMPORTED_MODULE_1__.WebSocket(this._endpoint);
                // Set up event handlers
                if (this._wsConnection) {
                    this._wsConnection.on('error', (error) => {
                        LogUtil.logError('WebSocket ', error);
                        this._wsConnection = null;
                    });
                    this._wsConnection.on('close', () => {
                        LogUtil.logInfo('WebSocket  ');
                        this._wsConnection = null;
                    });
                    // Wait for connection to be established
                    this._wsConnection.on('open', () => {
                        LogUtil.logInfo('WebSocket   ');
                    });
                }
            }
            catch (error) {
                LogUtil.logError('WebSocket   ', error);
                this._wsConnection = null;
            }
        }
        else {
            LogUtil.logInfo(' WebSocket  ');
        }
    }
    /**
     * Formats messages for the API
     * @param messages Messages to format
     * @param options Optional request options
     * @returns Formatted messages array
     */
    _formatMessagesForAPI(messages, options) {
        LogUtil.logInfo('API   ', {
            messageCount: messages.length,
            hasSystemPrompt: !!options?.systemPrompt,
            hasContextMessages: options?.contextMessages ? options.contextMessages.length : 0
        });
        let formattedMessages = [...messages];
        // Add system prompt as a system message if provided
        if (options?.systemPrompt) {
            formattedMessages.unshift({
                id: `system_${Date.now()}`,
                role: _types_chat__WEBPACK_IMPORTED_MODULE_2__.MessageRole.System,
                content: options.systemPrompt,
                timestamp: new Date()
            });
            LogUtil.logInfo('  ');
        }
        // Add context messages if provided
        if (options?.contextMessages && options.contextMessages.length > 0) {
            formattedMessages = [...options.contextMessages, ...formattedMessages];
            LogUtil.logInfo(`  ${options.contextMessages.length} `);
        }
        // Apply VAULT context if available and requested
        if (this._vaultService && options?.vaultOptions) {
            const vaultOptions = options.vaultOptions;
            // vaultOptions undefined         
            formattedMessages = (0,_vaultIntegration__WEBPACK_IMPORTED_MODULE_3__.applyVaultContext)(formattedMessages, this._vaultService, vaultOptions || {});
            LogUtil.logInfo('VAULT  ');
        }
        // Apply Rules if available
        if (this._rulesService) {
            const rulesOptions = options?.rulesOptions;
            formattedMessages = (0,_rulesIntegration__WEBPACK_IMPORTED_MODULE_4__.applyRulesContext)(formattedMessages, this._rulesService, rulesOptions);
            LogUtil.logInfo('Rules  ');
        }
        // Return formatted messages
        LogUtil.logInfo('  ', { finalMessageCount: formattedMessages.length });
        return formattedMessages;
    }
    /**
     * Processes an HTTP API response
     * @param responseData Raw response data
     * @returns Processed LLM response
     */
    _processHttpResponse(responseData) {
        // OpenRouter/OpenAI    (choices  )
        if (responseData.choices && Array.isArray(responseData.choices)) {
            const content = responseData.choices[0]?.message?.content || '';
            LogUtil.logInfo('OpenAI/OpenRouter   ', {
                responseId: responseData.id,
                contentLength: content.length
            });
            return {
                message: {
                    id: responseData.id || `msg_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_2__.MessageRole.Assistant,
                    content: content,
                    timestamp: new Date(),
                    metadata: {
                        model: responseData.model || this.getActiveModel()
                    }
                },
                usage: responseData.usage || {
                    promptTokens: 0,
                    completionTokens: 0,
                    totalTokens: 0
                },
                metadata: responseData.metadata || {},
                content: content //   
            };
        }
        //    
        else {
            const messageContent = responseData.content || responseData.message?.content || '';
            LogUtil.logInfo('   ', {
                responseId: responseData.message?.id,
                contentLength: messageContent.length
            });
            return {
                message: {
                    id: responseData.message?.id || `msg_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_2__.MessageRole.Assistant,
                    content: messageContent,
                    timestamp: new Date(),
                    metadata: responseData.message?.metadata || {
                        model: responseData.model || this.getActiveModel()
                    }
                },
                usage: responseData.usage || {
                    promptTokens: 0,
                    completionTokens: 0,
                    totalTokens: 0
                },
                metadata: responseData.metadata || {}
            };
        }
    }
    /**
     * Processes a WebSocket API response
     * @param responseData Raw response data
     * @returns Processed LLM response
     */
    _processWebSocketResponse(responseData) {
        // Process according to the WebSocket response format
        const messageContent = responseData.content || responseData.message?.content || '';
        LogUtil.logInfo('WebSocket  ', {
            responseId: responseData.message?.id,
            contentLength: messageContent.length
        });
        return {
            message: {
                id: responseData.message?.id || `msg_${Date.now()}`,
                role: _types_chat__WEBPACK_IMPORTED_MODULE_2__.MessageRole.Assistant,
                content: messageContent,
                timestamp: new Date(),
                metadata: responseData.message?.metadata || {
                    model: responseData.model || this.getActiveModel()
                }
            },
            usage: responseData.usage || {
                promptTokens: 0,
                completionTokens: 0,
                totalTokens: 0
            },
            metadata: responseData.metadata || {}
        };
    }
    /**
     * Processes a streaming chunk
     * @param chunk Raw chunk data
     * @returns Processed chunk as a string
     */
    _processStreamChunk(chunk) {
        // Skip processing for empty chunks
        if (!chunk) {
            return '';
        }
        LogUtil.logInfo('   ');
        // Process based on the API's streaming format
        try {
            if (typeof chunk === 'string') {
                // Skip empty strings
                if (!chunk.trim()) {
                    return '';
                }
                try {
                    // Try to parse as JSON if it's a string
                    const data = JSON.parse(chunk);
                    const content = data.content || data.text || data.chunk || '';
                    // Only log non-empty content
                    if (content) {
                        LogUtil.logInfo('   ( )', {
                            contentLength: content.length
                        });
                    }
                    return content;
                }
                catch (e) {
                    // If it's not JSON, return as is
                    return chunk;
                }
            }
            else if (typeof chunk === 'object') {
                // Already a parsed object
                const content = chunk.content || chunk.text || chunk.chunk || '';
                // Only log non-empty content
                if (content) {
                    LogUtil.logInfo('   ( )', {
                        contentLength: content.length
                    });
                }
                return content;
            }
        }
        catch (error) {
            // If parsing fails, return as is but log error
            LogUtil.logError('  ', error);
            return chunk ? chunk.toString() : '';
        }
        // Default case - return empty string for anything else
        return '';
    }
    /**
     * Gets a simple completion from the LLM for a prompt
     * @param prompt The prompt to send to the LLM
     * @param options Optional request options
     * @returns Promise that resolves to LLMResult containing the completion text
     */
    async getCompletion(prompt, options) {
        try {
            LogUtil.logInfo('   ', {
                promptLength: prompt.length,
                promptPreview: prompt.substring(0, 100) + (prompt.length > 100 ? '...' : '')
            });
            // Create a simple message with the prompt
            const messages = [
                {
                    id: `user_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_2__.MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            // Send the request
            const result = await this.sendRequest(messages, options);
            if (result.success && result.data) {
                LogUtil.logInfo('  ', {
                    contentLength: result.data.message.content.length
                });
                return {
                    success: true,
                    data: result.data.message.content
                };
            }
            else {
                LogUtil.logError('  ', result.error || new Error('Failed to get completion'));
                return {
                    success: false,
                    error: result.error || new Error('Failed to get completion')
                };
            }
        }
        catch (error) {
            LogUtil.logError('   ', error);
            return {
                success: false,
                error: error instanceof Error
                    ? error
                    : new Error(`Failed to get completion: ${String(error)}`)
            };
        }
    }
    /**
     * Disposes resources
     */
    dispose() {
        LogUtil.logInfo('LLMService   ');
        // Dispose event listeners
        this._configListener.dispose();
        this._modelChangeListener.dispose();
        // Cancel any ongoing operations
        if (this._cancelTokenSource) {
            this._cancelTokenSource.cancel('Extension deactivated');
            this._cancelTokenSource = null;
            LogUtil.logInfo('  HTTP  ');
        }
        // Close WebSocket connection
        if (this._wsConnection) {
            this._wsConnection.close();
            this._wsConnection = null;
            LogUtil.logInfo('WebSocket  ');
        }
        LogUtil.logInfo('LLMService   ');
    }
}


/***/ }),

/***/ "./src/core/llm/modelManager.ts":
/*!**************************************!*\
  !*** ./src/core/llm/modelManager.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModelManager: () => (/* binding */ ModelManager)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types_models__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../types/models */ "./src/types/models.ts");


/**
 *   
 * LLM  ,     .
 */
class ModelManager {
    _context;
    //   
    _activeModel = _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI;
    //      
    _isUpdatingConfig = false;
    //   
    _onDidChangeModel = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    onDidChangeModel = this._onDidChangeModel.event;
    //     
    _configListener;
    /**
     * 
     * @param _context VSCode  
     */
    constructor(_context) {
        this._context = _context;
        //   
        this._loadConfiguration();
        //    
        this._configListener = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration('ape.llm.defaultModel') && !this._isUpdatingConfig) {
                this._loadConfiguration();
            }
        });
    }
    /**
     *    
     */
    _loadConfiguration() {
        try {
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.llm');
            const configModel = config.get('defaultModel', _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI);
            //   
            if (this._isValidModel(configModel)) {
                //     
                if (this._activeModel !== configModel) {
                    const oldModel = this._activeModel;
                    this._activeModel = configModel;
                    //    
                    this._onDidChangeModel.fire({
                        oldModel,
                        newModel: this._activeModel
                    });
                }
            }
            else {
                console.warn(`  : ${configModel},   : ${_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI}`);
                //        
                if (this._activeModel !== _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI) {
                    const oldModel = this._activeModel;
                    this._activeModel = _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI;
                    //    
                    this._isUpdatingConfig = true;
                    //  
                    Promise.resolve(config.update('defaultModel', _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global))
                        .then(() => {
                        //    
                        this._onDidChangeModel.fire({
                            oldModel,
                            newModel: _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI
                        });
                        console.log(`   : ${_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId.GPT_4_1_MINI}`);
                    })
                        .then(undefined, (err) => {
                        console.error('   :', err);
                    })
                        .finally(() => {
                        //     ( )
                        setTimeout(() => {
                            this._isUpdatingConfig = false;
                        }, 100);
                    });
                }
            }
        }
        catch (error) {
            console.error('    :', error);
        }
    }
    /**
     *  ID  
     * @param modelId   ID
     * @returns   
     */
    _isValidModel(modelId) {
        //   
        const isStandardModel = Object.values(_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId).includes(modelId);
        return isStandardModel;
    }
    /**
     *    
     * @returns   
     */
    getActiveModel() {
        return this._activeModel;
    }
    /**
     *   
     * @param model   
     * @returns    Promise
     */
    async setActiveModel(model) {
        //        
        if (this._activeModel === model || this._isUpdatingConfig) {
            return false;
        }
        //   
        if (!this._isValidModel(model)) {
            console.warn(`  : ${model},   : ${this._activeModel}`);
            return false;
        }
        try {
            //    
            this._isUpdatingConfig = true;
            //   
            const oldModel = this._activeModel;
            //   
            this._activeModel = model;
            //    
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.llm');
            await config.update('defaultModel', model, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global);
            //    
            this._onDidChangeModel.fire({
                oldModel,
                newModel: model
            });
            console.log(` : ${oldModel} -> ${model}`);
            return true;
        }
        catch (error) {
            console.error('   :', error);
            return false;
        }
        finally {
            //     ( )
            setTimeout(() => {
                this._isUpdatingConfig = false;
            }, 100);
        }
    }
    /**
     *     
     * @returns    
     */
    getAvailableModels() {
        try {
            //     
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.llm');
            // inspect       
            const inspection = config.inspect('defaultModel');
            const configModels = inspection && typeof inspection === 'object' ?
                inspection.properties?.enum : undefined;
            //      
            if (configModels && Array.isArray(configModels)) {
                //    
                return configModels.filter(model => model !== 'NARRNAS' &&
                    model !== 'LLAMA4-SCOUT' &&
                    model !== 'LLAMA4-MAVERICK');
            }
            //    (  )
            return Object.values(_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId);
        }
        catch (error) {
            //       
            console.error('    :', error);
            return Object.values(_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId);
        }
    }
    /**
     *     -  CommandManager 
     * @deprecated      ,   CommandManager .
     *
     * :       .
     * extension.ts commandManager.registerCommands() .
     */
    registerCommands() {
        console.log(': ModelManager.registerCommands() . CommandManager .');
        //    
    }
    /**
     *  ID   
     * @param modelId  ID
     * @returns     
     */
    getModelDisplayName(modelId) {
        // ModelDisplayNames     
        if (Object.values(_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId).includes(modelId)) {
            return _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelDisplayNames[modelId];
        }
        //      (   )
        switch (modelId) {
            case 'openai/gpt-4.1-mini':
                return 'GPT-4.1 Mini';
            case 'anthropic/claude-3-haiku-20240307':
                return 'Claude 3 Haiku';
            case 'anthropic/claude-3-sonnet-20240229':
                return 'Claude 3 Sonnet';
            case 'perplexity/sonar-small-online':
                return 'Perplexity Sonar';
            case 'mistralai/mistral-large-latest':
                return 'Mistral Large';
            case 'google/gemma-7b-it':
                return 'Gemma 7B';
            default: {
                // 'provider/model-name'   
                const parts = modelId.split('/');
                if (parts.length > 1) {
                    //       
                    const modelName = parts[1].replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                    return modelName;
                }
                return modelId;
            }
        }
    }
    /**
     *    
     * @param model  
     * @returns  
     */
    getModelDescription(model) {
        // ModelDescriptions    
        if (Object.values(_types_models__WEBPACK_IMPORTED_MODULE_1__.ModelId).includes(model)) {
            return _types_models__WEBPACK_IMPORTED_MODULE_1__.ModelDescriptions[model];
        }
        //      (   )
        switch (model) {
            case 'openai/gpt-4.1-mini':
                return '    ( )';
            case 'anthropic/claude-3-haiku-20240307':
                return '    ';
            case 'anthropic/claude-3-sonnet-20240229':
                return '    ';
            case 'anthropic/claude-3-opus-20240229':
                return '      ';
            case 'google/gemini-pro':
                return 'Google   ';
            case 'google/gemma-7b-it':
                return '  ,   ';
            default:
                return '';
        }
    }
    /**
     *  
     */
    dispose() {
        //   
        this._onDidChangeModel.dispose();
        //    
        this._configListener.dispose();
    }
}


/***/ }),

/***/ "./src/core/llm/rulesIntegration.ts":
/*!******************************************!*\
  !*** ./src/core/llm/rulesIntegration.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyRulesContext: () => (/* binding */ applyRulesContext)
/* harmony export */ });
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/**
 * Rules  
 *
 * LLM  Rules   .
 * LLM   Rules   .
 */

/**
 * Rules    
 * @param messages  
 * @param rulesService Rules 
 * @param options Rules 
 * @returns Rules   
 */
function applyRulesContext(messages, rulesService, options) {
    // Rules   false  Rules 
    const includeRules = options?.includeRules !== false;
    if (!includeRules || !rulesService) {
        return messages;
    }
    try {
        //  Rules  
        const activeRules = rulesService.getActiveRules();
        if (activeRules.length === 0) {
            return messages;
        }
        // Rules   
        const rulesPrompt = rulesService.getRulesAsSystemPrompt();
        if (!rulesPrompt) {
            return messages;
        }
        //     
        const systemMessageIndex = messages.findIndex(msg => msg.role === _types_chat__WEBPACK_IMPORTED_MODULE_0__.MessageRole.System);
        if (systemMessageIndex >= 0) {
            //     Rules  
            const updatedMessages = [...messages];
            const existingSystemMessage = updatedMessages[systemMessageIndex];
            updatedMessages[systemMessageIndex] = {
                ...existingSystemMessage,
                content: `${rulesPrompt}\n\n${existingSystemMessage.content}`
            };
            return updatedMessages;
        }
        else {
            //       
            return [
                {
                    id: `system_rules_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_0__.MessageRole.System,
                    content: rulesPrompt,
                    timestamp: new Date()
                },
                ...messages
            ];
        }
    }
    catch (error) {
        console.error('Rules    :', error);
        return messages;
    }
}


/***/ }),

/***/ "./src/core/llm/vaultIntegration.ts":
/*!******************************************!*\
  !*** ./src/core/llm/vaultIntegration.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyVaultContext: () => (/* binding */ applyVaultContext)
/* harmony export */ });
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");
/* harmony import */ var _services_vaultService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../services/vaultService */ "./src/core/services/vaultService.ts");
/**
 * VAULT  LLM   
 *
 * VAULT  LLM    .
 */


/**
 * VAULT  LLM  
 * @param messages   
 * @param vaultService VAULT  
 * @param options VAULT   
 * @returns VAULT    
 */
function applyVaultContext(messages, vaultService, options) {
    if (!options) {
        return messages;
    }
    //    
    const items = findRelevantVaultItems(vaultService, options);
    if (items.length === 0) {
        return messages;
    }
    //   
    const contextMessages = createContextMessages(items);
    //      
    return combineMessages(messages, contextMessages, options.combinationMode || 'prepend');
}
/**
 *   VAULT  
 */
function findRelevantVaultItems(vaultService, options) {
    let result = [];
    // 1.  ID   (  )
    if (options.itemIds && options.itemIds.length > 0) {
        const allContexts = vaultService.getAllContexts();
        for (const context of allContexts) {
            const matchingItems = context.items.filter(item => options.itemIds.includes(item.id));
            result.push(...matchingItems);
        }
        //  ID      
        return result;
    }
    // 2.  ID     
    if (options.contextIds && options.contextIds.length > 0) {
        for (const contextId of options.contextIds) {
            const context = vaultService.getContextById(contextId);
            if (context) {
                result.push(...context.items);
            }
        }
        //        
    }
    // 3.    (contextIds  )
    if ((!options.contextIds || options.contextIds.length === 0) &&
        options.contextTypes && options.contextTypes.length > 0) {
        for (const contextType of options.contextTypes) {
            const contexts = vaultService.getContextsByType(contextType);
            for (const context of contexts) {
                result.push(...context.items);
            }
        }
    }
    // 4.     ,     
    if ((!options.contextIds || options.contextIds.length === 0) &&
        (!options.contextTypes || options.contextTypes.length === 0) &&
        (options.searchQuery || (options.tags && options.tags.length > 0))) {
        result = vaultService.searchItems(options.searchQuery || '', { tags: options.tags });
    }
    //  :   (     )
    if (options.tags && options.tags.length > 0) {
        result = result.filter(item => {
            if (!item.tags)
                return false;
            return options.tags.some(tag => item.tags.includes(tag));
        });
    }
    //  :   (     )
    if (options.searchQuery) {
        const query = options.searchQuery.toLowerCase();
        result = result.filter(item => item.name.toLowerCase().includes(query) ||
            (item.description && item.description.toLowerCase().includes(query)) ||
            item.content.toLowerCase().includes(query) ||
            (item.tags && item.tags.some(tag => tag.toLowerCase().includes(query))));
    }
    return result;
}
/**
 * VAULT    
 */
function createContextMessages(items) {
    const contextMessages = [];
    //    
    for (const item of items) {
        //       
        let role = _types_chat__WEBPACK_IMPORTED_MODULE_0__.MessageRole.System;
        if (item.contextType === _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Personal ||
            item.contextType === _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Project ||
            item.contextType === _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Shared) {
            role = _types_chat__WEBPACK_IMPORTED_MODULE_0__.MessageRole.User;
        }
        contextMessages.push({
            id: `vault_${item.id}_${Date.now()}`,
            role,
            content: formatItemContent(item),
            timestamp: new Date(),
            metadata: {
                isVaultContext: true,
                vaultItemId: item.id,
                vaultContextType: item.contextType,
                vaultTags: item.tags
            }
        });
    }
    return contextMessages;
}
/**
 * VAULT   
 */
function formatItemContent(item) {
    //    
    const content = item.content;
    //      
    if (item.contextType === _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.System) {
        //   
        return content;
    }
    else if (item.contextType === _services_vaultService__WEBPACK_IMPORTED_MODULE_1__.VaultContextType.Template) {
        //   
        return content;
    }
    else {
        //    
        const header = `VAULT : ${item.name}\n`;
        const tags = item.tags?.length ? `: ${item.tags.join(', ')}\n` : '';
        return `${header}${tags}${content}`;
    }
}
/**
 *     
 */
function combineMessages(originalMessages, contextMessages, mode) {
    if (mode === 'replace') {
        return contextMessages;
    }
    else if (mode === 'append') {
        return [...originalMessages, ...contextMessages];
    }
    else { // prepend ()
        return [...contextMessages, ...originalMessages];
    }
}


/***/ }),

/***/ "./src/core/memory/memoryService.ts":
/*!******************************************!*\
  !*** ./src/core/memory/memoryService.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MemoryService: () => (/* binding */ MemoryService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs/promises */ "fs/promises");
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../types/chat */ "./src/types/chat.ts");





/**
 * Memory service manages storing and retrieving conversation data
 */
class MemoryService {
    _context;
    _sessions = new Map();
    _currentSessionId = null;
    _storageDir;
    _maxMessages;
    _sessionDuration;
    _configListener;
    /**
     * Creates a new MemoryService instance
     * @param _context The VSCode extension context
     */
    constructor(_context) {
        this._context = _context;
        // Initialize properties
        this._maxMessages = 30;
        this._sessionDuration = 240;
        // Create storage directory
        this._storageDir = path__WEBPACK_IMPORTED_MODULE_1__.join(_context.globalStoragePath, 'memory');
        this._ensureStorageDirectory();
        // Load configuration
        this._loadConfiguration();
        // Initialize with default session
        this._initializeDefaultSession();
        // Listen for configuration changes
        this._configListener = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.memory')) {
                this._loadConfiguration();
            }
        });
    }
    /**
     * Loads configuration from VSCode settings
     */
    _loadConfiguration() {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.memory');
        this._maxMessages = config.get('maxMessages', 30);
        this._sessionDuration = config.get('sessionDuration', 240); // minutes
    }
    /**
     * Creates storage directory if it doesn't exist
     */
    _ensureStorageDirectory() {
        if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(this._storageDir)) {
            (0,fs__WEBPACK_IMPORTED_MODULE_3__.mkdirSync)(this._storageDir, { recursive: true });
        }
    }
    /**
     * Initializes default session
     */
    async _initializeDefaultSession() {
        const defaultSessionId = 'default';
        try {
            // Check if default session exists
            const existingSession = await this._loadSession(defaultSessionId);
            if (existingSession) {
                this._sessions.set(defaultSessionId, existingSession);
            }
            else {
                // Create new default session
                const newSession = {
                    id: defaultSessionId,
                    name: 'Default Session',
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    messages: []
                };
                this._sessions.set(defaultSessionId, newSession);
                await this._saveSession(newSession);
            }
            this._currentSessionId = defaultSessionId;
        }
        catch (error) {
            console.error('Failed to initialize default session:', error);
            // Create an in-memory default session as fallback
            this._sessions.set(defaultSessionId, {
                id: defaultSessionId,
                name: 'Default Session',
                createdAt: new Date(),
                updatedAt: new Date(),
                messages: []
            });
            this._currentSessionId = defaultSessionId;
        }
    }
    /**
     * Gets the current session ID
     * @returns Current session ID or null if no session is active
     */
    getCurrentSessionId() {
        return this._currentSessionId;
    }
    /**
     * Gets the current session
     * @returns Current session or null if no session is active
     */
    getCurrentSession() {
        if (!this._currentSessionId) {
            return null;
        }
        return this._sessions.get(this._currentSessionId) || null;
    }
    /**
     * Gets messages from the current session
     * @returns Promise that resolves to a MemoryResult containing messages
     */
    async getMessages() {
        try {
            if (!this._currentSessionId) {
                return { success: true, data: [] };
            }
            const session = this._sessions.get(this._currentSessionId);
            return {
                success: true,
                data: session ? session.messages : []
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Adds a message to the current session
     * @param message Message to add
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async addMessage(message) {
        try {
            if (!this._currentSessionId) {
                return {
                    success: false,
                    error: new Error('No active session')
                };
            }
            const session = this._sessions.get(this._currentSessionId);
            if (session) {
                //    
                const existingIndex = session.messages.findIndex(m => m.id === message.id);
                if (existingIndex >= 0) {
                    //   
                    session.messages[existingIndex] = message;
                }
                else {
                    //   
                    session.messages.push(message);
                }
                // Limit messages if needed
                if (this._maxMessages > 0 && session.messages.length > this._maxMessages) {
                    // Keep the most recent messages
                    session.messages = session.messages.slice(-this._maxMessages);
                }
                // Update session timestamp
                session.updatedAt = new Date();
                // Save session
                await this._saveSession(session);
                return { success: true };
            }
            else {
                return {
                    success: false,
                    error: new Error('Session not found')
                };
            }
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     *   
     * @param message  
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async updateMessage(message) {
        try {
            if (!this._currentSessionId) {
                return {
                    success: false,
                    error: new Error('No active session')
                };
            }
            const session = this._sessions.get(this._currentSessionId);
            if (session) {
                //   
                const index = session.messages.findIndex(m => m.id === message.id);
                if (index === -1) {
                    return {
                        success: false,
                        error: new Error(`Message with ID ${message.id} not found`)
                    };
                }
                //  
                session.messages[index] = message;
                // Update session timestamp
                session.updatedAt = new Date();
                // Save session
                await this._saveSession(session);
                return { success: true };
            }
            else {
                return {
                    success: false,
                    error: new Error('Session not found')
                };
            }
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Saves messages to the current session
     * @param messages Messages to save
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async saveMessages(messages) {
        try {
            if (!this._currentSessionId) {
                return {
                    success: false,
                    error: new Error('No active session')
                };
            }
            const session = this._sessions.get(this._currentSessionId);
            if (session) {
                // Replace messages in the session
                session.messages = messages;
                // Limit messages if needed
                if (this._maxMessages > 0 && session.messages.length > this._maxMessages) {
                    // Keep the most recent messages
                    session.messages = session.messages.slice(-this._maxMessages);
                }
                // Update session timestamp
                session.updatedAt = new Date();
                // Save session
                await this._saveSession(session);
                return { success: true };
            }
            else {
                return {
                    success: false,
                    error: new Error('Session not found')
                };
            }
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Creates a new chat session
     * @param name Session name
     * @param options Optional session options
     * @returns Promise that resolves to a MemoryResult containing the session ID
     */
    async createSession(name, options) {
        try {
            const sessionId = `session_${Date.now()}`;
            const newSession = {
                id: sessionId,
                name,
                createdAt: new Date(),
                updatedAt: new Date(),
                messages: [],
                metadata: options?.metadata
            };
            this._sessions.set(sessionId, newSession);
            await this._saveSession(newSession);
            return {
                success: true,
                data: sessionId
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Switches to a different session
     * @param sessionId Session ID to switch to
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async switchSession(sessionId) {
        try {
            // If session is not loaded, try to load it
            if (!this._sessions.has(sessionId)) {
                const session = await this._loadSession(sessionId);
                if (!session) {
                    return {
                        success: false,
                        error: new Error(`Session ${sessionId} not found`)
                    };
                }
                this._sessions.set(sessionId, session);
            }
            this._currentSessionId = sessionId;
            return {
                success: true,
                data: true
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Gets all available sessions
     * @returns Promise that resolves to a MemoryResult containing session summaries
     */
    async getSessions() {
        try {
            // Load all sessions from storage
            await this._loadAllSessions();
            const sessionSummaries = Array.from(this._sessions.values()).map(session => ({
                id: session.id,
                name: session.name,
                createdAt: session.createdAt,
                updatedAt: session.updatedAt,
                messageCount: session.messages.length,
                summary: session.metadata?.summary || this._summarizeConversation(session.messages)
            }));
            return {
                success: true,
                data: sessionSummaries
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Gets a specific session by ID
     * @param sessionId Session ID to get
     * @returns Promise that resolves to a MemoryResult containing the session
     */
    async getSession(sessionId) {
        try {
            // If session is not loaded, try to load it
            if (!this._sessions.has(sessionId)) {
                const session = await this._loadSession(sessionId);
                if (!session) {
                    return {
                        success: false,
                        error: new Error(`Session ${sessionId} not found`)
                    };
                }
                this._sessions.set(sessionId, session);
            }
            const session = this._sessions.get(sessionId);
            if (!session) {
                return {
                    success: false,
                    error: new Error(`Session ${sessionId} not found`)
                };
            }
            return {
                success: true,
                data: session
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Updates a session's properties (not including messages)
     * @param sessionId Session ID to update
     * @param updates Object containing updates to apply
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async updateSession(sessionId, updates) {
        try {
            const sessionResult = await this.getSession(sessionId);
            if (!sessionResult.success || !sessionResult.data) {
                return {
                    success: false,
                    error: sessionResult.error || new Error(`Session ${sessionId} not found`)
                };
            }
            const session = sessionResult.data;
            // Apply updates
            if (updates.name) {
                session.name = updates.name;
            }
            if (updates.metadata) {
                session.metadata = {
                    ...session.metadata,
                    ...updates.metadata
                };
            }
            // Update timestamp
            session.updatedAt = new Date();
            // Save session
            await this._saveSession(session);
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Deletes a session
     * @param sessionId Session ID to delete
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async deleteSession(sessionId) {
        try {
            // Don't allow deleting the default session
            if (sessionId === 'default') {
                return {
                    success: false,
                    error: new Error('Cannot delete the default session')
                };
            }
            // Remove from memory
            this._sessions.delete(sessionId);
            // If this was the current session, switch to default
            if (this._currentSessionId === sessionId) {
                await this.switchSession('default');
            }
            // Remove from disk
            const sessionFile = path__WEBPACK_IMPORTED_MODULE_1__.join(this._storageDir, `${sessionId}.json`);
            if ((0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(sessionFile)) {
                await fs_promises__WEBPACK_IMPORTED_MODULE_2__.unlink(sessionFile);
            }
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Clears messages from the current session
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async clearMessages() {
        try {
            if (!this._currentSessionId) {
                return {
                    success: false,
                    error: new Error('No active session')
                };
            }
            const session = this._sessions.get(this._currentSessionId);
            if (session) {
                session.messages = [];
                session.updatedAt = new Date();
                await this._saveSession(session);
                return { success: true };
            }
            else {
                return {
                    success: false,
                    error: new Error('Session not found')
                };
            }
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Archives old sessions based on session duration configuration
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async archiveOldSessions() {
        try {
            // Load all sessions from storage
            await this._loadAllSessions();
            const now = new Date();
            const archiveThreshold = new Date(now.getTime() - this._sessionDuration * 60 * 1000);
            let archivedCount = 0;
            for (const [sessionId, session] of this._sessions.entries()) {
                // Skip the default session and current session
                if (sessionId === 'default' || sessionId === this._currentSessionId) {
                    continue;
                }
                // Archive sessions older than the threshold
                if (session.updatedAt < archiveThreshold) {
                    // Create an archive copy
                    const archiveDir = path__WEBPACK_IMPORTED_MODULE_1__.join(this._storageDir, 'archive');
                    if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(archiveDir)) {
                        (0,fs__WEBPACK_IMPORTED_MODULE_3__.mkdirSync)(archiveDir, { recursive: true });
                    }
                    // Generate summary if not already present
                    if (!session.metadata) {
                        session.metadata = {};
                    }
                    if (!session.metadata.summary) {
                        session.metadata.summary = this._summarizeConversation(session.messages);
                    }
                    // Save to archive
                    const archiveFile = path__WEBPACK_IMPORTED_MODULE_1__.join(archiveDir, `${session.id}_${Math.floor(session.updatedAt.getTime() / 1000)}.json`);
                    await fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile(archiveFile, JSON.stringify(session, null, 2), 'utf-8');
                    // Remove from active sessions
                    this._sessions.delete(sessionId);
                    // Remove from disk
                    const sessionFile = path__WEBPACK_IMPORTED_MODULE_1__.join(this._storageDir, `${sessionId}.json`);
                    if ((0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(sessionFile)) {
                        await fs_promises__WEBPACK_IMPORTED_MODULE_2__.unlink(sessionFile);
                    }
                    archivedCount++;
                }
            }
            return {
                success: true,
                data: archivedCount
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Exports a session to a file
     * @param sessionId Session ID to export
     * @param filePath File path to export to
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async exportSession(sessionId, filePath) {
        try {
            const sessionResult = await this.getSession(sessionId);
            if (!sessionResult.success || !sessionResult.data) {
                return {
                    success: false,
                    error: sessionResult.error || new Error(`Session ${sessionId} not found`)
                };
            }
            const session = sessionResult.data;
            // Export to file
            await fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile(filePath, JSON.stringify(session, null, 2), 'utf-8');
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Imports a session from a file
     * @param filePath File path to import from
     * @param setAsCurrent Whether to set the imported session as current
     * @returns Promise that resolves to a MemoryResult containing the session ID
     */
    async importSession(filePath, setAsCurrent = false) {
        try {
            // Read and parse file
            const data = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.readFile(filePath, 'utf-8');
            const sessionData = JSON.parse(data);
            // Validate session data
            if (!sessionData.id || !sessionData.name || !sessionData.createdAt || !sessionData.updatedAt) {
                return {
                    success: false,
                    error: new Error('Invalid session data')
                };
            }
            // Convert date strings to Date objects
            sessionData.createdAt = new Date(sessionData.createdAt);
            sessionData.updatedAt = new Date(sessionData.updatedAt);
            if (sessionData.messages) {
                sessionData.messages.forEach((message) => {
                    message.timestamp = new Date(message.timestamp);
                });
            }
            // Generate a new ID to avoid conflicts
            const originalId = sessionData.id;
            sessionData.id = `imported_${Date.now()}`;
            // Add a note about the import
            if (!sessionData.metadata) {
                sessionData.metadata = {};
            }
            sessionData.metadata.importedFrom = originalId;
            sessionData.metadata.importedAt = new Date();
            // Save the session
            this._sessions.set(sessionData.id, sessionData);
            await this._saveSession(sessionData);
            // Switch to the imported session if requested
            if (setAsCurrent) {
                this._currentSessionId = sessionData.id;
            }
            return {
                success: true,
                data: sessionData.id
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Loads a specific session from storage
     * @param sessionId Session ID to load
     * @returns Promise that resolves to a ChatSession or null
     */
    async _loadSession(sessionId) {
        const sessionFile = path__WEBPACK_IMPORTED_MODULE_1__.join(this._storageDir, `${sessionId}.json`);
        try {
            if ((0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(sessionFile)) {
                const data = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.readFile(sessionFile, 'utf-8');
                const sessionData = JSON.parse(data);
                // Convert date strings back to Date objects
                sessionData.createdAt = new Date(sessionData.createdAt);
                sessionData.updatedAt = new Date(sessionData.updatedAt);
                if (sessionData.messages) {
                    sessionData.messages.forEach((message) => {
                        message.timestamp = new Date(message.timestamp);
                    });
                }
                return sessionData;
            }
        }
        catch (error) {
            console.error(`Error loading session ${sessionId}:`, error);
        }
        return null;
    }
    /**
     * Saves a session to storage
     * @param session Session to save
     * @returns Promise that resolves when the session is saved
     */
    async _saveSession(session) {
        const sessionFile = path__WEBPACK_IMPORTED_MODULE_1__.join(this._storageDir, `${session.id}.json`);
        try {
            const sessionJson = JSON.stringify(session, null, 2);
            await fs_promises__WEBPACK_IMPORTED_MODULE_2__.writeFile(sessionFile, sessionJson, 'utf-8');
        }
        catch (error) {
            console.error(`Error saving session ${session.id}:`, error);
            throw error;
        }
    }
    /**
     * Loads all sessions from storage
     * @returns Promise that resolves when all sessions are loaded
     */
    async _loadAllSessions() {
        try {
            if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(this._storageDir)) {
                return;
            }
            const files = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.readdir(this._storageDir);
            for (const file of files) {
                if (file.endsWith('.json')) {
                    const sessionId = path__WEBPACK_IMPORTED_MODULE_1__.basename(file, '.json');
                    // Don't reload sessions we already have in memory
                    if (!this._sessions.has(sessionId)) {
                        const session = await this._loadSession(sessionId);
                        if (session) {
                            this._sessions.set(sessionId, session);
                        }
                    }
                }
            }
        }
        catch (error) {
            console.error('Error loading sessions:', error);
            throw error;
        }
    }
    /**
     * Summarizes a conversation for long-term memory
     * @param messages Messages to summarize
     * @returns Summary of the conversation
     */
    _summarizeConversation(messages) {
        if (messages.length === 0) {
            return 'Empty conversation';
        }
        // Find the first user message
        const firstUserMessage = messages.find(m => m.role === _types_chat__WEBPACK_IMPORTED_MODULE_4__.MessageRole.User);
        if (!firstUserMessage) {
            return `Conversation with ${messages.length} messages`;
        }
        // Get first user message content
        const content = firstUserMessage.content;
        const truncatedContent = content.substring(0, 50) + (content.length > 50 ? '...' : '');
        // Count messages by role
        const userMessages = messages.filter(m => m.role === _types_chat__WEBPACK_IMPORTED_MODULE_4__.MessageRole.User).length;
        const assistantMessages = messages.filter(m => m.role === _types_chat__WEBPACK_IMPORTED_MODULE_4__.MessageRole.Assistant).length;
        return `Conversation with ${userMessages} user and ${assistantMessages} assistant messages. Started with: "${truncatedContent}"`;
    }
    /**
     * Disposes resources
     */
    dispose() {
        // Dispose configuration change listener
        this._configListener.dispose();
        // Save any unsaved sessions
        for (const session of this._sessions.values()) {
            this._saveSession(session).catch(error => {
                console.error(`Error saving session ${session.id} during disposal:`, error);
            });
        }
    }
}


/***/ }),

/***/ "./src/core/services/jiraService.ts":
/*!******************************************!*\
  !*** ./src/core/services/jiraService.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JiraErrorType: () => (/* binding */ JiraErrorType),
/* harmony export */   JiraIssueStatus: () => (/* binding */ JiraIssueStatus),
/* harmony export */   JiraService: () => (/* binding */ JiraService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ "./node_modules/axios/lib/axios.js");
/* harmony import */ var _serviceConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serviceConfig */ "./src/core/services/serviceConfig.ts");
/* harmony import */ var _serviceError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serviceError */ "./src/core/services/serviceError.ts");
/* harmony import */ var _serviceResult__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serviceResult */ "./src/core/services/serviceResult.ts");
/**
 * Jira 
 *
 * Jira API      .
 *  Jira  ,       (Mock)  .
 */





/**
 * Jira   
 */
var JiraIssueStatus;
(function (JiraIssueStatus) {
    JiraIssueStatus["ToDo"] = "todo";
    JiraIssueStatus["InProgress"] = "in-progress";
    JiraIssueStatus["Done"] = "done";
    JiraIssueStatus["InReview"] = "in-review";
    JiraIssueStatus["Blocked"] = "blocked";
    JiraIssueStatus["Unknown"] = "unknown";
})(JiraIssueStatus || (JiraIssueStatus = {}));
/**
 * Jira   
 */
var JiraErrorType;
(function (JiraErrorType) {
    JiraErrorType["ConnectionFailed"] = "connection_failed";
    JiraErrorType["AuthenticationFailed"] = "authentication_failed";
    JiraErrorType["PermissionDenied"] = "permission_denied";
    JiraErrorType["ResourceNotFound"] = "resource_not_found";
    JiraErrorType["ServerError"] = "server_error";
    JiraErrorType["InvalidRequest"] = "invalid_request";
    JiraErrorType["Unknown"] = "unknown";
})(JiraErrorType || (JiraErrorType = {}));
/**
 * Jira  
 */
class JiraService {
    context;
    serviceConfigManager;
    baseUrl = '';
    apiPath = '/rest/api/2';
    username = '';
    password = '';
    token = '';
    authType = _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic;
    useMock = true;
    disposables = [];
    _lastError = null;
    /**
     * Jira  
     * @param context VSCode  
     * @param serviceConfigManager    ()
     */
    constructor(context, serviceConfigManager) {
        this.context = context;
        this.serviceConfigManager = serviceConfigManager;
        //  
        this.loadConfiguration();
        //   
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.jira')) {
                this.loadConfiguration();
            }
        }));
    }
    /**
     *   
     */
    loadConfiguration() {
        if (this.serviceConfigManager) {
            //      
            const config = this.serviceConfigManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira);
            this.baseUrl = config.url;
            this.authType = config.authType;
            this.username = config.username || '';
            this.password = config.password || '';
            this.token = config.token || '';
            this.useMock = config.useMock;
            //   API  
            const additionalParams = config.additionalParams || {};
            this.apiPath = additionalParams.apiPath || '/rest/api/2';
        }
        else {
            //  VSCode  
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.jira');
            this.baseUrl = config.get('url', '');
            this.apiPath = config.get('apiPath', '/rest/api/2');
            this.username = config.get('username', '');
            this.password = config.get('password', '');
            this.token = config.get('token', '');
            this.authType = config.get('authType', _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic);
            this.useMock = config.get('useMock', false);
        }
        //       
        if (!this.baseUrl || (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) ||
            (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token)) {
            this.useMock = true;
        }
    }
    /**
     *   
     */
    get lastError() {
        return this._lastError;
    }
    /**
     *  
     * @param issueKey Jira   (: 'APE-123')
     * @returns Jira     
     */
    async getIssue(issueKey) {
        try {
            //   
            this._lastError = null;
            //      
            if (this.useMock) {
                const mockIssue = this.getMockIssue(issueKey);
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(mockIssue);
            }
            //   
            if (!this.baseUrl) {
                throw new Error('Jira  URL  .  .');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira    .    .');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('Jira    .   .');
            }
            // Jira REST API 
            const url = `${this.baseUrl}${this.apiPath}/issue/${issueKey}`;
            // API  
            const config = {};
            //    
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API  
            const response = await axios__WEBPACK_IMPORTED_MODULE_4__["default"].get(url, config);
            //   
            const issue = this.parseJiraIssue(response.data);
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(issue);
        }
        catch (error) {
            //    
            this.handleError(error, issueKey);
            //  
            console.error(`Jira    (${issueKey}):`, error);
            //   
            let serviceError;
            if (this._lastError) {
                // JiraError IServiceError 
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createErrorResult)(serviceError);
        }
    }
    /**
     * Jira  
     * @param issueData  
     * @returns      
     */
    async createIssue(issueData) {
        try {
            //   
            this._lastError = null;
            //      
            if (this.useMock) {
                const mockIssue = this.getMockIssue(`${issueData.projectKey}-${Math.floor(Math.random() * 1000)}`);
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(mockIssue);
            }
            //   
            if (!this.baseUrl) {
                throw new Error('Jira  URL  .  .');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira    .    .');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('Jira    .   .');
            }
            // Jira REST API 
            const url = `${this.baseUrl}${this.apiPath}/issue`;
            //   
            if (!issueData.projectKey) {
                throw new Error('Jira   .');
            }
            if (!issueData.issueType) {
                throw new Error('Jira   .');
            }
            if (!issueData.summary) {
                throw new Error('Jira   .');
            }
            //   
            const requestData = {
                fields: {
                    project: {
                        key: issueData.projectKey
                    },
                    issuetype: {
                        name: issueData.issueType
                    },
                    summary: issueData.summary,
                    description: issueData.description || '',
                    assignee: issueData.assignee ? { name: issueData.assignee } : undefined,
                    components: issueData.components?.map(name => ({ name })),
                    labels: issueData.labels,
                    duedate: issueData.dueDate
                }
            };
            // API  
            const config = {};
            //    
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API  
            const response = await axios__WEBPACK_IMPORTED_MODULE_4__["default"].post(url, requestData, config);
            //   ID  
            const issueKey = response.data.key;
            const issueResult = await this.getIssue(issueKey);
            if (issueResult.success && issueResult.data) {
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(issueResult.data);
            }
            else {
                //       
                const basicIssue = {
                    id: '0',
                    key: issueKey,
                    summary: issueData.summary,
                    description: issueData.description || '',
                    status: JiraIssueStatus.ToDo,
                    created: new Date().toISOString(),
                    updated: new Date().toISOString()
                };
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(basicIssue);
            }
        }
        catch (error) {
            //    
            this.handleError(error);
            //  
            console.error('Jira   :', error);
            //   
            let serviceError;
            if (this._lastError) {
                // JiraError IServiceError 
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createErrorResult)(serviceError);
        }
    }
    /**
     * Jira   
     * @param issueKey Jira   (: 'APE-123')
     * @param status  
     * @returns     
     */
    async updateIssueStatus(issueKey, status) {
        try {
            //   
            this._lastError = null;
            //     
            if (this.useMock) {
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(true);
            }
            //   
            if (!this.baseUrl) {
                throw new Error('Jira  URL  .  .');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira    .    .');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('Jira    .   .');
            }
            //     ID 
            const transitionId = await this.getTransitionIdForStatus(issueKey, status);
            if (!transitionId) {
                throw new Error(` ${issueKey}   '${status}'   .`);
            }
            // Jira REST API 
            const url = `${this.baseUrl}${this.apiPath}/issue/${issueKey}/transitions`;
            //   
            const requestData = {
                transition: {
                    id: transitionId
                }
            };
            // API  
            const config = {};
            //    
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API  
            await axios__WEBPACK_IMPORTED_MODULE_4__["default"].post(url, requestData, config);
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(true);
        }
        catch (error) {
            //    
            this.handleError(error, issueKey);
            //  
            console.error(`Jira     (${issueKey}):`, error);
            //   
            let serviceError;
            if (this._lastError) {
                // JiraError IServiceError 
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createErrorResult)(serviceError);
        }
    }
    /**
     * Jira  
     * @param criteria  
     * @returns     
     */
    async searchIssues(criteria) {
        try {
            //   
            this._lastError = null;
            //  
            const maxResults = criteria.maxResults || 50;
            const startAt = criteria.startAt || 0;
            //      
            if (this.useMock) {
                const mockResult = this.getMockSearchResult(criteria);
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(mockResult);
            }
            //   
            if (!this.baseUrl) {
                throw new Error('Jira  URL  .  .');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira    .    .');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('Jira    .   .');
            }
            // JQL   
            const jql = this.buildJqlQuery(criteria);
            // Jira REST API 
            const url = `${this.baseUrl}${this.apiPath}/search`;
            //   
            const requestData = {
                jql,
                startAt,
                maxResults,
                fields: [
                    'summary',
                    'description',
                    'status',
                    'assignee',
                    'reporter',
                    'created',
                    'updated',
                    'duedate',
                    'priority',
                    'labels',
                    'components',
                    'project'
                ]
            };
            // API  
            const config = {
                params: {
                    jql,
                    startAt,
                    maxResults,
                    fields: 'summary,description,status,assignee,reporter,created,updated,duedate,priority,labels,components,project'
                }
            };
            //    
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API  
            const response = await axios__WEBPACK_IMPORTED_MODULE_4__["default"].get(url, config);
            //   
            const data = response.data;
            const issues = (data.issues || []).map((issue) => this.parseJiraIssue(issue));
            const result = {
                issues,
                total: data.total || 0,
                startAt: data.startAt || 0,
                maxResults: data.maxResults || maxResults,
                hasMore: (data.startAt + issues.length) < data.total
            };
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(result);
        }
        catch (error) {
            //    
            this.handleError(error);
            //  
            console.error('Jira   :', error);
            //   
            let serviceError;
            if (this._lastError) {
                // JiraError IServiceError 
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createErrorResult)(serviceError);
        }
    }
    /**
     * JQL   
     * @param criteria  
     * @returns JQL  
     * @private
     */
    buildJqlQuery(criteria) {
        const conditions = [];
        //  
        if (criteria.projectKey) {
            conditions.push(`project = "${criteria.projectKey}"`);
        }
        //  
        if (criteria.assignee) {
            conditions.push(`assignee = "${criteria.assignee}"`);
        }
        //  
        if (criteria.reporter) {
            conditions.push(`reporter = "${criteria.reporter}"`);
        }
        //  
        if (criteria.status) {
            if (Array.isArray(criteria.status)) {
                if (criteria.status.length > 0) {
                    const statuses = criteria.status.map(s => `"${s}"`).join(',');
                    conditions.push(`status IN (${statuses})`);
                }
            }
            else {
                conditions.push(`status = "${criteria.status}"`);
            }
        }
        //  
        if (criteria.labels && criteria.labels.length > 0) {
            const labelConditions = criteria.labels.map(label => `labels = "${label}"`).join(' AND ');
            conditions.push(`(${labelConditions})`);
        }
        //  
        if (criteria.components && criteria.components.length > 0) {
            const componentConditions = criteria.components.map(component => `component = "${component}"`).join(' OR ');
            conditions.push(`(${componentConditions})`);
        }
        //   
        if (criteria.text) {
            conditions.push(`(summary ~ "${criteria.text}" OR description ~ "${criteria.text}")`);
        }
        //  
        if (criteria.createdAfter) {
            conditions.push(`created >= "${criteria.createdAfter}"`);
        }
        //  
        if (criteria.updatedAfter) {
            conditions.push(`updated >= "${criteria.updatedAfter}"`);
        }
        //     
        if (conditions.length === 0) {
            return 'order by created DESC';
        }
        //  JQL  
        return `${conditions.join(' AND ')} order by created DESC`;
    }
    /**
     *    
     * @param criteria  
     * @returns   
     * @private
     */
    getMockSearchResult(criteria) {
        //       
        const maxResults = criteria.maxResults || 50;
        const startAt = criteria.startAt || 0;
        //   
        const mockIssues = [];
        const totalIssues = 100; //     
        //     
        const count = Math.min(maxResults, totalIssues - startAt);
        //    (: 'APE')
        const projectKey = criteria.projectKey || 'APE';
        //   
        for (let i = 0; i < count; i++) {
            const issueNumber = startAt + i + 1;
            const issueKey = `${projectKey}-${issueNumber}`;
            const mockIssue = this.getMockIssue(issueKey);
            //    
            let includeIssue = true;
            //  
            if (criteria.status) {
                if (Array.isArray(criteria.status)) {
                    includeIssue = criteria.status.includes(mockIssue.status);
                }
                else {
                    includeIssue = mockIssue.status === criteria.status;
                }
            }
            //   
            if (includeIssue && criteria.text) {
                const text = criteria.text.toLowerCase();
                includeIssue =
                    mockIssue.summary.toLowerCase().includes(text) ||
                        (mockIssue.description?.toLowerCase().includes(text) || false);
            }
            //      
            if (includeIssue) {
                //       
                if (criteria.assignee) {
                    mockIssue.assignee = {
                        name: criteria.assignee,
                        displayName: `${criteria.assignee} `
                    };
                }
                //   
                mockIssue.project = {
                    id: '10000',
                    key: projectKey,
                    name: `${projectKey} `
                };
                mockIssues.push(mockIssue);
            }
        }
        return {
            issues: mockIssues,
            total: totalIssues,
            startAt,
            maxResults,
            hasMore: (startAt + count) < totalIssues
        };
    }
    /**
     * Jira   
     * @param projectKey   (,     )
     * @param maxRecentIssues      (: 5)
     * @param maxOldIssues       (: 5)
     * @returns Jira     
     */
    async getProjectSummary(projectKey, maxRecentIssues = 5, maxOldIssues = 5) {
        try {
            //   
            this._lastError = null;
            //      
            if (this.useMock) {
                const mockSummary = this.getMockSummary(projectKey, maxRecentIssues, maxOldIssues);
                return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(mockSummary);
            }
            //   
            if (!this.baseUrl) {
                throw new Error('Jira  URL  .  .');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira    .    .');
            }
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token && !this.token) {
                throw new Error('Jira    .   .');
            }
            //     
            const searchCriteria = {
                projectKey: projectKey,
                maxResults: 1000 //    
            };
            const searchResult = await this.searchIssues(searchCriteria);
            if (!searchResult.success || !searchResult.data) {
                throw new Error('  ');
            }
            const issues = searchResult.data.issues;
            //   
            const totalIssues = issues.length;
            //    
            const issuesByStatus = {
                [JiraIssueStatus.ToDo]: 0,
                [JiraIssueStatus.InProgress]: 0,
                [JiraIssueStatus.InReview]: 0,
                [JiraIssueStatus.Done]: 0,
                [JiraIssueStatus.Blocked]: 0,
                [JiraIssueStatus.Unknown]: 0
            };
            //    
            const issuesByAssignee = {};
            //    
            const issuesByPriority = {};
            //        
            let recentIssues = [];
            const unresolvedIssues = [];
            //      
            let resolvedCount = 0;
            let totalResolutionTime = 0;
            //     
            for (const issue of issues) {
                //    
                const status = issue.status;
                issuesByStatus[status] = (issuesByStatus[status] || 0) + 1;
                //    
                if (issue.assignee) {
                    const assigneeName = issue.assignee.displayName || issue.assignee.name;
                    issuesByAssignee[assigneeName] = (issuesByAssignee[assigneeName] || 0) + 1;
                }
                else {
                    issuesByAssignee[''] = (issuesByAssignee[''] || 0) + 1;
                }
                //    
                if (issue.priority) {
                    const priorityName = issue.priority.name;
                    issuesByPriority[priorityName] = (issuesByPriority[priorityName] || 0) + 1;
                }
                else {
                    issuesByPriority[''] = (issuesByPriority[''] || 0) + 1;
                }
                //    
                if (issue.status !== JiraIssueStatus.Done) {
                    unresolvedIssues.push(issue);
                }
                else {
                    //     
                    const created = new Date(issue.created).getTime();
                    const updated = new Date(issue.updated).getTime();
                    const resolutionTime = updated - created;
                    if (resolutionTime > 0) {
                        totalResolutionTime += resolutionTime;
                        resolvedCount++;
                    }
                }
            }
            //    ( )
            recentIssues = [...issues].sort((a, b) => new Date(b.created).getTime() - new Date(a.created).getTime()).slice(0, maxRecentIssues);
            //     ( )
            const oldestUnresolvedIssues = unresolvedIssues
                .sort((a, b) => new Date(a.created).getTime() - new Date(b.created).getTime())
                .slice(0, maxOldIssues);
            //     ( )
            const averageResolutionTime = resolvedCount > 0 ? totalResolutionTime / resolvedCount : undefined;
            //   
            const openIssues = totalIssues - (issuesByStatus[JiraIssueStatus.Done] || 0);
            const percentComplete = totalIssues > 0 ? Math.round((issuesByStatus[JiraIssueStatus.Done] || 0) * 100 / totalIssues) : 0;
            //   
            const result = {
                totalIssues,
                issuesByStatus,
                issuesByAssignee,
                issuesByPriority,
                recentIssues,
                oldestUnresolvedIssues,
                averageResolutionTime,
                projectStats: projectKey ? {
                    projectKey,
                    totalIssues,
                    openIssues,
                    percentComplete
                } : undefined
            };
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createSuccessResult)(result);
        }
        catch (error) {
            //    
            this.handleError(error);
            //  
            console.error('Jira    :', error);
            //   
            let serviceError;
            if (this._lastError) {
                // JiraError IServiceError 
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorManager.createError(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira, _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return (0,_serviceResult__WEBPACK_IMPORTED_MODULE_3__.createErrorResult)(serviceError);
        }
    }
    /**
     *    
     * @param projectKey  
     * @param maxRecentIssues   
     * @param maxOldIssues    
     * @returns   
     * @private
     */
    getMockSummary(projectKey, maxRecentIssues = 5, maxOldIssues = 5) {
        //    
        const project = projectKey || 'APE';
        //   
        const mockIssues = [];
        const totalIssues = 50; //     
        //   
        for (let i = 0; i < totalIssues; i++) {
            const issueNumber = i + 1;
            const issueKey = `${project}-${issueNumber}`;
            const mockIssue = this.getMockIssue(issueKey);
            //   
            mockIssue.project = {
                id: '10000',
                key: project,
                name: `${project} `
            };
            mockIssues.push(mockIssue);
        }
        //    
        const issuesByStatus = {
            [JiraIssueStatus.ToDo]: 15,
            [JiraIssueStatus.InProgress]: 10,
            [JiraIssueStatus.InReview]: 5,
            [JiraIssueStatus.Done]: 15,
            [JiraIssueStatus.Blocked]: 3,
            [JiraIssueStatus.Unknown]: 2
        };
        //    
        const issuesByAssignee = {
            '': 10,
            '': 15,
            '': 8,
            '': 5,
            '': 12
        };
        //    
        const issuesByPriority = {
            'Highest': 5,
            'High': 10,
            'Medium': 20,
            'Low': 10,
            '': 5
        };
        //    
        const recentIssues = mockIssues
            .slice(0, maxRecentIssues)
            .map(issue => {
            //       
            const now = new Date();
            const randomHours = Math.floor(Math.random() * 48); //  48 
            const createdDate = new Date(now.getTime() - randomHours * 60 * 60 * 1000);
            return {
                ...issue,
                created: createdDate.toISOString(),
                updated: createdDate.toISOString()
            };
        });
        //     
        const oldestUnresolvedIssues = mockIssues
            .filter(issue => issue.status !== JiraIssueStatus.Done)
            .slice(0, maxOldIssues)
            .map(issue => {
            //       
            const now = new Date();
            const randomDays = 30 + Math.floor(Math.random() * 60); // 30-90 
            const createdDate = new Date(now.getTime() - randomDays * 24 * 60 * 60 * 1000);
            return {
                ...issue,
                created: createdDate.toISOString(),
                updated: createdDate.toISOString(),
                status: [JiraIssueStatus.ToDo, JiraIssueStatus.Blocked][Math.floor(Math.random() * 2)]
            };
        });
        //     (3 )
        const averageResolutionTime = 3 * 24 * 60 * 60 * 1000;
        return {
            totalIssues,
            issuesByStatus,
            issuesByAssignee,
            issuesByPriority,
            recentIssues,
            oldestUnresolvedIssues,
            averageResolutionTime,
            projectStats: projectKey ? {
                projectKey,
                totalIssues,
                openIssues: totalIssues - issuesByStatus[JiraIssueStatus.Done],
                percentComplete: Math.round(issuesByStatus[JiraIssueStatus.Done] * 100 / totalIssues)
            } : undefined
        };
    }
    /**
     *      ID 
     * @param issueKey Jira  
     * @param targetStatus  
     * @returns  ID
     * @private
     */
    async getTransitionIdForStatus(issueKey, targetStatus) {
        try {
            // Jira REST API 
            const url = `${this.baseUrl}${this.apiPath}/issue/${issueKey}/transitions`;
            // API  
            const config = {};
            //    
            if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API  
            const response = await axios__WEBPACK_IMPORTED_MODULE_4__["default"].get(url, config);
            //         
            const transitions = response.data.transitions || [];
            //    
            const normalizeStatus = (status) => {
                return status.toLowerCase()
                    .replace(/\s+/g, '-')
                    .replace(/in\s+progress/i, 'in-progress')
                    .replace(/to\s+do/i, 'todo');
            };
            //     
            const matchingTransition = transitions.find((t) => {
                const transitionStatus = normalizeStatus(t.to.name);
                return transitionStatus === targetStatus || transitionStatus.includes(targetStatus);
            });
            return matchingTransition ? matchingTransition.id : null;
        }
        catch (error) {
            console.error(` ID   (${issueKey}):`, error);
            return null;
        }
    }
    /**
     * Jira API    
     * @param data API  
     * @returns   
     * @private
     */
    parseJiraIssue(data) {
        const fields = data.fields || {};
        //  
        const normalizeStatus = (statusName) => {
            const lowerStatus = statusName.toLowerCase();
            if (lowerStatus.includes('todo') || lowerStatus.includes('to do') || lowerStatus.includes('open')) {
                return JiraIssueStatus.ToDo;
            }
            else if (lowerStatus.includes('progress')) {
                return JiraIssueStatus.InProgress;
            }
            else if (lowerStatus.includes('review')) {
                return JiraIssueStatus.InReview;
            }
            else if (lowerStatus.includes('done') || lowerStatus.includes('closed') || lowerStatus.includes('resolved')) {
                return JiraIssueStatus.Done;
            }
            else if (lowerStatus.includes('block')) {
                return JiraIssueStatus.Blocked;
            }
            else {
                return JiraIssueStatus.Unknown;
            }
        };
        const statusName = fields.status?.name || 'Unknown';
        const issue = {
            id: data.id,
            key: data.key,
            summary: fields.summary || '',
            description: fields.description || '',
            status: normalizeStatus(statusName),
            assignee: fields.assignee ? {
                name: fields.assignee.name,
                displayName: fields.assignee.displayName,
                email: fields.assignee.emailAddress
            } : undefined,
            reporter: fields.reporter ? {
                name: fields.reporter.name,
                displayName: fields.reporter.displayName,
                email: fields.reporter.emailAddress
            } : undefined,
            created: fields.created || '',
            updated: fields.updated || '',
            dueDate: fields.duedate,
            priority: fields.priority ? {
                id: fields.priority.id,
                name: fields.priority.name
            } : undefined,
            labels: fields.labels || [],
            components: (fields.components || []).map((c) => ({
                id: c.id,
                name: c.name
            }))
        };
        return issue;
    }
    /**
     *  Jira  
     * @param issueKey  
     * @returns   
     * @private
     */
    getMockIssue(issueKey) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [_project, id] = issueKey.split('-');
        //       
        const idNum = parseInt(id, 10) || 0;
        const mod = idNum % 5;
        let status;
        let summary;
        switch (mod) {
            case 0:
                status = JiraIssueStatus.ToDo;
                summary = '  ';
                break;
            case 1:
                status = JiraIssueStatus.InProgress;
                summary = '  ';
                break;
            case 2:
                status = JiraIssueStatus.InReview;
                summary = ' ';
                break;
            case 3:
                status = JiraIssueStatus.Done;
                summary = ' ';
                break;
            case 4:
                status = JiraIssueStatus.Blocked;
                summary = ' ';
                break;
            default:
                status = JiraIssueStatus.Unknown;
                summary = ' ';
        }
        const now = new Date().toISOString();
        return {
            id: id,
            key: issueKey,
            summary: `[ ] ${summary}`,
            description: '  Jira .  Jira  .',
            status: status,
            assignee: {
                name: 'testuser',
                displayName: ' '
            },
            reporter: {
                name: 'reporter',
                displayName: ''
            },
            created: now,
            updated: now,
            priority: {
                id: '3',
                name: 'Medium'
            },
            labels: ['mock', 'test'],
            components: [
                { id: '10000', name: 'UI' },
                { id: '10001', name: 'Backend' }
            ]
        };
    }
    /**
     *    
     * @param error  
     * @param resourceId   ID ()
     * @private
     */
    handleError(error, resourceId) {
        if (axios__WEBPACK_IMPORTED_MODULE_4__["default"].isAxiosError(error)) {
            const axiosError = error;
            if (!axiosError.response) {
                //  
                this.setError(JiraErrorType.ConnectionFailed, `Jira   : ${error.message}.  URL : ${this.baseUrl}`);
            }
            else {
                // HTTP     
                const status = axiosError.response.status;
                if (status === 401 || status === 403) {
                    this.setError(JiraErrorType.AuthenticationFailed, `Jira  : ${error.message}.    .`);
                }
                else if (status === 404) {
                    this.setError(JiraErrorType.ResourceNotFound, `Jira    ${resourceId ? ` (${resourceId})` : ''}: ${error.message}`);
                }
                else if (status >= 500) {
                    this.setError(JiraErrorType.ServerError, `Jira  : ${error.message}.   .`);
                }
                else if (status === 400) {
                    this.setError(JiraErrorType.InvalidRequest, `Jira  : ${error.message}`);
                }
                else {
                    this.setError(JiraErrorType.Unknown, `Jira : ${error.message}`);
                }
            }
        }
        else {
            //  
            this.setError(JiraErrorType.Unknown, `Jira : ${error.message}`);
        }
    }
    /**
     *  
     * @param type  
     * @param message  
     * @param details   
     * @private
     */
    setError(type, message, details) {
        this._lastError = {
            type,
            message,
            details
        };
        //   
        console.error(`Jira  (${type}):`, message, details || '');
    }
    /**
     *  
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/services/rulesService.ts":
/*!*******************************************!*\
  !*** ./src/core/services/rulesService.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RuleStatus: () => (/* binding */ RuleStatus),
/* harmony export */   RulesService: () => (/* binding */ RulesService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _serviceError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serviceError */ "./src/core/services/serviceError.ts");
/**
 * APE Rules 
 *
 * Rules   LLM    .
 * Rules , , /  .
 */




/**
 * Rule  
 */
var RuleStatus;
(function (RuleStatus) {
    RuleStatus["Active"] = "active";
    RuleStatus["Inactive"] = "inactive";
})(RuleStatus || (RuleStatus = {}));
/**
 * Rules  
 */
class RulesService {
    context;
    configManager;
    _onDidChangeRules = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    onDidChangeRules = this._onDidChangeRules.event;
    rules = new Map();
    disposables = [];
    rulesDir;
    /**
     * 
     * @param context VSCode  
     * @param configManager    ()
     */
    constructor(context, configManager) {
        this.context = context;
        this.configManager = configManager;
        // Rules  
        this.rulesDir = path__WEBPACK_IMPORTED_MODULE_2__.join(this.context.globalStorageUri.fsPath, 'rules');
        // Rules   ( )
        this.ensureRulesDir();
        //    
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.rules')) {
                this.loadAllRules();
            }
        }));
        //    
        const watcher = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.createFileSystemWatcher(new vscode__WEBPACK_IMPORTED_MODULE_0__.RelativePattern(this.rulesDir, '**/*.md'));
        this.disposables.push(watcher, watcher.onDidCreate(() => this.loadAllRules()), watcher.onDidDelete(() => this.loadAllRules()), watcher.onDidChange(() => this.loadAllRules()));
        //  Rules 
        this.loadAllRules();
    }
    /**
     * Rules    
     */
    ensureRulesDir() {
        if (!fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(this.rulesDir)) {
            fs__WEBPACK_IMPORTED_MODULE_1__.mkdirSync(this.rulesDir, { recursive: true });
        }
    }
    /**
     *  Rules 
     */
    async loadAllRules() {
        try {
            this.ensureRulesDir();
            this.rules.clear();
            // Rules   .md  
            const files = fs__WEBPACK_IMPORTED_MODULE_1__.readdirSync(this.rulesDir).filter(file => file.endsWith('.md'));
            //   Rules  
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.rules');
            const activeRules = config.get('activeRules', []);
            //   Rule  
            for (const file of files) {
                const filePath = path__WEBPACK_IMPORTED_MODULE_2__.join(this.rulesDir, file);
                const fileStats = fs__WEBPACK_IMPORTED_MODULE_1__.statSync(filePath);
                const content = fs__WEBPACK_IMPORTED_MODULE_1__.readFileSync(filePath, 'utf-8');
                //    ID 
                const id = path__WEBPACK_IMPORTED_MODULE_2__.basename(file, '.md');
                // Rule  
                const rule = {
                    id,
                    name: this.extractNameFromContent(content) || id,
                    filePath,
                    content,
                    status: activeRules.includes(id) ? RuleStatus.Active : RuleStatus.Inactive,
                    createdAt: fileStats.birthtime,
                    updatedAt: fileStats.mtime
                };
                // Rules  
                this.rules.set(id, rule);
            }
            //   
            this._onDidChangeRules.fire();
        }
        catch (error) {
            console.error('Rules  :', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rules    : ${error}`);
        }
    }
    /**
     *     (   )
     * @param content  
     */
    extractNameFromContent(content) {
        //   (#  ) 
        const titleMatch = content.match(/^#\s+(.+)$/m);
        if (titleMatch && titleMatch[1]) {
            return titleMatch[1].trim();
        }
        return null;
    }
    /**
     *  Rules 
     */
    getAllRules() {
        return Array.from(this.rules.values());
    }
    /**
     *  Rules 
     */
    getActiveRules() {
        return this.getAllRules().filter(rule => rule.status === RuleStatus.Active);
    }
    /**
     * ID Rule 
     * @param id Rule ID
     */
    getRuleById(id) {
        return this.rules.get(id);
    }
    /**
     * Rule 
     * @param name Rule 
     * @param content Rule 
     * @param activate    
     */
    async createRule(name, content, activate = false) {
        try {
            this.ensureRulesDir();
            //   ID  (  )
            const id = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
            //   ID 
            if (this.rules.has(id)) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`  Rule : ${name}`, 'rule-already-exists');
            }
            //       
            let finalContent = content;
            if (!content.trim().startsWith('#')) {
                finalContent = `# ${name}\n\n${content}`;
            }
            //   
            const filePath = path__WEBPACK_IMPORTED_MODULE_2__.join(this.rulesDir, `${id}.md`);
            //  
            fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(filePath, finalContent, 'utf-8');
            // Rule  
            const rule = {
                id,
                name,
                filePath,
                content: finalContent,
                status: RuleStatus.Inactive,
                createdAt: new Date(),
                updatedAt: new Date()
            };
            // Rules  
            this.rules.set(id, rule);
            //    
            if (activate) {
                await this.activateRule(id);
            }
            //   
            this._onDidChangeRules.fire();
            return rule;
        }
        catch (error) {
            console.error('Rule  :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule    : ${error}`, 'rule-creation-failed');
        }
    }
    /**
     * Rule 
     * @param id Rule ID
     * @param updates  
     */
    async updateRule(id, updates) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`ID ${id} Rule   .`, 'rule-not-found');
            }
            //    
            let updatedContent = rule.content;
            let updatedName = rule.name;
            if (updates.name) {
                updatedName = updates.name;
                //         
                if (!updates.content) {
                    const titleRegex = /^#\s+(.+)$/m;
                    if (titleRegex.test(updatedContent)) {
                        updatedContent = updatedContent.replace(titleRegex, `# ${updatedName}`);
                    }
                    else {
                        updatedContent = `# ${updatedName}\n\n${updatedContent}`;
                    }
                }
            }
            if (updates.content) {
                updatedContent = updates.content;
                //    
                if (!updatedContent.trim().startsWith('#')) {
                    updatedContent = `# ${updatedName}\n\n${updatedContent}`;
                }
            }
            //  
            fs__WEBPACK_IMPORTED_MODULE_1__.writeFileSync(rule.filePath, updatedContent, 'utf-8');
            // Rule  
            const updatedRule = {
                ...rule,
                name: updatedName,
                content: updatedContent,
                updatedAt: new Date()
            };
            // Rules  
            this.rules.set(id, updatedRule);
            //   
            this._onDidChangeRules.fire();
            return updatedRule;
        }
        catch (error) {
            console.error('Rule  :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule    : ${error}`, 'rule-update-failed');
        }
    }
    /**
     * Rule 
     * @param id Rule ID
     */
    async deleteRule(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`ID ${id} Rule   .`, 'rule-not-found');
            }
            //   
            if (rule.status === RuleStatus.Active) {
                await this.deactivateRule(id);
            }
            //  
            if (fs__WEBPACK_IMPORTED_MODULE_1__.existsSync(rule.filePath)) {
                fs__WEBPACK_IMPORTED_MODULE_1__.unlinkSync(rule.filePath);
            }
            // Rules  
            this.rules.delete(id);
            //   
            this._onDidChangeRules.fire();
            return true;
        }
        catch (error) {
            console.error('Rule  :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule    : ${error}`, 'rule-deletion-failed');
        }
    }
    /**
     * Rule 
     * @param id Rule ID
     */
    async activateRule(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`ID ${id} Rule   .`, 'rule-not-found');
            }
            //     
            if (rule.status === RuleStatus.Active) {
                return true;
            }
            //   Rules  
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.rules');
            const activeRules = config.get('activeRules', []);
            // ID   
            if (!activeRules.includes(id)) {
                activeRules.push(id);
                await config.update('activeRules', activeRules, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global);
            }
            // Rule  
            const updatedRule = {
                ...rule,
                status: RuleStatus.Active,
                updatedAt: new Date()
            };
            // Rules  
            this.rules.set(id, updatedRule);
            //   
            this._onDidChangeRules.fire();
            return true;
        }
        catch (error) {
            console.error('Rule  :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule    : ${error}`, 'rule-activation-failed');
        }
    }
    /**
     * Rule 
     * @param id Rule ID
     */
    async deactivateRule(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`ID ${id} Rule   .`, 'rule-not-found');
            }
            //     
            if (rule.status === RuleStatus.Inactive) {
                return true;
            }
            //   Rules  
            const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.rules');
            const activeRules = config.get('activeRules', []);
            // ID   
            const updatedActiveRules = activeRules.filter(activeId => activeId !== id);
            await config.update('activeRules', updatedActiveRules, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global);
            // Rule  
            const updatedRule = {
                ...rule,
                status: RuleStatus.Inactive,
                updatedAt: new Date()
            };
            // Rules  
            this.rules.set(id, updatedRule);
            //   
            this._onDidChangeRules.fire();
            return true;
        }
        catch (error) {
            console.error('Rule  :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule    : ${error}`, 'rule-deactivation-failed');
        }
    }
    /**
     * Rules  
     * @param id Rule ID
     */
    async openRuleFile(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`ID ${id} Rule   .`, 'rule-not-found');
            }
            // VS Code  
            const document = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument(rule.filePath);
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showTextDocument(document);
            return true;
        }
        catch (error) {
            console.error('Rule   :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError(`Rule     : ${error}`, 'rule-open-failed');
        }
    }
    /**
     * Rules LLM   
     */
    getRulesAsSystemPrompt() {
        const activeRules = this.getActiveRules();
        if (activeRules.length === 0) {
            return '';
        }
        //  
        let systemPrompt = '# APE Rules\n\n';
        systemPrompt += '   :\n\n';
        //   Rule  
        for (const rule of activeRules) {
            //       
            let content = rule.content;
            const titleMatch = content.match(/^#\s+(.+)$/m);
            if (titleMatch) {
                content = content.replace(titleMatch[0], '').trim();
            }
            systemPrompt += `## ${rule.name}\n\n${content}\n\n`;
        }
        return systemPrompt;
    }
    /**
     *  
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/services/serviceConfig.ts":
/*!********************************************!*\
  !*** ./src/core/services/serviceConfig.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AuthType: () => (/* binding */ AuthType),
/* harmony export */   ServiceConfigManager: () => (/* binding */ ServiceConfigManager),
/* harmony export */   ServiceType: () => (/* binding */ ServiceType)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/**
 *   
 *
 * Git, Jira, S3, SWDP      .
 *   URL,    VSCode   .
 */

/**
 *    
 */
var AuthType;
(function (AuthType) {
    AuthType["None"] = "none";
    AuthType["Basic"] = "basic";
    AuthType["OAuth"] = "oauth";
    AuthType["Token"] = "token";
    AuthType["AWS"] = "aws";
})(AuthType || (AuthType = {}));
/**
 *  
 */
var ServiceType;
(function (ServiceType) {
    ServiceType["Git"] = "git";
    ServiceType["Bitbucket"] = "bitbucket";
    ServiceType["Jira"] = "jira";
    ServiceType["S3"] = "pocket";
    ServiceType["SWDP"] = "swdp";
    ServiceType["Vault"] = "vault";
    ServiceType["Unknown"] = "unknown";
})(ServiceType || (ServiceType = {}));
/**
 *    
 */
class ServiceConfigManager {
    context;
    configs = new Map();
    disposables = [];
    /**
     * 
     * @param context VSCode  
     */
    constructor(context) {
        this.context = context;
        //   
        this.loadAllConfigs();
        //   
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            let configChanged = false;
            for (const serviceType of Object.values(ServiceType)) {
                if (e.affectsConfiguration(`ape.${serviceType}`)) {
                    this.loadServiceConfig(serviceType);
                    configChanged = true;
                }
            }
            if (configChanged) {
                //    
                this.onConfigChange();
            }
        }));
    }
    /**
     *      
     * @private
     */
    onConfigChange() {
        //     
        //  EventEmitter  
    }
    /**
     *    
     * @private
     */
    loadAllConfigs() {
        for (const serviceType of Object.values(ServiceType)) {
            this.loadServiceConfig(serviceType);
        }
    }
    /**
     *    
     * @param serviceType  
     * @private
     */
    loadServiceConfig(serviceType) {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(`ape.${serviceType}`);
        const serviceConfig = {
            enabled: config.get('enabled', false),
            url: config.get('url', ''),
            authType: config.get('authType', AuthType.None),
            username: config.get('username', ''),
            password: config.get('password', ''),
            token: config.get('token', ''),
            useMock: config.get('useMock', true),
            additionalParams: {}
        };
        // VAULT     
        if (serviceType === ServiceType.Vault) {
            serviceConfig.additionalParams = {
                vaultDirectory: config.get('vaultDirectory', '.ape-vault')
            };
        }
        else {
            serviceConfig.additionalParams = config.get('additionalParams', {});
        }
        this.configs.set(serviceType, serviceConfig);
    }
    /**
     *   
     * @param serviceType  
     */
    getServiceConfig(serviceType) {
        //    
        if (!this.configs.has(serviceType)) {
            this.loadServiceConfig(serviceType);
        }
        return this.configs.get(serviceType);
    }
    /**
     *   
     * @param serviceType  
     * @param config  
     */
    async updateServiceConfig(serviceType, config) {
        try {
            const vscodeConfig = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(`ape.${serviceType}`);
            //   
            for (const [key, value] of Object.entries(config)) {
                if (value !== undefined) {
                    await vscodeConfig.update(key, value, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global);
                }
            }
            //   
            this.loadServiceConfig(serviceType);
            return true;
        }
        catch (error) {
            console.error(`    (${serviceType}):`, error);
            return false;
        }
    }
    /**
     *   
     * @param serviceType  
     */
    validateServiceConfig(serviceType) {
        const config = this.getServiceConfig(serviceType);
        const errors = [];
        //  :     URL 
        if (config.enabled && !config.useMock) {
            if (!config.url) {
                errors.push(`${serviceType}  URL  .`);
            }
            else if (!this.isValidUrl(config.url)) {
                errors.push(`${serviceType}  URL   : ${config.url}`);
            }
            //    
            if (config.authType === AuthType.Basic) {
                if (!config.username) {
                    errors.push(`${serviceType}     .`);
                }
                if (!config.password) {
                    errors.push(`${serviceType}    .`);
                }
            }
            else if (config.authType === AuthType.Token) {
                if (!config.token) {
                    errors.push(`${serviceType}    .`);
                }
            }
            else if (config.authType === AuthType.OAuth) {
                if (!config.token) {
                    errors.push(`${serviceType}  OAuth   .`);
                }
            }
            else if (config.authType === AuthType.AWS) {
                const params = config.additionalParams || {};
                if (!params.accessKeyId) {
                    errors.push(`${serviceType}  AWS   ID  .`);
                }
                if (!params.secretAccessKey) {
                    errors.push(`${serviceType}  AWS     .`);
                }
                if (!params.region) {
                    errors.push(`${serviceType}  AWS   .`);
                }
            }
        }
        return errors;
    }
    /**
     * URL  
     * @param url  URL
     * @private
     */
    isValidUrl(url) {
        try {
            new URL(url);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     *   
     * @param serviceType  
     */
    async testConnection(serviceType) {
        const config = this.getServiceConfig(serviceType);
        //     
        if (config.useMock) {
            return {
                success: true,
                message: `${serviceType}     .    .`
            };
        }
        //  
        const errors = this.validateServiceConfig(serviceType);
        if (errors.length > 0) {
            return {
                success: false,
                message: ` : ${errors.join(' ')}`
            };
        }
        //       
        return {
            success: true,
            message: `${serviceType}   .       .`
        };
    }
    /**
     *  
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/services/serviceError.ts":
/*!*******************************************!*\
  !*** ./src/core/services/serviceError.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ServiceError: () => (/* binding */ ServiceError),
/* harmony export */   ServiceErrorManager: () => (/* binding */ ServiceErrorManager),
/* harmony export */   ServiceErrorType: () => (/* binding */ ServiceErrorType)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _serviceConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serviceConfig */ "./src/core/services/serviceConfig.ts");
/**
 *   
 *
 *           
 *         
 */


/**
 *    
 */
var ServiceErrorType;
(function (ServiceErrorType) {
    //   
    ServiceErrorType["ConnectionFailed"] = "connection_failed";
    ServiceErrorType["Timeout"] = "timeout";
    //   
    ServiceErrorType["AuthenticationFailed"] = "authentication_failed";
    ServiceErrorType["TokenExpired"] = "token_expired";
    ServiceErrorType["PermissionDenied"] = "permission_denied";
    //   
    ServiceErrorType["ResourceNotFound"] = "resource_not_found";
    ServiceErrorType["InvalidResource"] = "invalid_resource";
    //   
    ServiceErrorType["InvalidRequest"] = "invalid_request";
    ServiceErrorType["BadRequest"] = "bad_request";
    ServiceErrorType["RateLimited"] = "rate_limited";
    //   
    ServiceErrorType["ServerError"] = "server_error";
    ServiceErrorType["ServiceUnavailable"] = "service_unavailable";
    //   
    ServiceErrorType["ConfigurationError"] = "configuration_error";
    //  
    ServiceErrorType["Unknown"] = "unknown";
})(ServiceErrorType || (ServiceErrorType = {}));
/**
 *   
 */
class ServiceError extends Error {
    type;
    serviceType;
    details;
    timestamp;
    /**
     *   
     * @param message  
     * @param originalError   ()
     * @param serviceType   (: Unknown)
     * @param errorType   (: Unknown)
     */
    constructor(message, originalError, serviceType = _serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Unknown, errorType = ServiceErrorType.Unknown) {
        super(message);
        this.name = 'ServiceError';
        this.message = message;
        this.type = errorType;
        this.serviceType = serviceType;
        this.details = originalError;
        this.timestamp = new Date();
        // Error    
        Object.setPrototypeOf(this, ServiceError.prototype);
    }
}
/**
 *    
 */
class ServiceErrorManager {
    static _lastErrors = new Map();
    /**
     *    
     * @param serviceType  
     * @param errorType  
     * @param message  
     * @param details   
     * @returns   
     */
    static createError(serviceType, errorType, message, details) {
        const error = new ServiceError(message, details, serviceType, errorType);
        //     
        this._lastErrors.set(serviceType, error);
        //   
        console.error(`[${serviceType}] ${errorType}: ${message}`, details || '');
        return error;
    }
    /**
     *   
     * @param serviceType  
     * @returns     null
     */
    static getLastError(serviceType) {
        return this._lastErrors.get(serviceType) || null;
    }
    /**
     *    
     * @returns    
     */
    static getAllErrors() {
        return new Map(this._lastErrors);
    }
    /**
     *      
     * @param error  
     * @returns    
     */
    static getUserFriendlyMessage(error) {
        //    
        const serviceNames = {
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Git]: 'Git',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Bitbucket]: 'Bitbucket',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Jira]: 'Jira',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.S3]: 'Pocket/S3',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.SWDP]: 'SWDP',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault]: 'VAULT',
            [_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Unknown]: '   '
        };
        const serviceName = serviceNames[error.serviceType] || error.serviceType;
        //    
        switch (error.type) {
            case ServiceErrorType.ConnectionFailed:
                return `${serviceName}   . URL : ${error.details?.url || ''}`;
            case ServiceErrorType.Timeout:
                return `${serviceName}    .    .`;
            case ServiceErrorType.AuthenticationFailed:
                return `${serviceName}  .   .`;
            case ServiceErrorType.TokenExpired:
                return `${serviceName}   .  .`;
            case ServiceErrorType.PermissionDenied:
                return `${serviceName}   .   .`;
            case ServiceErrorType.ResourceNotFound:
                return `${serviceName}     .`;
            case ServiceErrorType.InvalidResource:
                return `${serviceName}   .`;
            case ServiceErrorType.InvalidRequest:
            case ServiceErrorType.BadRequest:
                return `${serviceName}   .`;
            case ServiceErrorType.RateLimited:
                return `${serviceName}   .    .`;
            case ServiceErrorType.ServerError:
                return `${serviceName}   .   .`;
            case ServiceErrorType.ServiceUnavailable:
                return `${serviceName}     .   .`;
            case ServiceErrorType.ConfigurationError:
                return `${serviceName}  : ${error.message}`;
            case ServiceErrorType.Unknown:
            default:
                return `${serviceName} : ${error.message}`;
        }
    }
    /**
     *   
     * @param error  
     * @param showDetailAction      
     */
    static async showErrorToUser(error, showDetailAction = true) {
        const userMessage = this.getUserFriendlyMessage(error);
        if (showDetailAction) {
            const selection = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(userMessage, ' ', '');
            if (selection === ' ') {
                //     
                const outputChannel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createOutputChannel(`APE ${error.serviceType} `);
                outputChannel.appendLine(`: ${error.timestamp.toLocaleString()}`);
                outputChannel.appendLine(`: ${error.serviceType}`);
                outputChannel.appendLine(` : ${error.type}`);
                outputChannel.appendLine(`: ${error.message}`);
                if (error.details) {
                    outputChannel.appendLine('\n :');
                    outputChannel.appendLine(JSON.stringify(error.details, null, 2));
                }
                outputChannel.show();
            }
        }
        else {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(userMessage);
        }
    }
    /**
     * HTTP   ServiceErrorType 
     * @param statusCode HTTP  
     * @returns    
     */
    static errorTypeFromHttpStatus(statusCode) {
        if (statusCode >= 500) {
            return ServiceErrorType.ServerError;
        }
        switch (statusCode) {
            case 400:
                return ServiceErrorType.BadRequest;
            case 401:
                return ServiceErrorType.AuthenticationFailed;
            case 403:
                return ServiceErrorType.PermissionDenied;
            case 404:
                return ServiceErrorType.ResourceNotFound;
            case 408:
                return ServiceErrorType.Timeout;
            case 429:
                return ServiceErrorType.RateLimited;
            default:
                return ServiceErrorType.Unknown;
        }
    }
}


/***/ }),

/***/ "./src/core/services/serviceResult.ts":
/*!********************************************!*\
  !*** ./src/core/services/serviceResult.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createErrorResult: () => (/* binding */ createErrorResult),
/* harmony export */   createSuccessResult: () => (/* binding */ createSuccessResult)
/* harmony export */ });
/**
 *   
 *
 *         
 * / , ,     
 */
/**
 *     
 *
 * @param data  
 * @returns   
 */
function createSuccessResult(data) {
    return {
        success: true,
        data
    };
}
/**
 *     
 *
 * @param error  
 * @returns   
 */
function createErrorResult(error) {
    return {
        success: false,
        error
    };
}


/***/ }),

/***/ "./src/core/services/vaultService.ts":
/*!*******************************************!*\
  !*** ./src/core/services/vaultService.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VaultContextType: () => (/* binding */ VaultContextType),
/* harmony export */   VaultService: () => (/* binding */ VaultService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _serviceConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./serviceConfig */ "./src/core/services/serviceConfig.ts");
/* harmony import */ var _serviceError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./serviceError */ "./src/core/services/serviceError.ts");
/**
 * VAULT 
 *
 * VAULT     .
 *  , ,    .
 */



/**
 * VAULT  
 */
var VaultContextType;
(function (VaultContextType) {
    VaultContextType["System"] = "system";
    VaultContextType["Project"] = "project";
    VaultContextType["Personal"] = "personal";
    VaultContextType["Shared"] = "shared";
    VaultContextType["Template"] = "template";
})(VaultContextType || (VaultContextType = {}));
/**
 * VAULT  
 */
class VaultService {
    context;
    configManager;
    _onDidChangeVault = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    onDidChangeVault = this._onDidChangeVault.event;
    contexts = new Map();
    disposables = [];
    vaultDir;
    fs = __webpack_require__(/*! fs */ "fs");
    path = __webpack_require__(/*! path */ "path");
    /**
     * 
     * @param context VSCode  
     * @param configManager   
     */
    constructor(context, configManager) {
        this.context = context;
        this.configManager = configManager;
        // VAULT   
        const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
        this.vaultDir = config.additionalParams?.vaultDirectory || '.ape-vault';
        //       
        if (!this.path.isAbsolute(this.vaultDir)) {
            this.vaultDir = this.path.join(this.getUserHomeDir(), this.vaultDir);
        }
        // VAULT     
        this.ensureVaultDirectory();
        //    
        this.disposables.push(vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.vault')) {
                //     
                const newConfig = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
                const newDir = newConfig.additionalParams?.vaultDirectory || '.ape-vault';
                if (newDir !== this.vaultDir) {
                    this.vaultDir = this.path.isAbsolute(newDir)
                        ? newDir
                        : this.path.join(this.getUserHomeDir(), newDir);
                    this.ensureVaultDirectory();
                    this.loadAllContexts();
                }
                else {
                    this.loadAllContexts();
                }
            }
        }));
        //   
        this.loadAllContexts();
    }
    /**
     *    
     */
    getUserHomeDir() {
        return process.env.HOME || process.env.USERPROFILE || '.';
    }
    /**
     * VAULT     
     */
    ensureVaultDirectory() {
        try {
            //  VAULT 
            if (!this.fs.existsSync(this.vaultDir)) {
                this.fs.mkdirSync(this.vaultDir, { recursive: true });
                console.log(`VAULT  : ${this.vaultDir}`);
            }
            //    
            const contextTypeDirs = Object.values(VaultContextType);
            for (const dir of contextTypeDirs) {
                const typePath = this.path.join(this.vaultDir, dir);
                if (!this.fs.existsSync(typePath)) {
                    this.fs.mkdirSync(typePath, { recursive: true });
                }
            }
        }
        catch (error) {
            console.error('VAULT   :', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`VAULT    : ${error}`);
        }
    }
    /**
     *   
     */
    async loadAllContexts() {
        try {
            this.contexts.clear();
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (config.useMock) {
                //   
                this.loadMockContexts();
            }
            else if (config.enabled) {
                //    
                await this.loadContextsFromFileSystem();
                //     
                if (this.contexts.size === 0) {
                    this.createDefaultContexts();
                }
            }
            //   
            this._onDidChangeVault.fire();
        }
        catch (error) {
            console.error('VAULT   :', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`VAULT     : ${error}`);
        }
    }
    /**
     *    
     */
    async loadContextsFromFileSystem() {
        try {
            //     
            for (const contextType of Object.values(VaultContextType)) {
                const typeDir = this.path.join(this.vaultDir, contextType);
                //   
                if (!this.fs.existsSync(typeDir)) {
                    continue;
                }
                //     
                const contextFiles = this.fs.readdirSync(typeDir)
                    .filter((file) => file.endsWith('.context.json'));
                //    
                for (const fileName of contextFiles) {
                    try {
                        const filePath = this.path.join(typeDir, fileName);
                        const data = this.fs.readFileSync(filePath, 'utf8');
                        const contextData = JSON.parse(data);
                        //   Date  
                        contextData.createdAt = new Date(contextData.createdAt);
                        contextData.updatedAt = new Date(contextData.updatedAt);
                        //   
                        contextData.items = await this.loadContextItems(contextData.id, contextType);
                        //   
                        this.contexts.set(contextData.id, contextData);
                    }
                    catch (error) {
                        console.error(`    (${fileName}):`, error);
                    }
                }
            }
        }
        catch (error) {
            console.error('    :', error);
            throw error;
        }
    }
    /**
     *    
     * @param contextId  ID
     * @param contextType  
     */
    async loadContextItems(contextId, contextType) {
        const items = [];
        const itemsDir = this.path.join(this.vaultDir, contextType, contextId);
        //      
        if (!this.fs.existsSync(itemsDir)) {
            return items;
        }
        //    
        const itemFiles = this.fs.readdirSync(itemsDir)
            .filter((file) => file.endsWith('.item.json'));
        //    
        for (const fileName of itemFiles) {
            try {
                const filePath = this.path.join(itemsDir, fileName);
                const data = this.fs.readFileSync(filePath, 'utf8');
                const itemData = JSON.parse(data);
                //   Date  
                itemData.createdAt = new Date(itemData.createdAt);
                itemData.updatedAt = new Date(itemData.updatedAt);
                //   
                const contentFilePath = this.path.join(itemsDir, `${itemData.id}.content.md`);
                if (this.fs.existsSync(contentFilePath)) {
                    itemData.content = this.fs.readFileSync(contentFilePath, 'utf8');
                }
                items.push(itemData);
            }
            catch (error) {
                console.error(`    (${fileName}):`, error);
            }
        }
        return items;
    }
    /**
     *   
     */
    createDefaultContexts() {
        //      
        this.loadMockContexts();
        //   
        this.contexts.forEach(context => {
            this.saveContextToFileSystem(context);
        });
    }
    /**
     *    
     * @param context  
     */
    saveContextToFileSystem(context) {
        try {
            //    
            const typeDir = this.path.join(this.vaultDir, context.type);
            //   
            const contextMetadata = { ...context };
            delete contextMetadata.items; //   
            const contextFilePath = this.path.join(typeDir, `${context.id}.context.json`);
            this.fs.writeFileSync(contextFilePath, JSON.stringify(contextMetadata, null, 2), 'utf8');
            //    
            const itemsDir = this.path.join(typeDir, context.id);
            if (!this.fs.existsSync(itemsDir)) {
                this.fs.mkdirSync(itemsDir, { recursive: true });
            }
            //   
            context.items.forEach(item => {
                this.saveItemToFileSystem(item, context.id, context.type);
            });
        }
        catch (error) {
            console.error(`   (${context.id}):`, error);
        }
    }
    /**
     *    
     * @param item  
     * @param contextId  ID
     * @param contextType  
     */
    saveItemToFileSystem(item, contextId, contextType) {
        try {
            //   
            const itemsDir = this.path.join(this.vaultDir, contextType, contextId);
            //   
            const itemMetadata = { ...item };
            const content = itemMetadata.content;
            delete itemMetadata.content; //    
            const itemFilePath = this.path.join(itemsDir, `${item.id}.item.json`);
            this.fs.writeFileSync(itemFilePath, JSON.stringify(itemMetadata, null, 2), 'utf8');
            //   
            const contentFilePath = this.path.join(itemsDir, `${item.id}.content.md`);
            this.fs.writeFileSync(contentFilePath, content, 'utf8');
        }
        catch (error) {
            console.error(`   (${item.id}):`, error);
        }
    }
    /**
     *    
     */
    loadMockContexts() {
        this.contexts.clear();
        //  
        const systemContext = {
            id: 'system-context',
            name: ' ',
            description: '  .',
            type: VaultContextType.System,
            createdAt: new Date('2023-01-01'),
            updatedAt: new Date('2023-01-01'),
            items: [
                {
                    id: 'system-item-1',
                    name: '  ',
                    description: '  .',
                    content: 'You are an AI assistant. Answer questions concisely and accurately.',
                    createdAt: new Date('2023-01-01'),
                    updatedAt: new Date('2023-01-01'),
                    contextType: VaultContextType.System,
                    contextId: 'system-context',
                    tags: ['system', 'default', 'prompt']
                },
                {
                    id: 'system-item-2',
                    name: '  ',
                    description: '   .',
                    content: 'You are a code review assistant. Analyze the provided code and give feedback.',
                    createdAt: new Date('2023-01-02'),
                    updatedAt: new Date('2023-01-02'),
                    contextType: VaultContextType.System,
                    contextId: 'system-context',
                    tags: ['system', 'code-review', 'prompt']
                }
            ]
        };
        //  
        const projectContext = {
            id: 'project-context',
            name: 'APE  ',
            description: 'APE   .',
            type: VaultContextType.Project,
            createdAt: new Date('2023-02-01'),
            updatedAt: new Date('2023-02-01'),
            items: [
                {
                    id: 'project-item-1',
                    name: ' ',
                    description: 'APE   .',
                    content: 'APE      . Core , UI ,  ...',
                    createdAt: new Date('2023-02-01'),
                    updatedAt: new Date('2023-02-01'),
                    contextType: VaultContextType.Project,
                    contextId: 'project-context',
                    tags: ['project', 'architecture', 'documentation']
                },
                {
                    id: 'project-item-2',
                    name: ' ',
                    description: '  .',
                    content: '     . 1.    ...',
                    createdAt: new Date('2023-02-02'),
                    updatedAt: new Date('2023-02-02'),
                    contextType: VaultContextType.Project,
                    contextId: 'project-context',
                    tags: ['project', 'guidelines', 'development']
                }
            ]
        };
        //  
        const personalContext = {
            id: 'personal-context',
            name: ' ',
            description: '  .',
            type: VaultContextType.Personal,
            createdAt: new Date('2023-03-01'),
            updatedAt: new Date('2023-03-01'),
            items: [
                {
                    id: 'personal-item-1',
                    name: '  ',
                    description: '  .',
                    content: '   ,       ...',
                    createdAt: new Date('2023-03-01'),
                    updatedAt: new Date('2023-03-01'),
                    contextType: VaultContextType.Personal,
                    contextId: 'personal-context',
                    tags: ['personal', 'memo', 'work']
                }
            ]
        };
        //  
        const sharedContext = {
            id: 'shared-context',
            name: '  ',
            description: '   .',
            type: VaultContextType.Shared,
            createdAt: new Date('2023-04-01'),
            updatedAt: new Date('2023-04-01'),
            items: [
                {
                    id: 'shared-item-1',
                    name: ' ',
                    description: '  .',
                    content: ': 2023-04-01\n: ...\n:       ...',
                    createdAt: new Date('2023-04-01'),
                    updatedAt: new Date('2023-04-01'),
                    contextType: VaultContextType.Shared,
                    contextId: 'shared-context',
                    tags: ['shared', 'meeting', 'team']
                }
            ]
        };
        //  
        const templateContext = {
            id: 'template-context',
            name: ' ',
            description: '   .',
            type: VaultContextType.Template,
            createdAt: new Date('2023-05-01'),
            updatedAt: new Date('2023-05-01'),
            items: [
                {
                    id: 'template-item-1',
                    name: '  ',
                    description: '   .',
                    content: '   []   ...',
                    createdAt: new Date('2023-05-01'),
                    updatedAt: new Date('2023-05-01'),
                    contextType: VaultContextType.Template,
                    contextId: 'template-context',
                    tags: ['template', 'code-generation']
                },
                {
                    id: 'template-item-2',
                    name: ' ',
                    description: '  .',
                    content: '# [ ]\n\n## \n\n## \n\n##  \n\n## ',
                    createdAt: new Date('2023-05-02'),
                    updatedAt: new Date('2023-05-02'),
                    contextType: VaultContextType.Template,
                    contextId: 'template-context',
                    tags: ['template', 'documentation']
                }
            ]
        };
        //   
        this.contexts.set(systemContext.id, systemContext);
        this.contexts.set(projectContext.id, projectContext);
        this.contexts.set(personalContext.id, personalContext);
        this.contexts.set(sharedContext.id, sharedContext);
        this.contexts.set(templateContext.id, templateContext);
    }
    /**
     *   
     */
    getAllContexts() {
        return Array.from(this.contexts.values());
    }
    /**
     *    
     * @param type  
     */
    getContextsByType(type) {
        return Array.from(this.contexts.values()).filter(context => context.type === type);
    }
    /**
     *  ID  
     * @param contextId  ID
     */
    getContextById(contextId) {
        return this.contexts.get(contextId);
    }
    /**
     *  
     * @param name  
     * @param type  
     * @param description  ()
     */
    async createContext(name, type, description) {
        try {
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT   .', 'vault-disabled');
            }
            const newContext = {
                id: `${type}-${Date.now()}`,
                name,
                description,
                type,
                createdAt: new Date(),
                updatedAt: new Date(),
                items: []
            };
            if (!config.useMock) {
                //    
                this.saveContextToFileSystem(newContext);
            }
            //   
            this.contexts.set(newContext.id, newContext);
            //   
            this._onDidChangeVault.fire();
            return newContext;
        }
        catch (error) {
            console.error('VAULT   :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT     : ${error}`, 'vault-context-creation-failed');
        }
    }
    /**
     *  
     * @param contextId  ID
     * @param updates  
     */
    async updateContext(contextId, updates) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID ${contextId}    .`, 'vault-context-not-found');
            }
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT   .', 'vault-disabled');
            }
            //  
            const updatedContext = {
                ...context,
                ...updates,
                updatedAt: new Date()
            };
            if (!config.useMock) {
                //     
                this.saveContextToFileSystem(updatedContext);
            }
            //   
            this.contexts.set(contextId, updatedContext);
            //   
            this._onDidChangeVault.fire();
            return updatedContext;
        }
        catch (error) {
            console.error('VAULT   :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT     : ${error}`, 'vault-context-update-failed');
        }
    }
    /**
     *  
     * @param contextId  ID
     */
    async deleteContext(contextId) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID ${contextId}    .`, 'vault-context-not-found');
            }
            //    
            if (context.type === VaultContextType.System) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('    .', 'vault-system-context-deletion-forbidden');
            }
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT   .', 'vault-disabled');
            }
            if (!config.useMock) {
                //    
                this.deleteContextFromFileSystem(context);
            }
            //   
            this.contexts.delete(contextId);
            //   
            this._onDidChangeVault.fire();
            return true;
        }
        catch (error) {
            console.error('VAULT   :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT     : ${error}`, 'vault-context-deletion-failed');
        }
    }
    /**
     *    
     * @param context  
     */
    deleteContextFromFileSystem(context) {
        try {
            //    
            const typeDir = this.path.join(this.vaultDir, context.type);
            //    
            const contextFilePath = this.path.join(typeDir, `${context.id}.context.json`);
            if (this.fs.existsSync(contextFilePath)) {
                this.fs.unlinkSync(contextFilePath);
            }
            //     ()
            const itemsDir = this.path.join(typeDir, context.id);
            if (this.fs.existsSync(itemsDir)) {
                this.deleteDirectoryRecursive(itemsDir);
            }
        }
        catch (error) {
            console.error(`    (${context.id}):`, error);
            throw error;
        }
    }
    /**
     *   
     * @param dirPath   
     */
    deleteDirectoryRecursive(dirPath) {
        if (this.fs.existsSync(dirPath)) {
            this.fs.readdirSync(dirPath).forEach((file) => {
                const curPath = this.path.join(dirPath, file);
                if (this.fs.lstatSync(curPath).isDirectory()) {
                    //     
                    this.deleteDirectoryRecursive(curPath);
                }
                else {
                    //  
                    this.fs.unlinkSync(curPath);
                }
            });
            //   
            this.fs.rmdirSync(dirPath);
        }
    }
    /**
     *  
     * @param contextId  ID
     * @param item  
     */
    async createItem(contextId, item) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID ${contextId}    .`, 'vault-context-not-found');
            }
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT   .', 'vault-disabled');
            }
            const newItem = {
                ...item,
                id: `${contextId}-item-${Date.now()}`,
                createdAt: new Date(),
                updatedAt: new Date(),
                contextId: contextId
            };
            if (!config.useMock) {
                //    
                this.saveItemToFileSystem(newItem, contextId, context.type);
            }
            //   
            context.items.push(newItem);
            context.updatedAt = new Date();
            //   
            this._onDidChangeVault.fire();
            return newItem;
        }
        catch (error) {
            console.error('VAULT   :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT     : ${error}`, 'vault-item-creation-failed');
        }
    }
    /**
     *  
     * @param contextId  ID
     * @param itemId  ID
     * @param updates  
     */
    async updateItem(contextId, itemId, updates) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID ${contextId}    .`, 'vault-context-not-found');
            }
            const itemIndex = context.items.findIndex(item => item.id === itemId);
            if (itemIndex === -1) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID ${itemId}    .`, 'vault-item-not-found');
            }
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT   .', 'vault-disabled');
            }
            //  
            const item = context.items[itemIndex];
            const updatedItem = {
                ...item,
                ...updates,
                updatedAt: new Date()
            };
            if (!config.useMock) {
                //     
                this.saveItemToFileSystem(updatedItem, contextId, context.type);
            }
            //   
            context.items[itemIndex] = updatedItem;
            context.updatedAt = new Date();
            //   
            this._onDidChangeVault.fire();
            return updatedItem;
        }
        catch (error) {
            console.error('VAULT   :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT     : ${error}`, 'vault-item-update-failed');
        }
    }
    /**
     *  
     * @param contextId  ID
     * @param itemId  ID
     */
    async deleteItem(contextId, itemId) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID ${contextId}    .`, 'vault-context-not-found');
            }
            const itemIndex = context.items.findIndex(item => item.id === itemId);
            if (itemIndex === -1) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`ID ${itemId}    .`, 'vault-item-not-found');
            }
            const config = this.configManager.getServiceConfig(_serviceConfig__WEBPACK_IMPORTED_MODULE_1__.ServiceType.Vault);
            if (!config.enabled) {
                throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError('VAULT   .', 'vault-disabled');
            }
            if (!config.useMock) {
                //    
                this.deleteItemFromFileSystem(context.items[itemIndex], contextId, context.type);
            }
            //   
            context.items.splice(itemIndex, 1);
            context.updatedAt = new Date();
            //   
            this._onDidChangeVault.fire();
            return true;
        }
        catch (error) {
            console.error('VAULT   :', error);
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_2__.ServiceError(`VAULT     : ${error}`, 'vault-item-deletion-failed');
        }
    }
    /**
     *    
     * @param item  
     * @param contextId  ID
     * @param contextType  
     */
    deleteItemFromFileSystem(item, contextId, contextType) {
        try {
            //   
            const itemsDir = this.path.join(this.vaultDir, contextType, contextId);
            //    
            const itemFilePath = this.path.join(itemsDir, `${item.id}.item.json`);
            if (this.fs.existsSync(itemFilePath)) {
                this.fs.unlinkSync(itemFilePath);
            }
            //    
            const contentFilePath = this.path.join(itemsDir, `${item.id}.content.md`);
            if (this.fs.existsSync(contentFilePath)) {
                this.fs.unlinkSync(contentFilePath);
            }
        }
        catch (error) {
            console.error(`    (${item.id}):`, error);
            throw error;
        }
    }
    /**
     *  
     * @param query 
     * @param filters  ( ,  )
     */
    searchItems(query, filters) {
        const allContexts = this.getAllContexts();
        let filteredContexts = allContexts;
        //   
        if (filters?.contextTypes && filters.contextTypes.length > 0) {
            filteredContexts = filteredContexts.filter(context => filters.contextTypes.includes(context.type));
        }
        //  ID 
        if (filters?.contextIds && filters.contextIds.length > 0) {
            filteredContexts = filteredContexts.filter(context => filters.contextIds.includes(context.id));
        }
        //   
        let items = filteredContexts.flatMap(context => context.items);
        //  
        if (filters?.tags && filters.tags.length > 0) {
            items = items.filter(item => {
                if (!item.tags)
                    return false;
                return filters.tags.some(tag => item.tags.includes(tag));
            });
        }
        //     
        if (query) {
            const lowerQuery = query.toLowerCase();
            items = items.filter(item => item.name.toLowerCase().includes(lowerQuery) ||
                (item.description && item.description.toLowerCase().includes(lowerQuery)) ||
                item.content.toLowerCase().includes(lowerQuery) ||
                (item.tags && item.tags.some(tag => tag.toLowerCase().includes(lowerQuery))));
        }
        return items;
    }
    /**
     *  LLM  
     * @param item 
     */
    itemToLLMContext(item) {
        //  :    
        return item.content;
    }
    /**
     *  
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}


/***/ }),

/***/ "./src/core/services/versionManager.ts":
/*!*********************************************!*\
  !*** ./src/core/services/versionManager.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VersionManager: () => (/* binding */ VersionManager),
/* harmony export */   VersionType: () => (/* binding */ VersionType)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _serviceError__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./serviceError */ "./src/core/services/serviceError.ts");




/**
 *      
 */
var VersionType;
(function (VersionType) {
    /**
     *  :      (0.0.1)
     */
    VersionType["PATCH"] = "patch";
    /**
     *  :       (0.1.0)
     */
    VersionType["MINOR"] = "minor";
    /**
     *  :        (1.0.0)
     */
    VersionType["MAJOR"] = "major";
})(VersionType || (VersionType = {}));
/**
 *   
 * -   
 * -   (patch, minor, major)
 * - Git  
 */
class VersionManager {
    _extensionContext;
    constructor(context) {
        this._extensionContext = context;
    }
    /**
     *     
     * @returns  
     */
    async getCurrentVersion() {
        try {
            const packageJsonPath = this.getPackageJsonPath();
            const packageJson = await this.readPackageJson(packageJsonPath);
            const version = packageJson.version || '0.0.0';
            const versionParts = this.parseVersion(version);
            return {
                version,
                packageJsonPath,
                versionParts
            };
        }
        catch (error) {
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError('     .', error);
        }
    }
    /**
     *  
     * @param type    (patch, minor, major)
     * @param message   /
     * @param createGitTag Git   
     * @returns   
     */
    async updateVersion(type, message, createGitTag = false) {
        try {
            //    
            const currentVersionInfo = await this.getCurrentVersion();
            const { versionParts, packageJsonPath } = currentVersionInfo;
            //   
            const newVersionParts = [...versionParts];
            switch (type) {
                case VersionType.PATCH:
                    newVersionParts[2] += 1;
                    break;
                case VersionType.MINOR:
                    newVersionParts[1] += 1;
                    newVersionParts[2] = 0;
                    break;
                case VersionType.MAJOR:
                    newVersionParts[0] += 1;
                    newVersionParts[1] = 0;
                    newVersionParts[2] = 0;
                    break;
            }
            const newVersion = newVersionParts.join('.');
            // package.json 
            await this.updatePackageJsonVersion(packageJsonPath, newVersion);
            // Git   ()
            if (createGitTag) {
                await this.createGitTag(newVersion, message);
            }
            //  
            this.updateStatusBar(newVersion);
            //  
            return {
                version: newVersion,
                packageJsonPath,
                versionParts: newVersionParts
            };
        }
        catch (error) {
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError('    .', error);
        }
    }
    /**
     * Git  
     * @param version  
     * @param message  
     */
    async createGitTag(version, message) {
        try {
            const tagName = `v${version}`;
            const tagMessage = message || `Version ${version}`;
            // Git   
            const terminal = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createTerminal('APE Version Manager');
            terminal.sendText(`git tag -a "${tagName}" -m "${tagMessage}"`);
            terminal.sendText('git push --tags');
            terminal.show();
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Created Git tag: ${tagName}`);
        }
        catch (error) {
            throw new _serviceError__WEBPACK_IMPORTED_MODULE_3__.ServiceError('Git     .', error);
        }
    }
    /**
     *    
     */
    registerCommands() {
        //    
        this._extensionContext.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.internal.version.bump.patch', async () => {
            await this.bumpVersion(VersionType.PATCH);
        }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.internal.version.bump.minor', async () => {
            await this.bumpVersion(VersionType.MINOR);
        }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.internal.version.bump.major', async () => {
            await this.bumpVersion(VersionType.MAJOR);
        }));
    }
    /**
     * VS Code    
     * @param version  
     */
    updateStatusBar(version) {
        //      
        const statusBarItem = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createStatusBarItem(vscode__WEBPACK_IMPORTED_MODULE_0__.StatusBarAlignment.Right, 100);
        statusBarItem.text = `$(tag) APE v${version}`;
        statusBarItem.tooltip = 'APE Extension Version';
        statusBarItem.show();
        // Extension Context    
        this._extensionContext.subscriptions.push(statusBarItem);
    }
    /**
     *    
     * @param type   
     */
    async bumpVersion(type) {
        try {
            //   
            const message = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: '   ',
                placeHolder: ':   UI '
            });
            if (message === undefined) {
                return; // 
            }
            // Git    
            const createTag = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(['Yes', 'No'], {
                placeHolder: 'Git  ?'
            });
            if (createTag === undefined) {
                return; // 
            }
            //  
            const newVersionInfo = await this.updateVersion(type, message, createTag === 'Yes');
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(` ${newVersionInfo.version}() .`);
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`  : ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * package.json  
     */
    getPackageJsonPath() {
        return path__WEBPACK_IMPORTED_MODULE_2__.join(this._extensionContext.extensionPath, 'package.json');
    }
    /**
     * package.json  
     * @param filePath package.json  
     */
    async readPackageJson(filePath) {
        return new Promise((resolve, reject) => {
            fs__WEBPACK_IMPORTED_MODULE_1__.readFile(filePath, 'utf8', (err, data) => {
                if (err) {
                    reject(err);
                    return;
                }
                try {
                    const packageJson = JSON.parse(data);
                    resolve(packageJson);
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
    /**
     * package.json  
     * @param filePath package.json  
     * @param newVersion   
     */
    async updatePackageJsonVersion(filePath, newVersion) {
        return new Promise((resolve, reject) => {
            fs__WEBPACK_IMPORTED_MODULE_1__.readFile(filePath, 'utf8', (err, data) => {
                if (err) {
                    reject(err);
                    return;
                }
                try {
                    const packageJson = JSON.parse(data);
                    packageJson.version = newVersion;
                    const updatedContent = JSON.stringify(packageJson, null, 2);
                    fs__WEBPACK_IMPORTED_MODULE_1__.writeFile(filePath, updatedContent, 'utf8', (writeErr) => {
                        if (writeErr) {
                            reject(writeErr);
                            return;
                        }
                        resolve();
                    });
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
    /**
     *   
     * @param version   (x.y.z )
     * @returns [major, minor, patch]  
     */
    parseVersion(version) {
        const parts = version.split('.').map(part => parseInt(part, 10));
        //  3   
        while (parts.length < 3) {
            parts.push(0);
        }
        return parts;
    }
}


/***/ }),

/***/ "./src/data/helpSystemPrompt.ts":
/*!**************************************!*\
  !*** ./src/data/helpSystemPrompt.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CODE_HELP_PROMPT: () => (/* binding */ CODE_HELP_PROMPT),
/* harmony export */   GIT_HELP_PROMPT: () => (/* binding */ GIT_HELP_PROMPT),
/* harmony export */   HELP_SYSTEM_PROMPT: () => (/* binding */ HELP_SYSTEM_PROMPT),
/* harmony export */   generateCommandDetailPrompt: () => (/* binding */ generateCommandDetailPrompt),
/* harmony export */   generateFaqPrompt: () => (/* binding */ generateFaqPrompt),
/* harmony export */   generateGuidePrompt: () => (/* binding */ generateGuidePrompt),
/* harmony export */   generateGuidesListPrompt: () => (/* binding */ generateGuidesListPrompt),
/* harmony export */   generateHelpSystemPrompt: () => (/* binding */ generateHelpSystemPrompt)
/* harmony export */ });
/**
 *   
 *
 *   LLM       .
 */
/**
 *    
 */
const HELP_SYSTEM_PROMPT = `
 APE(Agentic Pipeline Engine) VS Code   AI .
       .

#  

##  
- /help, /? -   
- /clear, /cls -   
- /settings, /config -   
- /model [] - LLM   (: /model NARRNAS, /model list)

## Git 
- /git status - Git  
- /git commit -    (  )
- /git push -   
- /git pull -   
- /git solve -   
- /git auto -    
- /git consolidate -   

##  
- /analyze, /code -   
- /open, /file -   

#  
-   :       
-  :      
-    :    , ,     
-   :       

#  
- : v0.3.0
- : APE  

       .
`;
/**
 *    
 */
const CODE_HELP_PROMPT = `
#    

##  
- /analyze, /code -    .
  : (  ) /analyze

##  
- /optimize -    .
  : (  ) /optimize

##  
- /refactor -     .
  : (  ) /refactor

##  
- /explain -     .
  : (  ) /explain

#   

##   
-  :     .
-  :      .
-   :      .

##   
       :
- "TypeScript   "
- "Python    "
- "Java HTTP  "
`;
/**
 * Git   
 */
const GIT_HELP_PROMPT = `
# Git  

##  Git 
- /git status -  Git   .
- /git commit -    .       .
- /git push -      .
- /git pull -      .

##  Git 
- /git solve -     .
- /git branch [] -      .
- /git auto [on|off] -     .      .
- /git consolidate - '[APE][Temporary]'         .

## 
-   : /git status
-  : /git commit
-   : /git auto on
-   : /git consolidate

## 
-       .
-   AI  ,       .
-       .
`;
/**
 *    
 * @param helpData   
 * @param query  
 * @returns LLM  
 */
function generateHelpSystemPrompt(helpData, query) {
    return `
# APE   - LLM  

 APE(Agentic Pipeline Extension)  .           .       .

##  

1.       .
2.      "      ." .
3.    , ,   .
4.    ,     .
5.      .
6.      ,  APE   .

##  

     :

${JSON.stringify(helpData, null, 2)}

##  

: ${query}

##  

    :

1.      H1  H2  
2.       (\`/command\`)
3.     
4.     " "  " "  

 .
`;
}
/**
 *     
 * @param commandData  
 * @returns LLM  
 */
function generateCommandDetailPrompt(commandData) {
    return `
# APE    - LLM  

 APE(Agentic Pipeline Extension)  .      .

##  

${JSON.stringify(commandData, null, 2)}

##  

     :

1.     H1  
2.    
3.   
4.   
5.   
6.   

   .      .

 .
`;
}
/**
 * FAQ    
 * @param faqData FAQ 
 * @param query  
 * @returns LLM  
 */
function generateFaqPrompt(faqData, query) {
    return `
# APE FAQ  

 APE(Agentic Pipeline Extension) FAQ .      FAQ    .

## FAQ 

${JSON.stringify(faqData, null, 2)}

##  

: ${query}

##  

1.     FAQ () .
2. FAQ   ,      .
3.  FAQ  "   FAQ  ." .
4.     .

   .

 .
`;
}
/**
 *     
 * @param guideData   
 * @param guideId  ID
 * @returns LLM  
 */
function generateGuidePrompt(guideData, guideId) {
    const guide = guideData.find(g => g.id === guideId);
    if (!guide) {
        return `
# APE   

  (ID: ${guideId})   .     :

${guideData.map(g => `- ${g.id}: ${g.title}`).join('\n')}

  ID   .
`;
    }
    return `
# APE   - ${guide.title}

       :

${guide.content}

    :
1.    .
2.    .
3.       .
4.       .

 .
`;
}
/**
 *     
 * @param guideData   
 * @returns LLM  
 */
function generateGuidesListPrompt(guideData) {
    return `
# APE   

 APE       :

${JSON.stringify(guideData, null, 2)}

     :
1.  
2.   ( )
3.  ID (     )

 :

## APE  

     :

1. **[  1]**
   - ID: [ ID]
   - [ ]

2. **[  2]**
   - ID: [ ID]
   - [ ]

    "/help guide [ ID]"  .
: /help guide auto-commit

 .
`;
}


/***/ }),

/***/ "./src/plugins/core sync recursive":
/*!********************************!*\
  !*** ./src/plugins/core/ sync ***!
  \********************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./src/plugins/core sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./src/plugins/core/api.ts":
/*!*********************************!*\
  !*** ./src/plugins/core/api.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PluginAPIImpl: () => (/* binding */ PluginAPIImpl)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Implementation of the LLM Service API
 */
class LLMServiceAPIImpl {
    _llmService;
    constructor(_llmService) {
        this._llmService = _llmService;
    }
    /**
     * Get currently active LLM model
     * @returns Active LLM model
     */
    getActiveModel() {
        return this._llmService.getActiveModel();
    }
    /**
     * Set active LLM model
     * @param model Model to set as active
     */
    setActiveModel(model) {
        this._llmService.setActiveModel(model);
    }
    /**
     * Get available LLM models
     * @returns Array of available models
     */
    getAvailableModels() {
        return this._llmService.getAvailableModels();
    }
    /**
     * Send a request to the LLM
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to a service result containing the response
     */
    async sendRequest(messages, options) {
        return await this._llmService.sendRequest(messages, options);
    }
    /**
     * Stream a response from the LLM
     * @param messages Messages to send
     * @param onChunk Callback for each chunk of the response
     * @param options Request options
     * @returns Promise that resolves to a service result indicating success
     */
    async streamResponse(messages, onChunk, options) {
        return await this._llmService.streamResponse(messages, onChunk, options);
    }
    /**
     * Cancel an ongoing streaming response
     */
    cancelStream() {
        this._llmService.cancelStream();
    }
}
/**
 * Implementation of the Memory Service API
 */
class MemoryServiceAPIImpl {
    _memoryService;
    constructor(_memoryService) {
        this._memoryService = _memoryService;
    }
    /**
     * Get current session ID
     * @returns Current session ID or null if no session is active
     */
    getCurrentSessionId() {
        return this._memoryService.getCurrentSessionId();
    }
    /**
     * Get messages from current session
     * @returns Promise that resolves to a service result containing messages
     */
    async getMessages() {
        return await this._memoryService.getMessages();
    }
    /**
     * Add a message to the current session
     * @param message Message to add
     * @returns Promise that resolves to a service result indicating success
     */
    async addMessage(message) {
        return await this._memoryService.addMessage(message);
    }
    /**
     * Create a new session
     * @param options Session creation options
     * @returns Promise that resolves to a service result containing the session ID
     */
    async createSession(options) {
        return await this._memoryService.createSession(options.name, { metadata: options.metadata });
    }
    /**
     * Switch to a different session
     * @param sessionId Session ID to switch to
     * @returns Promise that resolves to a service result indicating success
     */
    async switchSession(sessionId) {
        return await this._memoryService.switchSession(sessionId);
    }
    /**
     * Get all available sessions
     * @returns Promise that resolves to a service result containing session summaries
     */
    async getSessions() {
        const result = await this._memoryService.getSessions();
        if (result.success && result.data) {
            const simplifiedSessions = result.data.map(session => ({
                id: session.id,
                name: session.name,
                messageCount: session.messageCount,
                updatedAt: session.updatedAt
            }));
            return {
                success: true,
                data: simplifiedSessions
            };
        }
        return result;
    }
    /**
     * Clear messages from current session
     * @returns Promise that resolves to a service result indicating success
     */
    async clearMessages() {
        return await this._memoryService.clearMessages();
    }
}
/**
 * Implementation of the UI Service API
 */
class UIServiceAPIImpl {
    /**
     * Show an information message
     * @param message Message to show
     * @param items Items to include in the message
     * @returns Promise that resolves to the selected item
     */
    async showInformationMessage(message, ...items) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(message, ...items);
    }
    /**
     * Show a warning message
     * @param message Message to show
     * @param items Items to include in the message
     * @returns Promise that resolves to the selected item
     */
    async showWarningMessage(message, ...items) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage(message, ...items);
    }
    /**
     * Show an error message
     * @param message Message to show
     * @param items Items to include in the message
     * @returns Promise that resolves to the selected item
     */
    async showErrorMessage(message, ...items) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(message, ...items);
    }
    /**
     * Show quick pick selection
     * @param items Items to show in the quick pick
     * @param options Quick pick options
     * @returns Promise that resolves to the selected item
     */
    async showQuickPick(items, options) {
        // Convert string items to QuickPickItems if needed
        const quickPickItems = Array.isArray(items) && items.length > 0 && typeof items[0] === 'string'
            ? items.map(item => ({ label: item }))
            : items;
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(quickPickItems, options);
    }
    /**
     * Show input box
     * @param options Input box options
     * @returns Promise that resolves to the entered text
     */
    async showInputBox(options) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox(options);
    }
    /**
     * Create and show a webview panel
     * @param viewType Type of the webview
     * @param title Title of the webview
     * @param options Webview options
     * @returns The created webview panel
     */
    createWebviewPanel(viewType, title, options) {
        const viewColumn = options?.viewColumn || vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.Active;
        const preserveFocus = options?.preserveFocus || false;
        return vscode__WEBPACK_IMPORTED_MODULE_0__.window.createWebviewPanel(viewType, title, { viewColumn, preserveFocus });
    }
    /**
     * Create status bar item
     * @param options Status bar item options
     * @returns The created status bar item
     */
    createStatusBarItem(options) {
        const alignment = options?.alignment || vscode__WEBPACK_IMPORTED_MODULE_0__.StatusBarAlignment.Left;
        const priority = options?.priority || 0;
        return vscode__WEBPACK_IMPORTED_MODULE_0__.window.createStatusBarItem(alignment, priority);
    }
}
/**
 * Implementation of the File System API
 */
class FileSystemAPIImpl {
    /**
     * Read file contents
     * @param uri File URI
     * @returns Promise that resolves to file contents
     */
    async readFile(uri) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(uri);
    }
    /**
     * Read file as text
     * @param uri File URI
     * @returns Promise that resolves to file contents as text
     */
    async readFileAsText(uri) {
        const data = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(uri);
        return new TextDecoder().decode(data);
    }
    /**
     * Write data to a file
     * @param uri File URI
     * @param content Content to write
     * @returns Promise that resolves when the file is written
     */
    async writeFile(uri, content) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.writeFile(uri, content);
    }
    /**
     * Write text to a file
     * @param uri File URI
     * @param content Content to write
     * @returns Promise that resolves when the file is written
     */
    async writeFileAsText(uri, content) {
        const data = new TextEncoder().encode(content);
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.writeFile(uri, data);
    }
    /**
     * Delete a file
     * @param uri File URI
     * @returns Promise that resolves when the file is deleted
     */
    async deleteFile(uri) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.delete(uri);
    }
    /**
     * Check if a file exists
     * @param uri File URI
     * @returns Promise that resolves to true if the file exists
     */
    async fileExists(uri) {
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(uri);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * List files in a directory
     * @param uri Directory URI
     * @returns Promise that resolves to an array of files and their types
     */
    async readDirectory(uri) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readDirectory(uri);
    }
    /**
     * Create a directory
     * @param uri Directory URI
     * @returns Promise that resolves when the directory is created
     */
    async createDirectory(uri) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.createDirectory(uri);
    }
    /**
     * Delete a directory
     * @param uri Directory URI
     * @param options Delete options
     * @returns Promise that resolves when the directory is deleted
     */
    async deleteDirectory(uri, options) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.delete(uri, {
            recursive: options?.recursive || false,
            useTrash: false
        });
    }
    /**
     * Rename a file or directory
     * @param oldUri Old URI
     * @param newUri New URI
     * @returns Promise that resolves when the rename is complete
     */
    async rename(oldUri, newUri) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.rename(oldUri, newUri);
    }
    /**
     * Copy a file or directory
     * @param source Source URI
     * @param target Target URI
     * @returns Promise that resolves when the copy is complete
     */
    async copy(source, target) {
        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.copy(source, target);
    }
}
/**
 * Implementation of the Git Service API
 */
class GitServiceAPIImpl {
    /**
     * Get Git repositories in workspace
     * @returns Promise that resolves to an array of repository URIs
     */
    async getRepositories() {
        try {
            // Try to get git extension
            const gitExtension = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('vscode.git')?.exports;
            if (gitExtension) {
                const api = gitExtension.getAPI(1);
                if (api) {
                    // Return URIs for all repositories
                    return api.repositories.map((repo) => {
                        return vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.parse(repo.rootUri.toString());
                    });
                }
            }
            // If extension not available or no repositories, try to infer from workspace folders
            const workspaceFolders = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders;
            if (workspaceFolders && workspaceFolders.length > 0) {
                // Filter to include only folders that contain a .git directory
                const repoFolders = [];
                for (const folder of workspaceFolders) {
                    try {
                        const gitFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(folder.uri, '.git');
                        const stat = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(gitFolder);
                        if (stat.type === vscode__WEBPACK_IMPORTED_MODULE_0__.FileType.Directory) {
                            repoFolders.push(folder.uri);
                        }
                    }
                    catch (e) {
                        // No .git folder, skip
                    }
                }
                return repoFolders;
            }
        }
        catch (error) {
            console.error('Error getting Git repositories:', error);
        }
        return [];
    }
    /**
     * Get current branch name
     * @param repoUri Repository URI
     * @returns Promise that resolves to the branch name
     */
    async getCurrentBranch(repoUri) {
        try {
            // Try to get git extension
            const gitExtension = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('vscode.git')?.exports;
            if (gitExtension) {
                const api = gitExtension.getAPI(1);
                if (api) {
                    const repo = api.repositories.find((r) => r.rootUri.toString() === repoUri.toString());
                    if (repo) {
                        return repo.state.HEAD?.name || 'main';
                    }
                }
            }
            // If extension not available, try to read from .git/HEAD
            try {
                const headFile = vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(repoUri, '.git', 'HEAD');
                const headContent = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(headFile);
                const headText = new TextDecoder().decode(headContent);
                const match = /ref: refs\/heads\/(.+)/.exec(headText);
                if (match && match[1]) {
                    return match[1];
                }
            }
            catch (e) {
                // Failed to read HEAD file
            }
        }
        catch (error) {
            console.error('Error getting current branch:', error);
        }
        return 'main'; // Default fallback
    }
    /**
     * Get repository status
     * @param repoUri Repository URI
     * @returns Promise that resolves to an array of resource states
     */
    async getStatus(repoUri) {
        try {
            // Try to get git extension
            const gitExtension = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('vscode.git')?.exports;
            if (gitExtension) {
                const api = gitExtension.getAPI(1);
                if (api) {
                    const repo = api.repositories.find((r) => r.rootUri.toString() === repoUri.toString());
                    if (repo) {
                        // Combine working tree and index changes
                        return [
                            ...repo.state.workingTreeChanges,
                            ...repo.state.indexChanges
                        ];
                    }
                }
            }
        }
        catch (error) {
            console.error('Error getting repository status:', error);
        }
        return [];
    }
    /**
     * Commit changes
     * @param repoUri Repository URI
     * @param message Commit message
     * @param stagedOnly Whether to commit only staged changes
     * @returns Promise that resolves when the commit is complete
     */
    async commit(repoUri, message, stagedOnly) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.commit', {
                repository: repoUri.toString(),
                message: message,
                stagedOnly: stagedOnly || false
            });
        }
        catch (error) {
            console.error('Error committing changes:', error);
            // Fallback to default git command if the repository-specific command fails
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.commit', stagedOnly);
        }
    }
    /**
     * Create a new branch
     * @param repoUri Repository URI
     * @param name Branch name
     * @param checkout Whether to checkout the new branch
     * @returns Promise that resolves when the branch is created
     */
    async createBranch(repoUri, name, checkout) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.branch', {
                repository: repoUri.toString(),
                name: name,
                checkout: checkout || false
            });
        }
        catch (error) {
            console.error('Error creating branch:', error);
            // Fallback to default git command if the repository-specific command fails
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.createBranch', name);
        }
    }
    /**
     * Checkout a branch
     * @param repoUri Repository URI
     * @param name Branch name
     * @returns Promise that resolves when the branch is checked out
     */
    async checkoutBranch(repoUri, name) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.checkout', {
                repository: repoUri.toString(),
                name: name
            });
        }
        catch (error) {
            console.error('Error checking out branch:', error);
            // Fallback to default git command if the repository-specific command fails
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.checkout', name);
        }
    }
    /**
     * Pull changes
     * @param repoUri Repository URI
     * @returns Promise that resolves when the pull is complete
     */
    async pull(repoUri) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.pull', {
                repository: repoUri.toString()
            });
        }
        catch (error) {
            console.error('Error pulling changes:', error);
            // Fallback to default git command if the repository-specific command fails
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.pull');
        }
    }
    /**
     * Push changes
     * @param repoUri Repository URI
     * @param forcePush Whether to force push
     * @returns Promise that resolves when the push is complete
     */
    async push(repoUri, forcePush) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.push', {
                repository: repoUri.toString(),
                forcePush: forcePush || false
            });
        }
        catch (error) {
            console.error('Error pushing changes:', error);
            // Fallback to default git command if the repository-specific command fails
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('git.push', forcePush ? '--force' : undefined);
        }
    }
}
/**
 * Implementation of the Workspace API
 */
class WorkspaceAPIImpl {
    /**
     * Get workspace folders
     * @returns Workspace folders or undefined if none
     */
    getWorkspaceFolders() {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders;
    }
    /**
     * Find files matching a glob pattern
     * @param include Include pattern
     * @param exclude Exclude pattern
     * @returns Promise that resolves to an array of matching file URIs
     */
    async findFiles(include, exclude) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.findFiles(include, exclude);
    }
    /**
     * Save all dirty editors
     * @param includeUntitled Whether to include untitled documents
     * @returns Promise that resolves to true if all files were saved
     */
    async saveAll(includeUntitled) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.saveAll(includeUntitled);
    }
    /**
     * Open a text document
     * @param uri Document URI
     * @returns Promise that resolves to the opened document
     */
    async openTextDocument(uri) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument(uri);
    }
    /**
     * Create a file system watcher
     * @param globPattern Glob pattern to watch
     * @param ignoreCreateEvents Whether to ignore create events
     * @param ignoreChangeEvents Whether to ignore change events
     * @param ignoreDeleteEvents Whether to ignore delete events
     * @returns File system watcher
     */
    createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
    }
    /**
     * Register a text document content provider
     * @param scheme URI scheme
     * @param provider Content provider
     * @returns Disposable for unregistering
     */
    registerTextDocumentContentProvider(scheme, provider) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.registerTextDocumentContentProvider(scheme, provider);
    }
}
/**
 * Implementation of the Debug API
 */
class DebugAPIImpl {
    /**
     * Register a debug adapter descriptor factory
     * @param debugType Debug type
     * @param factory Factory implementation
     * @returns Disposable for unregistering
     */
    registerDebugAdapterDescriptorFactory(debugType, factory) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.debug.registerDebugAdapterDescriptorFactory(debugType, factory);
    }
    /**
     * Start debugging
     * @param folder Workspace folder
     * @param nameOrConfig Debug configuration name or configuration object
     * @returns Promise that resolves to true if debugging started
     */
    async startDebugging(folder, nameOrConfig) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.debug.startDebugging(folder, nameOrConfig);
    }
    /**
     * Add breakpoints
     * @param breakpoints Breakpoints to add
     */
    addBreakpoints(breakpoints) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.debug.addBreakpoints(breakpoints);
    }
    /**
     * Remove breakpoints
     * @param breakpoints Breakpoints to remove
     */
    removeBreakpoints(breakpoints) {
        vscode__WEBPACK_IMPORTED_MODULE_0__.debug.removeBreakpoints(breakpoints);
    }
    /**
     * Get current debug session
     * @returns Active debug session or undefined if none
     */
    getActiveDebugSession() {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.debug.activeDebugSession;
    }
}
/**
 * Implementation of the Plugin API
 */
class PluginAPIImpl {
    _llmService;
    _memoryService;
    events;
    vscode = vscode__WEBPACK_IMPORTED_MODULE_0__;
    llm;
    memory;
    ui;
    fs;
    git;
    workspace;
    debug;
    /**
     * Creates a new Plugin API implementation
     * @param _llmService LLM service
     * @param _memoryService Memory service
     * @param _events Event emitter
     */
    constructor(_llmService, _memoryService, events) {
        this._llmService = _llmService;
        this._memoryService = _memoryService;
        this.events = events;
        // Initialize API implementations
        this.llm = new LLMServiceAPIImpl(_llmService);
        this.memory = new MemoryServiceAPIImpl(_memoryService);
        this.ui = new UIServiceAPIImpl();
        this.fs = new FileSystemAPIImpl();
        this.git = new GitServiceAPIImpl();
        this.workspace = new WorkspaceAPIImpl();
        this.debug = new DebugAPIImpl();
    }
    /**
     * Register a command with VSCode
     * @param command Command ID
     * @param callback Command implementation
     * @param thisArg 'this' context for the callback
     * @returns Disposable for unregistering the command
     */
    registerCommand(command, callback, thisArg) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand(command, callback, thisArg);
    }
    /**
     * Execute a command
     * @param command Command ID
     * @param args Command arguments
     * @returns Promise that resolves to the command result
     */
    async executeCommand(command, ...args) {
        return await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand(command, ...args);
    }
    /**
     * Get configuration section
     * @param section Configuration section name
     * @returns Configuration object
     */
    getConfiguration(section) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(section);
    }
}


/***/ }),

/***/ "./src/plugins/core/events.ts":
/*!************************************!*\
  !*** ./src/plugins/core/events.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventEmitterImpl: () => (/* binding */ EventEmitterImpl)
/* harmony export */ });
/**
 * Implementation of EventEmitter interface
 */
class EventEmitterImpl {
    _eventId = 0;
    _handlers = new Map();
    /**
     * Subscribe to events
     * @param filter Optional filter to limit which events are received
     * @param handler Event handler function
     * @returns Disposable for unsubscribing
     */
    on(filter, handler) {
        const handlerId = `handler_${++this._eventId}`;
        this._handlers.set(handlerId, { filter, handler });
        return {
            dispose: () => {
                this._handlers.delete(handlerId);
            }
        };
    }
    /**
     * Subscribe to a single event occurrence
     * @param filter Optional filter to limit which events are received
     * @param handler Event handler function
     * @returns Disposable for unsubscribing
     */
    once(filter, handler) {
        const handlerId = `once_handler_${++this._eventId}`;
        // Create a wrapper handler that self-disposes after one execution
        const onceHandler = (event) => {
            // Call the original handler
            handler(event);
            // Self-dispose after execution
            this._handlers.delete(handlerId);
        };
        this._handlers.set(handlerId, { filter, handler: onceHandler });
        return {
            dispose: () => {
                this._handlers.delete(handlerId);
            }
        };
    }
    /**
     * Emit an event
     * @param type Event type
     * @param payload Event payload
     * @param source Event source (defaults to 'system')
     * @returns The emitted event data
     */
    emit(type, payload, source = 'system') {
        // Create event data
        const event = {
            id: `event_${Date.now()}_${++this._eventId}`,
            source,
            type,
            timestamp: new Date(),
            payload
        };
        // Call all handlers that match the filter
        for (const { filter, handler } of this._handlers.values()) {
            if (this._matchesFilter(event, filter)) {
                try {
                    handler(event);
                }
                catch (error) {
                    console.error(`Error in event handler for ${event.type}:`, error);
                }
            }
        }
        return event;
    }
    /**
     * Check if an event matches a filter
     * @param event Event to check
     * @param filter Filter to apply (or null for all events)
     * @returns Whether the event matches the filter
     */
    _matchesFilter(event, filter) {
        // If no filter, match all events
        if (!filter) {
            return true;
        }
        // Check source filter
        if (filter.source !== undefined) {
            if (typeof filter.source === 'string') {
                if (event.source !== filter.source) {
                    return false;
                }
            }
            else if (filter.source instanceof RegExp) {
                if (!filter.source.test(event.source)) {
                    return false;
                }
            }
        }
        // Check type filter
        if (filter.type !== undefined) {
            if (typeof filter.type === 'string') {
                if (event.type !== filter.type) {
                    return false;
                }
            }
            else if (filter.type instanceof RegExp) {
                if (!filter.type.test(event.type)) {
                    return false;
                }
            }
        }
        // Passed all filters
        return true;
    }
}


/***/ }),

/***/ "./src/plugins/core/index.ts":
/*!***********************************!*\
  !*** ./src/plugins/core/index.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EventEmitterImpl: () => (/* reexport safe */ _events__WEBPACK_IMPORTED_MODULE_1__.EventEmitterImpl),
/* harmony export */   PluginAPIImpl: () => (/* reexport safe */ _api__WEBPACK_IMPORTED_MODULE_0__.PluginAPIImpl),
/* harmony export */   PluginLoader: () => (/* reexport safe */ _loader__WEBPACK_IMPORTED_MODULE_2__.PluginLoader),
/* harmony export */   PluginRegistryImpl: () => (/* reexport safe */ _registry__WEBPACK_IMPORTED_MODULE_3__.PluginRegistryImpl),
/* harmony export */   PluginSettingsManagerImpl: () => (/* reexport safe */ _settings__WEBPACK_IMPORTED_MODULE_4__.PluginSettingsManagerImpl)
/* harmony export */ });
/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ "./src/plugins/core/api.ts");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ "./src/plugins/core/events.ts");
/* harmony import */ var _loader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./loader */ "./src/plugins/core/loader.ts");
/* harmony import */ var _registry__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./registry */ "./src/plugins/core/registry.ts");
/* harmony import */ var _settings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./settings */ "./src/plugins/core/settings.ts");
// Export plugin core components







/***/ }),

/***/ "./src/plugins/core/loader.ts":
/*!************************************!*\
  !*** ./src/plugins/core/loader.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PluginLoader: () => (/* binding */ PluginLoader)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs/promises */ "fs/promises");
/* harmony import */ var fs_promises__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs_promises__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _types_plugin__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../types/plugin */ "./src/plugins/types/plugin.ts");





/**
 * Manages loading and unloading of plugins
 */
class PluginLoader {
    _extensionContext;
    _registry;
    _pluginAPI;
    _internalPluginPath;
    _externalPluginPath = null;
    /**
     * Creates a new plugin loader
     * @param _extensionContext Extension context
     * @param _registry Plugin registry
     * @param _pluginAPI Plugin API
     */
    constructor(_extensionContext, _registry, _pluginAPI) {
        this._extensionContext = _extensionContext;
        this._registry = _registry;
        this._pluginAPI = _pluginAPI;
        // Set up plugin paths
        this._internalPluginPath = path__WEBPACK_IMPORTED_MODULE_1__.join(_extensionContext.extensionPath, 'out', 'plugins', 'internal');
        // Load external plugin path from configuration
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.plugins');
        const configuredPath = config.get('path', '');
        if (configuredPath) {
            this._externalPluginPath = configuredPath;
        }
        else {
            // Use default path in global storage
            this._externalPluginPath = path__WEBPACK_IMPORTED_MODULE_1__.join(_extensionContext.globalStoragePath, 'plugins');
            // Create directory if it doesn't exist
            if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(this._externalPluginPath)) {
                (0,fs__WEBPACK_IMPORTED_MODULE_3__.mkdirSync)(this._externalPluginPath, { recursive: true });
            }
        }
        // Listen for configuration changes
        vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration('ape.plugins.path')) {
                this._updateExternalPluginPath();
            }
        });
    }
    /**
     * Update external plugin path when configuration changes
     */
    _updateExternalPluginPath() {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.plugins');
        const configuredPath = config.get('path', '');
        if (configuredPath) {
            this._externalPluginPath = configuredPath;
        }
        else {
            this._externalPluginPath = path__WEBPACK_IMPORTED_MODULE_1__.join(this._extensionContext.globalStoragePath, 'plugins');
        }
    }
    /**
     * Discover and load all internal plugins
     * @returns Promise that resolves to the number of plugins loaded
     */
    async loadInternalPlugins() {
        console.log('Loading internal plugins from:', this._internalPluginPath);
        try {
            const pluginDirs = await this._getDirectories(this._internalPluginPath);
            let loadedCount = 0;
            for (const dir of pluginDirs) {
                try {
                    const loaded = await this._loadPluginFromDirectory(path__WEBPACK_IMPORTED_MODULE_1__.join(this._internalPluginPath, dir), true);
                    if (loaded) {
                        loadedCount++;
                    }
                }
                catch (error) {
                    console.error(`Error loading internal plugin from ${dir}:`, error);
                }
            }
            return loadedCount;
        }
        catch (error) {
            console.error('Error loading internal plugins:', error);
            return 0;
        }
    }
    /**
     * Discover and load all external plugins
     * @returns Promise that resolves to the number of plugins loaded
     */
    async loadExternalPlugins() {
        if (!this._externalPluginPath) {
            return 0;
        }
        console.log('Loading external plugins from:', this._externalPluginPath);
        try {
            const pluginDirs = await this._getDirectories(this._externalPluginPath);
            let loadedCount = 0;
            for (const dir of pluginDirs) {
                try {
                    const loaded = await this._loadPluginFromDirectory(path__WEBPACK_IMPORTED_MODULE_1__.join(this._externalPluginPath, dir), false);
                    if (loaded) {
                        loadedCount++;
                    }
                }
                catch (error) {
                    console.error(`Error loading external plugin from ${dir}:`, error);
                }
            }
            return loadedCount;
        }
        catch (error) {
            console.error('Error loading external plugins:', error);
            return 0;
        }
    }
    /**
     * Load a plugin from a specific directory
     * @param pluginDir Plugin directory path
     * @param isInternal Whether this is an internal plugin
     * @returns Promise that resolves to true if the plugin was loaded
     */
    async _loadPluginFromDirectory(pluginDir, isInternal) {
        // Check for package.json
        const packageJsonPath = path__WEBPACK_IMPORTED_MODULE_1__.join(pluginDir, 'package.json');
        if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(packageJsonPath)) {
            console.log(`No package.json found in ${pluginDir}, skipping`);
            return false;
        }
        try {
            // Load package.json
            const packageJson = JSON.parse(await fs_promises__WEBPACK_IMPORTED_MODULE_2__.readFile(packageJsonPath, 'utf-8'));
            // Skip if this is not an APE plugin
            if (packageJson.apePlugin !== true) {
                console.log(`Directory ${pluginDir} is not an APE plugin, skipping`);
                return false;
            }
            // Extract metadata
            const metadata = {
                id: packageJson.name,
                name: packageJson.displayName || packageJson.name,
                version: packageJson.version || '0.0.1',
                description: packageJson.description,
                author: packageJson.author,
                dependencies: packageJson.apeDependencies || [],
                activationEvents: packageJson.activationEvents || [],
                features: packageJson.apeFeatures || [],
                configuration: packageJson.apeConfiguration,
                category: packageJson.category,
                isBuiltIn: isInternal,
                enabledByDefault: packageJson.enabledByDefault !== false
            };
            // Load the plugin implementation
            const mainModulePath = path__WEBPACK_IMPORTED_MODULE_1__.join(pluginDir, packageJson.main || 'index.js');
            if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(mainModulePath)) {
                throw new Error(`Plugin main module not found: ${mainModulePath}`);
            }
            // Use require() for webpack compatibility instead of dynamic import
            // This is still dynamic but uses CommonJS which webpack can handle better
            // eslint-disable-next-line @typescript-eslint/no-require-imports
            const pluginModule = __webpack_require__("./src/plugins/core sync recursive")(mainModulePath);
            const pluginImpl = pluginModule.default || pluginModule;
            // Check if plugin implements required interface
            if (!pluginImpl || typeof pluginImpl.activate !== 'function') {
                throw new Error(`Plugin does not implement the required interface`);
            }
            // Register the plugin
            const pluginId = await this._registry.registerPlugin(pluginImpl, metadata);
            // Create storage path for the plugin
            const pluginStoragePath = path__WEBPACK_IMPORTED_MODULE_1__.join(this._extensionContext.globalStoragePath, 'plugin-storage', pluginId);
            // Ensure storage directory exists
            if (!(0,fs__WEBPACK_IMPORTED_MODULE_3__.existsSync)(pluginStoragePath)) {
                (0,fs__WEBPACK_IMPORTED_MODULE_3__.mkdirSync)(pluginStoragePath, { recursive: true });
            }
            // Create plugin context
            const plugin = this._registry.getPlugin(pluginId);
            if (plugin) {
                const subscriptions = [];
                const context = {
                    extensionContext: this._extensionContext,
                    api: this._pluginAPI,
                    metadata,
                    storagePath: pluginStoragePath,
                    subscriptions,
                    log: (message, severity = 'info') => {
                        switch (severity) {
                            case 'info':
                                console.log(`[Plugin: ${pluginId}] ${message}`);
                                break;
                            case 'warn':
                                console.warn(`[Plugin: ${pluginId}] ${message}`);
                                break;
                            case 'error':
                                console.error(`[Plugin: ${pluginId}] ${message}`);
                                break;
                        }
                    },
                    getConfig: (key) => {
                        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(`ape.plugins.${pluginId}`);
                        return config.get(key);
                    },
                    updateConfig: (key, value) => {
                        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(`ape.plugins.${pluginId}`);
                        return Promise.resolve(config.update(key, value, vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global));
                    }
                };
                // Set the context on the plugin instance
                plugin.context = context;
                // Auto-activate if configured
                const autoActivate = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape.plugins')
                    .get('autoActivate', true);
                if (autoActivate && metadata.enabledByDefault !== false) {
                    // Queue activation to avoid blocking the loading process
                    setImmediate(() => {
                        this._registry.activatePlugin(pluginId).catch(error => {
                            console.error(`Error auto-activating plugin ${pluginId}:`, error);
                        });
                    });
                }
                return true;
            }
            return false;
        }
        catch (error) {
            console.error(`Error loading plugin from ${pluginDir}:`, error);
            return false;
        }
    }
    /**
     * Activate all plugins that match a specific activation event
     * @param activationEvent Activation event to match
     * @returns Promise that resolves to the number of plugins activated
     */
    async activatePluginsByEvent(activationEvent) {
        const plugins = this._registry.getAllPlugins().filter(plugin => plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_4__.PluginState.Registered &&
            plugin.metadata.activationEvents?.some(event => {
                // Exact match
                if (event === activationEvent) {
                    return true;
                }
                // Wildcard match
                if (event.endsWith('*')) {
                    const prefix = event.slice(0, -1);
                    return activationEvent.startsWith(prefix);
                }
                return false;
            }));
        let activatedCount = 0;
        for (const plugin of plugins) {
            try {
                const success = await this._registry.activatePlugin(plugin.id);
                if (success) {
                    activatedCount++;
                }
            }
            catch (error) {
                console.error(`Error activating plugin ${plugin.id} for event ${activationEvent}:`, error);
            }
        }
        return activatedCount;
    }
    /**
     * Activate all registered plugins
     * @returns Promise that resolves to the number of plugins activated
     */
    async activateAllPlugins() {
        const plugins = this._registry.getAllPlugins().filter(plugin => plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_4__.PluginState.Registered);
        let activatedCount = 0;
        for (const plugin of plugins) {
            try {
                const success = await this._registry.activatePlugin(plugin.id);
                if (success) {
                    activatedCount++;
                }
            }
            catch (error) {
                console.error(`Error activating plugin ${plugin.id}:`, error);
            }
        }
        return activatedCount;
    }
    /**
     * Deactivate all active plugins
     * @returns Promise that resolves to the number of plugins deactivated
     */
    async deactivateAllPlugins() {
        const activePlugins = this._registry.getActivePlugins();
        let deactivatedCount = 0;
        for (const plugin of activePlugins) {
            try {
                const success = await this._registry.deactivatePlugin(plugin.id);
                if (success) {
                    deactivatedCount++;
                }
            }
            catch (error) {
                console.error(`Error deactivating plugin ${plugin.id}:`, error);
            }
        }
        return deactivatedCount;
    }
    /**
     * Helper function to get directories in a path
     * @param dirPath Directory path to scan
     * @returns Promise that resolves to an array of directory names
     */
    async _getDirectories(dirPath) {
        try {
            const entries = await fs_promises__WEBPACK_IMPORTED_MODULE_2__.readdir(dirPath, { withFileTypes: true });
            return entries
                .filter(entry => entry.isDirectory())
                .map(entry => entry.name);
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                // Directory doesn't exist, return empty array
                return [];
            }
            throw error;
        }
    }
}


/***/ }),

/***/ "./src/plugins/core/registry.ts":
/*!**************************************!*\
  !*** ./src/plugins/core/registry.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PluginRegistryImpl: () => (/* binding */ PluginRegistryImpl)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types_plugin__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/plugin */ "./src/plugins/types/plugin.ts");


/**
 * Implementation of the Plugin Registry
 */
class PluginRegistryImpl {
    _eventEmitter;
    /** Maps plugin IDs to plugin instances */
    _plugins = new Map();
    /** Event emitters for plugin state changes */
    _stateChangeEmitter = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    /** Observable for plugin state changes */
    onDidChangePluginState = (listener) => {
        return this._stateChangeEmitter.event(e => listener(e.pluginId, e.oldState, e.newState));
    };
    /**
     * Creates a new plugin registry
     * @param _eventEmitter Event emitter for plugin events
     */
    constructor(_eventEmitter) {
        this._eventEmitter = _eventEmitter;
    }
    /**
     * Register a plugin with the registry
     * @param plugin Plugin implementation
     * @param metadata Plugin metadata
     * @returns Promise that resolves to the plugin ID
     */
    async registerPlugin(plugin, metadata) {
        // Check for duplicate plugin ID
        if (this._plugins.has(metadata.id)) {
            throw new Error(`Plugin with ID ${metadata.id} is already registered`);
        }
        // Create plugin instance
        const instance = {
            id: metadata.id,
            metadata,
            implementation: plugin,
            state: _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Registered
        };
        // Add to registry
        this._plugins.set(metadata.id, instance);
        // Emit event
        this._eventEmitter.emit('plugin:registered', {
            pluginId: metadata.id,
            metadata
        });
        return metadata.id;
    }
    /**
     * Unregister a plugin from the registry
     * @param pluginId Plugin ID to unregister
     * @returns Promise that resolves to true if successful
     */
    async unregisterPlugin(pluginId) {
        const plugin = this._plugins.get(pluginId);
        if (!plugin) {
            return false;
        }
        // Deactivate plugin if it's active
        if (plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active) {
            await this.deactivatePlugin(pluginId);
        }
        // Remove from registry
        this._plugins.delete(pluginId);
        // Emit event
        this._eventEmitter.emit('plugin:unregistered', {
            pluginId
        });
        return true;
    }
    /**
     * Activate a plugin
     * @param pluginId Plugin ID to activate
     * @returns Promise that resolves to true if successful
     */
    async activatePlugin(pluginId) {
        const plugin = this._plugins.get(pluginId);
        if (!plugin) {
            return false;
        }
        // Check if already active or activating
        if (plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active) {
            return true;
        }
        if (plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Activating) {
            return false; // Already activating
        }
        // Update state to activating
        this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Activating);
        try {
            // Check and activate dependencies if needed
            if (plugin.metadata.dependencies?.length) {
                for (const depId of plugin.metadata.dependencies) {
                    const dependency = this._plugins.get(depId);
                    if (!dependency) {
                        throw new _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginActivationError(pluginId, `Missing dependency: ${depId}`);
                    }
                    if (dependency.state !== _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active) {
                        const success = await this.activatePlugin(depId);
                        if (!success) {
                            throw new _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginActivationError(pluginId, `Failed to activate dependency: ${depId}`);
                        }
                    }
                }
            }
            // Context will be provided by PluginLoader
            if (!plugin.context) {
                throw new _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginActivationError(pluginId, 'Plugin context not set. This is likely an internal error.');
            }
            // Activate the plugin
            await plugin.implementation.activate(plugin.context);
            // Update state to active
            this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active);
            // Emit event
            this._eventEmitter.emit('plugin:activated', {
                pluginId,
                metadata: plugin.metadata
            });
            return true;
        }
        catch (error) {
            // Update state to activation failed
            plugin.error = error instanceof Error ? error : new Error(String(error));
            this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.ActivationFailed);
            // Emit failure event
            this._eventEmitter.emit('plugin:activation:failed', {
                pluginId,
                error: plugin.error
            });
            return false;
        }
    }
    /**
     * Deactivate a plugin
     * @param pluginId Plugin ID to deactivate
     * @returns Promise that resolves to true if successful
     */
    async deactivatePlugin(pluginId) {
        const plugin = this._plugins.get(pluginId);
        if (!plugin) {
            return false;
        }
        // Check if already inactive or deactivating
        if (plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Inactive ||
            plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Registered ||
            plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Discovered) {
            return true;
        }
        if (plugin.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Deactivating) {
            return false; // Already deactivating
        }
        // Check if this plugin is a dependency of any active plugins
        const activePlugins = this.getPluginsByState(_types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active);
        const dependents = activePlugins.filter(p => p.metadata.dependencies?.includes(pluginId));
        // Deactivate dependents first
        for (const dependent of dependents) {
            await this.deactivatePlugin(dependent.id);
        }
        // Update state to deactivating
        this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Deactivating);
        try {
            // Call deactivate if implemented
            if (plugin.implementation.deactivate) {
                await plugin.implementation.deactivate();
            }
            // Dispose context subscriptions
            if (plugin.context) {
                for (const subscription of plugin.context.subscriptions) {
                    try {
                        subscription.dispose();
                    }
                    catch (error) {
                        console.error(`Error disposing subscription for plugin ${pluginId}:`, error);
                    }
                }
            }
            // Update state to inactive
            this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Inactive);
            // Clear error if previously failed
            delete plugin.error;
            // Emit event
            this._eventEmitter.emit('plugin:deactivated', {
                pluginId,
                metadata: plugin.metadata
            });
            return true;
        }
        catch (error) {
            // Still mark as inactive, but keep error
            plugin.error = error instanceof Error ? error : new Error(String(error));
            this._changePluginState(plugin, _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Inactive);
            // Emit warning event
            this._eventEmitter.emit('plugin:deactivation:warning', {
                pluginId,
                error: plugin.error
            });
            // Still return true because the plugin is now inactive
            return true;
        }
    }
    /**
     * Check if a plugin is active
     * @param pluginId Plugin ID to check
     * @returns Whether the plugin is active
     */
    isPluginActive(pluginId) {
        const plugin = this._plugins.get(pluginId);
        return plugin?.state === _types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active;
    }
    /**
     * Get a plugin instance by ID
     * @param pluginId Plugin ID to get
     * @returns Plugin instance or undefined if not found
     */
    getPlugin(pluginId) {
        return this._plugins.get(pluginId);
    }
    /**
     * Get all registered plugins
     * @returns Array of all plugin instances
     */
    getAllPlugins() {
        return Array.from(this._plugins.values());
    }
    /**
     * Get plugins by state
     * @param state State to filter by
     * @returns Array of matching plugin instances
     */
    getPluginsByState(state) {
        return Array.from(this._plugins.values()).filter(p => p.state === state);
    }
    /**
     * Get active plugins only
     * @returns Array of active plugin instances
     */
    getActivePlugins() {
        return this.getPluginsByState(_types_plugin__WEBPACK_IMPORTED_MODULE_1__.PluginState.Active);
    }
    /**
     * Update a plugin's state and emit change event
     * @param plugin Plugin instance to update
     * @param newState New state to set
     */
    _changePluginState(plugin, newState) {
        const oldState = plugin.state;
        plugin.state = newState;
        // Emit event for state change
        this._stateChangeEmitter.fire({
            pluginId: plugin.id,
            oldState,
            newState
        });
    }
}


/***/ }),

/***/ "./src/plugins/core/settings.ts":
/*!**************************************!*\
  !*** ./src/plugins/core/settings.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PluginSettingsManagerImpl: () => (/* binding */ PluginSettingsManagerImpl)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

/**
 * Implementation of PluginSettingsManager
 */
class PluginSettingsManagerImpl {
    _extensionContext;
    // Map of registered schemas by plugin ID
    _schemas = new Map();
    // Map of configuration change listeners
    _listeners = new Map();
    /**
     * Creates a new PluginSettingsManager
     * @param _extensionContext Extension context
     */
    constructor(_extensionContext) {
        this._extensionContext = _extensionContext;
        // Listen for configuration changes
        vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(this._handleConfigChange, this);
    }
    /**
     * Register configuration schema for a plugin
     * @param pluginId Plugin ID
     * @param schema Settings schema
     */
    registerSettings(pluginId, schema) {
        this._schemas.set(pluginId, schema);
        // TODO: Register settings with VSCode dynamically
        // This is normally done via package.json, but for dynamically loaded plugins
        // we might need a different approach
    }
    /**
     * Get configuration for a plugin
     * @param pluginId Plugin ID
     * @returns Configuration object
     */
    getConfiguration(pluginId) {
        return vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration(`ape.plugins.${pluginId}`);
    }
    /**
     * Get a specific setting value
     * @param pluginId Plugin ID
     * @param key Setting key
     * @param defaultValue Default value if setting is not found
     * @returns Setting value or default value
     */
    get(pluginId, key, defaultValue) {
        const config = this.getConfiguration(pluginId);
        return config.get(key, defaultValue);
    }
    /**
     * Update a specific setting value
     * @param pluginId Plugin ID
     * @param key Setting key
     * @param value New value
     * @param configurationTarget Where to update the setting
     * @returns Promise that resolves when the update is complete
     */
    async update(pluginId, key, value, configurationTarget = vscode__WEBPACK_IMPORTED_MODULE_0__.ConfigurationTarget.Global) {
        const config = this.getConfiguration(pluginId);
        await config.update(key, value, configurationTarget);
    }
    /**
     * Listen for setting changes
     * @param pluginId Plugin ID
     * @param key Setting key
     * @param callback Callback function invoked when the setting changes
     * @returns Disposable for unsubscribing
     */
    onDidChangeConfiguration(pluginId, key, callback) {
        // Get current value as baseline
        const initialValue = this.get(pluginId, key);
        // Create a disposable to manage this listener
        const disposable = {
            dispose: () => {
                // Remove this listener from our records
                const listeners = this._listeners.get(pluginId) || [];
                const index = listeners.findIndex(l => l === disposable);
                if (index !== -1) {
                    listeners.splice(index, 1);
                }
                this._listeners.set(pluginId, listeners);
            }
        };
        // Add to our listeners
        const listeners = this._listeners.get(pluginId) || [];
        listeners.push(disposable);
        this._listeners.set(pluginId, listeners);
        // Store state for this listener
        disposable._lastValue = initialValue;
        disposable._pluginId = pluginId;
        disposable._key = key;
        disposable._callback = callback;
        return disposable;
    }
    /**
     * Handle configuration changes
     * @param event Configuration change event
     */
    _handleConfigChange(event) {
        // Check each plugin and its listeners
        for (const [pluginId, listeners] of this._listeners.entries()) {
            const configSection = `ape.plugins.${pluginId}`;
            if (event.affectsConfiguration(configSection)) {
                // Configuration for this plugin has changed
                for (const listener of listeners) {
                    // Get stored properties
                    const key = listener._key;
                    const lastValue = listener._lastValue;
                    const callback = listener._callback;
                    // Check if this specific key was affected
                    if (event.affectsConfiguration(`${configSection}.${key}`)) {
                        // Get the new value
                        const newValue = this.get(pluginId, key);
                        // Only notify if value actually changed
                        if (JSON.stringify(newValue) !== JSON.stringify(lastValue)) {
                            // Update stored last value
                            listener._lastValue = newValue;
                            // Call the callback with the new value
                            try {
                                callback(newValue);
                            }
                            catch (error) {
                                console.error(`Error in settings change listener for ${pluginId}.${key}:`, error);
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * Dispose of all listeners
     */
    dispose() {
        // Clear all listeners
        this._listeners.clear();
        this._schemas.clear();
    }
}


/***/ }),

/***/ "./src/plugins/types/plugin.ts":
/*!*************************************!*\
  !*** ./src/plugins/types/plugin.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PluginActivationError: () => (/* binding */ PluginActivationError),
/* harmony export */   PluginFeatureType: () => (/* binding */ PluginFeatureType),
/* harmony export */   PluginState: () => (/* binding */ PluginState)
/* harmony export */ });
/**
 * Possible states for a plugin
 */
var PluginState;
(function (PluginState) {
    /** Plugin has been discovered but not registered yet */
    PluginState["Discovered"] = "discovered";
    /** Plugin is registered but not activated */
    PluginState["Registered"] = "registered";
    /** Plugin is currently being activated */
    PluginState["Activating"] = "activating";
    /** Plugin is active */
    PluginState["Active"] = "active";
    /** Plugin is currently being deactivated */
    PluginState["Deactivating"] = "deactivating";
    /** Plugin has been activated and is now deactivated */
    PluginState["Inactive"] = "inactive";
    /** Plugin activation failed */
    PluginState["ActivationFailed"] = "activation_failed";
    /** Plugin is disabled */
    PluginState["Disabled"] = "disabled";
})(PluginState || (PluginState = {}));
/**
 * Error thrown when plugin activation fails
 */
class PluginActivationError extends Error {
    pluginId;
    cause;
    constructor(pluginId, message, cause) {
        super(`Failed to activate plugin ${pluginId}: ${message}${cause ? ` (${cause.message})` : ''}`);
        this.pluginId = pluginId;
        this.cause = cause;
        this.name = 'PluginActivationError';
    }
}
/**
 * Supported plugin feature types
 */
var PluginFeatureType;
(function (PluginFeatureType) {
    // UI components
    PluginFeatureType["WebviewPanel"] = "webview_panel";
    PluginFeatureType["StatusBarItem"] = "status_bar_item";
    PluginFeatureType["TreeView"] = "tree_view";
    // Commands and actions
    PluginFeatureType["Command"] = "command";
    PluginFeatureType["ContextMenu"] = "context_menu";
    PluginFeatureType["KeyBinding"] = "key_binding";
    // Language features
    PluginFeatureType["CodeLens"] = "code_lens";
    PluginFeatureType["CompletionProvider"] = "completion_provider";
    PluginFeatureType["DiagnosticProvider"] = "diagnostic_provider";
    PluginFeatureType["FormattingProvider"] = "formatting_provider";
    // Other
    PluginFeatureType["Watcher"] = "watcher";
    PluginFeatureType["Task"] = "task";
    PluginFeatureType["Custom"] = "custom";
})(PluginFeatureType || (PluginFeatureType = {}));


/***/ }),

/***/ "./src/types/chat.ts":
/*!***************************!*\
  !*** ./src/types/chat.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LLMModel: () => (/* reexport safe */ _models__WEBPACK_IMPORTED_MODULE_0__.ModelId),
/* harmony export */   MessageRole: () => (/* binding */ MessageRole)
/* harmony export */ });
/* harmony import */ var _models__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models */ "./src/types/models.ts");
/**
 * Message roles representing different participants in a conversation
 */
var MessageRole;
(function (MessageRole) {
    MessageRole["User"] = "user";
    MessageRole["Assistant"] = "assistant";
    MessageRole["System"] = "system"; // System messages (e.g., errors, notifications)
})(MessageRole || (MessageRole = {}));
/**
 * @deprecated Use ModelId from 'types/models.ts' instead.
 * This type is kept for backward compatibility.
 */



/***/ }),

/***/ "./src/types/models.ts":
/*!*****************************!*\
  !*** ./src/types/models.ts ***!
  \*****************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ModelDescriptions: () => (/* binding */ ModelDescriptions),
/* harmony export */   ModelDisplayNames: () => (/* binding */ ModelDisplayNames),
/* harmony export */   ModelId: () => (/* binding */ ModelId),
/* harmony export */   getModelInfo: () => (/* binding */ getModelInfo),
/* harmony export */   parseModelId: () => (/* binding */ parseModelId)
/* harmony export */ });
/**
 *      
 */
/**
 *    - LLM API   
 *  API     
 */
var ModelId;
(function (ModelId) {
    // OpenAI models ( )
    ModelId["GPT_4_1_MINI"] = "openai/gpt-4.1-mini";
    ModelId["GPT_4_1_PREVIEW"] = "openai/gpt-4.1-preview";
    ModelId["GPT_4O"] = "openai/gpt-4o";
    ModelId["GPT_3_5_TURBO"] = "openai/gpt-3.5-turbo";
    // Anthropic models (Claude )
    ModelId["CLAUDE_3_OPUS"] = "anthropic/claude-3-opus-20240229";
    ModelId["CLAUDE_3_SONNET"] = "anthropic/claude-3-sonnet-20240229";
    ModelId["CLAUDE_3_HAIKU"] = "anthropic/claude-3-haiku-20240307";
    //  
    ModelId["GEMINI_PRO"] = "google/gemini-pro";
    ModelId["GEMMA_7B"] = "google/gemma-7b-it";
    ModelId["QWEN_72B"] = "qwen/qwen-72b-chat";
    ModelId["DEEPSEEK"] = "deepseek/deepseek-coder";
    //  
    ModelId["MISTRAL_7B"] = "mistralai/mistral-7b-instruct";
    ModelId["LLAMA3_8B"] = "meta-llama/llama-3-8b-instruct"; //   
})(ModelId || (ModelId = {}));
/**
 *    - UI    
 */
const ModelDisplayNames = {
    // OpenAI 
    [ModelId.GPT_4_1_MINI]: 'GPT-4.1 Mini',
    [ModelId.GPT_4_1_PREVIEW]: 'GPT-4.1 Preview',
    [ModelId.GPT_4O]: 'GPT-4o',
    [ModelId.GPT_3_5_TURBO]: 'GPT-3.5 Turbo',
    // Anthropic 
    [ModelId.CLAUDE_3_OPUS]: 'Claude 3 Opus',
    [ModelId.CLAUDE_3_SONNET]: 'Claude 3 Sonnet',
    [ModelId.CLAUDE_3_HAIKU]: 'Claude 3 Haiku',
    //  
    [ModelId.GEMINI_PRO]: 'Gemini Pro',
    [ModelId.GEMMA_7B]: 'Gemma 7B',
    [ModelId.QWEN_72B]: 'Qwen 72B',
    [ModelId.DEEPSEEK]: 'DeepSeek Coder',
    //  
    [ModelId.MISTRAL_7B]: 'Mistral 7B',
    [ModelId.LLAMA3_8B]: 'Llama 3 8B'
};
/**
 *   -    
 */
const ModelDescriptions = {
    // OpenAI 
    [ModelId.GPT_4_1_MINI]: '    ( )',
    [ModelId.GPT_4_1_PREVIEW]: '  ',
    [ModelId.GPT_4O]: '   ',
    [ModelId.GPT_3_5_TURBO]: '   ',
    // Anthropic 
    [ModelId.CLAUDE_3_OPUS]: '      ',
    [ModelId.CLAUDE_3_SONNET]: '    ',
    [ModelId.CLAUDE_3_HAIKU]: '    ',
    //  
    [ModelId.GEMINI_PRO]: 'Google   ',
    [ModelId.GEMMA_7B]: '  ,   ',
    [ModelId.QWEN_72B]: 'Alibaba   ',
    [ModelId.DEEPSEEK]: '   ',
    //  
    [ModelId.MISTRAL_7B]: '  ,  ',
    [ModelId.LLAMA3_8B]: 'Meta   '
};
/**
 * ModelId ModelInfo  
 * @param modelId  ID
 * @returns ModelInfo 
 */
function getModelInfo(modelId) {
    return {
        id: modelId,
        displayName: ModelDisplayNames[modelId],
        description: ModelDescriptions[modelId]
    };
}
/**
 *   ID ModelId   
 * @param modelIdString  ID 
 * @returns ModelId   (  )
 */
function parseModelId(modelIdString) {
    if (Object.values(ModelId).includes(modelIdString)) {
        return modelIdString;
    }
    //   
    console.warn(`Invalid model ID: ${modelIdString}, using default model`);
    return ModelId.GPT_4_1_MINI;
}


/***/ }),

/***/ "./src/ui/chat/codeService.ts":
/*!************************************!*\
  !*** ./src/ui/chat/codeService.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CodeService: () => (/* binding */ CodeService)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);
/**
 *  
 *
 *   UI    ,     
 */



/**
 *    
 */
class CodeService {
    static codeBlockCounter = 0;
    /**
     *    
     * @param context  
     * @param webview 
     */
    static async registerHandlers(context, webview) {
        console.log('CodeService.registerHandlers called');
        //      (  )
        await this.registerCommands(context);
        //    
        webview.onDidReceiveMessage(async (message) => {
            switch (message.type) {
                case 'copyCode': {
                    await this.handleCopyCode(message.code);
                    break;
                }
                case 'insertCodeToEditor': {
                    await this.handleInsertCode(message);
                    break;
                }
                case 'createFileWithCode': {
                    await this.handleCreateFile(message);
                    break;
                }
                case 'attachFile': {
                    await this.handleAttachFile(webview);
                    break;
                }
            }
        }, undefined, context.subscriptions);
    }
    /**
     *   
     * @param code  
     */
    static async handleCopyCode(code) {
        try {
            await vscode__WEBPACK_IMPORTED_MODULE_0__.env.clipboard.writeText(code);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('  .');
        }
        catch (error) {
            console.error('    :', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    .');
        }
    }
    /**
     *   
     * @param message  
     */
    static async handleInsertCode(message) {
        try {
            const options = {
                code: message.code,
                language: message.language || 'plaintext',
                insertAtCursor: message.insertAtCursor,
                replaceSelection: message.replaceSelection,
                createNewFile: message.createNewFile,
                filename: message.filename
            };
            const result = await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.insertCodeToEditor', options);
            if (!result) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('   .');
            }
        }
        catch (error) {
            console.error('    :', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    .');
        }
    }
    /**
     *    
     * @param message  
     */
    static async handleCreateFile(message) {
        try {
            const options = {
                code: message.code,
                language: message.language || 'plaintext',
                createNewFile: true,
                filename: message.filename
            };
            const result = await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.createNewFileWithCode', options);
            if (!result) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('   .');
            }
        }
        catch (error) {
            console.error('    :', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('    .');
        }
    }
    /**
     *   
     * @param webview 
     */
    static async handleAttachFile(webview) {
        try {
            // VSCode    
            const fileUris = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showOpenDialog({
                canSelectFiles: true,
                canSelectFolders: false,
                canSelectMany: false,
                openLabel: '',
                filters: {
                    'All Files': ['*']
                }
            });
            if (!fileUris || fileUris.length === 0) {
                return; //  
            }
            const fileUri = fileUris[0];
            const fileName = path__WEBPACK_IMPORTED_MODULE_2__.basename(fileUri.fsPath);
            const fileExtension = path__WEBPACK_IMPORTED_MODULE_2__.extname(fileUri.fsPath).toLowerCase();
            let fileContent = '';
            //    (    )
            const stat = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.stat(fileUri);
            const fileSize = stat.size;
            const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
            //     
            if (fileSize <= MAX_FILE_SIZE) {
                try {
                    const buffer = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.readFile(fileUri);
                    fileContent = new TextDecoder().decode(buffer);
                }
                catch (error) {
                    console.log('    :', error);
                    //      
                }
            }
            //   
            let relativePath = fileUri.fsPath;
            if (vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.length) {
                const workspaceFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders[0];
                const workspacePath = workspaceFolder.uri.fsPath;
                if (fileUri.fsPath.startsWith(workspacePath)) {
                    relativePath = fileUri.fsPath.substring(workspacePath.length + 1);
                }
            }
            //    
            webview.postMessage({
                type: 'fileAttached',
                file: {
                    path: fileUri.fsPath,
                    relativePath: relativePath,
                    name: fileName,
                    type: fileExtension,
                    size: fileSize,
                    content: fileContent,
                    hasContent: fileContent.length > 0
                }
            });
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`${fileName}  .`);
        }
        catch (error) {
            console.error('    :', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`    : ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     *   CSS  
     * @param webview 
     * @param context  
     * @returns CSS URI
     */
    static getCodeBlockStyleUri(webview, context) {
        return webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(context.extensionUri, 'media', 'code-block.css'));
    }
    /**
     *    
     * @returns JavaScript 
     */
    static getCodeBlockScript() {
        return `
    //    
    (function() {
      document.addEventListener('click', function(event) {
        const target = event.target;
        
        //    (    )
        const copyButton = target.closest('.code-action-button.copy-button');
        if (copyButton) {
          const codeId = copyButton.getAttribute('data-code-id');
          const codeElement = document.getElementById('code-' + codeId);
          
          if (codeElement) {
            const code = codeElement.textContent;
            
            // VS Code   
            vscode.postMessage({
              type: 'copyCode',
              code: code,
              language: codeElement.className.replace('language-', '')
            });
            
            //    
            const codeBlock = copyButton.closest('.code-block-container');
            codeBlock.classList.add('success-animation');
            setTimeout(() => {
              codeBlock.classList.remove('success-animation');
            }, 1000);
          }
          
          event.preventDefault();
          return;
        }
        
        //    
        const insertButton = target.closest('.code-action-button.insert-code-button');
        if (insertButton) {
          const codeId = insertButton.getAttribute('data-code-id');
          const codeElement = document.getElementById('code-' + codeId);
          
          if (codeElement) {
            const code = codeElement.textContent;
            const language = codeElement.className.replace('language-', '');
            
            // VS Code   
            vscode.postMessage({
              type: 'insertCodeToEditor',
              code: code,
              language: language,
              insertAtCursor: true
            });
          }
          
          event.preventDefault();
          return;
        }
        
        //     
        const newFileButton = target.closest('.code-action-button.new-file-button');
        if (newFileButton) {
          const codeId = newFileButton.getAttribute('data-code-id');
          const codeElement = document.getElementById('code-' + codeId);
          
          if (codeElement) {
            const code = codeElement.textContent;
            const language = codeElement.className.replace('language-', '');
            
            // VS Code     
            vscode.postMessage({
              type: 'createFileWithCode',
              code: code,
              language: language
            });
          }
          
          event.preventDefault();
          return;
        }
      });
      
      //     
      function markStreamingCodeBlock(id, isStreaming) {
        const codeBlock = document.getElementById('code-' + id)?.closest('.code-block-container');
        if (codeBlock) {
          if (isStreaming) {
            codeBlock.classList.add('streaming-code-block');
          } else {
            codeBlock.classList.remove('streaming-code-block');
          }
        }
      }
      
      //  /  
      window.addEventListener('message', (event) => {
        const message = event.data;
        if (message.type === 'streamingCodeStart') {
          markStreamingCodeBlock(message.codeId, true);
        } 
        else if (message.type === 'streamingCodeEnd') {
          markStreamingCodeBlock(message.codeId, false);
        }
      });
    })();
    `;
    }
    /**
     *    
     */
    static async getCodeBlockTemplate() {
        const extensionPath = vscode__WEBPACK_IMPORTED_MODULE_0__.extensions.getExtension('ape.ape-extension')?.extensionPath;
        if (!extensionPath) {
            console.error('     .');
            return this.getDefaultCodeBlockTemplate();
        }
        const templatePath = path__WEBPACK_IMPORTED_MODULE_2__.join(extensionPath, 'src', 'data', 'codeBlockTemplate.html');
        try {
            return await fs__WEBPACK_IMPORTED_MODULE_1__.promises.readFile(templatePath, 'utf-8');
        }
        catch (error) {
            console.error('     :', error);
            return this.getDefaultCodeBlockTemplate();
        }
    }
    /**
     *     
     */
    static getDefaultCodeBlockTemplate() {
        return '<div class="code-block-container code-block-popup">\n' +
            '  <div class="code-block-header">\n' +
            '    <span class="code-block-language language-${language}">${language}</span>\n' +
            '    <div class="code-block-actions">\n' +
            '      <button class="code-action-button copy-button" data-code-id="${codeId}" title="">\n' +
            '        <i class="codicon codicon-copy"></i>\n' +
            '        <span class="tooltip"> </span>\n' +
            '      </button>\n' +
            '      <button class="code-action-button insert-code-button" data-code-id="${codeId}" title=" ">\n' +
            '        <i class="codicon codicon-arrow-small-right"></i>\n' +
            '        <span class="tooltip">  </span>\n' +
            '      </button>\n' +
            '      <button class="code-action-button new-file-button" data-code-id="${codeId}" title="  ">\n' +
            '        <i class="codicon codicon-new-file"></i>\n' +
            '        <span class="tooltip">  </span>\n' +
            '      </button>\n' +
            '    </div>\n' +
            '  </div>\n' +
            '  <div class="code-content ${showLineNumbers ? \'with-line-numbers\' : \'\'}">\n' +
            '    ${showLineNumbers ? \'<div class="line-numbers">${lineNumbers}</div>\' : \'\'}\n' +
            '    <div class="code-area">\n' +
            '      <code class="language-${language}" id="code-${codeId}">${codeContent}</code>\n' +
            '    </div>\n' +
            '  </div>\n' +
            '</div>';
    }
    /**
     *     
     * @param options   
     * @returns  
     */
    static async insertCodeToEditor(options) {
        try {
            const { code, replaceSelection, insertAtCursor, createNewFile, filename } = options;
            //      
            if (createNewFile) {
                return await this.createNewFileWithCode(code, options.language, filename);
            }
            //    
            const editor = vscode__WEBPACK_IMPORTED_MODULE_0__.window.activeTextEditor;
            if (!editor) {
                //    ,    
                const createNewFile = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('  .   ?', '  ', '');
                if (createNewFile === '  ') {
                    return await this.createNewFileWithCode(code, options.language);
                }
                return false;
            }
            //    
            const selection = editor.selection;
            //   
            await editor.edit(editBuilder => {
                if (replaceSelection && !selection.isEmpty) {
                    //   
                    editBuilder.replace(selection, code);
                }
                else if (insertAtCursor) {
                    //   
                    editBuilder.insert(selection.active, code);
                }
                else {
                    //       
                    editBuilder.insert(selection.active, code);
                }
            });
            //    (    )
            try {
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('editor.action.formatDocument');
            }
            catch (error) {
                console.log('    :', error);
                //    (    )
            }
            return true;
        }
        catch (error) {
            console.error('    :', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`    : ${error instanceof Error ? error.message : String(error)}`);
            return false;
        }
    }
    /**
     *    
     * @param code  
     * @param language 
     * @param suggestedFilename  
     * @returns  
     */
    static async createNewFileWithCode(code, language, suggestedFilename) {
        try {
            //   
            const extension = this.getFileExtensionForLanguage(language);
            const filename = suggestedFilename || `new_file${extension}`;
            //   
            const document = await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.openTextDocument({
                language: language,
                content: code
            });
            await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showTextDocument(document);
            //    
            const saveFile = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('  . ?', '', '');
            if (saveFile === '') {
                if (document.isDirty) {
                    const uri = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showSaveDialog({
                        defaultUri: vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.file(filename),
                        filters: {
                            ' ': ['*']
                        }
                    });
                    if (uri) {
                        await vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.fs.writeFile(uri, Buffer.from(code));
                        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(` : ${uri.fsPath}`);
                    }
                }
            }
            return true;
        }
        catch (error) {
            console.error('     :', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`     : ${error instanceof Error ? error.message : String(error)}`);
            return false;
        }
    }
    /**
     *  ID   
     * @param language  ID
     * @returns  
     */
    static getFileExtensionForLanguage(language) {
        const languageToExtension = {
            'typescript': '.ts',
            'javascript': '.js',
            'python': '.py',
            'java': '.java',
            'csharp': '.cs',
            'c': '.c',
            'cpp': '.cpp',
            'go': '.go',
            'rust': '.rs',
            'php': '.php',
            'ruby': '.rb',
            'html': '.html',
            'css': '.css',
            'json': '.json',
            'markdown': '.md',
            'plaintext': '.txt',
            'xml': '.xml',
            'yaml': '.yml',
            'shell': '.sh',
            'bash': '.sh',
            'powershell': '.ps1',
            'sql': '.sql'
        };
        return languageToExtension[language] || '.txt';
    }
    /**
     *       
     * @returns  
     */
    static async promptForInsertionMode() {
        const options = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick([
            {
                label: '$(cursor)   ',
                description: '    .',
                detail: '   .',
                value: 'insert'
            },
            {
                label: '$(edit)   ',
                description: '    .',
                detail: '     .',
                value: 'replace'
            },
            {
                label: '$(new-file)   ',
                description: '   .',
                detail: '     .',
                value: 'new'
            }
        ], {
            placeHolder: '   ',
            matchOnDescription: true,
            matchOnDetail: true
        });
        if (!options) {
            return undefined; //  
        }
        switch (options.value) {
            case 'insert': {
                return { insertAtCursor: true };
            }
            case 'replace': {
                return { replaceSelection: true };
            }
            case 'new': {
                return { createNewFile: true };
            }
        }
        return undefined;
    }
    /**
     *    
     * @param context  
     */
    static async registerCommands(context) {
        //       
        const existingCommands = await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.getCommands();
        //     ( )
        if (!existingCommands.includes('ape.insertCodeToEditor')) {
            context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.insertCodeToEditor', async (options) => {
                const insertionOptions = await this.promptForInsertionMode();
                if (!insertionOptions) {
                    return false;
                }
                return await this.insertCodeToEditor({
                    ...options,
                    ...insertionOptions
                });
            }));
        }
        //    (  )
        if (!existingCommands.includes('ape.insertCodeAtCursor')) {
            context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.insertCodeAtCursor', async (options) => {
                return await this.insertCodeToEditor({
                    ...options,
                    insertAtCursor: true
                });
            }));
        }
        //    
        if (!existingCommands.includes('ape.replaceSelectionWithCode')) {
            context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.replaceSelectionWithCode', async (options) => {
                return await this.insertCodeToEditor({
                    ...options,
                    replaceSelection: true
                });
            }));
        }
        //    
        if (!existingCommands.includes('ape.createNewFileWithCode')) {
            context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.createNewFileWithCode', async (options) => {
                return await this.insertCodeToEditor({
                    ...options,
                    createNewFile: true
                });
            }));
        }
        //   
        if (!existingCommands.includes('ape.attachFile')) {
            context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.attachFile', async () => {
                try {
                    //   
                    const activeViewColumn = vscode__WEBPACK_IMPORTED_MODULE_0__.window.activeTextEditor?.viewColumn || vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.One;
                    const panel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.visibleTextEditors
                        .find(editor => editor.viewColumn === activeViewColumn);
                    if (panel) {
                        //    
                        const fileUris = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showOpenDialog({
                            canSelectFiles: true,
                            canSelectFolders: false,
                            canSelectMany: false,
                            openLabel: '',
                            filters: {
                                'All Files': ['*']
                            }
                        });
                        if (fileUris && fileUris.length > 0) {
                            return fileUris[0].fsPath;
                        }
                    }
                    return null;
                }
                catch (error) {
                    console.error('   :', error);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`    : ${error instanceof Error ? error.message : String(error)}`);
                    return null;
                }
            }));
        }
    }
    /**
     *   UI 
     * @param codeContent  
     * @param language 
     * @param showLineNumbers    
     * @returns  HTML
     */
    static formatCodeBlock(codeContent, language = 'plaintext', showLineNumbers = true) {
        const codeId = `code_${++this.codeBlockCounter}`;
        const escapedCode = this.escapeHtml(codeContent);
        //   
        const lineNumbers = showLineNumbers ?
            codeContent.split('\n').map((_, i) => `${i + 1}`).join('\n') : '';
        //    
        const template = `<div class="code-block-container code-block-popup">
  <div class="code-block-header">
    <span class="code-block-language language-${language}">${language}</span>
    <div class="code-block-actions">
      <button class="code-action-button copy-button" data-code-id="${codeId}" title="">
        <i class="codicon codicon-copy"></i>
        <span class="tooltip"> </span>
      </button>
      <button class="code-action-button insert-code-button" data-code-id="${codeId}" title=" ">
        <i class="codicon codicon-arrow-small-right"></i>
        <span class="tooltip">  </span>
      </button>
      <button class="code-action-button new-file-button" data-code-id="${codeId}" title="  ">
        <i class="codicon codicon-new-file"></i>
        <span class="tooltip">  </span>
      </button>
    </div>
  </div>
  <div class="code-content ${showLineNumbers ? 'with-line-numbers' : ''}">
    ${showLineNumbers ? `<div class="line-numbers">${lineNumbers}</div>` : ''}
    <div class="code-area">
      <code class="language-${language}" id="code-${codeId}">${escapedCode}</code>
    </div>
  </div>
</div>`;
        return template;
    }
    /**
     * HTML  
     * @param unsafe  
     * @returns  
     */
    static escapeHtml(unsafe) {
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }
}


/***/ }),

/***/ "./src/ui/mainChatViewProvider.ts":
/*!****************************************!*\
  !*** ./src/ui/mainChatViewProvider.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   MainChatViewProvider: () => (/* binding */ MainChatViewProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _types_chat__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../types/chat */ "./src/types/chat.ts");
/* harmony import */ var _chat_codeService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chat/codeService */ "./src/ui/chat/codeService.ts");
/* harmony import */ var _welcomeView__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./welcomeView */ "./src/ui/welcomeView.ts");




/**
 * MainChatViewProvider manages the primary chat interface WebView
 * with a clean, modern, and user-friendly design
 */
class MainChatViewProvider {
    _context;
    _llmService;
    _memoryService;
    _commandManager;
    _modelManager;
    static viewType = 'apeChat';
    _view;
    _messages = [];
    _isStreaming = false;
    _currentStreamMessageId = null;
    _streamUpdateTimeout = null;
    _modelChangeListener;
    // Command suggestion event
    _onDidSuggestCommands = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    onDidSuggestCommands = this._onDidSuggestCommands.event;
    constructor(_context, _llmService, _memoryService, _commandManager, _modelManager) {
        this._context = _context;
        this._llmService = _llmService;
        this._memoryService = _memoryService;
        this._commandManager = _commandManager;
        this._modelManager = _modelManager;
    }
    /**
     * Converts a URI to a webview-compatible URI
     */
    getWebviewResource(uri) {
        if (!this._view) {
            return null;
        }
        return this._view.webview.asWebviewUri(uri);
    }
    /**
     * Called when the view is first created or becomes visible again
     */
    async resolveWebviewView(webviewView, _context, _token) {
        this._view = webviewView;
        // Set options for the webview
        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [
                vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this._context.extensionUri, 'media'),
                vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this._context.extensionUri, 'out'),
                vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this._context.extensionUri, 'src')
            ]
        };
        // Load previous messages from memory service
        await this.loadMessages();
        // Set initial HTML content
        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);
        // Handle messages from the webview
        webviewView.webview.onDidReceiveMessage(this._handleMessage.bind(this));
        // Register code service handlers
        try {
            await _chat_codeService__WEBPACK_IMPORTED_MODULE_2__.CodeService.registerHandlers(this._context, webviewView.webview);
        }
        catch (error) {
            console.log('Code service handlers may already be registered:', error);
        }
        // Listen for model changes if ModelManager is available
        if (this._modelManager) {
            // Dispose any existing listener
            if (this._modelChangeListener) {
                this._modelChangeListener.dispose();
            }
            // Register new listener
            this._modelChangeListener = this._modelManager.onDidChangeModel(() => {
                // Update the UI when model changes
                this.updateModelIndicator();
            });
            // Add listener to context for disposal
            this._context.subscriptions.push(this._modelChangeListener);
        }
    }
    /**
     * Updates the model indicator UI with the current model
     */
    updateModelIndicator() {
        if (!this._view) {
            console.log('Model indicator update failed: no webview');
            return;
        }
        try {
            // Use ModelManager if available, otherwise fall back to LLMService
            let currentModel, displayName;
            if (this._modelManager) {
                currentModel = this._modelManager.getActiveModel();
                displayName = this._modelManager.getModelDisplayName(currentModel);
                console.log('Using ModelManager to get current model info:', currentModel);
            }
            else {
                currentModel = this._llmService.getActiveModel();
                displayName = this.getModelDisplayName(currentModel);
                console.log('Using LLMService to get current model info:', currentModel);
            }
            // Send message to webview to update model name display
            this._view.webview.postMessage({
                type: 'updateModelIndicator',
                modelName: displayName
            });
            console.log('Model indicator update message sent to webview');
        }
        catch (error) {
            console.error('Error updating model indicator:', error);
        }
    }
    /**
     * Converts model ID to a user-friendly display name
     * @deprecated Use the ModelManager.getModelDisplayName method instead
     */
    getModelDisplayName(modelId) {
        return this._llmService.getModelDisplayName(modelId);
    }
    /**
     * Sends a user message to the LLM and processes the response
     */
    async sendMessage(content) {
        if (!this._view) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('APE Chat view is not available');
            return;
        }
        if (this._isStreaming) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('Please wait for the current response to complete');
            return;
        }
        // Handle slash commands
        if (content.trim().startsWith('/')) {
            // Execute slash command directly via commandManager
            await this._commandManager.slashCommandManager.executeCommand(content);
            return;
        }
        // Create and add user message
        const userMessage = {
            id: `msg_${Date.now()}`,
            role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.User,
            content,
            timestamp: new Date()
        };
        this._messages.push(userMessage);
        this.updateChatView();
        try {
            // Create assistant message placeholder for streaming
            const assistantMessageId = `msg_${Date.now() + 1}`;
            const assistantMessage = {
                id: assistantMessageId,
                role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.Assistant,
                content: '',
                timestamp: new Date()
            };
            this._messages.push(assistantMessage);
            this._currentStreamMessageId = assistantMessageId;
            this._isStreaming = true;
            this.updateChatView();
            // Filter messages before sending to LLM
            const filteredMessages = this._messages.filter(message => {
                // Remove UI-only messages by checking metadata flag
                if (message.metadata?.uiOnly === true) {
                    console.log(`Filtering out UI-only message: ${message.id}`);
                    return false;
                }
                // As a fallback, also filter by content for older message formats
                if (message.role === _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System) {
                    const content = message.content || '';
                    if (content.includes('<div class="welcome-container"') ||
                        (content.trim().startsWith('<') && content.includes('</div>'))) {
                        console.log(`Filtering out HTML system message: ${message.id}`);
                        return false;
                    }
                }
                // Keep all other messages
                return true;
            });
            console.log(`Filtered out ${this._messages.length - filteredMessages.length} UI-only messages before LLM request`);
            // Start streaming response from LLM with filtered messages
            await this._llmService.streamResponse(filteredMessages, (chunk, done) => {
                // Update the assistant message with the new chunk only if it has content
                const assistantMessage = this._messages.find(m => m.id === this._currentStreamMessageId);
                if (assistantMessage) {
                    // Only append non-empty chunks
                    if (chunk && chunk.trim()) {
                        assistantMessage.content += chunk;
                        // Debounce updates for efficiency
                        if (!this._streamUpdateTimeout) {
                            this._streamUpdateTimeout = setTimeout(() => {
                                this.updateChatView();
                                this._streamUpdateTimeout = null;
                            }, 30); // 30ms debouncing
                        }
                    }
                    if (done) {
                        // Stream completed
                        this._isStreaming = false;
                        this._currentStreamMessageId = null;
                        // Cancel any pending timeout
                        if (this._streamUpdateTimeout) {
                            clearTimeout(this._streamUpdateTimeout);
                            this._streamUpdateTimeout = null;
                        }
                        // Save messages to memory
                        this.saveMessages();
                        this.updateChatView();
                    }
                }
            });
        }
        catch (error) {
            this._isStreaming = false;
            this._currentStreamMessageId = null;
            // Cancel any pending timeout
            if (this._streamUpdateTimeout) {
                clearTimeout(this._streamUpdateTimeout);
                this._streamUpdateTimeout = null;
            }
            // Add error message
            const errorMessage = {
                id: `msg_error_${Date.now()}`,
                role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System,
                content: `Error: ${error instanceof Error ? error.message : String(error)}`,
                timestamp: new Date()
            };
            this._messages.push(errorMessage);
            this.updateChatView();
        }
    }
    /**
     * Clears all messages from the chat and shows welcome screen
     */
    clearChat() {
        console.log('Clearing chat - creating new welcome message');
        // Clear messages from memory service
        this._memoryService.clearMessages();
        try {
            // Get HTML content for welcome message
            const welcomeHTML = _welcomeView__WEBPACK_IMPORTED_MODULE_3__.WelcomeViewProvider.getWelcomeMessageHTML();
            console.log('WelcomeViewProvider used - welcome HTML generated, length:', welcomeHTML.length);
            // Create welcome messages
            const welcomeId = `welcome_${Date.now()}`;
            const assistantId = `assistant_welcome_${Date.now()}`;
            this._messages = [
                {
                    id: welcomeId,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System,
                    content: welcomeHTML,
                    timestamp: new Date()
                },
                {
                    id: assistantId,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.Assistant,
                    content: '!  ?',
                    timestamp: new Date()
                }
            ];
            console.log('Welcome messages added - IDs:', welcomeId, assistantId);
            // Update UI immediately
            this.updateChatView();
        }
        catch (error) {
            console.error('Error creating welcome message:', error);
            this._messages = [{
                    id: `error_${Date.now()}`,
                    role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System,
                    content: '     .',
                    timestamp: new Date()
                }];
            // Update UI with error message
            this.updateChatView();
        }
    }
    /**
     * Loads messages from memory service
     */
    async loadMessages() {
        console.log('Loading messages - checking for existing messages');
        const result = await this._memoryService.getMessages();
        if (result.success && result.data && result.data.length > 0) {
            console.log(`Loaded ${result.data.length} saved messages`);
            this._messages = result.data;
        }
        else {
            console.log('No saved messages found, adding welcome message');
            try {
                // Get HTML content for welcome message with error handling
                let welcomeHTML = '';
                try {
                    welcomeHTML = _welcomeView__WEBPACK_IMPORTED_MODULE_3__.WelcomeViewProvider.getWelcomeMessageHTML();
                    console.log('WelcomeViewProvider used - welcome HTML generated');
                }
                catch (welcomeError) {
                    console.error('Error getting welcome HTML from provider:', welcomeError);
                    welcomeHTML = '<div class="welcome-container minimal"><h1>Welcome to APE</h1></div>';
                }
                // Create UI-only welcome message and conversation starter
                const welcomeId = `welcome_ui_${Date.now()}`;
                const assistantId = `assistant_welcome_${Date.now()}`;
                // Ensure welcome HTML is not empty
                if (!welcomeHTML || welcomeHTML.trim() === '') {
                    welcomeHTML = '<div class="welcome-container minimal"><h1>Welcome to APE</h1></div>';
                    console.warn('Empty welcome HTML detected, using fallback');
                }
                this._messages = [
                    // UI-only message with metadata flag
                    {
                        id: welcomeId,
                        role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System,
                        content: welcomeHTML,
                        timestamp: new Date(),
                        metadata: {
                            uiOnly: true, // Flag to indicate this shouldn't be sent to LLM
                            type: 'welcome' // Mark this as a welcome message
                        }
                    },
                    // Actual assistant greeting message
                    {
                        id: assistantId,
                        role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.Assistant,
                        content: 'Welcome to APE. How can I assist with your development today?',
                        timestamp: new Date()
                    }
                ];
                console.log('Welcome messages added - IDs:', welcomeId, assistantId);
            }
            catch (error) {
                console.error('Error creating welcome message:', error);
                this._messages = [{
                        id: `error_${Date.now()}`,
                        role: _types_chat__WEBPACK_IMPORTED_MODULE_1__.MessageRole.System,
                        content: '     .',
                        timestamp: new Date()
                    }];
            }
        }
    }
    /**
     * Saves messages to memory service
     */
    async saveMessages() {
        for (const message of this._messages) {
            await this._memoryService.addMessage(message);
        }
    }
    /**
     * Updates the chat view with the current messages
     */
    updateChatView() {
        if (this._view) {
            this._view.webview.postMessage({
                type: 'updateMessages',
                messages: this._messages,
                isStreaming: this._isStreaming
            });
        }
    }
    /**
     * Handles messages sent from the webview
     */
    _handleMessage(message) {
        switch (message.type) {
            case 'sendMessage':
                this.sendMessage(message.content);
                break;
            case 'cancelStream':
                this._llmService.cancelStream();
                this._isStreaming = false;
                this._currentStreamMessageId = null;
                // Cancel any pending timeout
                if (this._streamUpdateTimeout) {
                    clearTimeout(this._streamUpdateTimeout);
                    this._streamUpdateTimeout = null;
                }
                this.updateChatView();
                break;
            case 'clearChat':
                this.clearChat();
                break;
            case 'command':
                // Execute command from help panel
                this.sendMessage(message.command);
                break;
            case 'insertCommand':
                // Insert command text into chat input
                this.insertCommandToChat(message.command);
                break;
            case 'getEditorContent':
                this.getEditorContent().then(content => {
                    if (this._view) {
                        this._view.webview.postMessage({
                            type: 'editorContent',
                            content
                        });
                    }
                });
                break;
            case 'inputChanged':
                // Update command suggestions when input changes
                this.updateCommandSuggestions(message.content);
                break;
            case 'showModelSelector':
                console.log('Model selector request received');
                try {
                    // Call CommandManager's selectModel directly
                    if (this._commandManager) {
                        Promise.resolve(this._commandManager.selectModel()).catch((error) => {
                            console.error('Error executing model selection command:', error);
                            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Unable to execute model selection');
                        });
                    }
                    else {
                        // Fallback: Use VSCode command system
                        Promise.resolve(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.selectModel')).catch((error) => {
                            console.error('Error executing VSCode command:', error);
                            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Unable to execute model selection');
                        });
                    }
                }
                catch (error) {
                    console.error('Unexpected error:', error);
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Unexpected error during model selection');
                }
                break;
            case 'copyCode':
            case 'insertCodeToEditor':
            case 'createFileWithCode':
                // Code block actions handled by CodeService
                break;
        }
    }
    /**
     * Updates command suggestions
     */
    updateCommandSuggestions(input) {
        if (input.startsWith('/')) {
            // Get slash command suggestions
            const suggestions = this._commandManager.slashCommandManager.getCommandSuggestions(input);
            // Send suggestions to webview
            if (this._view) {
                this._view.webview.postMessage({
                    type: 'commandSuggestions',
                    suggestions
                });
            }
            // Fire event for VSCode integration
            this._onDidSuggestCommands.fire(suggestions);
        }
        else if (this._view) {
            // Clear suggestions
            this._view.webview.postMessage({
                type: 'commandSuggestions',
                suggestions: []
            });
        }
    }
    /**
     * Inserts a command into the chat input
     */
    insertCommandToChat(command) {
        if (!this._view) {
            return;
        }
        // Send insert command request to webview
        this._view.webview.postMessage({
            type: 'insertCommandToInput',
            command: command
        });
    }
    /**
     * Inserts text into the chat input from external sources
     */
    handleChatInput(text) {
        if (!this._view) {
            return;
        }
        // Send insert text request to webview
        this._view.webview.postMessage({
            type: 'insertCommandToInput',
            command: text
        });
    }
    /**
     * Adds a direct LLM response to the chat from external sources
     * Used for automated test results or system messages
     */
    async sendLlmResponse(message) {
        if (!this._view) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('APE Chat view is not available');
            return;
        }
        // Create message object
        const newMessage = {
            id: `msg_${Date.now()}`,
            role: message.role,
            content: message.content,
            timestamp: new Date()
        };
        // Add message to list
        this._messages.push(newMessage);
        // Save to memory
        await this._memoryService.addMessage(newMessage);
        // Update UI
        this.updateChatView();
    }
    /**
     * Gets content from the active editor
     */
    async getEditorContent() {
        const editor = vscode__WEBPACK_IMPORTED_MODULE_0__.window.activeTextEditor;
        if (editor) {
            const document = editor.document;
            const selection = editor.selection;
            // Return selected text if there's a selection, otherwise entire document
            if (!selection.isEmpty) {
                return document.getText(selection);
            }
            else {
                return document.getText();
            }
        }
        return null;
    }
    /**
     * Generates the HTML for the main chat interface webview
     */
    _getHtmlForWebview(webview) {
        console.log('Generating main chat interface HTML for webview');
        // Get paths to local resources
        const mainStylesUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this._context.extensionUri, 'media', 'chat-ape.css'));
        console.log('chat-main.css URI:', mainStylesUri.toString());
        const codiconsUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(this._context.extensionUri, 'media', 'codicon', 'codicon.css'));
        console.log('codicon.css URI:', codiconsUri.toString());
        const codeBlockStylesUri = _chat_codeService__WEBPACK_IMPORTED_MODULE_2__.CodeService.getCodeBlockStyleUri(webview, this._context);
        console.log('code-block.css URI:', codeBlockStylesUri.toString());
        const nonce = this._getNonce();
        return `<!DOCTYPE html>
    <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; font-src ${webview.cspSource} data:; img-src ${webview.cspSource} https: data:; script-src 'nonce-${nonce}' 'unsafe-inline';">
      <link href="${mainStylesUri}" rel="stylesheet" onload="console.log('chat-main.css loaded')" onerror="console.error('Failed to load chat-main.css')">
      <link href="${codiconsUri}" rel="stylesheet" onload="console.log('codicon.css loaded')" onerror="console.error('Failed to load codicon.css')">
      <link href="${codeBlockStylesUri}" rel="stylesheet" onload="console.log('code-block.css loaded')" onerror="console.error('Failed to load code-block.css')">
      <title>APE Chat</title>
    </head>
    <body>
      <div id="chat-container">
        <div class="chat-header">
          <div class="chat-title">APE Chat</div>
        </div>
        <div id="chat-messages"></div>
        <div id="chat-input-container">
          <textarea id="chat-input" placeholder=" ..." rows="1"></textarea>
          <div id="input-buttons">
            <button id="clear-button" title=" ">
              <span class="emoji-icon"></span>
            </button>
            <button id="send-button" title=" ">
              <svg class="send-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
            </button>
          </div>
        </div>
        <div id="model-indicator">
          <span id="model-name">LLM Model</span>
          <button id="model-selector" title=" ">
             
          </button>
        </div>
        <div id="command-suggestions"></div>
      </div>
      
      <script nonce="${nonce}">
        // Main script
        (function() {
          // Initial data
          const vscode = acquireVsCodeApi();
          const initialMessages = ${JSON.stringify(this._messages)};
          const isStreaming = ${this._isStreaming};
          let codeBlockCounter = 0;
          
          // Store messages in state
          vscode.setState({ messages: initialMessages });
          
          // Setup message handler
          window.addEventListener('message', event => {
            const message = event.data;
            
            switch (message.type) {
              case 'updateMessages': {
                updateMessages(message.messages, message.isStreaming);
                break;
              }
                
              case 'editorContent': {
                handleEditorContent(message.content);
                break;
              }
                
              case 'commandSuggestions': {
                updateCommandSuggestions(message.suggestions);
                break;
              }
                
              case 'insertCommandToInput': {
                insertCommandFromHelp(message.command);
                break;
              }
                
              case 'updateModelIndicator': {
                // Update model name display
                if (modelIndicator) {
                  modelIndicator.textContent = message.modelName;
                }
                break;
              }
            }
          });
          
          // DOM Elements - initialize as variables first, we'll get them in init()
          let chatMessages;
          let chatInput;
          let sendButton;
          let clearButton;
          let modelIndicator;
          let modelSelector;
          
          // Command suggestions container
          let commandSuggestionsContainer;
          
          // Active suggestion index
          let activeSuggestionIndex = -1;
          let suggestions = [];
          
          // Smart scroll state management
          let isUserScrolled = false;
          let isScrollNearBottom = true;
          const SCROLL_THRESHOLD = 100; // Distance from bottom to consider "near bottom"
        
          // Detect user scroll function
          function detectUserScroll() {
            if (!chatMessages) return;
            
            // Calculate scroll position
            const scrollPosition = chatMessages.scrollTop + chatMessages.clientHeight;
            const scrollThreshold = chatMessages.scrollHeight - SCROLL_THRESHOLD;
            
            // Check if scroll is near bottom
            isScrollNearBottom = scrollPosition >= scrollThreshold;
            
            // Detect user scrolling up
            if (!isScrollNearBottom) {
              isUserScrolled = true;
            }
          }
          
          // Smart scroll function
          function performSmartScroll(forceScroll = false) {
            if (!chatMessages) return;
            
            // Only scroll if user hasn't scrolled up, or a force scroll is needed
            if (forceScroll || !isUserScrolled || isScrollNearBottom) {
              chatMessages.scrollTop = chatMessages.scrollHeight;
              isUserScrolled = false;
            }
          }

          // Helper function to format date for iOS-style timestamp display
          function formatMessageDate(date) {
            if (!date) return '';
            
            // Create a date object
            const messageDate = new Date(date);
            
            // Get current date
            const now = new Date();
            
            // Check if message is from today
            const isToday = messageDate.toDateString() === now.toDateString();
            
            // Format the time (HH:MM)
            const hours = messageDate.getHours().toString().padStart(2, '0');
            const minutes = messageDate.getMinutes().toString().padStart(2, '0');
            const timeStr = \`\${hours}:\${minutes}\`;
            
            // Return appropriate format based on age
            if (isToday) {
              return timeStr;
            } else {
              // For older messages, include date
              const month = messageDate.getMonth() + 1;
              const day = messageDate.getDate();
              return \`\${month} \${day} \${timeStr}\`;
            }
          }
          
          // Get the timestamp group for a message
          function getTimestampGroup(date) {
            if (!date) return 'unknown';
            
            const messageDate = new Date(date);
            return messageDate.toDateString();
          }
          
          // Add timestamp dividers between message groups
          function addTimestampDividers(messages) {
            const result = [];
            let currentGroup = null;
            
            messages.forEach((message, index) => {
              // Determine the timestamp group for this message
              const group = getTimestampGroup(message.timestamp);
              
              // If group changed, add timestamp divider
              if (group !== currentGroup) {
                currentGroup = group;
                
                // Skip adding timestamp for welcome message
                if (index > 0) {
                  const divider = {
                    id: \`timestamp_\${Date.now()}_\${index}\`,
                    type: 'timestamp',
                    content: formatMessageDate(message.timestamp),
                    timestamp: message.timestamp
                  };
                  result.push(divider);
                }
              }
              
              // Add the actual message
              result.push(message);
            });
            
            return result;
          }
          
          // Message DOM ID converter
          function getMessageDomId(messageId) {
            return 'msg-' + messageId.replace(/\\s+/g, '-');
          }
          
          // Update messages in the UI
          function updateMessages(messages, isStreaming) {
            console.log("updateMessages called with", messages.length, "messages, isStreaming:", isStreaming);
            
            // Store in state
            vscode.setState({ messages });
            
            // Check if chatMessages exists
            if (!chatMessages) {
              console.error("Error: chatMessages element not found. Retrying initialization...");
              setTimeout(init, 100);
              return;
            }
            
            // Get current messages in the DOM
            const currentMessageIds = Array.from(chatMessages.children)
              .filter(el => el.classList.contains('message'))
              .map(el => el.getAttribute('data-message-id'))
              .filter(id => id);
            
            // Check scroll position
            detectUserScroll();
            
            // Add timestamp dividers
            const messagesWithTimestamps = addTimestampDividers(messages);
            
            // Get DOM elements that should be in the view
            const shouldContainIds = messagesWithTimestamps.map(m => m.id);

            // Add typing indicator if streaming
            if (isStreaming) {
              if (!document.querySelector('.typing-indicator')) {
                const typingIndicator = document.createElement('div');
                typingIndicator.className = 'typing-indicator';
                typingIndicator.innerHTML = \`
                  <span class="typing-dot"></span>
                  <span class="typing-dot"></span>
                  <span class="typing-dot"></span>
                \`;
                
                // Add after last message
                chatMessages.appendChild(typingIndicator);
              }
            } else {
              // Remove typing indicator if present
              const typingIndicator = document.querySelector('.typing-indicator');
              if (typingIndicator) {
                typingIndicator.remove();
              }
            }
            
            // Remove elements that should no longer be in the view
            Array.from(chatMessages.children).forEach(el => {
              const id = el.getAttribute('data-message-id');
              // Keep timestamp dividers
              if (!id || !shouldContainIds.includes(id)) {
                // Don't remove typing indicator
                if (!el.classList.contains('typing-indicator')) {
                  el.remove();
                }
              }
            });
            
            // Clear existing timestamp dividers (we'll recreate them)
            Array.from(chatMessages.querySelectorAll('.timestamp-divider')).forEach(el => {
              el.remove();
            });
            
            // Create mapping for quick element lookup
            const elementMap = {};
            Array.from(chatMessages.children).forEach(el => {
              const id = el.getAttribute('data-message-id');
              if (id) {
                elementMap[id] = el;
              }
            });
            
            // Process messages and add to DOM
            let previousElement = null;
            messagesWithTimestamps.forEach((item, index) => {
              // Handle timestamp dividers
              if (item.type === 'timestamp') {
                const dividerElement = document.createElement('div');
                dividerElement.className = 'timestamp-divider';
                dividerElement.setAttribute('data-message-id', item.id);
                
                dividerElement.innerHTML = \`
                  <span class="timestamp-text">\${item.content}</span>
                \`;
                
                // Insert divider at correct position
                if (previousElement) {
                  previousElement.after(dividerElement);
                } else {
                  chatMessages.appendChild(dividerElement);
                }
                
                previousElement = dividerElement;
                return;
              }
              
              // Handle regular messages
              const message = item;
              const messageId = message.id;
              let messageElement = elementMap[messageId];
              const isLastMessage = message.id === messages[messages.length - 1].id;
              
              // Create new message element if needed
              if (!messageElement) {
                messageElement = document.createElement('div');
                messageElement.className = 'message ' + message.role;
                messageElement.setAttribute('data-message-id', messageId);
                
                const contentElement = document.createElement('div');
                contentElement.className = 'message-content';
                messageElement.appendChild(contentElement);
                
                // Add read/delivered indicator for user messages
                if (message.role === 'user') {
                  const statusElement = document.createElement('div');
                  statusElement.className = 'message-status';
                  messageElement.appendChild(statusElement);
                }
                
                // Insert at correct position
                if (previousElement) {
                  previousElement.after(messageElement);
                } else {
                  chatMessages.appendChild(messageElement);
                }
              }
              
              // Update content if changed
              const contentElement = messageElement.querySelector('.message-content');
              const formattedContent = formatMessageContent(message.content);
              
              if (contentElement.innerHTML !== formattedContent) {
                contentElement.innerHTML = formattedContent;
              }
              
              previousElement = messageElement;
            });
            
            // Smart scroll (force scroll for new messages or when streaming ends)
            performSmartScroll(messages.length !== currentMessageIds.length || !isStreaming);
            
            // Update UI based on streaming state
            if (isStreaming) {
              sendButton.innerHTML = \`<span class="emoji-icon"></span>\`;
              sendButton.title = ' ';
              chatInput.disabled = true;
            } else {
              sendButton.innerHTML = \`
                <svg class="send-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              \`;
              sendButton.title = ' ';
              chatInput.disabled = false;
            }
          }
          
          // Format message content with code blocks and other formatting
          function formatMessageContent(content) {
            if (!content) return '';
            
            // If content is already HTML, return as is
            const trimmedContent = content.trim();
            if (trimmedContent.startsWith('<') && (
              trimmedContent.includes('</div>') || 
              trimmedContent.includes('</p>') || 
              trimmedContent.includes('</h') || 
              trimmedContent.includes('</span>') ||
              trimmedContent.includes('</ul>') ||
              trimmedContent.includes('</li>') ||
              trimmedContent.includes('</table>') ||
              trimmedContent.match(/<[a-zA-Z0-9_]+[^>]*>/)
            )) {
              return content;
            }
            
            // Format content
            let formatted = content;
            
            // Replace code blocks with modern UI
            formatted = formatted.replace(/\`\`\`(\\w*)\\n([\\s\\S]*?)\\n\`\`\`/g, function(match, language, code) {
              const codeId = 'code_' + (++codeBlockCounter);
              const escapedCode = escapeHtml(code);
              const lang = language || 'plaintext';
              
              // Generate line numbers
              const lines = code.split('\\n');
              const lineNumbers = lines.map((_, i) => (i + 1)).join('\\n');
              const showLineNumbers = lines.length > 1;
              
              // Create code block HTML
              return '<div class="code-block-container code-block-popup">' +
                '<div class="code-block-header">' +
                  '<span class="code-block-language language-' + lang + '">' + lang + '</span>' +
                  '<div class="code-block-actions">' +
                    '<button class="code-action-button copy-button" data-code-id="' + codeId + '" title="">' +
                      '<i class="codicon codicon-copy"></i>' +
                      '<span class="tooltip"> </span>' +
                    '</button>' +
                    '<button class="code-action-button insert-code-button" data-code-id="' + codeId + '" title=" ">' +
                      '<i class="codicon codicon-arrow-small-right"></i>' +
                      '<span class="tooltip">  </span>' +
                    '</button>' +
                    '<button class="code-action-button new-file-button" data-code-id="' + codeId + '" title="  ">' +
                      '<i class="codicon codicon-new-file"></i>' +
                      '<span class="tooltip">  </span>' +
                    '</button>' +
                  '</div>' +
                '</div>' +
                '<div class="code-content ' + (showLineNumbers ? 'with-line-numbers' : '') + '">' +
                  (showLineNumbers ? '<div class="line-numbers">' + lineNumbers + '</div>' : '') +
                  '<div class="code-area">' +
                    '<code class="language-' + lang + '" id="code-' + codeId + '">' + escapedCode + '</code>' +
                  '</div>' +
                '</div>' +
              '</div>';
            });
            
            // Replace inline code
            formatted = formatted.replace(/\`([^\`]+)\`/g, function(match, code) {
              return '<code class="inline-code">' + escapeHtml(code) + '</code>';
            });
            
            // Replace newlines with <br>
            formatted = formatted.replace(/\\n/g, '<br>');
            
            return formatted;
          }
          
          // HTML escape function
          function escapeHtml(unsafe) {
            return unsafe
              .replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&#039;");
          }
          
          // Handle editor content insertion
          function handleEditorContent(content) {
            if (content) {
              chatInput.value += '\`\`\`\\n' + content + '\\n\`\`\`\\n';
              resizeInput();
            }
          }
          
          // Auto-resize input based on content
          function resizeInput() {
            chatInput.style.height = 'auto';
            chatInput.style.height = (chatInput.scrollHeight) + 'px';
          }
          
          // Update command suggestions in popover
          function updateCommandSuggestions(newSuggestions) {
            suggestions = newSuggestions || [];
            activeSuggestionIndex = -1;
            
            // Clear the container
            commandSuggestionsContainer.innerHTML = '';
            
            if (suggestions.length === 0) {
              // Hide the container if no suggestions
              commandSuggestionsContainer.style.display = 'none';
              return;
            }
            
            // Position the suggestions container
            positionCommandSuggestions();
            
            // Show the container
            commandSuggestionsContainer.style.display = 'block';
            
            // Group suggestions by category
            const categorizedSuggestions = {};
            suggestions.forEach(suggestion => {
              // Add category data attribute
              suggestion.categoryAttr = suggestion.category;
              
              if (!categorizedSuggestions[suggestion.category]) {
                categorizedSuggestions[suggestion.category] = [];
              }
              categorizedSuggestions[suggestion.category].push(suggestion);
            });
            
            // Add each category and its suggestions
            Object.keys(categorizedSuggestions).forEach(category => {
              // Create category header
              const categoryHeader = document.createElement('div');
              categoryHeader.className = 'suggestion-category';
              categoryHeader.textContent = getCategoryTitle(category);
              commandSuggestionsContainer.appendChild(categoryHeader);
              
              // Add suggestions for this category
              categorizedSuggestions[category].forEach((suggestion, index) => {
                const suggestionElement = document.createElement('div');
                suggestionElement.className = 'command-suggestion';
                suggestionElement.dataset.category = suggestion.categoryAttr;
                const suggestionIndex = suggestions.findIndex(s => s.label === suggestion.label);
                suggestionElement.dataset.index = String(suggestionIndex);
                
                // Add icon
                const iconElement = document.createElement('span');
                iconElement.className = 'suggestion-icon';
                iconElement.textContent = getSvgIconForCategory(suggestion.category);
                suggestionElement.appendChild(iconElement);
                
                // Add label
                const labelElement = document.createElement('span');
                labelElement.className = 'suggestion-label';
                labelElement.textContent = suggestion.label;
                suggestionElement.appendChild(labelElement);
                
                // Add description
                const descriptionElement = document.createElement('span');
                descriptionElement.className = 'suggestion-description';
                descriptionElement.textContent = suggestion.description;
                suggestionElement.appendChild(descriptionElement);
                
                // Add click handler
                suggestionElement.addEventListener('click', () => {
                  insertSuggestion(suggestion);
                });
                
                // Add mouseover handler
                suggestionElement.addEventListener('mouseover', () => {
                  activeSuggestionIndex = Number(suggestionElement.dataset.index);
                  highlightActiveSuggestion();
                });
                
                commandSuggestionsContainer.appendChild(suggestionElement);
              });
            });
            
            // Scroll to top
            commandSuggestionsContainer.scrollTop = 0;
          }
          
          // Position command suggestions popover
          function positionCommandSuggestions() {
            if (!chatInput || !commandSuggestionsContainer) return;
            
            // Get the input container's position
            const inputContainer = document.getElementById('chat-input-container');
            if (!inputContainer) return;
            
            const inputRect = inputContainer.getBoundingClientRect();
            
            // Set the position relative to the input container
            commandSuggestionsContainer.style.position = 'absolute';
            commandSuggestionsContainer.style.bottom = (inputRect.height + 8) + 'px';
            commandSuggestionsContainer.style.left = '12px';
            commandSuggestionsContainer.style.right = '12px';
            
            // Make sure it's visible
            commandSuggestionsContainer.style.zIndex = '1000';
          }
          
          // Get category title
          function getCategoryTitle(category) {
            switch (category) {
              case 'general': return ' ';
              case 'git': return 'Git  ';
              case 'code': return '  ';
              case 'utility': return ' ';
              case 'advanced': return ' ';
              default: return category;
            }
          }
          
          // Get icon for category
          function getSvgIconForCategory(category) {
            switch (category) {
              case 'general': return '';
              case 'git': return '';
              case 'code': return '';
              case 'utility': return '';
              case 'advanced': return '';
              default: return '';
            }
          }
          
          // Highlight active suggestion
          function highlightActiveSuggestion() {
            // Remove highlight from all suggestions
            document.querySelectorAll('.command-suggestion').forEach(el => {
              el.classList.remove('active');
            });
            
            // Highlight the active suggestion
            if (activeSuggestionIndex >= 0 && activeSuggestionIndex < suggestions.length) {
              const activeElement = document.querySelector(
                '.command-suggestion[data-index="' + activeSuggestionIndex + '"]'
              );
              
              if (activeElement) {
                activeElement.classList.add('active');
                
                // Scroll into view if needed
                const container = commandSuggestionsContainer;
                const elementTop = activeElement.offsetTop;
                const elementBottom = elementTop + activeElement.offsetHeight;
                const containerTop = container.scrollTop;
                const containerBottom = containerTop + container.offsetHeight;
                
                if (elementTop < containerTop) {
                  container.scrollTop = elementTop;
                } else if (elementBottom > containerBottom) {
                  container.scrollTop = elementBottom - container.offsetHeight;
                }
              }
            }
          }
          
          // Insert suggestion into input
          function insertSuggestion(suggestion) {
            if (!suggestion) return;
            
            chatInput.value = suggestion.insertText;
            chatInput.focus();
            
            // Position cursor at the end
            chatInput.selectionStart = chatInput.selectionEnd = chatInput.value.length;
            
            // Resize input
            resizeInput();
            
            // Clear suggestions
            updateCommandSuggestions([]);
            
            // Notify about input change
            notifyInputChanged();
          }
          
          // List of standalone commands (ones that can be auto-executed)
          const standAloneCommands = ['help', 'clear', 'settings', 'model'];
          
          // Check if a command can be executed standalone
          function isStandAloneCommand(commandText) {
            if (!commandText.startsWith('/')) return false;
            
            const commandParts = commandText.substring(1).split(/ +/);
            const baseCommand = commandParts[0];
            
            return standAloneCommands.includes(baseCommand) && commandParts.length === 1;
          }
          
          // Send message function
          function sendMessage() {
            const content = chatInput.value.trim();
            if (content) {
              vscode.postMessage({ type: 'sendMessage', content });
              chatInput.value = '';
              resizeInput();
              
              // Clear suggestions
              updateCommandSuggestions([]);
            }
          }
          
          // Navigate through suggestions
          function navigateSuggestions(direction) {
            if (suggestions.length === 0) return false;
            
            // Set active index to 0 if not set
            if (activeSuggestionIndex === -1) {
              activeSuggestionIndex = 0;
              highlightActiveSuggestion();
              return true;
            }
            
            // Navigate based on direction
            if (direction === 'up') {
              activeSuggestionIndex = activeSuggestionIndex <= 0 ? 
                suggestions.length - 1 : activeSuggestionIndex - 1;
            } else if (direction === 'down') {
              activeSuggestionIndex = activeSuggestionIndex >= suggestions.length - 1 ? 
                0 : activeSuggestionIndex + 1;
            }
            
            highlightActiveSuggestion();
            return true;
          }
          
          // Notify about input change
          function notifyInputChanged() {
            const inputValue = chatInput.value;
            
            vscode.postMessage({ 
              type: 'inputChanged', 
              content: inputValue 
            });
          }
          
          // Insert command from help panel
          function insertCommandFromHelp(command) {
            // Add slash if not present
            if (!command.startsWith('/')) {
              command = '/' + command;
            }
            
            // Set input value
            chatInput.value = command;
            chatInput.focus();
            
            // Position cursor at end
            chatInput.selectionStart = chatInput.selectionEnd = chatInput.value.length;
            
            // Resize input and notify
            resizeInput();
            notifyInputChanged();
          }
          
          // Set up event listeners for code actions
          function setupCodeBlockListeners() {
            chatMessages.addEventListener('click', event => {
              const target = event.target;
              
              // Check for copy button
              if (target.closest('.copy-button')) {
                const button = target.closest('.copy-button');
                const codeId = button.getAttribute('data-code-id');
                const codeElement = document.getElementById('code-' + codeId);
                
                if (codeElement) {
                  vscode.postMessage({ 
                    type: 'copyCode', 
                    code: codeElement.textContent 
                  });
                  
                  // Show copied feedback
                  button.classList.add('copied');
                  setTimeout(() => {
                    button.classList.remove('copied');
                  }, 2000);
                }
              }
              
              // Check for insert code button
              if (target.closest('.insert-code-button')) {
                const button = target.closest('.insert-code-button');
                const codeId = button.getAttribute('data-code-id');
                const codeElement = document.getElementById('code-' + codeId);
                
                if (codeElement) {
                  vscode.postMessage({ 
                    type: 'insertCodeToEditor', 
                    code: codeElement.textContent 
                  });
                }
              }
              
              // Check for new file button
              if (target.closest('.new-file-button')) {
                const button = target.closest('.new-file-button');
                const codeId = button.getAttribute('data-code-id');
                const codeElement = document.getElementById('code-' + codeId);
                const languageElement = button.closest('.code-block-container').querySelector('.code-block-language');
                
                if (codeElement) {
                  const language = languageElement ? 
                    languageElement.textContent.trim() || 'plaintext' : 
                    'plaintext';
                    
                  vscode.postMessage({ 
                    type: 'createFileWithCode', 
                    code: codeElement.textContent,
                    language: language
                  });
                }
              }
            });
          }
          
          // Initialize UI
          function init() {
            console.log("Initializing iOS-style chat UI");
            
            // Get DOM elements
            chatMessages = document.getElementById('chat-messages');
            chatInput = document.getElementById('chat-input');
            sendButton = document.getElementById('send-button');
            clearButton = document.getElementById('clear-button');
            modelIndicator = document.getElementById('model-name');
            modelSelector = document.getElementById('model-selector');
            commandSuggestionsContainer = document.getElementById('command-suggestions');
            
            // Check if elements are found
            if (!chatMessages || !chatInput || !sendButton || !clearButton || !commandSuggestionsContainer) {
              console.error("Critical UI elements missing");
              setTimeout(init, 500);
              return;
            }
            
            console.log("UI elements initialized successfully");
            
            // Set up smart scroll detection
            chatMessages.addEventListener('scroll', detectUserScroll);
            
            // Set up event listeners
            sendButton.addEventListener('click', () => {
              if (chatInput.disabled) {
                vscode.postMessage({ type: 'cancelStream' });
              } else {
                sendMessage();
              }
            });
            
            clearButton.addEventListener('click', () => {
              vscode.postMessage({ type: 'clearChat' });
            });
            
            chatInput.addEventListener('input', () => {
              resizeInput();
              notifyInputChanged();
              
              // Directly check for slash commands here as well
              if (chatInput.value.startsWith('/')) {
                console.log('Slash command detected:', chatInput.value);
              }
            });
            
            chatInput.addEventListener('keydown', (e) => {
              if (suggestions.length > 0) {
                if (e.key === 'ArrowUp') {
                  if (navigateSuggestions('up')) {
                    e.preventDefault();
                    return;
                  }
                } else if (e.key === 'ArrowDown') {
                  if (navigateSuggestions('down')) {
                    e.preventDefault();
                    return;
                  }
                } else if (e.key === 'Enter' && activeSuggestionIndex >= 0) {
                  if (activeSuggestionIndex >= 0 && activeSuggestionIndex < suggestions.length) {
                    const suggestion = suggestions[activeSuggestionIndex];
                    insertSuggestion(suggestion);
                    
                    if (isStandAloneCommand(suggestion.insertText)) {
                      e.preventDefault();
                      sendMessage();
                    }
                    return;
                  }
                } else if (e.key === 'Escape') {
                  updateCommandSuggestions([]);
                  e.preventDefault();
                  return;
                }
              }
              
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
              } else if (e.key === '/' && chatInput.value === '') {
                // Special handling for slash key
                setTimeout(() => {
                  notifyInputChanged();
                  console.log('Slash key pressed on empty input');
                }, 10);
              }
            });
            
            modelSelector.addEventListener('click', () => {
              vscode.postMessage({ type: 'showModelSelector' });
            });
            
            // Set up code block action listeners
            setupCodeBlockListeners();
            
            // Initialize with stored messages
            const state = vscode.getState();
            if (state && state.messages) {
              updateMessages(state.messages, isStreaming);
            } else {
              updateMessages(initialMessages, isStreaming);
            }
            
            // Set initial input height
            resizeInput();
            
            // Set focus to input
            setTimeout(() => {
              if (chatInput) {
                chatInput.focus();
              }
            }, 300);
          }
          
          // Start the app when document is ready
          if (document.readyState === 'complete' || document.readyState === 'interactive') {
            console.log('Document already ready, initializing chat view immediately');
            setTimeout(init, 0);
          } else {
            console.log('Waiting for DOMContentLoaded before initializing chat view');
            document.addEventListener('DOMContentLoaded', () => {
              console.log('DOMContentLoaded fired, initializing chat view');
              init();
            });
          }
        })();
      </script>
    </body>
    </html>`;
    }
    /**
     * Generates a random nonce for CSP
     */
    _getNonce() {
        let text = '';
        const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (let i = 0; i < 32; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    }
    /**
     * Smart Prompting UI update - required for interface compatibility
     * No-op in this implementation as we don't need this feature for the iPhone style
     */
    _updateSmartPromptingUI(enabled) {
        // No-op for this implementation
    }
    /**
     * Open attached file - required for interface compatibility
     * No-op in this implementation as we don't need this feature for the iPhone style
     */
    _openAttachedFile(filePath) {
        return Promise.resolve();
    }
}


/***/ }),

/***/ "./src/ui/tree/apeTreeDataProvider.ts":
/*!********************************************!*\
  !*** ./src/ui/tree/apeTreeDataProvider.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ApeTreeDataProvider: () => (/* binding */ ApeTreeDataProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ "fs");
/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./treeNodeTypes */ "./src/ui/tree/treeNodeTypes.ts");
/* harmony import */ var _core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../core/services/vaultService */ "./src/core/services/vaultService.ts");
/**
 * APE Navigator   
 *
 * VS Code TreeView API  APE     .
 *  , ,     .
 */





/**
 * APE Navigator    
 */
class ApeTreeDataProvider {
    context;
    llmService;
    memoryService;
    todoService;
    vaultService;
    rulesService;
    jiraService;
    //    
    _onDidChangeTreeData = new vscode__WEBPACK_IMPORTED_MODULE_0__.EventEmitter();
    onDidChangeTreeData = this._onDidChangeTreeData.event;
    //  
    treeData = [];
    /**
     * 
     * @param context   
     * @param llmService LLM 
     * @param memoryService  
     */
    constructor(context, llmService, memoryService, todoService, vaultService, rulesService, jiraService) {
        this.context = context;
        this.llmService = llmService;
        this.memoryService = memoryService;
        this.todoService = todoService;
        this.vaultService = vaultService;
        this.rulesService = rulesService;
        this.jiraService = jiraService;
        //   
        this.initializeTreeData();
        //    
        vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape')) {
                this.refresh();
            }
        });
        // VAULT    
        if (this.vaultService) {
            this.vaultService.onDidChangeVault(() => {
                this.refresh();
            });
        }
        // Rules    
        if (this.rulesService) {
            this.rulesService.onDidChangeRules(() => {
                this.refresh();
            });
        }
    }
    /**
     *   
     */
    initializeTreeData() {
        this.treeData = [
            // Git  ( )
            {
                id: 'git-root',
                label: 'Git',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_ROOT,
                iconPath: this.getIconPath('git-version-control', 'git-commit'),
                contextValue: 'gitRoot',
                children: this.getGitItems()
            },
            //   
            {
                id: 'chat-history-root',
                label: ' ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.CHAT_HISTORY_ROOT,
                iconPath: this.getIconPath('chat', 'history'),
                contextValue: 'chatHistoryRoot',
                children: this.getChatHistoryItems()
            },
            //  
            {
                id: 'commands',
                label: '',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND_ROOT,
                iconPath: this.getIconPath('command-line', 'symbol-method'),
                contextValue: 'commandRoot',
                children: this.getCommandItems()
            },
            //  
            {
                id: 'settings',
                label: '',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ROOT,
                iconPath: this.getIconPath('config', 'gear'),
                contextValue: 'settingsRoot',
                children: this.getSettingsItems()
            },
            // Rules 
            {
                id: 'rules-root',
                label: 'Rules',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_ROOT,
                iconPath: this.getIconPath('notebook', 'book'),
                contextValue: 'rulesRoot',
                children: this.getRulesItems()
            },
            // VAULT 
            {
                id: 'vault',
                label: 'VAULT ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_ROOT,
                iconPath: this.getIconPath('brain-ai', 'library'),
                contextValue: 'vaultRoot',
                children: this.getVaultItems()
            },
            //   (Mock)
            {
                id: 'jira',
                label: 'Jira ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ROOT,
                iconPath: this.getIconPath('jira', 'issues'),
                contextValue: 'jiraRoot',
                children: this.getJiraItems()
            },
            //   (Mock)
            {
                id: 'pocket',
                label: 'Pocket ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_ROOT,
                iconPath: this.getIconPath('folder', 'library'),
                contextValue: 'pocketRoot',
                children: this.getPocketItems()
            },
            // SWDP  (Mock)
            {
                id: 'swdp',
                label: 'SWDP',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_ROOT,
                iconPath: this.getIconPath('cicd', 'package'),
                contextValue: 'swdpRoot',
                children: this.getSWDPItems()
            },
            //  
            {
                id: 'plugins',
                label: '',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.PLUGIN_ROOT,
                iconPath: this.getIconPath('plugin', 'extensions'),
                contextValue: 'pluginRoot',
                children: this.getPluginItems()
            }
        ];
    }
    /**
     * Git  
     */
    getGitItems() {
        return [
            {
                id: 'git-commands',
                label: 'Git ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_CATEGORY,
                iconPath: this.getIconPath('git-version-control', 'git-commit'),
                tooltip: 'Git    . ,  ,     .',
                contextValue: 'gitCategory',
                children: [
                    {
                        id: 'git-command-status',
                        label: '/git status',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: 'Git  ',
                        tooltip: ' Git   .  ,  ,    .',
                        iconPath: this.getIconPath('git-version-control', 'git-pull-request'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['status'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-commit',
                        label: '/git commit',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: ' ',
                        tooltip: '  Git .     .',
                        iconPath: this.getIconPath('git-version-control', 'git-commit'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['commit'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-auto',
                        label: '/git auto',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: '  ',
                        tooltip: '    .        .',
                        iconPath: this.getIconPath('config', 'settings-gear'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['auto'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-consolidate',
                        label: '/git consolidate',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: '  ',
                        tooltip: '[APE][Temporary]         .',
                        iconPath: this.getIconPath('github', 'git-merge'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['consolidate'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-pr-list',
                        label: '/git pr-list [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: 'PR  ',
                        tooltip: 'Git  PR(Pull Request)  .',
                        iconPath: this.getIconPath('github', 'git-pull-request'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['pr-list'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-pr-create',
                        label: '/git pr-create [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: ' PR ',
                        tooltip: 'Git   PR(Pull Request) .',
                        iconPath: this.getIconPath('github', 'diff-added'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['pr-create'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-branch-list',
                        label: '/git branch-list [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND,
                        description: '  ',
                        tooltip: 'Git    .',
                        iconPath: this.getIconPath('git-version-control', 'git-branch'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['branch-list'],
                            category: 'git'
                        }
                    }
                ]
            }
        ];
    }
    /**
     *   
     */
    getCommandItems() {
        const categories = [
            {
                id: 'commands-general',
                label: ' ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND_CATEGORY,
                iconPath: this.getIconPath('command-line', 'info'),
                tooltip: '     .',
                contextValue: 'commandCategory',
                children: [
                    {
                        id: 'command-help',
                        label: '/help',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: ' ',
                        tooltip: '      . "/?"  "/"  .',
                        iconPath: this.getIconPath('message', 'question'),
                        contextValue: 'command',
                        metadata: {
                            name: 'help',
                            category: 'general'
                        }
                    },
                    {
                        id: 'command-clear',
                        label: '/clear',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: '  ',
                        tooltip: '    . "/cls"  "/"  .',
                        iconPath: this.getIconPath('chat', 'clear-all'),
                        contextValue: 'command',
                        metadata: {
                            name: 'clear',
                            category: 'general'
                        }
                    },
                    {
                        id: 'command-model',
                        label: '/model',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: 'LLM  ',
                        tooltip: ' LLM   . "/model list"       .',
                        iconPath: this.getIconPath('llm', 'server-process'),
                        contextValue: 'command',
                        metadata: {
                            name: 'model',
                            category: 'general'
                        }
                    }
                ]
            },
            {
                id: 'commands-code',
                label: '   ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND_CATEGORY,
                iconPath: this.getIconPath('coding', 'symbol-class'),
                tooltip: '   VS Code     .',
                contextValue: 'commandCategory',
                children: [
                    {
                        id: 'command-analyze',
                        label: '/analyze',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: ' ',
                        tooltip: '   .  , ,    . "/code"  "/"  .',
                        iconPath: this.getIconPath('code-editor', 'inspect'),
                        contextValue: 'command',
                        metadata: {
                            name: 'analyze',
                            category: 'code'
                        }
                    },
                    {
                        id: 'command-settings',
                        label: '/settings',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: 'APE  ',
                        tooltip: 'VS Code  APE       . "/config"  "/"  .',
                        iconPath: this.getIconPath('config', 'gear'),
                        contextValue: 'command',
                        metadata: {
                            name: 'settings',
                            category: 'utility'
                        }
                    },
                    {
                        id: 'command-open',
                        label: '/open',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND,
                        description: ' ',
                        tooltip: '  VS Code . "/file"  "/"  .',
                        iconPath: this.getIconPath('code-file', 'go-to-file'),
                        contextValue: 'command',
                        metadata: {
                            name: 'open',
                            category: 'utility'
                        }
                    }
                ]
            }
        ];
        return categories;
    }
    /**
     *   
     */
    getSettingsItems() {
        return [
            {
                id: 'settings-llm',
                label: 'LLM ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_CATEGORY,
                iconPath: this.getIconPath('llm', 'server'),
                contextValue: 'settingsCategory',
                children: [
                    {
                        id: 'settings-llm-model',
                        label: ' ',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('ai-neural-network', 'symbol-enum'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.llm.defaultModel') || 'openai/gpt-4.1-mini',
                        metadata: {
                            settingKey: 'ape.llm.defaultModel'
                        }
                    },
                    {
                        id: 'settings-llm-endpoint',
                        label: 'API ',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('api', 'link'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.llm.endpoint') || 'http://localhost:8000/api/chat',
                        metadata: {
                            settingKey: 'ape.llm.endpoint'
                        }
                    }
                ]
            },
            {
                id: 'settings-memory',
                label: ' ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_CATEGORY,
                iconPath: this.getIconPath('database', 'database'),
                contextValue: 'settingsCategory',
                children: [
                    {
                        id: 'settings-memory-duration',
                        label: '  ',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('event', 'history'),
                        contextValue: 'settingsItem',
                        description: `${this.getConfigValue('ape.memory.sessionDuration') || '240'}`,
                        metadata: {
                            settingKey: 'ape.memory.sessionDuration'
                        }
                    },
                    {
                        id: 'settings-memory-messages',
                        label: '  ',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('message', 'symbol-number'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.memory.maxMessages') || '30',
                        metadata: {
                            settingKey: 'ape.memory.maxMessages'
                        }
                    }
                ]
            },
            {
                id: 'settings-ui',
                label: 'UI ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_CATEGORY,
                iconPath: this.getIconPath('code-editor', 'browser'),
                contextValue: 'settingsCategory',
                children: [
                    {
                        id: 'settings-ui-theme',
                        label: 'UI ',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('vscode', 'symbol-color'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.ui.theme') || 'auto',
                        metadata: {
                            settingKey: 'ape.ui.theme'
                        }
                    }
                ]
            }
        ];
    }
    /**
     * VAULT  
     */
    getVaultItems() {
        // VAULT    
        if (!this.vaultService) {
            return [{
                    id: 'vault-not-initialized',
                    label: 'VAULT   ',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_ROOT,
                    iconPath: this.getIconPath('brain-ai', 'error'),
                    contextValue: 'vaultError',
                    description: '  ',
                    tooltip: 'VAULT   .   .'
                }];
        }
        //    
        const contextTypeItems = [];
        //  
        const systemContexts = this.vaultService.getContextsByType(_core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__.VaultContextType.System);
        if (systemContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-system',
                label: ' ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('brain-ai', 'server'),
                contextValue: 'vaultCategory',
                tooltip: '  .',
                children: systemContexts.flatMap(context => this.createContextNode(context))
            });
        }
        //  
        const projectContexts = this.vaultService.getContextsByType(_core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__.VaultContextType.Project);
        if (projectContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-project',
                label: ' ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('coding', 'git-merge'),
                contextValue: 'vaultCategory',
                tooltip: ' .',
                children: projectContexts.flatMap(context => this.createContextNode(context))
            });
        }
        //  
        const personalContexts = this.vaultService.getContextsByType(_core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__.VaultContextType.Personal);
        if (personalContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-personal',
                label: ' ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('message', 'account'),
                contextValue: 'vaultCategory',
                tooltip: '  .',
                children: personalContexts.flatMap(context => this.createContextNode(context))
            });
        }
        //  
        const sharedContexts = this.vaultService.getContextsByType(_core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__.VaultContextType.Shared);
        if (sharedContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-shared',
                label: ' ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('github', 'repo-forked'),
                contextValue: 'vaultCategory',
                tooltip: '   .',
                children: sharedContexts.flatMap(context => this.createContextNode(context))
            });
        }
        //  
        const templateContexts = this.vaultService.getContextsByType(_core_services_vaultService__WEBPACK_IMPORTED_MODULE_4__.VaultContextType.Template);
        if (templateContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-template',
                label: ' ',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('code-file', 'file-code'),
                contextValue: 'vaultCategory',
                tooltip: '   .',
                children: templateContexts.flatMap(context => this.createContextNode(context))
            });
        }
        return contextTypeItems;
    }
    /**
     * VAULT   
     * @param context 
     */
    createContextNode(context) {
        if (!context || !context.items) {
            return [];
        }
        const contextNode = {
            id: `vault-context-${context.id}`,
            label: context.name,
            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_CONTEXT,
            description: `${context.items.length} `,
            tooltip: context.description || context.name,
            iconPath: this.getIconPath('brain-ai', 'library'),
            contextValue: 'vaultContext',
            metadata: {
                contextId: context.id,
                contextType: context.type
            },
            children: context.items.map((item) => this.createItemNode(item, context))
        };
        return [contextNode];
    }
    /**
     * VAULT   
     * @param item 
     * @param context 
     */
    createItemNode(item, context) {
        let iconName = 'file-text';
        let fallbackIcon = 'symbol-string';
        //    
        if (item.tags) {
            if (item.tags.includes('prompt')) {
                iconName = 'brain-ai';
                fallbackIcon = 'symbol-text';
            }
            else if (item.tags.includes('code')) {
                iconName = 'code-file';
                fallbackIcon = 'file-code';
            }
            else if (item.tags.includes('architecture')) {
                iconName = 'orchestration';
                fallbackIcon = 'type-hierarchy';
            }
            else if (item.tags.includes('meeting')) {
                iconName = 'event';
                fallbackIcon = 'group';
            }
            else if (item.tags.includes('documentation')) {
                iconName = 'markdown';
                fallbackIcon = 'markdown';
            }
        }
        //   
        const updatedAtStr = item.updatedAt instanceof Date
            ? item.updatedAt.toLocaleDateString()
            : new Date(item.updatedAt).toLocaleDateString();
        return {
            id: `vault-item-${item.id}`,
            label: item.name,
            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_ITEM,
            description: updatedAtStr,
            tooltip: item.description || item.name,
            iconPath: this.getIconPath(iconName, fallbackIcon),
            contextValue: 'vaultItem',
            metadata: {
                itemId: item.id,
                contextId: context.id,
                content: item.content,
                tags: item.tags
            }
        };
    }
    /**
     *   
     */
    getJiraItems() {
        // Jira   Mock  
        if (!this.jiraService) {
            return [
                {
                    id: 'jira-not-initialized',
                    label: 'Jira   ',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ROOT,
                    iconPath: this.getIconPath('jira', 'error'),
                    contextValue: 'jiraError',
                    description: '  ',
                    tooltip: 'Jira   .   .'
                }
            ];
        }
        try {
            //  Jira     Mock    
            //      Mock  
            /*
            //   
            const configResult = this.jiraService.getConfig();
            if (!configResult.success || !configResult.data || !configResult.data.isConfigured) {
              return [
                {
                  id: 'jira-not-configured',
                  label: 'Jira  ',
                  type: TreeNodeType.JIRA_ROOT,
                  iconPath: this.getIconPath('jira', 'warning'),
                  contextValue: 'jiraNotConfigured',
                  description: '  ',
                  tooltip: 'Jira    .   Jira   .'
                }
              ];
            }
            
            //   
            const projectsResult = await this.jiraService.getProjects();
            if (!projectsResult.success || !projectsResult.data) {
              throw new Error(projectsResult.error?.message || 'Jira    ');
            }
            
            const projects = projectsResult.data;
            
            //    
            return projects.map(project => {
              return {
                id: `jira-project-${project.key}`,
                label: `${project.name} (${project.key})`,
                type: TreeNodeType.JIRA_PROJECT,
                iconPath: this.getIconPath('jira', 'project'),
                contextValue: 'jiraProject',
                description: `${project.issueCount || 0} `,
                tooltip: project.description || project.name,
                children: this.getJiraIssuesForProject(project.key)
              };
            });
            */
            // Mock  ( )
            return [
                {
                    id: 'jira-project-ape',
                    label: 'APE ',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_PROJECT,
                    iconPath: this.getIconPath('jira', 'project'),
                    contextValue: 'jiraProject',
                    description: 'APE-001  10 ',
                    tooltip: 'Agentic Pipeline Engine ',
                    children: [
                        {
                            id: 'jira-issue-ape-001',
                            label: 'APE-001:   ',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-closed'),
                            contextValue: 'jiraIssue',
                            description: '',
                            tooltip: '      ',
                            metadata: {
                                id: 'APE-001',
                                status: 'Done',
                                assignee: '',
                                priority: 'High',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'APE-001']
                                }
                            }
                        },
                        {
                            id: 'jira-issue-ape-002',
                            label: 'APE-002:  UI ',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-open'),
                            contextValue: 'jiraIssue',
                            description: ' ',
                            tooltip: ' UI    ',
                            metadata: {
                                id: 'APE-002',
                                status: 'In Progress',
                                assignee: '',
                                priority: 'Medium',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'APE-002']
                                }
                            }
                        },
                        {
                            id: 'jira-issue-ape-003',
                            label: 'APE-003:  ',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issues'),
                            contextValue: 'jiraIssue',
                            description: ' ',
                            tooltip: '    ',
                            metadata: {
                                id: 'APE-003',
                                status: 'In Progress',
                                assignee: '',
                                priority: 'High',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'APE-003']
                                }
                            }
                        }
                    ]
                },
                {
                    id: 'jira-project-int',
                    label: ' ',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_PROJECT,
                    iconPath: this.getIconPath('jira', 'project'),
                    contextValue: 'jiraProject',
                    description: 'INT-001  5 ',
                    tooltip: '  ',
                    children: [
                        {
                            id: 'jira-issue-int-001',
                            label: 'INT-001: Git ',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-open'),
                            contextValue: 'jiraIssue',
                            description: ' ',
                            tooltip: 'Git       ',
                            metadata: {
                                id: 'INT-001',
                                status: 'In Progress',
                                assignee: '',
                                priority: 'High',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'INT-001']
                                }
                            }
                        },
                        {
                            id: 'jira-issue-int-002',
                            label: 'INT-002: Jira ',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-draft'),
                            contextValue: 'jiraIssue',
                            description: '',
                            tooltip: 'Jira       ',
                            metadata: {
                                id: 'INT-002',
                                status: 'Planned',
                                assignee: '',
                                priority: 'Medium',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'INT-002']
                                }
                            }
                        }
                    ]
                },
                {
                    id: 'jira-commands',
                    label: 'Jira ',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_CATEGORY,
                    iconPath: this.getIconPath('command-line', 'terminal'),
                    contextValue: 'jiraCommands',
                    tooltip: 'Jira  ',
                    children: [
                        {
                            id: 'jira-command-create',
                            label: '/jira create',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'add'),
                            contextValue: 'jiraCommand',
                            description: '  ',
                            tooltip: ' Jira  ',
                            metadata: {
                                name: 'jira',
                                args: ['create'],
                                category: 'utility'
                            }
                        },
                        {
                            id: 'jira-command-search',
                            label: '/jira search',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'search'),
                            contextValue: 'jiraCommand',
                            description: ' ',
                            tooltip: 'Jira  ',
                            metadata: {
                                name: 'jira',
                                args: ['search'],
                                category: 'utility'
                            }
                        },
                        {
                            id: 'jira-command-summary',
                            label: '/jira summary',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'graph'),
                            contextValue: 'jiraCommand',
                            description: ' ',
                            tooltip: 'Jira    ',
                            metadata: {
                                name: 'jira',
                                args: ['summary'],
                                category: 'utility'
                            }
                        },
                        {
                            id: 'jira-command-status',
                            label: '/jira status',
                            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'sync'),
                            contextValue: 'jiraCommand',
                            description: '  ',
                            tooltip: 'Jira   ',
                            metadata: {
                                name: 'jira',
                                args: ['status'],
                                category: 'utility'
                            }
                        }
                    ]
                }
            ];
        }
        catch (error) {
            console.error('Jira   :', error);
            return [{
                    id: 'jira-error',
                    label: 'Jira  ',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.JIRA_ROOT,
                    iconPath: this.getIconPath('jira', 'error'),
                    contextValue: 'jiraError',
                    description: `: ${error instanceof Error ? error.message : String(error)}`,
                    tooltip: ' : ' + (error instanceof Error ? error.message : String(error))
                }];
        }
    }
    /**
     *   Jira  
     * @param projectKey  
     */
    getJiraIssuesForProject(projectKey) {
        if (!this.jiraService) {
            return [];
        }
        try {
            /*
            //   ( )
            const searchCriteria = {
              projectKey: projectKey,
              maxResults: 10
            };
            
            const searchResult = await this.jiraService.searchIssues(searchCriteria);
            if (!searchResult.success || !searchResult.data) {
              throw new Error(searchResult.error?.message || '  ');
            }
            
            const issues = searchResult.data.issues;
            
            return issues.map(issue => {
              let iconName = 'jira';
              let fallbackIcon = 'issues';
              
              //    
              if (issue.status === JiraIssueStatus.Done ||
                  issue.status === JiraIssueStatus.Closed ||
                  issue.status === JiraIssueStatus.Resolved) {
                fallbackIcon = 'issue-closed';
              } else if (issue.status === JiraIssueStatus.InProgress) {
                fallbackIcon = 'issue-open';
              } else {
                fallbackIcon = 'issue-draft';
              }
              
              return {
                id: `jira-issue-${issue.key}`,
                label: `${issue.key}: ${issue.summary}`,
                type: TreeNodeType.JIRA_ISSUE,
                iconPath: this.getIconPath(iconName, fallbackIcon),
                contextValue: 'jiraIssue',
                description: issue.status,
                tooltip: issue.description || issue.summary,
                metadata: {
                  id: issue.key,
                  status: issue.status,
                  assignee: issue.assignee || '',
                  priority: issue.priority || 'Medium',
                  command: {
                    name: 'jira',
                    args: ['show', issue.key]
                  }
                }
              };
            });
            */
            // Mock  (   )
            return [];
        }
        catch (error) {
            console.error(`Jira    (${projectKey}):`, error);
            return [];
        }
    }
    /**
     *    (Mock)
     */
    getPocketItems() {
        return [
            {
                id: 'pocket-category-code',
                label: '  [Mock]',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_CATEGORY,
                iconPath: this.getIconPath('code-file', 'code'),
                contextValue: 'pocketCategory',
                description: '3 ',
                tooltip: '   ',
                children: [
                    {
                        id: 'pocket-item-code-1',
                        label: '   [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_ITEM,
                        iconPath: this.getIconPath('typescript', 'symbol-method'),
                        contextValue: 'pocketItem',
                        description: '2023-05-01 ',
                        tooltip: '     ',
                        metadata: {
                            id: 'code-1',
                            createdAt: '2023-05-01',
                            tags: ['typescript', 'utility']
                        }
                    },
                    {
                        id: 'pocket-item-code-2',
                        label: 'VS Code API  [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_ITEM,
                        iconPath: this.getIconPath('vscode', 'symbol-method'),
                        contextValue: 'pocketItem',
                        description: '2023-05-05 ',
                        tooltip: 'VS Code API   ',
                        metadata: {
                            id: 'code-2',
                            createdAt: '2023-05-05',
                            tags: ['vscode', 'api', 'extension']
                        }
                    }
                ]
            },
            {
                id: 'pocket-category-notes',
                label: '  [Mock]',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_CATEGORY,
                iconPath: this.getIconPath('markdown', 'notebook'),
                contextValue: 'pocketCategory',
                description: '2 ',
                tooltip: '    ',
                children: [
                    {
                        id: 'pocket-item-notes-1',
                        label: '   [Mock]',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.POCKET_ITEM,
                        iconPath: this.getIconPath('markdown', 'file-text'),
                        contextValue: 'pocketItem',
                        description: '2023-04-28 ',
                        tooltip: '    ',
                        metadata: {
                            id: 'notes-1',
                            createdAt: '2023-04-28',
                            tags: ['architecture', 'design', 'memo']
                        }
                    }
                ]
            }
        ];
    }
    /**
     * SWDP   (Mock)
     */
    getSWDPItems() {
        return [
            {
                id: 'swdp-release',
                label: 'Release Build',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_BUILD_TYPE,
                iconPath: this.getIconPath('cicd', 'package'),
                contextValue: 'swdpBuildType',
                tooltip: 'SWDP Release Build ',
                children: [
                    {
                        id: 'swdp-release-info',
                        label: 'BUILD, COVERITY, SAM, ONBOARD TESTE, DOBEE, BLACKDUCK,    .',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_ARTIFACT,
                        iconPath: this.getIconPath('jenkins-ci-cd', 'info'),
                        contextValue: 'swdpArtifact',
                        tooltip: 'SWDP Release Build '
                    }
                ]
            },
            {
                id: 'swdp-layer',
                label: 'Layer Build',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_BUILD_TYPE,
                iconPath: this.getIconPath('orchestration', 'layers'),
                contextValue: 'swdpBuildType',
                tooltip: 'SWDP Layer Build ',
                children: [
                    {
                        id: 'swdp-layer-info',
                        label: 'BUILD, COVERITY, SAM, ONBOARD TESTE, DOBEE, BLACKDUCK,    .',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_ARTIFACT,
                        iconPath: this.getIconPath('jenkins-ci-cd', 'info'),
                        contextValue: 'swdpArtifact',
                        tooltip: 'SWDP Layer Build '
                    }
                ]
            },
            {
                id: 'swdp-local',
                label: 'Local Build',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_BUILD_TYPE,
                iconPath: this.getIconPath('docker', 'desktop-download'),
                contextValue: 'swdpBuildType',
                tooltip: 'SWDP Local Build ',
                children: [
                    {
                        id: 'swdp-local-info',
                        label: 'BUILD, COVERITY, SAM, ONBOARD TESTE, DOBEE, BLACKDUCK,    .',
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SWDP_ARTIFACT,
                        iconPath: this.getIconPath('docker-container', 'info'),
                        contextValue: 'swdpArtifact',
                        tooltip: 'SWDP Local Build '
                    }
                ]
            }
        ];
    }
    /**
     * Rules  
     */
    getRulesItems() {
        // Rules    
        if (!this.rulesService) {
            return [{
                    id: 'rules-not-initialized',
                    label: 'Rules   ',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_ROOT,
                    iconPath: this.getIconPath('notebook', 'error'),
                    contextValue: 'rulesError',
                    description: '  ',
                    tooltip: 'Rules   .   .'
                }];
        }
        try {
            const activeRules = this.rulesService.getActiveRules();
            const inactiveRules = this.rulesService.getAllRules().filter(rule => !activeRules.some(activeRule => activeRule.id === rule.id));
            const ruleItems = [];
            //  Rules 
            if (activeRules.length > 0) {
                ruleItems.push({
                    id: 'rules-active',
                    label: ' Rules',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_ACTIVE,
                    iconPath: this.getIconPath('notebook', 'check'),
                    contextValue: 'rulesActive',
                    tooltip: ' LLM    Rules',
                    description: `${activeRules.length} `,
                    children: activeRules.map(rule => this.createRuleNode(rule, true))
                });
            }
            //  Rules 
            if (inactiveRules.length > 0) {
                ruleItems.push({
                    id: 'rules-inactive',
                    label: ' Rules',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_INACTIVE,
                    iconPath: this.getIconPath('notebook', 'circle-outline'),
                    contextValue: 'rulesInactive',
                    tooltip: '   Rules',
                    description: `${inactiveRules.length} `,
                    children: inactiveRules.map(rule => this.createRuleNode(rule, false))
                });
            }
            // Rules  
            if (ruleItems.length === 0) {
                ruleItems.push({
                    id: 'rules-empty',
                    label: 'Rules ',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_ROOT,
                    iconPath: this.getIconPath('notebook', 'info'),
                    contextValue: 'rulesEmpty',
                    description: ' Rules ',
                    tooltip: '    Rule .'
                });
            }
            return ruleItems;
        }
        catch (error) {
            console.error('Rules   :', error);
            return [{
                    id: 'rules-error',
                    label: 'Rules  ',
                    type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULES_ROOT,
                    iconPath: this.getIconPath('notebook', 'error'),
                    contextValue: 'rulesError',
                    description: `: ${error instanceof Error ? error.message : String(error)}`,
                    tooltip: ' : ' + (error instanceof Error ? error.message : String(error))
                }];
        }
    }
    /**
     * Rule  
     * @param rule Rule 
     * @param isActive  
     */
    createRuleNode(rule, isActive) {
        const iconName = isActive ? 'notebook' : 'notebook';
        const fallbackIcon = isActive ? 'notebook-opened' : 'notebook';
        //   
        const fileName = rule.filePath.split('/').pop();
        return {
            id: `rule-item-${rule.id}`,
            label: rule.name,
            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.RULE_ITEM,
            description: fileName, //    
            tooltip: `${rule.name} (${fileName})\n\n${rule.content.substring(0, 100)}${rule.content.length > 100 ? '...' : ''}`,
            iconPath: this.getIconPath(iconName, fallbackIcon),
            contextValue: isActive ? 'ruleActive' : 'ruleInactive',
            metadata: {
                id: rule.id,
                filePath: rule.filePath,
                isActive: isActive
            }
        };
    }
    /**
     *    
     */
    getChatHistoryItems() {
        try {
            //    
            const workspaceFolder = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                return [this.createChatHistoryErrorNode('    ')];
            }
            //    
            const chatHistoryDir = path__WEBPACK_IMPORTED_MODULE_1__.join(workspaceFolder.uri.fsPath, 'vault', 'chat-history');
            //   
            if (!(0,fs__WEBPACK_IMPORTED_MODULE_2__.existsSync)(chatHistoryDir)) {
                return [this.createChatHistoryInfoNode('   ', '     `/save-chat`  .')];
            }
            //      
            const fs = __webpack_require__(/*! fs */ "fs");
            const metaFiles = fs.readdirSync(chatHistoryDir)
                .filter((name) => name.endsWith('.meta.json'));
            if (metaFiles.length === 0) {
                return [this.createChatHistoryInfoNode('   ', '     `/save-chat`  .')];
            }
            //    
            const chatItems = [];
            //   
            for (const fileName of metaFiles) {
                const filePath = path__WEBPACK_IMPORTED_MODULE_1__.join(chatHistoryDir, fileName);
                const chatId = fileName.replace('.meta.json', '');
                try {
                    //  
                    const metadata = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                    //  
                    const createdDate = new Date(metadata.createdAt);
                    const dateStr = createdDate.toLocaleDateString();
                    const timeStr = createdDate.toLocaleTimeString();
                    //    
                    chatItems.push({
                        id: `chat-history-${chatId}`,
                        label: metadata.title,
                        type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.CHAT_HISTORY_ITEM,
                        description: `${dateStr} ${timeStr}`,
                        tooltip: `${metadata.title} (${dateStr} ${timeStr})\n${metadata.messageCount} `,
                        iconPath: this.getIconPath('chat', 'comment-discussion'),
                        contextValue: 'chatHistoryItem',
                        metadata: {
                            id: chatId,
                            title: metadata.title,
                            createdAt: metadata.createdAt,
                            updatedAt: metadata.updatedAt,
                            messageCount: metadata.messageCount,
                            command: {
                                name: 'show',
                                args: [chatId]
                            }
                        }
                    });
                }
                catch (error) {
                    console.error(`     (${fileName}):`, error);
                }
            }
            //  
            chatItems.sort((a, b) => {
                const dateA = new Date(a.metadata.createdAt);
                const dateB = new Date(b.metadata.createdAt);
                return dateB.getTime() - dateA.getTime();
            });
            return chatItems;
        }
        catch (error) {
            console.error('    :', error);
            return [this.createChatHistoryErrorNode(`: ${error instanceof Error ? error.message : String(error)}`)];
        }
    }
    /**
     *     
     */
    createChatHistoryErrorNode(message) {
        return {
            id: 'chat-history-error',
            label: '   ',
            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.CHAT_HISTORY_ROOT,
            iconPath: this.getIconPath('chat', 'error'),
            contextValue: 'chatHistoryError',
            description: message,
            tooltip: message
        };
    }
    /**
     *     
     */
    createChatHistoryInfoNode(label, tooltip) {
        return {
            id: 'chat-history-info',
            label,
            type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.CHAT_HISTORY_ROOT,
            iconPath: this.getIconPath('chat', 'info'),
            contextValue: 'chatHistoryInfo',
            tooltip
        };
    }
    /**
     *    - Stub 
     */
    getPluginItems() {
        return [
            {
                id: 'plugin-not-implemented',
                label: '   ...',
                type: _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.PLUGIN_ROOT,
                iconPath: this.getIconPath('plugin', 'error'),
                contextValue: 'pluginStub',
                description: '  ',
                tooltip: '    . TASK-W3-001    .'
            }
        ];
    }
    /**
     *   
     */
    getConfigValue(key) {
        const config = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration();
        const value = config.get(key);
        return value !== undefined ? String(value) : '';
    }
    /**
     *   
     * @param iconName  
     * @param fallbackIcon   
     * @returns  
     */
    getIconPath(iconName, fallbackIcon = 'symbol-event') {
        // ThemeIcon 
        return new vscode__WEBPACK_IMPORTED_MODULE_0__.ThemeIcon(fallbackIcon);
    }
    /**
     * TreeView 
     */
    refresh() {
        this.initializeTreeData();
        this._onDidChangeTreeData.fire(undefined);
    }
    /**
     *   
     */
    getTreeItem(element) {
        const treeItem = new vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItem(element.label, element.children && element.children.length > 0
            ? vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.Collapsed
            : vscode__WEBPACK_IMPORTED_MODULE_0__.TreeItemCollapsibleState.None);
        //   
        treeItem.description = element.description || '';
        treeItem.tooltip = element.tooltip || element.description || element.label;
        treeItem.contextValue = element.contextValue || '';
        //  
        if (element.iconPath) {
            treeItem.iconPath = element.iconPath;
        }
        //  
        if (element.type === _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.COMMAND ||
            element.type === _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.GIT_COMMAND) {
            //    
            treeItem.command = {
                command: 'ape.executeCommand',
                title: ' ',
                arguments: [element.metadata]
            };
        }
        else if (element.type === _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.SETTINGS_ITEM) {
            //      
            treeItem.command = {
                command: 'ape.openSettings',
                title: ' ',
                arguments: [element.metadata?.settingKey]
            };
        }
        else if (element.type === _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.VAULT_ITEM) {
            // VAULT     
            treeItem.command = {
                command: 'ape.vaultShowItem',
                title: 'VAULT  ',
                arguments: [element.metadata]
            };
        }
        else if (element.type === _treeNodeTypes__WEBPACK_IMPORTED_MODULE_3__.TreeNodeType.CHAT_HISTORY_ITEM) {
            //       
            treeItem.command = {
                command: 'ape.executeCommand',
                title: '  ',
                arguments: [{
                        name: 'show',
                        args: [element.metadata.id]
                    }]
            };
        }
        return treeItem;
    }
    /**
     *   
     */
    getChildren(element) {
        if (!element) {
            return this.treeData;
        }
        return element.children || [];
    }
    /**
     *   
     */
    getParent() {
        //       
        return null;
    }
}


/***/ }),

/***/ "./src/ui/tree/treeNodeTypes.ts":
/*!**************************************!*\
  !*** ./src/ui/tree/treeNodeTypes.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TreeNodeType: () => (/* binding */ TreeNodeType)
/* harmony export */ });
/**
 *    
 *
 * APE Navigator     .
 */
/**
 *    
 */
var TreeNodeType;
(function (TreeNodeType) {
    //  
    TreeNodeType["CATEGORY"] = "category";
    //   
    TreeNodeType["COMMAND_ROOT"] = "command-root";
    TreeNodeType["COMMAND_CATEGORY"] = "command-category";
    TreeNodeType["COMMAND"] = "command";
    // Git  
    TreeNodeType["GIT_ROOT"] = "git-root";
    TreeNodeType["GIT_CATEGORY"] = "git-category";
    TreeNodeType["GIT_COMMAND"] = "git-command";
    //   
    TreeNodeType["SETTINGS_ROOT"] = "settings-root";
    TreeNodeType["SETTINGS_CATEGORY"] = "settings-category";
    TreeNodeType["SETTINGS_ITEM"] = "settings-item";
    //   
    TreeNodeType["PLUGIN_ROOT"] = "plugin-root";
    TreeNodeType["PLUGIN_ACTIVE"] = "plugin-active";
    TreeNodeType["PLUGIN_INACTIVE"] = "plugin-inactive";
    TreeNodeType["PLUGIN"] = "plugin";
    //   
    TreeNodeType["JIRA_ROOT"] = "jira-root";
    TreeNodeType["JIRA_PROJECT"] = "jira-project";
    TreeNodeType["JIRA_ISSUE"] = "jira-issue";
    TreeNodeType["JIRA_CATEGORY"] = "jira-category";
    TreeNodeType["JIRA_COMMAND"] = "jira-command";
    //   
    TreeNodeType["POCKET_ROOT"] = "pocket-root";
    TreeNodeType["POCKET_CATEGORY"] = "pocket-category";
    TreeNodeType["POCKET_ITEM"] = "pocket-item";
    // SWDP  
    TreeNodeType["SWDP_ROOT"] = "swdp-root";
    TreeNodeType["SWDP_RELEASE"] = "swdp-release";
    TreeNodeType["SWDP_BUILD_TYPE"] = "swdp-build-type";
    TreeNodeType["SWDP_ARTIFACT"] = "swdp-artifact";
    // VAULT  
    TreeNodeType["VAULT_ROOT"] = "vault-root";
    TreeNodeType["VAULT_CATEGORY"] = "vault-category";
    TreeNodeType["VAULT_CONTEXT"] = "vault-context";
    TreeNodeType["VAULT_ITEM"] = "vault-item";
    // Rules  
    TreeNodeType["RULES_ROOT"] = "rules-root";
    TreeNodeType["RULES_ACTIVE"] = "rules-active";
    TreeNodeType["RULES_INACTIVE"] = "rules-inactive";
    TreeNodeType["RULE_ITEM"] = "rule-item";
    //    
    TreeNodeType["CHAT_HISTORY_ROOT"] = "chat-history-root";
    TreeNodeType["CHAT_HISTORY_ITEM"] = "chat-history-item";
})(TreeNodeType || (TreeNodeType = {}));


/***/ }),

/***/ "./src/ui/welcomeView.ts":
/*!*******************************!*\
  !*** ./src/ui/welcomeView.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   WelcomeViewProvider: () => (/* binding */ WelcomeViewProvider)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);

/**
 * WelcomeViewProvider for luxury minimal welcome screen
 * Creates an elegant, clean welcome interface with premium aesthetics
 */
class WelcomeViewProvider {
    /**
     * Generate welcome message HTML with luxury minimal design
     * This is used for the first-run experience and when clearing chat
     */
    static getWelcomeMessageHTML() {
        try {
            console.log('Generating welcome view HTML');
            // Enhanced welcome view HTML with improved UX
            return `
      <div class="welcome-container">
        <div class="welcome-header">
          <div class="welcome-monologue">
            <h1 class="welcome-title">APE</h1>
            <div class="title-separator"></div>
            <p class="welcome-tagline">AGENTIC PIPELINE ENGINE</p>
            <p class="welcome-subtitle">Agentic Vision. Development Illuminated.</p>
          </div>
        </div>

        <div class="welcome-actions">
          <div class="action-group">
            <div class="action-button" onclick="vscode.postMessage({type: 'command', command: 'Hello, how can you help me?'})">
              <div class="action-icon"></div>
              <div class="action-content">
                <div class="action-title">New Conversation</div>
                <div class="action-description">Begin a dialogue with your AI assistant</div>
                <div class="action-commands">
                  <span class="command-tag" onclick="event.stopPropagation(); vscode.postMessage({type: 'insertCommand', command: '/new'});">/new</span>
                  <span class="command-tag" onclick="event.stopPropagation(); vscode.postMessage({type: 'insertCommand', command: '/clear'});">/clear</span>
                </div>
              </div>
            </div>

            <div class="action-button" onclick="vscode.postMessage({type: 'command', command: 'Analyze this code'})">
              <div class="action-icon"></div>
              <div class="action-content">
                <div class="action-title">Code Analysis</div>
                <div class="action-description">Understand and improve your code</div>
                <div class="action-commands">
                  <span class="command-tag" onclick="event.stopPropagation(); vscode.postMessage({type: 'insertCommand', command: '/analyze'});">/analyze</span>
                </div>
              </div>
            </div>
          </div>

          <div class="action-group">
            <div class="action-button" onclick="vscode.postMessage({type: 'command', command: 'Implement a new feature'})">
              <div class="action-icon"></div>
              <div class="action-content">
                <div class="action-title">Development</div>
                <div class="action-description">Implement new features</div>
                <div class="action-commands">
                  <span class="command-tag" onclick="event.stopPropagation(); vscode.postMessage({type: 'insertCommand', command: '/create'});">/create</span>
                </div>
              </div>
            </div>

            <div class="action-button" onclick="vscode.postMessage({type: 'command', command: 'Find code in this project'})">
              <div class="action-icon"></div>
              <div class="action-content">
                <div class="action-title">Code Search</div>
                <div class="action-description">Find code in your project</div>
                <div class="action-commands">
                  <span class="command-tag" onclick="event.stopPropagation(); vscode.postMessage({type: 'insertCommand', command: '/find'});">/find</span>
                </div>
              </div>
            </div>
          </div>
        </div>

        <div class="command-palette">
          <h3>Command Palette</h3>
          <div class="command-categories">
            <button class="category-tab active" data-category="popular">Popular</button>
            <button class="category-tab" data-category="git">Git</button>
            <button class="category-tab" data-category="code">Code</button>
          </div>
          <div class="command-list" id="popular-commands">
            <div class="command-item" onclick="vscode.postMessage({type: 'insertCommand', command: '/help'})">
              <div class="command-name">/help</div>
              <div class="command-desc">Display available commands and usage</div>
            </div>
            <div class="command-item" onclick="vscode.postMessage({type: 'insertCommand', command: '/model'})">
              <div class="command-name">/model</div>
              <div class="command-desc">Change the AI model</div>
            </div>
            <div class="command-item" onclick="vscode.postMessage({type: 'insertCommand', command: '/clear'})">
              <div class="command-name">/clear</div>
              <div class="command-desc">Clear the current conversation</div>
            </div>
          </div>
        </div>

        <div class="welcome-quick-actions">
          <button class="quick-action" onclick="vscode.postMessage({type: 'command', command: '/help'})">Help</button>
          <button class="quick-action" onclick="vscode.postMessage({type: 'command', command: '/model'})">Model</button>
          <button class="quick-action" onclick="vscode.postMessage({type: 'command', command: '/clear'})">Reset</button>
        </div>
      </div>
      `;
        }
        catch (error) {
            console.error('Error generating welcome HTML:', error);
            // Fallback to ultra-minimal welcome content in case of errors
            return `
        <div class="welcome-container minimal">
          <h1>Welcome to APE</h1>
          <p>The Agentic Pipeline Engine for development</p>
          <div class="welcome-quick-actions">
            <button class="quick-action" onclick="vscode.postMessage({type: 'command', command: '/help'})">Help</button>
          </div>
        </div>
      `;
        }
    }
    /**
     * Generate HTML for the welcome webview panel
     * Extracts the HTML generation logic for better maintainability
     */
    static generateHtml(webview, extensionUri) {
        // Get WebView stylesheets
        const styleUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(extensionUri, 'media', 'chat-ape.css'));
        const customStyleUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(extensionUri, 'media', 'welcome-custom.css'));
        // Get icons for the welcome page
        const mascotIconUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(extensionUri, 'media', 'icons', 'mascot.svg'));
        const apeIconUri = webview.asWebviewUri(vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(extensionUri, 'media', 'icons', 'ape.svg'));
        // Generate nonce for script security
        const nonce = getNonce();
        return `<!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; font-src ${webview.cspSource}; img-src ${webview.cspSource} https: data:; script-src 'nonce-${nonce}';">
        <link href="${styleUri}" rel="stylesheet">
        <link href="${customStyleUri}" rel="stylesheet">
        <title>Welcome to APE</title>
        <style>
          body, html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            background-color: var(--ape-welcome-bg);
          }

          .welcome-standalone {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 0;
            width: 100%;
          }

          /*         */
          .welcome-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
          }

          /*         */
          .action-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
          }

          /*     */
          .welcome-title {
            font-size: 6rem;
            font-weight: 700;
            margin: 0;
            letter-spacing: -2px;
            background: linear-gradient(135deg, var(--ape-welcome-accent) 0%, #9f7aea 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
          }

          .title-separator {
            width: 80px;
            height: 4px;
            background-color: var(--ape-welcome-accent);
            margin: 12px 0;
            border-radius: 2px;
          }

          .welcome-tagline {
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 2px;
            color: var(--ape-welcome-accent);
            margin: 0 0 0.5rem 0;
          }

          .welcome-subtitle {
            font-size: 1.2rem;
            opacity: 0.8;
            margin: 0;
            font-weight: 400;
          }

          /*  */
          @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
          }

          @keyframes pulse {
            0% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.03); }
            100% { opacity: 1; transform: scale(1); }
          }

          .welcome-header {
            animation: fadeIn 0.8s ease-out;
          }

          .action-group {
            animation: fadeIn 1s ease-out 0.2s both;
          }

          .command-palette {
            animation: fadeIn 1.2s ease-out 0.4s both;
          }

          .welcome-quick-actions {
            animation: fadeIn 1.3s ease-out 0.6s both;
          }
        </style>
      </head>
      <body>
        <div class="welcome-standalone">
          ${WelcomeViewProvider.getWelcomeMessageHTML()}
        </div>

        <script nonce="${nonce}">
          const vscode = acquireVsCodeApi();

          // Command category tabs
          document.querySelectorAll('.category-tab').forEach(tab => {
            tab.addEventListener('click', () => {
              // Remove active class from all tabs
              document.querySelectorAll('.category-tab').forEach(t => {
                t.classList.remove('active');
              });

              // Add active class to clicked tab
              tab.classList.add('active');

              // Show the selected category
              const category = tab.dataset.category;

              // Toggle command lists visibility
              if (category === 'popular') {
                document.getElementById('popular-commands').style.display = 'flex';
                document.getElementById('popular-commands').style.flexDirection = 'column';
                document.getElementById('popular-commands').style.gap = '8px';
              }

              // For demonstration, we're only showing the popular commands section
              // In a real implementation, you would toggle visibility of different command lists
            });
          });

          // Example card click handlers
          document.querySelectorAll('.example-card').forEach(card => {
            card.addEventListener('click', event => {
              const command = card.querySelector('.example-text').textContent;
              vscode.postMessage({ type: 'command', command });
            });
          });

          // Quick action button handlers
          document.querySelectorAll('.quick-action').forEach(button => {
            button.addEventListener('click', event => {
              event.preventDefault();
              const commandText = button.textContent.toLowerCase();

              // Add a visual feedback animation
              button.classList.add('command-executing');
              setTimeout(() => {
                button.classList.remove('command-executing');
              }, 1000);

              vscode.postMessage({
                type: 'insertCommand',
                command: '/' + commandText
              });
            });
          });

          // Enhanced hover animations for all interactive elements
          document.querySelectorAll('.action-button, .example-card, .command-item').forEach(element => {
            element.addEventListener('mouseover', () => {
              element.style.transform = 'translateY(-2px)';
              element.style.boxShadow = '0 6px 14px var(--ape-welcome-shadow)';
              element.style.borderColor = 'var(--ape-card-hover-border)';
            });

            element.addEventListener('mouseout', () => {
              element.style.transform = '';
              element.style.boxShadow = '';
              element.style.borderColor = '';
            });
          });

          // Title animation
          setTimeout(() => {
            const title = document.querySelector('.welcome-title');
            if (title) {
              title.style.animation = 'pulse 3s infinite ease-in-out';
            }
          }, 1500);

          // Command tag click handlers with animation
          document.querySelectorAll('.command-tag').forEach(tag => {
            tag.addEventListener('click', (event) => {
              event.stopPropagation();

              // Visual feedback
              tag.style.backgroundColor = 'var(--ape-welcome-accent)';
              tag.style.color = 'white';

              setTimeout(() => {
                tag.style.backgroundColor = '';
                tag.style.color = '';

                const command = tag.textContent;
                vscode.postMessage({
                  type: 'insertCommand',
                  command
                });
              }, 300);
            });
          });
        </script>
      </body>
      </html>`;
    }
    /**
     * Create standalone webview panel with welcome content
     */
    static createOrShow(context) {
        const panel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createWebviewPanel('apeWelcome', 'Welcome to APE', vscode__WEBPACK_IMPORTED_MODULE_0__.ViewColumn.Active, //     
        {
            enableScripts: true,
            localResourceRoots: [
                vscode__WEBPACK_IMPORTED_MODULE_0__.Uri.joinPath(context.extensionUri, 'media')
            ],
            retainContextWhenHidden: true //    
        });
        // Set HTML content
        panel.webview.html = WelcomeViewProvider.generateHtml(panel.webview, context.extensionUri);
        // Set up message handler for the webview
        panel.webview.onDidReceiveMessage(message => {
            switch (message.type) {
                case 'command':
                    // Process direct command
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Executing command: ${message.command}`);
                    break;
                case 'insertCommand':
                    // Insert a command into the command palette
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Inserting command: ${message.command}`);
                    break;
            }
        }, undefined, context.subscriptions);
        return panel;
    }
}
/**
 * Generates a nonce string for Content Security Policy
 */
function getNonce() {
    let text = '';
    const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    for (let i = 0; i < 32; i++) {
        text += possible.charAt(Math.floor(Math.random() * possible.length));
    }
    return text;
}


/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "bufferutil":
/*!*****************************!*\
  !*** external "bufferutil" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
module.exports = require("bufferutil");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "fs/promises":
/*!******************************!*\
  !*** external "fs/promises" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("fs/promises");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "utf-8-validate":
/*!*********************************!*\
  !*** external "utf-8-validate" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("utf-8-validate");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "vscode":
/*!*************************!*\
  !*** external "vscode" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".extension.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			"main": 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
/*!**************************!*\
  !*** ./src/extension.ts ***!
  \**************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   activate: () => (/* binding */ activate),
/* harmony export */   deactivate: () => (/* binding */ deactivate)
/* harmony export */ });
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode */ "vscode");
/* harmony import */ var vscode__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(vscode__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ "path");
/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _core_llm_llmService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./core/llm/llmService */ "./src/core/llm/llmService.ts");
/* harmony import */ var _core_memory_memoryService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./core/memory/memoryService */ "./src/core/memory/memoryService.ts");
/* harmony import */ var _core_commands_commandManager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./core/commands/commandManager */ "./src/core/commands/commandManager.ts");
/* harmony import */ var _core_git_autoCommitService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./core/git/autoCommitService */ "./src/core/git/autoCommitService.ts");
/* harmony import */ var _core_git_bitbucketService__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./core/git/bitbucketService */ "./src/core/git/bitbucketService.ts");
/* harmony import */ var _core_git_conflictSolver__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./core/git/conflictSolver */ "./src/core/git/conflictSolver.ts");
/* harmony import */ var _core_completion_tabCompletionProvider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./core/completion/tabCompletionProvider */ "./src/core/completion/tabCompletionProvider.ts");
/* harmony import */ var _core_completion_inlineCompletionProvider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./core/completion/inlineCompletionProvider */ "./src/core/completion/inlineCompletionProvider.ts");
/* harmony import */ var _ui_tree_apeTreeDataProvider__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./ui/tree/apeTreeDataProvider */ "./src/ui/tree/apeTreeDataProvider.ts");
/* harmony import */ var _core_services_versionManager__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./core/services/versionManager */ "./src/core/services/versionManager.ts");
/* harmony import */ var _core_llm_modelManager__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./core/llm/modelManager */ "./src/core/llm/modelManager.ts");
/* harmony import */ var _ui_chat_codeService__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./ui/chat/codeService */ "./src/ui/chat/codeService.ts");
/* harmony import */ var _ui_mainChatViewProvider__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./ui/mainChatViewProvider */ "./src/ui/mainChatViewProvider.ts");
/* harmony import */ var _plugins_core__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./plugins/core */ "./src/plugins/core/index.ts");
/* harmony import */ var _core_services_rulesService__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./core/services/rulesService */ "./src/core/services/rulesService.ts");
/* harmony import */ var _core_services_vaultService__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./core/services/vaultService */ "./src/core/services/vaultService.ts");
/* harmony import */ var _core_services_serviceConfig__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./core/services/serviceConfig */ "./src/core/services/serviceConfig.ts");
/* harmony import */ var _core_services_jiraService__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./core/services/jiraService */ "./src/core/services/jiraService.ts");















// /   (  )
let autoPermissionHandler = null;
if (true) {
    try {
        //     
        __webpack_require__.e(/*! import() */ "src_test_helpers_auto-permission_ts").then(__webpack_require__.bind(__webpack_require__, /*! ./test/helpers/auto-permission */ "./src/test/helpers/auto-permission.ts")).then(module => {
            autoPermissionHandler = module.autoPermissionHandler;
            console.log('    (/ )');
        }).catch(error => {
            console.error('    :', error);
        });
    }
    catch (error) {
        console.log('      ():', error);
    }
}
// Plugin system imports





/**
 * Initialize all core services
 * @param context Extension context
 * @returns ServiceContainer with all initialized services
 */
async function initializeServices(context) {
    // Create service config manager first
    const configManager = new _core_services_serviceConfig__WEBPACK_IMPORTED_MODULE_18__.ServiceConfigManager(context);
    // Create model manager (should be initialized before LLMService)
    const modelManager = new _core_llm_modelManager__WEBPACK_IMPORTED_MODULE_12__.ModelManager(context);
    // Create core services with modelManager
    const llmService = new _core_llm_llmService__WEBPACK_IMPORTED_MODULE_2__.LLMService(context, modelManager); // Updated constructor
    const memoryService = new _core_memory_memoryService__WEBPACK_IMPORTED_MODULE_3__.MemoryService(context);
    // Create objects in the correct initialization order
    // Create chatViewProvider
    const chatViewProvider = new _ui_mainChatViewProvider__WEBPACK_IMPORTED_MODULE_14__.MainChatViewProvider(context, llmService, memoryService, null, // Will be set after CommandManager is created
    modelManager);
    // Initialize Rules service
    const rulesService = new _core_services_rulesService__WEBPACK_IMPORTED_MODULE_16__.RulesService(context, configManager);
    // Initialize VAULT service
    const vaultService = new _core_services_vaultService__WEBPACK_IMPORTED_MODULE_17__.VaultService(context, configManager);
    // Initialize Jira service
    const jiraService = new _core_services_jiraService__WEBPACK_IMPORTED_MODULE_19__.JiraService(context, configManager);
    // Apply Rules and VAULT services to LLM service
    llmService.setRulesService(rulesService);
    llmService.setVaultService(vaultService);
    // Then create CommandManager with chatViewProvider and services
    const commandManager = new _core_commands_commandManager__WEBPACK_IMPORTED_MODULE_4__.CommandManager(context, chatViewProvider, llmService, memoryService, modelManager, rulesService, vaultService, jiraService);
    // Now set the CommandManager reference in ChatViewProvider
    chatViewProvider._commandManager = commandManager;
    // Log debugging information
    console.log('ChatViewProvider  CommandManager  ');
    // Initialize Git services
    const bitbucketService = new _core_git_bitbucketService__WEBPACK_IMPORTED_MODULE_6__.BitbucketService(context);
    const autoCommitService = new _core_git_autoCommitService__WEBPACK_IMPORTED_MODULE_5__.AutoCommitService(context, llmService, bitbucketService);
    const conflictSolver = new _core_git_conflictSolver__WEBPACK_IMPORTED_MODULE_7__.ConflictSolver(llmService);
    // Initialize completion providers
    const tabCompletionProvider = new _core_completion_tabCompletionProvider__WEBPACK_IMPORTED_MODULE_8__.TabCompletionProvider(llmService);
    const inlineCompletionProvider = new _core_completion_inlineCompletionProvider__WEBPACK_IMPORTED_MODULE_9__.InlineCompletionProvider(llmService, context);
    // Initialize tree view data provider
    const treeDataProvider = new _ui_tree_apeTreeDataProvider__WEBPACK_IMPORTED_MODULE_10__.ApeTreeDataProvider(context, llmService, memoryService, undefined, // todoService
    vaultService, rulesService, jiraService);
    // Initialize version manager
    const versionManager = new _core_services_versionManager__WEBPACK_IMPORTED_MODULE_11__.VersionManager(context);
    // Initialize plugin system
    const pluginEventEmitter = new _plugins_core__WEBPACK_IMPORTED_MODULE_15__.EventEmitterImpl();
    const pluginRegistry = new _plugins_core__WEBPACK_IMPORTED_MODULE_15__.PluginRegistryImpl(pluginEventEmitter);
    const pluginAPI = new _plugins_core__WEBPACK_IMPORTED_MODULE_15__.PluginAPIImpl(llmService, memoryService, pluginEventEmitter);
    const pluginLoader = new _plugins_core__WEBPACK_IMPORTED_MODULE_15__.PluginLoader(context, pluginRegistry, pluginAPI);
    const pluginSettingsManager = new _plugins_core__WEBPACK_IMPORTED_MODULE_15__.PluginSettingsManagerImpl(context);
    return {
        modelManager,
        llmService,
        memoryService,
        chatViewProvider,
        commandManager,
        bitbucketService,
        autoCommitService,
        conflictSolver,
        tabCompletionProvider,
        inlineCompletionProvider,
        treeDataProvider,
        versionManager,
        rulesService,
        vaultService,
        jiraService,
        configManager,
        pluginEventEmitter,
        pluginRegistry,
        pluginAPI,
        pluginLoader,
        pluginSettingsManager
    };
}
/**
 * Register VSCode components
 * @param context Extension context
 * @param services Service container
 */
function registerComponents(context, services) {
    // Register WebView provider
    const chatViewProviderRegistration = vscode__WEBPACK_IMPORTED_MODULE_0__.window.registerWebviewViewProvider('apeChat', services.chatViewProvider, {
        webviewOptions: {
            retainContextWhenHidden: true
        }
    });
    //    
    console.log('APE Chat View Provider .');
    context.subscriptions.push(chatViewProviderRegistration);
    //   CommandManager  
    // ModelManager     (  )
    services.commandManager.registerCommands();
    // Register code block insertion commands
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.insertCodeToEditor', (options) => {
        return _ui_chat_codeService__WEBPACK_IMPORTED_MODULE_13__.CodeService.insertCodeToEditor(options);
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.createNewFileWithCode', (options) => {
        return _ui_chat_codeService__WEBPACK_IMPORTED_MODULE_13__.CodeService.insertCodeToEditor({
            ...options,
            createNewFile: true
        });
    }));
    // Register Git commands
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.git.resolveConflict', async () => {
        const resolvedCount = await services.conflictSolver.resolveAllConflicts();
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`${resolvedCount}   `);
    }));
    // Register tab completion for various languages
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.languages.registerCompletionItemProvider([
        { scheme: 'file', language: 'typescript' },
        { scheme: 'file', language: 'javascript' },
        { scheme: 'file', language: 'python' },
        { scheme: 'file', language: 'java' },
        { scheme: 'file', language: 'c' },
        { scheme: 'file', language: 'cpp' },
        { scheme: 'file', language: 'csharp' },
        { scheme: 'file', language: 'go' },
        { scheme: 'file', language: 'rust' },
        { scheme: 'file', language: 'php' },
        { scheme: 'file', language: 'ruby' },
        { scheme: 'file', language: 'html' },
        { scheme: 'file', language: 'css' },
        { scheme: 'file', language: 'json' },
        { scheme: 'file', language: 'markdown' }
    ], services.tabCompletionProvider, '\t' // Triggered by tab key
    ));
    // Register command completion
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.languages.registerCompletionItemProvider([{ scheme: 'file' }], services.tabCompletionProvider, '/' // Triggered by slash
    ));
    // Register inline completion provider
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.languages.registerInlineCompletionItemProvider([{ scheme: 'file' }], services.inlineCompletionProvider));
    // Register tree data provider with custom configuration
    const treeView = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createTreeView('apeNavigator', {
        treeDataProvider: services.treeDataProvider,
        showCollapseAll: true,
        canSelectMany: false //    UI 
    });
    // Add command to set optimal view layout
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.setOptimalLayout', async () => {
        try {
            //  
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.view.extension.ape-sidebar');
            await new Promise(r => setTimeout(r, 100));
            //   
            await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('apeChat.focus');
            await new Promise(r => setTimeout(r, 100));
            //    ( )
            for (let i = 0; i < 6; i++) {
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.decreaseSideBarWidth');
                await new Promise(r => setTimeout(r, 30));
            }
            //   
            for (let i = 0; i < 3; i++) {
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.increaseViewSize');
                await new Promise(r => setTimeout(r, 30));
            }
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('APE   .');
        }
        catch (error) {
            console.error('   :', error);
        }
    }));
    context.subscriptions.push(treeView);
    // Register version manager
    services.versionManager.registerCommands();
    // Register navigator commands
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.refreshNavigator', () => {
        services.treeDataProvider.refresh();
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.refreshTreeView', () => {
        services.treeDataProvider.refresh();
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.executeCommand', (commandInfo) => {
        if (!commandInfo || !commandInfo.name) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('   ');
            return;
        }
        const commandText = commandInfo.args
            ? `/${commandInfo.name} ${commandInfo.args.join(' ')}`
            : `/${commandInfo.name}`;
        //  SlashCommandManager  
        services.commandManager.slashCommandManager.executeCommand(commandText);
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.sendLlmResponse', (messageData) => {
        services.chatViewProvider.sendLlmResponse(messageData);
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.openSettings', (settingKey) => {
        if (settingKey) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', settingKey);
        }
        else {
            vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', 'ape');
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.handleChatInput', (text) => {
        services.chatViewProvider.handleChatInput(text);
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.sendChatMessage', () => {
        vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendMessage');
    }), 
    // VAULT  
    vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.vaultShowItem', (item) => {
        if (!item || !item.metadata) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('VAULT    ');
            return;
        }
        //   
        const content = item.metadata.content;
        const title = `VAULT : ${item.label}`;
        //   
        vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## ${title}\n\n${content}`
        });
    }));
    // Register Rules commands
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.activate', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Rule   ');
            return;
        }
        try {
            const success = await services.rulesService.activateRule(item.metadata.id);
            if (success) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Rule '${item.label}'  `);
                services.treeDataProvider.refresh();
            }
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule    : ${error instanceof Error ? error.message : String(error)}`);
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.deactivate', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Rule   ');
            return;
        }
        try {
            const success = await services.rulesService.deactivateRule(item.metadata.id);
            if (success) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Rule '${item.label}'  `);
                services.treeDataProvider.refresh();
            }
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule    : ${error instanceof Error ? error.message : String(error)}`);
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.openFile', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Rule   ');
            return;
        }
        try {
            await services.rulesService.openRuleFile(item.metadata.id);
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule     : ${error instanceof Error ? error.message : String(error)}`);
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.refresh', () => {
        try {
            services.rulesService.loadAllRules();
            services.treeDataProvider.refresh();
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rules    : ${error instanceof Error ? error.message : String(error)}`);
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.create', async () => {
        try {
            //    
            const ruleName = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInputBox({
                prompt: ' Rule  ',
                placeHolder: ':   , API   ',
                validateInput: (value) => {
                    if (!value || value.trim().length === 0) {
                        return '   ';
                    }
                    return null;
                }
            });
            if (!ruleName) {
                return; //   
            }
            //   
            const rulePath = path__WEBPACK_IMPORTED_MODULE_1__.join(services.rulesService['rulesDir'], `${ruleName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '')}.md`);
            const ruleContent = `# ${ruleName}\n\n LLM    .\n\n   .\n\n## \n\n1.    .\n2.   .\n3.    .`;
            //  
            const rule = await services.rulesService.createRule(ruleName, ruleContent, false);
            //    
            await services.rulesService.openRuleFile(rule.id);
            //  
            services.treeDataProvider.refresh();
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Rule '${ruleName}'  .    .`);
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule    : ${error instanceof Error ? error.message : String(error)}`);
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.rules.delete', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Rule   ');
            return;
        }
        try {
            //  
            const confirmation = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showWarningMessage(`Rule '${item.label}'() ?`, { modal: true }, '', '');
            if (confirmation !== '') {
                return;
            }
            //  
            const success = await services.rulesService.deleteRule(item.metadata.id);
            if (success) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Rule '${item.label}'  `);
                services.treeDataProvider.refresh();
            }
        }
        catch (error) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Rule    : ${error instanceof Error ? error.message : String(error)}`);
        }
    }));
    // Register plugin system commands
    context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.plugins.list', async () => {
        const plugins = services.pluginRegistry.getAllPlugins();
        const items = plugins.map(plugin => ({
            label: `${plugin.metadata.name} (${plugin.metadata.version})`,
            description: plugin.state,
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to see details'
        });
        if (selected) {
            const actions = [];
            if (selected.plugin.state === 'active') {
                actions.push('Deactivate');
            }
            else if (selected.plugin.state === 'registered' || selected.plugin.state === 'inactive') {
                actions.push('Activate');
            }
            actions.push('View Details', 'Open Settings');
            const action = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(actions, {
                placeHolder: 'Select an action'
            });
            if (action === 'Activate') {
                await services.pluginRegistry.activatePlugin(selected.plugin.id);
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} activated`);
            }
            else if (action === 'Deactivate') {
                await services.pluginRegistry.deactivatePlugin(selected.plugin.id);
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} deactivated`);
            }
            else if (action === 'View Details') {
                // Show details in output channel
                const outputChannel = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createOutputChannel(`APE Plugin: ${selected.plugin.metadata.name}`);
                outputChannel.appendLine(`ID: ${selected.plugin.id}`);
                outputChannel.appendLine(`Name: ${selected.plugin.metadata.name}`);
                outputChannel.appendLine(`Version: ${selected.plugin.metadata.version}`);
                outputChannel.appendLine(`Description: ${selected.plugin.metadata.description || 'No description'}`);
                outputChannel.appendLine(`Author: ${selected.plugin.metadata.author || 'Unknown'}`);
                outputChannel.appendLine(`State: ${selected.plugin.state}`);
                if (selected.plugin.metadata.dependencies?.length) {
                    outputChannel.appendLine(`Dependencies: ${selected.plugin.metadata.dependencies.join(', ')}`);
                }
                if (selected.plugin.error) {
                    outputChannel.appendLine(`\nError: ${selected.plugin.error.message}`);
                }
                outputChannel.show();
            }
            else if (action === 'Open Settings') {
                vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', `ape.plugins.${selected.plugin.id}`);
            }
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.plugins.activate', async () => {
        const plugins = services.pluginRegistry.getAllPlugins()
            .filter(p => p.state !== 'active');
        const items = plugins.map(plugin => ({
            label: plugin.metadata.name,
            description: plugin.state,
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to activate'
        });
        if (selected) {
            try {
                const success = await services.pluginRegistry.activatePlugin(selected.plugin.id);
                if (success) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} activated`);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Failed to activate plugin ${selected.plugin.metadata.name}`);
                }
            }
            catch (error) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Failed to activate plugin: ${error.message}`);
            }
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.plugins.deactivate', async () => {
        const plugins = services.pluginRegistry.getActivePlugins();
        const items = plugins.map(plugin => ({
            label: plugin.metadata.name,
            description: 'active',
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to deactivate'
        });
        if (selected) {
            try {
                const success = await services.pluginRegistry.deactivatePlugin(selected.plugin.id);
                if (success) {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} deactivated`);
                }
                else {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Failed to deactivate plugin ${selected.plugin.metadata.name}`);
                }
            }
            catch (error) {
                vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Failed to deactivate plugin: ${error.message}`);
            }
        }
    }), vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.plugins.openSettings', async () => {
        const plugins = services.pluginRegistry.getAllPlugins();
        const items = plugins.map(plugin => ({
            label: plugin.metadata.name,
            description: plugin.state,
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await vscode__WEBPACK_IMPORTED_MODULE_0__.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to open settings'
        });
        if (selected) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.openSettings', `ape.plugins.${selected.plugin.id}`);
        }
    }));
    // Add all services to context subscriptions for proper disposal
    context.subscriptions.push(services.modelManager, services.llmService, services.memoryService, services.bitbucketService, services.autoCommitService, services.vaultService, services.rulesService, services.jiraService, services.configManager, {
        dispose: () => {
            // Dispose plugin system
            services.pluginLoader.deactivateAllPlugins().catch(error => {
                console.error('Error deactivating plugins during extension deactivation:', error);
            });
            services.pluginSettingsManager.dispose();
            // Event emitter doesn't need explicit disposal
        }
    });
}
/**
 * Extension activation point
 * @param context Extension context
 */
async function activate(context) {
    console.log('APE Extension is now active!');
    //        
    const isTestMode = vscode__WEBPACK_IMPORTED_MODULE_0__.workspace.getConfiguration('ape').get('testing.enabled') ||
        process.env.APE_TEST_MODE === 'true';
    if (isTestMode) {
        process.env.APE_TEST_MODE = 'true';
        console.log('APE   :    .');
        //      
        context.subscriptions.push(vscode__WEBPACK_IMPORTED_MODULE_0__.commands.registerCommand('ape.acceptAllPermissions', () => {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('    .');
            return true;
        }));
    }
    //      
    try {
        const versionInfo = await context.extension.packageJSON.version;
        const statusBarItem = vscode__WEBPACK_IMPORTED_MODULE_0__.window.createStatusBarItem(vscode__WEBPACK_IMPORTED_MODULE_0__.StatusBarAlignment.Right, 100);
        statusBarItem.text = `$(tag) APE v${versionInfo}`;
        statusBarItem.tooltip = 'APE Extension Version';
        statusBarItem.show();
        context.subscriptions.push(statusBarItem);
    }
    catch (error) {
        console.error('Failed to display version in status bar:', error);
    }
    try {
        // Initialize all services
        const services = await initializeServices(context);
        // Register VSCode components
        registerComponents(context, services);
        // Load internal plugins
        try {
            const internalPluginCount = await services.pluginLoader.loadInternalPlugins();
            console.log(`Loaded ${internalPluginCount} internal plugins`);
            // Load external plugins
            const externalPluginCount = await services.pluginLoader.loadExternalPlugins();
            console.log(`Loaded ${externalPluginCount} external plugins`);
            // Auto-activate plugins based on extension activation event
            services.pluginLoader.activatePluginsByEvent('onExtensionActivate').catch(error => {
                console.error('Error activating plugins on extension activation:', error);
            });
        }
        catch (error) {
            console.error('Failed to initialize plugin system:', error);
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage('Failed to initialize APE plugin system. Some features may not work properly.');
        }
        // Show welcome message on first activation
        const hasShownWelcome = context.globalState.get('ape.hasShownWelcome');
        //       (3:1) 
        setTimeout(async () => {
            try {
                // VSCode  
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.resetLayout');
                await sleep(300);
                //   ( )
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.view.extension.ape-sidebar');
                console.log('APE Sidebar opened');
                await sleep(100);
                //     
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('apeChat.focus');
                console.log('APE Chat view activated');
                await sleep(100);
                //     (3:1)  
                //     (VSCode API    )
                const decreaseCount = 6; //   
                for (let i = 0; i < decreaseCount; i++) {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.decreaseSideBarWidth');
                    await sleep(30); //     
                }
                //     ( )
                const increaseCount = 3; //   
                for (let i = 0; i < increaseCount; i++) {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.action.increaseViewSize');
                    await sleep(30);
                }
                //      
                await sleep(100);
                await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('apeChat.focus');
            }
            catch (error) {
                console.error('      :', error);
                //    
                try {
                    await vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.view.extension.ape-sidebar');
                    console.log('APE Sidebar opened as fallback');
                }
                catch (sidebarError) {
                    console.error('  :', sidebarError);
                }
            }
        }, 1500); //       
        //     
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        if (!hasShownWelcome) {
            vscode__WEBPACK_IMPORTED_MODULE_0__.window.showInformationMessage('APE Extension is now active! Open the APE sidebar to start using it.', 'Open APE Sidebar').then(selection => {
                if (selection === 'Open APE Sidebar') {
                    vscode__WEBPACK_IMPORTED_MODULE_0__.commands.executeCommand('workbench.view.extension.ape-sidebar');
                }
            });
            context.globalState.update('ape.hasShownWelcome', true);
        }
    }
    catch (error) {
        console.error('Failed to activate APE extension:', error);
        vscode__WEBPACK_IMPORTED_MODULE_0__.window.showErrorMessage(`Failed to activate APE extension: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Extension deactivation point
 *
 *     ,      .
 * -    (LLM  )
 * -   
 * -   
 * -   
 */
function deactivate() {
    console.log('APE Extension is deactivated');
}

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=extension.js.map