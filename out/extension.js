/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 28:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(8051)
  , initState  = __webpack_require__(9500)
  , terminator = __webpack_require__(6276)
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),

/***/ 76:
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),

/***/ 181:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 405:
/***/ ((module) => {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),

/***/ 414:
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),

/***/ 453:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Object = __webpack_require__(9612);

var $Error = __webpack_require__(9383);
var $EvalError = __webpack_require__(1237);
var $RangeError = __webpack_require__(9290);
var $ReferenceError = __webpack_require__(9538);
var $SyntaxError = __webpack_require__(8068);
var $TypeError = __webpack_require__(9675);
var $URIError = __webpack_require__(5345);

var abs = __webpack_require__(1514);
var floor = __webpack_require__(8968);
var max = __webpack_require__(6188);
var min = __webpack_require__(8002);
var pow = __webpack_require__(3499);
var round = __webpack_require__(414);
var sign = __webpack_require__(3093);

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(5795);
var $defineProperty = __webpack_require__(655);

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(4039)();

var getProto = __webpack_require__(3628);
var $ObjectGPO = __webpack_require__(1064);
var $ReflectGPO = __webpack_require__(8648);

var $apply = __webpack_require__(1002);
var $call = __webpack_require__(76);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(6743);
var hasOwn = __webpack_require__(9957);
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),

/***/ 597:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { kForOnEventAttribute, kListener } = __webpack_require__(2614);

const kCode = Symbol('kCode');
const kData = Symbol('kData');
const kError = Symbol('kError');
const kMessage = Symbol('kMessage');
const kReason = Symbol('kReason');
const kTarget = Symbol('kTarget');
const kType = Symbol('kType');
const kWasClean = Symbol('kWasClean');

/**
 * Class representing an event.
 */
class Event {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  constructor(type) {
    this[kTarget] = null;
    this[kType] = type;
  }

  /**
   * @type {*}
   */
  get target() {
    return this[kTarget];
  }

  /**
   * @type {String}
   */
  get type() {
    return this[kType];
  }
}

Object.defineProperty(Event.prototype, 'target', { enumerable: true });
Object.defineProperty(Event.prototype, 'type', { enumerable: true });

/**
 * Class representing a close event.
 *
 * @extends Event
 */
class CloseEvent extends Event {
  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  constructor(type, options = {}) {
    super(type);

    this[kCode] = options.code === undefined ? 0 : options.code;
    this[kReason] = options.reason === undefined ? '' : options.reason;
    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
  }

  /**
   * @type {Number}
   */
  get code() {
    return this[kCode];
  }

  /**
   * @type {String}
   */
  get reason() {
    return this[kReason];
  }

  /**
   * @type {Boolean}
   */
  get wasClean() {
    return this[kWasClean];
  }
}

Object.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });
Object.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });

/**
 * Class representing an error event.
 *
 * @extends Event
 */
class ErrorEvent extends Event {
  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  constructor(type, options = {}) {
    super(type);

    this[kError] = options.error === undefined ? null : options.error;
    this[kMessage] = options.message === undefined ? '' : options.message;
  }

  /**
   * @type {*}
   */
  get error() {
    return this[kError];
  }

  /**
   * @type {String}
   */
  get message() {
    return this[kMessage];
  }
}

Object.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });
Object.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });

/**
 * Class representing a message event.
 *
 * @extends Event
 */
class MessageEvent extends Event {
  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  constructor(type, options = {}) {
    super(type);

    this[kData] = options.data === undefined ? null : options.data;
  }

  /**
   * @type {*}
   */
  get data() {
    return this[kData];
  }
}

Object.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });

/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */
const EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {(Function|Object)} handler The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener(type, handler, options = {}) {
    for (const listener of this.listeners(type)) {
      if (
        !options[kForOnEventAttribute] &&
        listener[kListener] === handler &&
        !listener[kForOnEventAttribute]
      ) {
        return;
      }
    }

    let wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        const event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        const event = new CloseEvent('close', {
          code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        const event = new ErrorEvent('error', {
          error,
          message: error.message
        });

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        const event = new Event('open');

        event[kTarget] = this;
        callListener(handler, this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = handler;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {(Function|Object)} handler The listener to remove
   * @public
   */
  removeEventListener(type, handler) {
    for (const listener of this.listeners(type)) {
      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
        this.removeListener(type, listener);
        break;
      }
    }
  }
};

module.exports = {
  CloseEvent,
  ErrorEvent,
  Event,
  EventTarget,
  MessageEvent
};

/**
 * Call an event listener
 *
 * @param {(Function|Object)} listener The listener to call
 * @param {*} thisArg The value to use as `this`` when calling the listener
 * @param {Event} event The event to pass to the listener
 * @private
 */
function callListener(listener, thisArg, event) {
  if (typeof listener === 'object' && listener.handleEvent) {
    listener.handleEvent.call(listener, event);
  } else {
    listener.call(thisArg, event);
  }
}


/***/ }),

/***/ 655:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),

/***/ 736:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(6585);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		const split = (typeof namespaces === 'string' ? namespaces : '')
			.trim()
			.replace(' ', ',')
			.split(',')
			.filter(Boolean);

		for (const ns of split) {
			if (ns[0] === '-') {
				createDebug.skips.push(ns.slice(1));
			} else {
				createDebug.names.push(ns);
			}
		}
	}

	/**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */
	function matchesTemplate(search, template) {
		let searchIndex = 0;
		let templateIndex = 0;
		let starIndex = -1;
		let matchIndex = 0;

		while (searchIndex < search.length) {
			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
				// Match character or proceed with wildcard
				if (template[templateIndex] === '*') {
					starIndex = templateIndex;
					matchIndex = searchIndex;
					templateIndex++; // Skip the '*'
				} else {
					searchIndex++;
					templateIndex++;
				}
			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
				// Backtrack to the last '*' and try to match more characters
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else {
				return false; // No match
			}
		}

		// Handle trailing '*' in template
		while (templateIndex < template.length && template[templateIndex] === '*') {
			templateIndex++;
		}

		return templateIndex === template.length;
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names,
			...createDebug.skips.map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		for (const skip of createDebug.skips) {
			if (matchesTemplate(name, skip)) {
				return false;
			}
		}

		for (const ns of createDebug.names) {
			if (matchesTemplate(name, ns)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),

/***/ 737:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var CombinedStream = __webpack_require__(3182);
var util = __webpack_require__(9023);
var path = __webpack_require__(6928);
var http = __webpack_require__(8611);
var https = __webpack_require__(5692);
var parseUrl = (__webpack_require__(7016).parse);
var fs = __webpack_require__(9896);
var Stream = (__webpack_require__(2203).Stream);
var mime = __webpack_require__(6049);
var asynckit = __webpack_require__(1873);
var setToStringTag = __webpack_require__(9605);
var populate = __webpack_require__(1362);

// Public API
module.exports = FormData;

// make it a Stream
util.inherits(FormData, CombinedStream);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {Object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function(field, value, options) {

  options = options || {};

  // allow filename as single option
  if (typeof options == 'string') {
    options = {filename: options};
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value == 'number') {
    value = '' + value;
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (Array.isArray(value)) {
    // Please convert your array into string
    // the way web server expects it
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function(header, value, options) {
  var valueLength = 0;

  // used w/ getLengthSync(), when length is known.
  // e.g. for streaming directly from a remote server,
  // w/ a known file a size, and not wanting to wait for
  // incoming file to finish to get its size.
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength +=
    Buffer.byteLength(header) +
    FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response or not a stream
  if (!value || ( !value.path && !(value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) && !(value instanceof Stream))) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function(value, callback) {
  if (Object.prototype.hasOwnProperty.call(value, 'fd')) {

    // take read range into a account
    // `end` = Infinity â€“> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {

      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0));

    // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function(err, stat) {

        var fileSize;

        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

  // or http response
  } else if (Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    callback(null, +value.headers['content-length']);

  // or request stream http://github.com/mikeal/request
  } else if (Object.prototype.hasOwnProperty.call(value, 'httpModule')) {
    // wait till response come back
    value.on('response', function(response) {
      value.pause();
      callback(null, +response.headers['content-length']);
    });
    value.resume();

  // something else
  } else {
    callback('Unknown stream');
  }
};

FormData.prototype._multiPartHeader = function(field, value, options) {
  // custom header specified (as string)?
  // it becomes responsible for boundary
  // (e.g. to handle extra CRLFs on .NET servers)
  if (typeof options.header == 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers  = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header == 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) {
    if (Object.prototype.hasOwnProperty.call(headers, prop)) {
      header = headers[prop];

      // skip nullish headers.
      if (header == null) {
        continue;
      }

      // convert all headers to arrays.
      if (!Array.isArray(header)) {
        header = [header];
      }

      // add non-empty headers.
      if (header.length) {
        contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
      }
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function(value, options) {

  var filename
    , contentDisposition
    ;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || value.name || value.path) {
    // custom filename take precedence
    // formidable and the browser add a name property
    // fs- and request- streams have path property
    filename = path.basename(options.filename || value.name || value.path);
  } else if (value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    contentDisposition = 'filename="' + filename + '"';
  }

  return contentDisposition;
};

FormData.prototype._getContentType = function(value, options) {

  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value.readable && Object.prototype.hasOwnProperty.call(value, 'httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && typeof value == 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function() {
  return function(next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = (this._streams.length === 0);
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function() {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function(userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) {
    if (Object.prototype.hasOwnProperty.call(userHeaders, header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc(0);
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {

      // Add content to the buffer.
      if(Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat( [dataBuffer, this._streams[i]]);
      }else {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring( 2, boundary.length + 2 ) !== boundary) {
        dataBuffer = Buffer.concat( [dataBuffer, Buffer.from(FormData.LINE_BREAK)] );
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat( [dataBuffer, Buffer.from(this._lastBoundary())] );
};

FormData.prototype._generateBoundary = function() {
  // This generates a 50 character boundary similar to those used by Firefox.
  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually
// and add it as knownLength option
FormData.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair
  // so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    // Some async length retrievers are present
    // therefore synchronous length calculation is false.
    // Please use getLength(callback) to get proper length
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function() {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function(length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function(params, cb) {
  var request
    , options
    , defaults = {method: 'post'}
    ;

  // parse provided url if it's string
  // or treat it as options object
  if (typeof params == 'string') {

    params = parseUrl(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);

  // use custom params
  } else {

    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol == 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol == 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function(err, length) {
    if (err && err !== 'Unknown stream') {
      this._error(err);
      return;
    }

    // add content length
    if (length) {
      request.setHeader('Content-Length', length);
    }

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce);
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};
setToStringTag(FormData, 'FormData');


/***/ }),

/***/ 857:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex" }] */



const { Duplex } = __webpack_require__(2203);
const { randomFillSync } = __webpack_require__(6982);

const PerMessageDeflate = __webpack_require__(2971);
const { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(2614);
const { isBlob, isValidStatusCode } = __webpack_require__(5880);
const { mask: applyMask, toBuffer } = __webpack_require__(3338);

const kByteLength = Symbol('kByteLength');
const maskBuffer = Buffer.alloc(4);
const RANDOM_POOL_SIZE = 8 * 1024;
let randomPool;
let randomPoolPointer = RANDOM_POOL_SIZE;

const DEFAULT = 0;
const DEFLATING = 1;
const GET_BLOB_DATA = 2;

/**
 * HyBi Sender implementation.
 */
class Sender {
  /**
   * Creates a Sender instance.
   *
   * @param {Duplex} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   * @param {Function} [generateMask] The function used to generate the masking
   *     key
   */
  constructor(socket, extensions, generateMask) {
    this._extensions = extensions || {};

    if (generateMask) {
      this._generateMask = generateMask;
      this._maskBuffer = Buffer.alloc(4);
    }

    this._socket = socket;

    this._firstFragment = true;
    this._compress = false;

    this._bufferedBytes = 0;
    this._queue = [];
    this._state = DEFAULT;
    this.onerror = NOOP;
    this[kWebSocket] = undefined;
  }

  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {(Buffer|String)} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {(Buffer|String)[]} The framed data
   * @public
   */
  static frame(data, options) {
    let mask;
    let merge = false;
    let offset = 2;
    let skipMasking = false;

    if (options.mask) {
      mask = options.maskBuffer || maskBuffer;

      if (options.generateMask) {
        options.generateMask(mask);
      } else {
        if (randomPoolPointer === RANDOM_POOL_SIZE) {
          /* istanbul ignore else  */
          if (randomPool === undefined) {
            //
            // This is lazily initialized because server-sent frames must not
            // be masked so it may never be used.
            //
            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
          }

          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
          randomPoolPointer = 0;
        }

        mask[0] = randomPool[randomPoolPointer++];
        mask[1] = randomPool[randomPoolPointer++];
        mask[2] = randomPool[randomPoolPointer++];
        mask[3] = randomPool[randomPoolPointer++];
      }

      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
      offset = 6;
    }

    let dataLength;

    if (typeof data === 'string') {
      if (
        (!options.mask || skipMasking) &&
        options[kByteLength] !== undefined
      ) {
        dataLength = options[kByteLength];
      } else {
        data = Buffer.from(data);
        dataLength = data.length;
      }
    } else {
      dataLength = data.length;
      merge = options.mask && options.readOnly && !skipMasking;
    }

    let payloadLength = dataLength;

    if (dataLength >= 65536) {
      offset += 8;
      payloadLength = 127;
    } else if (dataLength > 125) {
      offset += 2;
      payloadLength = 126;
    }

    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);

    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
    if (options.rsv1) target[0] |= 0x40;

    target[1] = payloadLength;

    if (payloadLength === 126) {
      target.writeUInt16BE(dataLength, 2);
    } else if (payloadLength === 127) {
      target[2] = target[3] = 0;
      target.writeUIntBE(dataLength, 4, 6);
    }

    if (!options.mask) return [target, data];

    target[1] |= 0x80;
    target[offset - 4] = mask[0];
    target[offset - 3] = mask[1];
    target[offset - 2] = mask[2];
    target[offset - 1] = mask[3];

    if (skipMasking) return [target, data];

    if (merge) {
      applyMask(data, mask, target, offset, dataLength);
      return [target];
    }

    applyMask(data, mask, data, 0, dataLength);
    return [target, data];
  }

  /**
   * Sends a close message to the other peer.
   *
   * @param {Number} [code] The status code component of the body
   * @param {(String|Buffer)} [data] The message component of the body
   * @param {Boolean} [mask=false] Specifies whether or not to mask the message
   * @param {Function} [cb] Callback
   * @public
   */
  close(code, data, mask, cb) {
    let buf;

    if (code === undefined) {
      buf = EMPTY_BUFFER;
    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
      throw new TypeError('First argument must be a valid error code number');
    } else if (data === undefined || !data.length) {
      buf = Buffer.allocUnsafe(2);
      buf.writeUInt16BE(code, 0);
    } else {
      const length = Buffer.byteLength(data);

      if (length > 123) {
        throw new RangeError('The message must not be greater than 123 bytes');
      }

      buf = Buffer.allocUnsafe(2 + length);
      buf.writeUInt16BE(code, 0);

      if (typeof data === 'string') {
        buf.write(data, 2);
      } else {
        buf.set(data, 2);
      }
    }

    const options = {
      [kByteLength]: buf.length,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x08,
      readOnly: false,
      rsv1: false
    };

    if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, buf, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(buf, options), cb);
    }
  }

  /**
   * Sends a ping message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  ping(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x09,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a pong message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback
   * @public
   */
  pong(data, mask, cb) {
    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (byteLength > 125) {
      throw new RangeError('The data size must not be greater than 125 bytes');
    }

    const options = {
      [kByteLength]: byteLength,
      fin: true,
      generateMask: this._generateMask,
      mask,
      maskBuffer: this._maskBuffer,
      opcode: 0x0a,
      readOnly,
      rsv1: false
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, false, options, cb]);
      } else {
        this.getBlobData(data, false, options, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, false, options, cb]);
    } else {
      this.sendFrame(Sender.frame(data, options), cb);
    }
  }

  /**
   * Sends a data message to the other peer.
   *
   * @param {*} data The message to send
   * @param {Object} options Options object
   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
   *     or text
   * @param {Boolean} [options.compress=false] Specifies whether or not to
   *     compress `data`
   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Function} [cb] Callback
   * @public
   */
  send(data, options, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
    let opcode = options.binary ? 2 : 1;
    let rsv1 = options.compress;

    let byteLength;
    let readOnly;

    if (typeof data === 'string') {
      byteLength = Buffer.byteLength(data);
      readOnly = false;
    } else if (isBlob(data)) {
      byteLength = data.size;
      readOnly = false;
    } else {
      data = toBuffer(data);
      byteLength = data.length;
      readOnly = toBuffer.readOnly;
    }

    if (this._firstFragment) {
      this._firstFragment = false;
      if (
        rsv1 &&
        perMessageDeflate &&
        perMessageDeflate.params[
          perMessageDeflate._isServer
            ? 'server_no_context_takeover'
            : 'client_no_context_takeover'
        ]
      ) {
        rsv1 = byteLength >= perMessageDeflate._threshold;
      }
      this._compress = rsv1;
    } else {
      rsv1 = false;
      opcode = 0;
    }

    if (options.fin) this._firstFragment = true;

    const opts = {
      [kByteLength]: byteLength,
      fin: options.fin,
      generateMask: this._generateMask,
      mask: options.mask,
      maskBuffer: this._maskBuffer,
      opcode,
      readOnly,
      rsv1
    };

    if (isBlob(data)) {
      if (this._state !== DEFAULT) {
        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);
      } else {
        this.getBlobData(data, this._compress, opts, cb);
      }
    } else if (this._state !== DEFAULT) {
      this.enqueue([this.dispatch, data, this._compress, opts, cb]);
    } else {
      this.dispatch(data, this._compress, opts, cb);
    }
  }

  /**
   * Gets the contents of a blob as binary data.
   *
   * @param {Blob} blob The blob
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     the data
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  getBlobData(blob, compress, options, cb) {
    this._bufferedBytes += options[kByteLength];
    this._state = GET_BLOB_DATA;

    blob
      .arrayBuffer()
      .then((arrayBuffer) => {
        if (this._socket.destroyed) {
          const err = new Error(
            'The socket was closed while the blob was being read'
          );

          //
          // `callCallbacks` is called in the next tick to ensure that errors
          // that might be thrown in the callbacks behave like errors thrown
          // outside the promise chain.
          //
          process.nextTick(callCallbacks, this, err, cb);
          return;
        }

        this._bufferedBytes -= options[kByteLength];
        const data = toBuffer(arrayBuffer);

        if (!compress) {
          this._state = DEFAULT;
          this.sendFrame(Sender.frame(data, options), cb);
          this.dequeue();
        } else {
          this.dispatch(data, compress, options, cb);
        }
      })
      .catch((err) => {
        //
        // `onError` is called in the next tick for the same reason that
        // `callCallbacks` above is.
        //
        process.nextTick(onError, this, err, cb);
      });
  }

  /**
   * Dispatches a message.
   *
   * @param {(Buffer|String)} data The message to send
   * @param {Boolean} [compress=false] Specifies whether or not to compress
   *     `data`
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
   *     key
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @param {Function} [cb] Callback
   * @private
   */
  dispatch(data, compress, options, cb) {
    if (!compress) {
      this.sendFrame(Sender.frame(data, options), cb);
      return;
    }

    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    this._bufferedBytes += options[kByteLength];
    this._state = DEFLATING;
    perMessageDeflate.compress(data, options.fin, (_, buf) => {
      if (this._socket.destroyed) {
        const err = new Error(
          'The socket was closed while data was being compressed'
        );

        callCallbacks(this, err, cb);
        return;
      }

      this._bufferedBytes -= options[kByteLength];
      this._state = DEFAULT;
      options.readOnly = false;
      this.sendFrame(Sender.frame(buf, options), cb);
      this.dequeue();
    });
  }

  /**
   * Executes queued send operations.
   *
   * @private
   */
  dequeue() {
    while (this._state === DEFAULT && this._queue.length) {
      const params = this._queue.shift();

      this._bufferedBytes -= params[3][kByteLength];
      Reflect.apply(params[0], this, params.slice(1));
    }
  }

  /**
   * Enqueues a send operation.
   *
   * @param {Array} params Send operation parameters.
   * @private
   */
  enqueue(params) {
    this._bufferedBytes += params[3][kByteLength];
    this._queue.push(params);
  }

  /**
   * Sends a frame.
   *
   * @param {(Buffer | String)[]} list The frame to send
   * @param {Function} [cb] Callback
   * @private
   */
  sendFrame(list, cb) {
    if (list.length === 2) {
      this._socket.cork();
      this._socket.write(list[0]);
      this._socket.write(list[1], cb);
      this._socket.uncork();
    } else {
      this._socket.write(list[0], cb);
    }
  }
}

module.exports = Sender;

/**
 * Calls queued callbacks with an error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error to call the callbacks with
 * @param {Function} [cb] The first callback
 * @private
 */
function callCallbacks(sender, err, cb) {
  if (typeof cb === 'function') cb(err);

  for (let i = 0; i < sender._queue.length; i++) {
    const params = sender._queue[i];
    const callback = params[params.length - 1];

    if (typeof callback === 'function') callback(err);
  }
}

/**
 * Handles a `Sender` error.
 *
 * @param {Sender} sender The `Sender` instance
 * @param {Error} err The error
 * @param {Function} [cb] The first pending callback
 * @private
 */
function onError(sender, err, cb) {
  callCallbacks(sender, err, cb);
  sender.onerror(err);
}


/***/ }),

/***/ 1002:
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),

/***/ 1060:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex|Readable$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(4434);
const https = __webpack_require__(5692);
const http = __webpack_require__(8611);
const net = __webpack_require__(9278);
const tls = __webpack_require__(4756);
const { randomBytes, createHash } = __webpack_require__(6982);
const { Duplex, Readable } = __webpack_require__(2203);
const { URL } = __webpack_require__(7016);

const PerMessageDeflate = __webpack_require__(2971);
const Receiver = __webpack_require__(6286);
const Sender = __webpack_require__(914);
const { isBlob } = __webpack_require__(5880);

const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  GUID,
  kForOnEventAttribute,
  kListener,
  kStatusCode,
  kWebSocket,
  NOOP
} = __webpack_require__(2614);
const {
  EventTarget: { addEventListener, removeEventListener }
} = __webpack_require__(597);
const { format, parse } = __webpack_require__(5926);
const { toBuffer } = __webpack_require__(3338);

const closeTimeout = 30 * 1000;
const kAborted = Symbol('kAborted');
const protocolVersions = [8, 13];
const readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
const subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;

/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */
class WebSocket extends EventEmitter {
  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  constructor(address, protocols, options) {
    super();

    this._binaryType = BINARY_TYPES[0];
    this._closeCode = 1006;
    this._closeFrameReceived = false;
    this._closeFrameSent = false;
    this._closeMessage = EMPTY_BUFFER;
    this._closeTimer = null;
    this._errorEmitted = false;
    this._extensions = {};
    this._paused = false;
    this._protocol = '';
    this._readyState = WebSocket.CONNECTING;
    this._receiver = null;
    this._sender = null;
    this._socket = null;

    if (address !== null) {
      this._bufferedAmount = 0;
      this._isServer = false;
      this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (typeof protocols === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(this, address, protocols, options);
    } else {
      this._autoPong = options.autoPong;
      this._isServer = true;
    }
  }

  /**
   * For historical reasons, the custom "nodebuffer" type is used by the default
   * instead of "blob".
   *
   * @type {String}
   */
  get binaryType() {
    return this._binaryType;
  }

  set binaryType(type) {
    if (!BINARY_TYPES.includes(type)) return;

    this._binaryType = type;

    //
    // Allow to change `binaryType` on the fly.
    //
    if (this._receiver) this._receiver._binaryType = type;
  }

  /**
   * @type {Number}
   */
  get bufferedAmount() {
    if (!this._socket) return this._bufferedAmount;

    return this._socket._writableState.length + this._sender._bufferedBytes;
  }

  /**
   * @type {String}
   */
  get extensions() {
    return Object.keys(this._extensions).join();
  }

  /**
   * @type {Boolean}
   */
  get isPaused() {
    return this._paused;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onclose() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onerror() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onopen() {
    return null;
  }

  /**
   * @type {Function}
   */
  /* istanbul ignore next */
  get onmessage() {
    return null;
  }

  /**
   * @type {String}
   */
  get protocol() {
    return this._protocol;
  }

  /**
   * @type {Number}
   */
  get readyState() {
    return this._readyState;
  }

  /**
   * @type {String}
   */
  get url() {
    return this._url;
  }

  /**
   * Set up the socket and the internal resources.
   *
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Object} options Options object
   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Function} [options.generateMask] The function used to generate the
   *     masking key
   * @param {Number} [options.maxPayload=0] The maximum allowed message size
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @private
   */
  setSocket(socket, head, options) {
    const receiver = new Receiver({
      allowSynchronousEvents: options.allowSynchronousEvents,
      binaryType: this.binaryType,
      extensions: this._extensions,
      isServer: this._isServer,
      maxPayload: options.maxPayload,
      skipUTF8Validation: options.skipUTF8Validation
    });

    const sender = new Sender(socket, this._extensions, options.generateMask);

    this._receiver = receiver;
    this._sender = sender;
    this._socket = socket;

    receiver[kWebSocket] = this;
    sender[kWebSocket] = this;
    socket[kWebSocket] = this;

    receiver.on('conclude', receiverOnConclude);
    receiver.on('drain', receiverOnDrain);
    receiver.on('error', receiverOnError);
    receiver.on('message', receiverOnMessage);
    receiver.on('ping', receiverOnPing);
    receiver.on('pong', receiverOnPong);

    sender.onerror = senderOnError;

    //
    // These methods may not be available if `socket` is just a `Duplex`.
    //
    if (socket.setTimeout) socket.setTimeout(0);
    if (socket.setNoDelay) socket.setNoDelay();

    if (head.length > 0) socket.unshift(head);

    socket.on('close', socketOnClose);
    socket.on('data', socketOnData);
    socket.on('end', socketOnEnd);
    socket.on('error', socketOnError);

    this._readyState = WebSocket.OPEN;
    this.emit('open');
  }

  /**
   * Emit the `'close'` event.
   *
   * @private
   */
  emitClose() {
    if (!this._socket) {
      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
      return;
    }

    if (this._extensions[PerMessageDeflate.extensionName]) {
      this._extensions[PerMessageDeflate.extensionName].cleanup();
    }

    this._receiver.removeAllListeners();
    this._readyState = WebSocket.CLOSED;
    this.emit('close', this._closeCode, this._closeMessage);
  }

  /**
   * Start a closing handshake.
   *
   *          +----------+   +-----------+   +----------+
   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
   *    |     +----------+   +-----------+   +----------+     |
   *          +----------+   +-----------+         |
   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
   *          +----------+   +-----------+   |
   *    |           |                        |   +---+        |
   *                +------------------------+-->|fin| - - - -
   *    |         +---+                      |   +---+
   *     - - - - -|fin|<---------------------+
   *              +---+
   *
   * @param {Number} [code] Status code explaining why the connection is closing
   * @param {(String|Buffer)} [data] The reason why the connection is
   *     closing
   * @public
   */
  close(code, data) {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this.readyState === WebSocket.CLOSING) {
      if (
        this._closeFrameSent &&
        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)
      ) {
        this._socket.end();
      }

      return;
    }

    this._readyState = WebSocket.CLOSING;
    this._sender.close(code, data, !this._isServer, (err) => {
      //
      // This error is handled by the `'error'` listener on the socket. We only
      // want to know if the close frame has been sent here.
      //
      if (err) return;

      this._closeFrameSent = true;

      if (
        this._closeFrameReceived ||
        this._receiver._writableState.errorEmitted
      ) {
        this._socket.end();
      }
    });

    setCloseTimer(this);
  }

  /**
   * Pause the socket.
   *
   * @public
   */
  pause() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = true;
    this._socket.pause();
  }

  /**
   * Send a ping.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the ping is sent
   * @public
   */
  ping(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.ping(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Send a pong.
   *
   * @param {*} [data] The data to send
   * @param {Boolean} [mask] Indicates whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when the pong is sent
   * @public
   */
  pong(data, mask, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof data === 'function') {
      cb = data;
      data = mask = undefined;
    } else if (typeof mask === 'function') {
      cb = mask;
      mask = undefined;
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    if (mask === undefined) mask = !this._isServer;
    this._sender.pong(data || EMPTY_BUFFER, mask, cb);
  }

  /**
   * Resume the socket.
   *
   * @public
   */
  resume() {
    if (
      this.readyState === WebSocket.CONNECTING ||
      this.readyState === WebSocket.CLOSED
    ) {
      return;
    }

    this._paused = false;
    if (!this._receiver._writableState.needDrain) this._socket.resume();
  }

  /**
   * Send a data message.
   *
   * @param {*} data The message to send
   * @param {Object} [options] Options object
   * @param {Boolean} [options.binary] Specifies whether `data` is binary or
   *     text
   * @param {Boolean} [options.compress] Specifies whether or not to compress
   *     `data`
   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
   *     last one
   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
   * @param {Function} [cb] Callback which is executed when data is written out
   * @public
   */
  send(data, options, cb) {
    if (this.readyState === WebSocket.CONNECTING) {
      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
    }

    if (typeof options === 'function') {
      cb = options;
      options = {};
    }

    if (typeof data === 'number') data = data.toString();

    if (this.readyState !== WebSocket.OPEN) {
      sendAfterClose(this, data, cb);
      return;
    }

    const opts = {
      binary: typeof data !== 'string',
      mask: !this._isServer,
      compress: true,
      fin: true,
      ...options
    };

    if (!this._extensions[PerMessageDeflate.extensionName]) {
      opts.compress = false;
    }

    this._sender.send(data || EMPTY_BUFFER, opts, cb);
  }

  /**
   * Forcibly close the connection.
   *
   * @public
   */
  terminate() {
    if (this.readyState === WebSocket.CLOSED) return;
    if (this.readyState === WebSocket.CONNECTING) {
      const msg = 'WebSocket was closed before the connection was established';
      abortHandshake(this, this._req, msg);
      return;
    }

    if (this._socket) {
      this._readyState = WebSocket.CLOSING;
      this._socket.destroy();
    }
  }
}

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */
Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */
Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});

[
  'binaryType',
  'bufferedAmount',
  'extensions',
  'isPaused',
  'protocol',
  'readyState',
  'url'
].forEach((property) => {
  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });
});

//
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//
['open', 'error', 'close', 'message'].forEach((method) => {
  Object.defineProperty(WebSocket.prototype, `on${method}`, {
    enumerable: true,
    get() {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) return listener[kListener];
      }

      return null;
    },
    set(handler) {
      for (const listener of this.listeners(method)) {
        if (listener[kForOnEventAttribute]) {
          this.removeListener(method, listener);
          break;
        }
      }

      if (typeof handler !== 'function') return;

      this.addEventListener(method, handler, {
        [kForOnEventAttribute]: true
      });
    }
  });
});

WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;

module.exports = WebSocket;

/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any
 *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple
 *     times in the same tick
 * @param {Boolean} [options.autoPong=true] Specifies whether or not to
 *     automatically send a pong in response to a ping
 * @param {Function} [options.finishRequest] A function which can be used to
 *     customize the headers of each http request before it is sent
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Function} [options.generateMask] The function used to generate the
 *     masking key
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */
function initAsClient(websocket, address, protocols, options) {
  const opts = {
    allowSynchronousEvents: true,
    autoPong: true,
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10,
    ...options,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: 'GET',
    host: undefined,
    path: undefined,
    port: undefined
  };

  websocket._autoPong = opts.autoPong;

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError(
      `Unsupported protocol version: ${opts.protocolVersion} ` +
        `(supported versions: ${protocolVersions.join(', ')})`
    );
  }

  let parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError(`Invalid URL: ${address}`);
    }
  }

  if (parsedUrl.protocol === 'http:') {
    parsedUrl.protocol = 'ws:';
  } else if (parsedUrl.protocol === 'https:') {
    parsedUrl.protocol = 'wss:';
  }

  websocket._url = parsedUrl.href;

  const isSecure = parsedUrl.protocol === 'wss:';
  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';
  let invalidUrlMessage;

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {
    invalidUrlMessage =
      'The URL\'s protocol must be one of "ws:", "wss:", ' +
      '"http:", "https:", or "ws+unix:"';
  } else if (isIpcUrl && !parsedUrl.pathname) {
    invalidUrlMessage = "The URL's pathname is empty";
  } else if (parsedUrl.hash) {
    invalidUrlMessage = 'The URL contains a fragment identifier';
  }

  if (invalidUrlMessage) {
    const err = new SyntaxError(invalidUrlMessage);

    if (websocket._redirects === 0) {
      throw err;
    } else {
      emitErrorAndClose(websocket, err);
      return;
    }
  }

  const defaultPort = isSecure ? 443 : 80;
  const key = randomBytes(16).toString('base64');
  const request = isSecure ? https.request : http.request;
  const protocolSet = new Set();
  let perMessageDeflate;

  opts.createConnection =
    opts.createConnection || (isSecure ? tlsConnect : netConnect);
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[')
    ? parsedUrl.hostname.slice(1, -1)
    : parsedUrl.hostname;
  opts.headers = {
    ...opts.headers,
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  };
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(
      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},
      false,
      opts.maxPayload
    );
    opts.headers['Sec-WebSocket-Extensions'] = format({
      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
    });
  }
  if (protocols.length) {
    for (const protocol of protocols) {
      if (
        typeof protocol !== 'string' ||
        !subprotocolRegex.test(protocol) ||
        protocolSet.has(protocol)
      ) {
        throw new SyntaxError(
          'An invalid or duplicated subprotocol was specified'
        );
      }

      protocolSet.add(protocol);
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }
  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }
  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
  }

  if (isIpcUrl) {
    const parts = opts.path.split(':');

    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  let req;

  if (opts.followRedirects) {
    if (websocket._redirects === 0) {
      websocket._originalIpc = isIpcUrl;
      websocket._originalSecure = isSecure;
      websocket._originalHostOrSocketPath = isIpcUrl
        ? opts.socketPath
        : parsedUrl.host;

      const headers = options && options.headers;

      //
      // Shallow copy the user provided options so that headers can be changed
      // without mutating the original object.
      //
      options = { ...options, headers: {} };

      if (headers) {
        for (const [key, value] of Object.entries(headers)) {
          options.headers[key.toLowerCase()] = value;
        }
      }
    } else if (websocket.listenerCount('redirect') === 0) {
      const isSameHost = isIpcUrl
        ? websocket._originalIpc
          ? opts.socketPath === websocket._originalHostOrSocketPath
          : false
        : websocket._originalIpc
          ? false
          : parsedUrl.host === websocket._originalHostOrSocketPath;

      if (!isSameHost || (websocket._originalSecure && !isSecure)) {
        //
        // Match curl 7.77.0 behavior and drop the following headers. These
        // headers are also dropped when following a redirect to a subdomain.
        //
        delete opts.headers.authorization;
        delete opts.headers.cookie;

        if (!isSameHost) delete opts.headers.host;

        opts.auth = undefined;
      }
    }

    //
    // Match curl 7.77.0 behavior and make the first `Authorization` header win.
    // If the `Authorization` header is set, then there is nothing to do as it
    // will take precedence.
    //
    if (opts.auth && !options.headers.authorization) {
      options.headers.authorization =
        'Basic ' + Buffer.from(opts.auth).toString('base64');
    }

    req = websocket._req = request(opts);

    if (websocket._redirects) {
      //
      // Unlike what is done for the `'upgrade'` event, no early exit is
      // triggered here if the user calls `websocket.close()` or
      // `websocket.terminate()` from a listener of the `'redirect'` event. This
      // is because the user can also call `request.destroy()` with an error
      // before calling `websocket.close()` or `websocket.terminate()` and this
      // would result in an error being emitted on the `request` object with no
      // `'error'` event listeners attached.
      //
      websocket.emit('redirect', websocket.url, req);
    }
  } else {
    req = websocket._req = request(opts);
  }

  if (opts.timeout) {
    req.on('timeout', () => {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', (err) => {
    if (req === null || req[kAborted]) return;

    req = websocket._req = null;
    emitErrorAndClose(websocket, err);
  });

  req.on('response', (res) => {
    const location = res.headers.location;
    const statusCode = res.statusCode;

    if (
      location &&
      opts.followRedirects &&
      statusCode >= 300 &&
      statusCode < 400
    ) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();

      let addr;

      try {
        addr = new URL(location, address);
      } catch (e) {
        const err = new SyntaxError(`Invalid URL: ${location}`);
        emitErrorAndClose(websocket, err);
        return;
      }

      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(
        websocket,
        req,
        `Unexpected server response: ${res.statusCode}`
      );
    }
  });

  req.on('upgrade', (res, socket, head) => {
    websocket.emit('upgrade', res);

    //
    // The user may have closed the connection from a listener of the
    // `'upgrade'` event.
    //
    if (websocket.readyState !== WebSocket.CONNECTING) return;

    req = websocket._req = null;

    const upgrade = res.headers.upgrade;

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      abortHandshake(websocket, socket, 'Invalid Upgrade header');
      return;
    }

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    const serverProt = res.headers['sec-websocket-protocol'];
    let protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;

    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        const message =
          'Server sent a Sec-WebSocket-Extensions header but no extension ' +
          'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      let extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      const extensionNames = Object.keys(extensions);

      if (
        extensionNames.length !== 1 ||
        extensionNames[0] !== PerMessageDeflate.extensionName
      ) {
        const message = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, message);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] =
        perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      allowSynchronousEvents: opts.allowSynchronousEvents,
      generateMask: opts.generateMask,
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });

  if (opts.finishRequest) {
    opts.finishRequest(req, websocket);
  } else {
    req.end();
  }
}

/**
 * Emit the `'error'` and `'close'` events.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {Error} The error to emit
 * @private
 */
function emitErrorAndClose(websocket, err) {
  websocket._readyState = WebSocket.CLOSING;
  //
  // The following assignment is practically useless and is done only for
  // consistency.
  //
  websocket._errorEmitted = true;
  websocket.emit('error', err);
  websocket.emitClose();
}

/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */
function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}

/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */
function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}

/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */
function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;

  const err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream[kAborted] = true;
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    process.nextTick(emitErrorAndClose, websocket, err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}

/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */
function sendAfterClose(websocket, data, cb) {
  if (data) {
    const length = isBlob(data) ? data.size : toBuffer(data).length;

    //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //
    if (websocket._socket) websocket._sender._bufferedBytes += length;
    else websocket._bufferedAmount += length;
  }

  if (cb) {
    const err = new Error(
      `WebSocket is not open: readyState ${websocket.readyState} ` +
        `(${readyStates[websocket.readyState]})`
    );
    process.nextTick(cb, err);
  }
}

/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */
function receiverOnConclude(code, reason) {
  const websocket = this[kWebSocket];

  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;

  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);
  process.nextTick(resume, websocket._socket);

  if (code === 1005) websocket.close();
  else websocket.close(code, reason);
}

/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */
function receiverOnDrain() {
  const websocket = this[kWebSocket];

  if (!websocket.isPaused) websocket._socket.resume();
}

/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */
function receiverOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData);

    //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //
    process.nextTick(resume, websocket._socket);

    websocket.close(err[kStatusCode]);
  }

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */
function receiverOnFinish() {
  this[kWebSocket].emitClose();
}

/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */
function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}

/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */
function receiverOnPing(data) {
  const websocket = this[kWebSocket];

  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
  websocket.emit('ping', data);
}

/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */
function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}

/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */
function resume(stream) {
  stream.resume();
}

/**
 * The `Sender` error event handler.
 *
 * @param {Error} The error
 * @private
 */
function senderOnError(err) {
  const websocket = this[kWebSocket];

  if (websocket.readyState === WebSocket.CLOSED) return;
  if (websocket.readyState === WebSocket.OPEN) {
    websocket._readyState = WebSocket.CLOSING;
    setCloseTimer(websocket);
  }

  //
  // `socket.end()` is used instead of `socket.destroy()` to allow the other
  // peer to finish sending queued data. There is no need to set a timer here
  // because `CLOSING` means that it is already set or not needed.
  //
  this._socket.end();

  if (!websocket._errorEmitted) {
    websocket._errorEmitted = true;
    websocket.emit('error', err);
  }
}

/**
 * Set a timer to destroy the underlying raw socket of a WebSocket.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @private
 */
function setCloseTimer(websocket) {
  websocket._closeTimer = setTimeout(
    websocket._socket.destroy.bind(websocket._socket),
    closeTimeout
  );
}

/**
 * The listener of the socket `'close'` event.
 *
 * @private
 */
function socketOnClose() {
  const websocket = this[kWebSocket];

  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);

  websocket._readyState = WebSocket.CLOSING;

  let chunk;

  //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //
  if (
    !this._readableState.endEmitted &&
    !websocket._closeFrameReceived &&
    !websocket._receiver._writableState.errorEmitted &&
    (chunk = websocket._socket.read()) !== null
  ) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;

  clearTimeout(websocket._closeTimer);

  if (
    websocket._receiver._writableState.finished ||
    websocket._receiver._writableState.errorEmitted
  ) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);
    websocket._receiver.on('finish', receiverOnFinish);
  }
}

/**
 * The listener of the socket `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}

/**
 * The listener of the socket `'end'` event.
 *
 * @private
 */
function socketOnEnd() {
  const websocket = this[kWebSocket];

  websocket._readyState = WebSocket.CLOSING;
  websocket._receiver.end();
  this.end();
}

/**
 * The listener of the socket `'error'` event.
 *
 * @private
 */
function socketOnError() {
  const websocket = this[kWebSocket];

  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}


/***/ }),

/***/ 1064:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(9612);

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),

/***/ 1237:
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),

/***/ 1333:
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),

/***/ 1362:
/***/ ((module) => {

// populates missing values
module.exports = function(dst, src) {

  Object.keys(src).forEach(function(prop)
  {
    dst[prop] = dst[prop] || src[prop];
  });

  return dst;
};


/***/ }),

/***/ 1398:
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),

/***/ 1514:
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),

/***/ 1722:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Duplex$", "caughtErrors": "none" }] */



const EventEmitter = __webpack_require__(4434);
const http = __webpack_require__(8611);
const { Duplex } = __webpack_require__(2203);
const { createHash } = __webpack_require__(6982);

const extension = __webpack_require__(5926);
const PerMessageDeflate = __webpack_require__(2971);
const subprotocol = __webpack_require__(8237);
const WebSocket = __webpack_require__(1060);
const { GUID, kWebSocket } = __webpack_require__(2614);

const keyRegex = /^[+/0-9A-Za-z]{22}==$/;

const RUNNING = 0;
const CLOSING = 1;
const CLOSED = 2;

/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */
class WebSocketServer extends EventEmitter {
  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {Boolean} [options.autoPong=true] Specifies whether or not to
   *     automatically send a pong in response to a ping
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
   *     class to use. It must be the `WebSocket` class or class that extends it
   * @param {Function} [callback] A listener for the `listening` event
   */
  constructor(options, callback) {
    super();

    options = {
      allowSynchronousEvents: true,
      autoPong: true,
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null, // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null,
      WebSocket,
      ...options
    };

    if (
      (options.port == null && !options.server && !options.noServer) ||
      (options.port != null && (options.server || options.noServer)) ||
      (options.server && options.noServer)
    ) {
      throw new TypeError(
        'One and only one of the "port", "server", or "noServer" options ' +
          'must be specified'
      );
    }

    if (options.port != null) {
      this._server = http.createServer((req, res) => {
        const body = http.STATUS_CODES[426];

        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });
      this._server.listen(
        options.port,
        options.host,
        options.backlog,
        callback
      );
    } else if (options.server) {
      this._server = options.server;
    }

    if (this._server) {
      const emitConnection = this.emit.bind(this, 'connection');

      this._removeListeners = addListeners(this._server, {
        listening: this.emit.bind(this, 'listening'),
        error: this.emit.bind(this, 'error'),
        upgrade: (req, socket, head) => {
          this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};
    if (options.clientTracking) {
      this.clients = new Set();
      this._shouldEmitClose = false;
    }

    this.options = options;
    this._state = RUNNING;
  }

  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */
  address() {
    if (this.options.noServer) {
      throw new Error('The server is operating in "noServer" mode');
    }

    if (!this._server) return null;
    return this._server.address();
  }

  /**
   * Stop the server from accepting new connections and emit the `'close'` event
   * when all existing connections are closed.
   *
   * @param {Function} [cb] A one-time listener for the `'close'` event
   * @public
   */
  close(cb) {
    if (this._state === CLOSED) {
      if (cb) {
        this.once('close', () => {
          cb(new Error('The server is not running'));
        });
      }

      process.nextTick(emitClose, this);
      return;
    }

    if (cb) this.once('close', cb);

    if (this._state === CLOSING) return;
    this._state = CLOSING;

    if (this.options.noServer || this.options.server) {
      if (this._server) {
        this._removeListeners();
        this._removeListeners = this._server = null;
      }

      if (this.clients) {
        if (!this.clients.size) {
          process.nextTick(emitClose, this);
        } else {
          this._shouldEmitClose = true;
        }
      } else {
        process.nextTick(emitClose, this);
      }
    } else {
      const server = this._server;

      this._removeListeners();
      this._removeListeners = this._server = null;

      //
      // The HTTP/S server was created internally. Close it, and rely on its
      // `'close'` event.
      //
      server.close(() => {
        emitClose(this);
      });
    }
  }

  /**
   * See if a given request should be handled by this server instance.
   *
   * @param {http.IncomingMessage} req Request object to inspect
   * @return {Boolean} `true` if the request is valid, else `false`
   * @public
   */
  shouldHandle(req) {
    if (this.options.path) {
      const index = req.url.indexOf('?');
      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;

      if (pathname !== this.options.path) return false;
    }

    return true;
  }

  /**
   * Handle a HTTP Upgrade request.
   *
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @public
   */
  handleUpgrade(req, socket, head, cb) {
    socket.on('error', socketOnError);

    const key = req.headers['sec-websocket-key'];
    const upgrade = req.headers.upgrade;
    const version = +req.headers['sec-websocket-version'];

    if (req.method !== 'GET') {
      const message = 'Invalid HTTP method';
      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
      return;
    }

    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {
      const message = 'Invalid Upgrade header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (key === undefined || !keyRegex.test(key)) {
      const message = 'Missing or invalid Sec-WebSocket-Key header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (version !== 8 && version !== 13) {
      const message = 'Missing or invalid Sec-WebSocket-Version header';
      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
      return;
    }

    if (!this.shouldHandle(req)) {
      abortHandshake(socket, 400);
      return;
    }

    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];
    let protocols = new Set();

    if (secWebSocketProtocol !== undefined) {
      try {
        protocols = subprotocol.parse(secWebSocketProtocol);
      } catch (err) {
        const message = 'Invalid Sec-WebSocket-Protocol header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];
    const extensions = {};

    if (
      this.options.perMessageDeflate &&
      secWebSocketExtensions !== undefined
    ) {
      const perMessageDeflate = new PerMessageDeflate(
        this.options.perMessageDeflate,
        true,
        this.options.maxPayload
      );

      try {
        const offers = extension.parse(secWebSocketExtensions);

        if (offers[PerMessageDeflate.extensionName]) {
          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
      } catch (err) {
        const message =
          'Invalid or unacceptable Sec-WebSocket-Extensions header';
        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
        return;
      }
    }

    //
    // Optionally call external client verification handler.
    //
    if (this.options.verifyClient) {
      const info = {
        origin:
          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],
        secure: !!(req.socket.authorized || req.socket.encrypted),
        req
      };

      if (this.options.verifyClient.length === 2) {
        this.options.verifyClient(info, (verified, code, message, headers) => {
          if (!verified) {
            return abortHandshake(socket, code || 401, message, headers);
          }

          this.completeUpgrade(
            extensions,
            key,
            protocols,
            req,
            socket,
            head,
            cb
          );
        });
        return;
      }

      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
    }

    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
  }

  /**
   * Upgrade the connection to WebSocket.
   *
   * @param {Object} extensions The accepted extensions
   * @param {String} key The value of the `Sec-WebSocket-Key` header
   * @param {Set} protocols The subprotocols
   * @param {http.IncomingMessage} req The request object
   * @param {Duplex} socket The network socket between the server and client
   * @param {Buffer} head The first packet of the upgraded stream
   * @param {Function} cb Callback
   * @throws {Error} If called more than once with the same socket
   * @private
   */
  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
    //
    // Destroy the socket if the client has already sent a FIN packet.
    //
    if (!socket.readable || !socket.writable) return socket.destroy();

    if (socket[kWebSocket]) {
      throw new Error(
        'server.handleUpgrade() was called more than once with the same ' +
          'socket, possibly due to a misconfiguration'
      );
    }

    if (this._state > RUNNING) return abortHandshake(socket, 503);

    const digest = createHash('sha1')
      .update(key + GUID)
      .digest('base64');

    const headers = [
      'HTTP/1.1 101 Switching Protocols',
      'Upgrade: websocket',
      'Connection: Upgrade',
      `Sec-WebSocket-Accept: ${digest}`
    ];

    const ws = new this.options.WebSocket(null, undefined, this.options);

    if (protocols.size) {
      //
      // Optionally call external protocol selection handler.
      //
      const protocol = this.options.handleProtocols
        ? this.options.handleProtocols(protocols, req)
        : protocols.values().next().value;

      if (protocol) {
        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);
        ws._protocol = protocol;
      }
    }

    if (extensions[PerMessageDeflate.extensionName]) {
      const params = extensions[PerMessageDeflate.extensionName].params;
      const value = extension.format({
        [PerMessageDeflate.extensionName]: [params]
      });
      headers.push(`Sec-WebSocket-Extensions: ${value}`);
      ws._extensions = extensions;
    }

    //
    // Allow external modification/inspection of handshake headers.
    //
    this.emit('headers', headers, req);

    socket.write(headers.concat('\r\n').join('\r\n'));
    socket.removeListener('error', socketOnError);

    ws.setSocket(socket, head, {
      allowSynchronousEvents: this.options.allowSynchronousEvents,
      maxPayload: this.options.maxPayload,
      skipUTF8Validation: this.options.skipUTF8Validation
    });

    if (this.clients) {
      this.clients.add(ws);
      ws.on('close', () => {
        this.clients.delete(ws);

        if (this._shouldEmitClose && !this.clients.size) {
          process.nextTick(emitClose, this);
        }
      });
    }

    cb(ws, req);
  }
}

module.exports = WebSocketServer;

/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */
function addListeners(server, map) {
  for (const event of Object.keys(map)) server.on(event, map[event]);

  return function removeListeners() {
    for (const event of Object.keys(map)) {
      server.removeListener(event, map[event]);
    }
  };
}

/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */
function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}

/**
 * Handle socket errors.
 *
 * @private
 */
function socketOnError() {
  this.destroy();
}

/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */
function abortHandshake(socket, code, message, headers) {
  //
  // The socket is writable unless the user destroyed or ended it before calling
  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user
  // error. Handling this does not make much sense as the worst that can happen
  // is that some of the data written by the user might be discarded due to the
  // call to `socket.end()` below, which triggers an `'error'` event that in
  // turn causes the socket to be destroyed.
  //
  message = message || http.STATUS_CODES[code];
  headers = {
    Connection: 'close',
    'Content-Type': 'text/html',
    'Content-Length': Buffer.byteLength(message),
    ...headers
  };

  socket.once('finish', socket.destroy);

  socket.end(
    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r\n` +
      Object.keys(headers)
        .map((h) => `${h}: ${headers[h]}`)
        .join('\r\n') +
      '\r\n\r\n' +
      message
  );
}

/**
 * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least
 * one listener for it, otherwise call `abortHandshake()`.
 *
 * @param {WebSocketServer} server The WebSocket server
 * @param {http.IncomingMessage} req The request object
 * @param {Duplex} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} message The HTTP response body
 * @private
 */
function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
  if (server.listenerCount('wsClientError')) {
    const err = new Error(message);
    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);

    server.emit('wsClientError', err, socket, req);
  } else {
    abortHandshake(socket, code, message);
  }
}


/***/ }),

/***/ 1813:
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),

/***/ 1873:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports =
{
  parallel      : __webpack_require__(8798),
  serial        : __webpack_require__(2081),
  serialOrdered : __webpack_require__(28)
};


/***/ }),

/***/ 1962:
/***/ ((module) => {

"use strict";
module.exports = require("bufferutil");

/***/ }),

/***/ 2018:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 2081:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var serialOrdered = __webpack_require__(28);

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),

/***/ 2203:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 2313:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defer = __webpack_require__(405);

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),

/***/ 2414:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 2414;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 2613:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 2614:
/***/ ((module) => {

"use strict";


const BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];
const hasBlob = typeof Blob !== 'undefined';

if (hasBlob) BINARY_TYPES.push('blob');

module.exports = {
  BINARY_TYPES,
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  hasBlob,
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: () => {}
};


/***/ }),

/***/ 2971:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const zlib = __webpack_require__(3106);

const bufferUtil = __webpack_require__(3338);
const Limiter = __webpack_require__(4759);
const { kStatusCode } = __webpack_require__(2614);

const FastBuffer = Buffer[Symbol.species];
const TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
const kPerMessageDeflate = Symbol('permessage-deflate');
const kTotalLength = Symbol('total-length');
const kCallback = Symbol('callback');
const kBuffers = Symbol('buffers');
const kError = Symbol('error');

//
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//
let zlibLimiter;

/**
 * permessage-deflate implementation.
 */
class PerMessageDeflate {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  constructor(options, isServer, maxPayload) {
    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold =
      this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;

    this.params = null;

    if (!zlibLimiter) {
      const concurrency =
        this._options.concurrencyLimit !== undefined
          ? this._options.concurrencyLimit
          : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }

  /**
   * @type {String}
   */
  static get extensionName() {
    return 'permessage-deflate';
  }

  /**
   * Create an extension negotiation offer.
   *
   * @return {Object} Extension parameters
   * @public
   */
  offer() {
    const params = {};

    if (this._options.serverNoContextTakeover) {
      params.server_no_context_takeover = true;
    }
    if (this._options.clientNoContextTakeover) {
      params.client_no_context_takeover = true;
    }
    if (this._options.serverMaxWindowBits) {
      params.server_max_window_bits = this._options.serverMaxWindowBits;
    }
    if (this._options.clientMaxWindowBits) {
      params.client_max_window_bits = this._options.clientMaxWindowBits;
    } else if (this._options.clientMaxWindowBits == null) {
      params.client_max_window_bits = true;
    }

    return params;
  }

  /**
   * Accept an extension negotiation offer/response.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Object} Accepted configuration
   * @public
   */
  accept(configurations) {
    configurations = this.normalizeParams(configurations);

    this.params = this._isServer
      ? this.acceptAsServer(configurations)
      : this.acceptAsClient(configurations);

    return this.params;
  }

  /**
   * Releases all resources used by the extension.
   *
   * @public
   */
  cleanup() {
    if (this._inflate) {
      this._inflate.close();
      this._inflate = null;
    }

    if (this._deflate) {
      const callback = this._deflate[kCallback];

      this._deflate.close();
      this._deflate = null;

      if (callback) {
        callback(
          new Error(
            'The deflate stream was closed while data was being processed'
          )
        );
      }
    }
  }

  /**
   *  Accept an extension negotiation offer.
   *
   * @param {Array} offers The extension negotiation offers
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsServer(offers) {
    const opts = this._options;
    const accepted = offers.find((params) => {
      if (
        (opts.serverNoContextTakeover === false &&
          params.server_no_context_takeover) ||
        (params.server_max_window_bits &&
          (opts.serverMaxWindowBits === false ||
            (typeof opts.serverMaxWindowBits === 'number' &&
              opts.serverMaxWindowBits > params.server_max_window_bits))) ||
        (typeof opts.clientMaxWindowBits === 'number' &&
          !params.client_max_window_bits)
      ) {
        return false;
      }

      return true;
    });

    if (!accepted) {
      throw new Error('None of the extension offers can be accepted');
    }

    if (opts.serverNoContextTakeover) {
      accepted.server_no_context_takeover = true;
    }
    if (opts.clientNoContextTakeover) {
      accepted.client_no_context_takeover = true;
    }
    if (typeof opts.serverMaxWindowBits === 'number') {
      accepted.server_max_window_bits = opts.serverMaxWindowBits;
    }
    if (typeof opts.clientMaxWindowBits === 'number') {
      accepted.client_max_window_bits = opts.clientMaxWindowBits;
    } else if (
      accepted.client_max_window_bits === true ||
      opts.clientMaxWindowBits === false
    ) {
      delete accepted.client_max_window_bits;
    }

    return accepted;
  }

  /**
   * Accept the extension negotiation response.
   *
   * @param {Array} response The extension negotiation response
   * @return {Object} Accepted configuration
   * @private
   */
  acceptAsClient(response) {
    const params = response[0];

    if (
      this._options.clientNoContextTakeover === false &&
      params.client_no_context_takeover
    ) {
      throw new Error('Unexpected parameter "client_no_context_takeover"');
    }

    if (!params.client_max_window_bits) {
      if (typeof this._options.clientMaxWindowBits === 'number') {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      }
    } else if (
      this._options.clientMaxWindowBits === false ||
      (typeof this._options.clientMaxWindowBits === 'number' &&
        params.client_max_window_bits > this._options.clientMaxWindowBits)
    ) {
      throw new Error(
        'Unexpected or invalid parameter "client_max_window_bits"'
      );
    }

    return params;
  }

  /**
   * Normalize parameters.
   *
   * @param {Array} configurations The extension negotiation offers/reponse
   * @return {Array} The offers/response with normalized parameters
   * @private
   */
  normalizeParams(configurations) {
    configurations.forEach((params) => {
      Object.keys(params).forEach((key) => {
        let value = params[key];

        if (value.length > 1) {
          throw new Error(`Parameter "${key}" must have only a single value`);
        }

        value = value[0];

        if (key === 'client_max_window_bits') {
          if (value !== true) {
            const num = +value;
            if (!Number.isInteger(num) || num < 8 || num > 15) {
              throw new TypeError(
                `Invalid value for parameter "${key}": ${value}`
              );
            }
            value = num;
          } else if (!this._isServer) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else if (key === 'server_max_window_bits') {
          const num = +value;
          if (!Number.isInteger(num) || num < 8 || num > 15) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
          value = num;
        } else if (
          key === 'client_no_context_takeover' ||
          key === 'server_no_context_takeover'
        ) {
          if (value !== true) {
            throw new TypeError(
              `Invalid value for parameter "${key}": ${value}`
            );
          }
        } else {
          throw new Error(`Unknown parameter "${key}"`);
        }

        params[key] = value;
      });
    });

    return configurations;
  }

  /**
   * Decompress data. Concurrency limited.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  decompress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._decompress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Compress data. Concurrency limited.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @public
   */
  compress(data, fin, callback) {
    zlibLimiter.add((done) => {
      this._compress(data, fin, (err, result) => {
        done();
        callback(err, result);
      });
    });
  }

  /**
   * Decompress data.
   *
   * @param {Buffer} data Compressed data
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _decompress(data, fin, callback) {
    const endpoint = this._isServer ? 'client' : 'server';

    if (!this._inflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._inflate = zlib.createInflateRaw({
        ...this._options.zlibInflateOptions,
        windowBits
      });
      this._inflate[kPerMessageDeflate] = this;
      this._inflate[kTotalLength] = 0;
      this._inflate[kBuffers] = [];
      this._inflate.on('error', inflateOnError);
      this._inflate.on('data', inflateOnData);
    }

    this._inflate[kCallback] = callback;

    this._inflate.write(data);
    if (fin) this._inflate.write(TRAILER);

    this._inflate.flush(() => {
      const err = this._inflate[kError];

      if (err) {
        this._inflate.close();
        this._inflate = null;
        callback(err);
        return;
      }

      const data = bufferUtil.concat(
        this._inflate[kBuffers],
        this._inflate[kTotalLength]
      );

      if (this._inflate._readableState.endEmitted) {
        this._inflate.close();
        this._inflate = null;
      } else {
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        if (fin && this.params[`${endpoint}_no_context_takeover`]) {
          this._inflate.reset();
        }
      }

      callback(null, data);
    });
  }

  /**
   * Compress data.
   *
   * @param {(Buffer|String)} data Data to compress
   * @param {Boolean} fin Specifies whether or not this is the last fragment
   * @param {Function} callback Callback
   * @private
   */
  _compress(data, fin, callback) {
    const endpoint = this._isServer ? 'server' : 'client';

    if (!this._deflate) {
      const key = `${endpoint}_max_window_bits`;
      const windowBits =
        typeof this.params[key] !== 'number'
          ? zlib.Z_DEFAULT_WINDOWBITS
          : this.params[key];

      this._deflate = zlib.createDeflateRaw({
        ...this._options.zlibDeflateOptions,
        windowBits
      });

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      this._deflate.on('data', deflateOnData);
    }

    this._deflate[kCallback] = callback;

    this._deflate.write(data);
    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
      if (!this._deflate) {
        //
        // The deflate stream was closed while data was being processed.
        //
        return;
      }

      let data = bufferUtil.concat(
        this._deflate[kBuffers],
        this._deflate[kTotalLength]
      );

      if (fin) {
        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);
      }

      //
      // Ensure that the callback will not be called again in
      // `PerMessageDeflate#cleanup()`.
      //
      this._deflate[kCallback] = null;

      this._deflate[kTotalLength] = 0;
      this._deflate[kBuffers] = [];

      if (fin && this.params[`${endpoint}_no_context_takeover`]) {
        this._deflate.reset();
      }

      callback(null, data);
    });
  }
}

module.exports = PerMessageDeflate;

/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}

/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */
function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (
    this[kPerMessageDeflate]._maxPayload < 1 ||
    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload
  ) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);

  //
  // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the
  // fact that in Node.js versions prior to 13.10.0, the callback for
  // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing
  // `zlib.reset()` ensures that either the callback is invoked or an error is
  // emitted.
  //
  this.reset();
}

/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */
function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;

  if (this[kError]) {
    this[kCallback](this[kError]);
    return;
  }

  err[kStatusCode] = 1007;
  this[kCallback](err);
}


/***/ }),

/***/ 3093:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(4459);

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),

/***/ 3106:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ 3126:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(6743);
var $TypeError = __webpack_require__(9675);

var $call = __webpack_require__(76);
var $actualApply = __webpack_require__(3144);

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),

/***/ 3144:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(6743);

var $apply = __webpack_require__(1002);
var $call = __webpack_require__(76);
var $reflectApply = __webpack_require__(7119);

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),

/***/ 3164:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var url = __webpack_require__(7016);
var URL = url.URL;
var http = __webpack_require__(8611);
var https = __webpack_require__(5692);
var Writable = (__webpack_require__(2203).Writable);
var assert = __webpack_require__(2613);
var debug = __webpack_require__(7507);

// Preventive platform detection
// istanbul ignore next
(function detectUnsupportedEnvironment() {
  var looksLikeNode = typeof process !== "undefined";
  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var looksLikeV8 = isFunction(Error.captureStackTrace);
  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
    console.warn("The follow-redirects package should be excluded from browser builds.");
  }
}());

// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
  assert(new URL(""));
}
catch (error) {
  useNativeURL = error.code === "ERR_INVALID_URL";
}

// URL fields to preserve in copy operations
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash",
];

// Create handlers that pass events from native requests
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = Object.create(null);
events.forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    try {
      self._processResponse(response);
    }
    catch (cause) {
      self.emit("error", cause instanceof RedirectionError ?
        cause : new RedirectionError({ cause: cause }));
    }
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

RedirectableRequest.prototype.abort = function () {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};

RedirectableRequest.prototype.destroy = function (error) {
  destroyRequest(this._currentRequest, error);
  destroy.call(this, error);
  return this;
};

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  }
  else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  var self = this;

  // Destroys the socket on timeout
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }

  // Sets up a timer to trigger a timeout event
  function startTimer(socket) {
    if (self._timeout) {
      clearTimeout(self._timeout);
    }
    self._timeout = setTimeout(function () {
      self.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }

  // Stops a timeout from triggering
  function clearTimer() {
    // Clear the timeout
    if (self._timeout) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }

    // Clean up all attached listeners
    self.removeListener("abort", clearTimer);
    self.removeListener("error", clearTimer);
    self.removeListener("response", clearTimer);
    self.removeListener("close", clearTimer);
    if (callback) {
      self.removeListener("timeout", callback);
    }
    if (!self.socket) {
      self._currentRequest.removeListener("socket", startTimer);
    }
  }

  // Attach callback if passed
  if (callback) {
    this.on("timeout", callback);
  }

  // Start the timer if or when the socket is opened
  if (this.socket) {
    startTimer(this.socket);
  }
  else {
    this._currentRequest.once("socket", startTimer);
  }

  // Clean up on events
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);

  return this;
};

// Proxy all other public ClientRequest methods
[
  "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request and set up its event handlers
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  request._redirectable = this;
  for (var event of events) {
    request.on(event, eventHandlers[event]);
  }

  // RFC7230Â§5.3.1: When making a request directly to an origin server, [â€¦]
  // a client MUST send only the absolute path [â€¦] as the request-target.
  this._currentUrl = /^\//.test(this._options.path) ?
    url.format(this._options) :
    // When making a request to a proxy, [â€¦]
    // a client MUST send the target URI in absolute-form [â€¦].
    this._options.path;

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      // istanbul ignore else
      if (request === self._currentRequest) {
        // Report any write errors
        // istanbul ignore if
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          // istanbul ignore else
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC7231Â§6.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.

  // If the response is not a redirect; return it as-is
  var location = response.headers.location;
  if (!location || this._options.followRedirects === false ||
      statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
    return;
  }

  // The response is a redirect, so abort the current request
  destroyRequest(this._currentRequest);
  // Discard the remainder of the response to avoid waiting for data
  response.destroy();

  // RFC7231Â§6.4: A client SHOULD detect and intervene
  // in cyclical redirections (i.e., "infinite" redirection loops).
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }

  // Store the request headers if applicable
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host"),
    }, this._options.headers);
  }

  // RFC7231Â§6.4: Automatic redirection needs to done with
  // care for methods not known to be safe, [â€¦]
  // RFC7231Â§6.4.2â€“3: For historical reasons, a user agent MAY change
  // the request method from POST to GET for the subsequent request.
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
      // RFC7231Â§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource [â€¦]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) [â€¦]
      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    // Drop a possible entity and headers related to it
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }

  // Drop the Host header, as the redirect might lead to a different host
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

  // If the redirect is relative, carry over the host of the last request
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
    url.format(Object.assign(currentUrlParts, { host: currentHost }));

  // Create the redirected request
  var redirectUrl = resolveUrl(location, currentUrl);
  debug("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);

  // Drop confidential headers when redirecting to a less secure protocol
  // or to a different domain that is not a superdomain
  if (redirectUrl.protocol !== currentUrlParts.protocol &&
     redirectUrl.protocol !== "https:" ||
     redirectUrl.host !== currentHost &&
     !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }

  // Evaluate the beforeRedirect callback
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode: statusCode,
    };
    var requestDetails = {
      url: currentUrl,
      method: method,
      headers: requestHeaders,
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }

  // Perform the redirected request
  this._performRequest();
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    function request(input, options, callback) {
      // Parse parameters, ensuring that input is an object
      if (isURL(input)) {
        input = spreadUrlObject(input);
      }
      else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      }
      else {
        callback = options;
        options = validateUrl(input);
        input = { protocol: protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }

    // Executes a GET request, following redirects
    function get(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }

    // Expose the properties on the wrapped protocol
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true },
    });
  });
  return exports;
}

function noop() { /* empty */ }

function parseUrl(input) {
  var parsed;
  // istanbul ignore else
  if (useNativeURL) {
    parsed = new URL(input);
  }
  else {
    // Ensure the URL is valid and absolute
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}

function resolveUrl(relative, base) {
  // istanbul ignore next
  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}

function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}

function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }

  // Fix IPv6 hostname
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  // Ensure port is a number
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  // Concatenate path
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

  return spread;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return (lastValue === null || typeof lastValue === "undefined") ?
    undefined : String(lastValue).trim();
}

function createErrorType(code, message, baseClass) {
  // Create constructor
  function CustomError(properties) {
    // istanbul ignore else
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    }
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }

  // Attach constructor and set default properties
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false,
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false,
    },
  });
  return CustomError;
}

function destroyRequest(request, error) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop);
  request.destroy(error);
}

function isSubdomain(subdomain, domain) {
  assert(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}

function isString(value) {
  return typeof value === "string" || value instanceof String;
}

function isFunction(value) {
  return typeof value === "function";
}

function isBuffer(value) {
  return typeof value === "object" && ("length" in value);
}

function isURL(value) {
  return URL && value instanceof URL;
}

// Exports
module.exports = wrap({ http: http, https: https });
module.exports.wrap = wrap;


/***/ }),

/***/ 3182:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(9023);
var Stream = (__webpack_require__(2203).Stream);
var DelayedStream = __webpack_require__(8069);

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),

/***/ 3338:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { EMPTY_BUFFER } = __webpack_require__(2614);

const FastBuffer = Buffer[Symbol.species];

/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */
function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];

  const target = Buffer.allocUnsafe(totalLength);
  let offset = 0;

  for (let i = 0; i < list.length; i++) {
    const buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) {
    return new FastBuffer(target.buffer, target.byteOffset, offset);
  }

  return target;
}

/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */
function _mask(source, mask, output, offset, length) {
  for (let i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}

/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */
function _unmask(buffer, mask) {
  for (let i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}

/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */
function toArrayBuffer(buf) {
  if (buf.length === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
}

/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */
function toBuffer(data) {
  toBuffer.readOnly = true;

  if (Buffer.isBuffer(data)) return data;

  let buf;

  if (data instanceof ArrayBuffer) {
    buf = new FastBuffer(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

module.exports = {
  concat,
  mask: _mask,
  toArrayBuffer,
  toBuffer,
  unmask: _unmask
};

/* istanbul ignore else  */
if (!process.env.WS_NO_BUFFER_UTIL) {
  try {
    const bufferUtil = __webpack_require__(1962);

    module.exports.mask = function (source, mask, output, offset, length) {
      if (length < 48) _mask(source, mask, output, offset, length);
      else bufferUtil.mask(source, mask, output, offset, length);
    };

    module.exports.unmask = function (buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);
      else bufferUtil.unmask(buffer, mask);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ 3499:
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),

/***/ 3628:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(8648);
var originalGetProto = __webpack_require__(1064);

var getDunderProto = __webpack_require__(7176);

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),

/***/ 3719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^WebSocket$" }] */


const WebSocket = __webpack_require__(1060);
const { Duplex } = __webpack_require__(2203);

/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */
function emitClose(stream) {
  stream.emit('close');
}

/**
 * The listener of the `'end'` event.
 *
 * @private
 */
function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}

/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */
function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();
  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}

/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */
function createWebSocketStream(ws, options) {
  let terminateOnDestroy = true;

  const duplex = new Duplex({
    ...options,
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  });

  ws.on('message', function message(msg, isBinary) {
    const data =
      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) ws.pause();
  });

  ws.once('error', function error(err) {
    if (duplex.destroyed) return;

    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.
    terminateOnDestroy = false;
    duplex.destroy(err);
  });

  ws.once('close', function close() {
    if (duplex.destroyed) return;

    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    let called = false;

    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });

    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });

    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    }

    // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.
    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });
      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.isPaused) ws.resume();
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;


/***/ }),

/***/ 4039:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(1333);

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),

/***/ 4286:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 4286;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 4434:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 4459:
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),

/***/ 4555:
/***/ ((module) => {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),

/***/ 4756:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 4759:
/***/ ((module) => {

"use strict";


const kDone = Symbol('kDone');
const kRun = Symbol('kRun');

/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */
class Limiter {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  constructor(concurrency) {
    this[kDone] = () => {
      this.pending--;
      this[kRun]();
    };
    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }

  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */
  add(job) {
    this.jobs.push(job);
    this[kRun]();
  }

  /**
   * Removes a job from the queue and runs it if possible.
   *
   * @private
   */
  [kRun]() {
    if (this.pending === this.concurrency) return;

    if (this.jobs.length) {
      const job = this.jobs.shift();

      this.pending++;
      job(this[kDone]);
    }
  }
}

module.exports = Limiter;


/***/ }),

/***/ 5345:
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),

/***/ 5692:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 5753:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(7833);
} else {
	module.exports = __webpack_require__(6033);
}


/***/ }),

/***/ 5795:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(6549);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),

/***/ 5880:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { isUtf8 } = __webpack_require__(181);

const { hasBlob } = __webpack_require__(2614);

//
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore
const tokenChars = [
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];

/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */
function isValidStatusCode(code) {
  return (
    (code >= 1000 &&
      code <= 1014 &&
      code !== 1004 &&
      code !== 1005 &&
      code !== 1006) ||
    (code >= 3000 && code <= 4999)
  );
}

/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */
function _isValidUTF8(buf) {
  const len = buf.length;
  let i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (
        i + 1 === len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (
        i + 2 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong
        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (
        i + 3 >= len ||
        (buf[i + 1] & 0xc0) !== 0x80 ||
        (buf[i + 2] & 0xc0) !== 0x80 ||
        (buf[i + 3] & 0xc0) !== 0x80 ||
        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong
        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||
        buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

/**
 * Determines whether a value is a `Blob`.
 *
 * @param {*} value The value to be tested
 * @return {Boolean} `true` if `value` is a `Blob`, else `false`
 * @private
 */
function isBlob(value) {
  return (
    hasBlob &&
    typeof value === 'object' &&
    typeof value.arrayBuffer === 'function' &&
    typeof value.type === 'string' &&
    typeof value.stream === 'function' &&
    (value[Symbol.toStringTag] === 'Blob' ||
      value[Symbol.toStringTag] === 'File')
  );
}

module.exports = {
  isBlob,
  isValidStatusCode,
  isValidUTF8: _isValidUTF8,
  tokenChars
};

if (isUtf8) {
  module.exports.isValidUTF8 = function (buf) {
    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
  };
} /* istanbul ignore else  */ else if (!process.env.WS_NO_UTF_8_VALIDATE) {
  try {
    const isValidUTF8 = __webpack_require__(6809);

    module.exports.isValidUTF8 = function (buf) {
      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
    };
  } catch (e) {
    // Continue regardless of the error.
  }
}


/***/ }),

/***/ 5884:
/***/ ((module) => {

"use strict";


module.exports = (flag, argv = process.argv) => {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
};


/***/ }),

/***/ 5926:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(5880);

/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */
function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];
  else dest[name].push(elem);
}

/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */
function parse(header) {
  const offers = Object.create(null);
  let params = Object.create(null);
  let mustUnescape = false;
  let isEscaping = false;
  let inQuotes = false;
  let extensionName;
  let paramName;
  let start = -1;
  let code = -1;
  let end = -1;
  let i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (
        i !== 0 &&
        (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        const name = header.slice(start, end);
        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
        if (start === -1) start = i;
        else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22 /* '"' */ && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c /* '\' */) {
          isEscaping = true;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }

        if (end === -1) end = i;
        let value = header.slice(start, end);
        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }
        push(params, paramName, value);
        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  const token = header.slice(start, end);
  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }
    push(offers, extensionName, params);
  }

  return offers;
}

/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */
function format(extensions) {
  return Object.keys(extensions)
    .map((extension) => {
      let configurations = extensions[extension];
      if (!Array.isArray(configurations)) configurations = [configurations];
      return configurations
        .map((params) => {
          return [extension]
            .concat(
              Object.keys(params).map((k) => {
                let values = params[k];
                if (!Array.isArray(values)) values = [values];
                return values
                  .map((v) => (v === true ? k : `${k}=${v}`))
                  .join('; ');
              })
            )
            .join('; ');
        })
        .join(', ');
    })
    .join(', ');
}

module.exports = { format, parse };


/***/ }),

/***/ 6033:
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(2018);
const util = __webpack_require__(9023);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(7687);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(736)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),

/***/ 6049:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(7598)
var extname = (__webpack_require__(6928).extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),

/***/ 6188:
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),

/***/ 6276:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var abort = __webpack_require__(4555)
  , async = __webpack_require__(2313)
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),

/***/ 6286:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { Writable } = __webpack_require__(2203);

const PerMessageDeflate = __webpack_require__(2971);
const {
  BINARY_TYPES,
  EMPTY_BUFFER,
  kStatusCode,
  kWebSocket
} = __webpack_require__(2614);
const { concat, toArrayBuffer, unmask } = __webpack_require__(3338);
const { isValidStatusCode, isValidUTF8 } = __webpack_require__(5880);

const FastBuffer = Buffer[Symbol.species];

const GET_INFO = 0;
const GET_PAYLOAD_LENGTH_16 = 1;
const GET_PAYLOAD_LENGTH_64 = 2;
const GET_MASK = 3;
const GET_DATA = 4;
const INFLATING = 5;
const DEFER_EVENT = 6;

/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */
class Receiver extends Writable {
  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
   *     multiple times in the same tick
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  constructor(options = {}) {
    super();

    this._allowSynchronousEvents =
      options.allowSynchronousEvents !== undefined
        ? options.allowSynchronousEvents
        : true;
    this._binaryType = options.binaryType || BINARY_TYPES[0];
    this._extensions = options.extensions || {};
    this._isServer = !!options.isServer;
    this._maxPayload = options.maxPayload | 0;
    this._skipUTF8Validation = !!options.skipUTF8Validation;
    this[kWebSocket] = undefined;

    this._bufferedBytes = 0;
    this._buffers = [];

    this._compressed = false;
    this._payloadLength = 0;
    this._mask = undefined;
    this._fragmented = 0;
    this._masked = false;
    this._fin = false;
    this._opcode = 0;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragments = [];

    this._errored = false;
    this._loop = false;
    this._state = GET_INFO;
  }

  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */
  _write(chunk, encoding, cb) {
    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();

    this._bufferedBytes += chunk.length;
    this._buffers.push(chunk);
    this.startLoop(cb);
  }

  /**
   * Consumes `n` bytes from the buffered data.
   *
   * @param {Number} n The number of bytes to consume
   * @return {Buffer} The consumed bytes
   * @private
   */
  consume(n) {
    this._bufferedBytes -= n;

    if (n === this._buffers[0].length) return this._buffers.shift();

    if (n < this._buffers[0].length) {
      const buf = this._buffers[0];
      this._buffers[0] = new FastBuffer(
        buf.buffer,
        buf.byteOffset + n,
        buf.length - n
      );

      return new FastBuffer(buf.buffer, buf.byteOffset, n);
    }

    const dst = Buffer.allocUnsafe(n);

    do {
      const buf = this._buffers[0];
      const offset = dst.length - n;

      if (n >= buf.length) {
        dst.set(this._buffers.shift(), offset);
      } else {
        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
        this._buffers[0] = new FastBuffer(
          buf.buffer,
          buf.byteOffset + n,
          buf.length - n
        );
      }

      n -= buf.length;
    } while (n > 0);

    return dst;
  }

  /**
   * Starts the parsing loop.
   *
   * @param {Function} cb Callback
   * @private
   */
  startLoop(cb) {
    this._loop = true;

    do {
      switch (this._state) {
        case GET_INFO:
          this.getInfo(cb);
          break;
        case GET_PAYLOAD_LENGTH_16:
          this.getPayloadLength16(cb);
          break;
        case GET_PAYLOAD_LENGTH_64:
          this.getPayloadLength64(cb);
          break;
        case GET_MASK:
          this.getMask();
          break;
        case GET_DATA:
          this.getData(cb);
          break;
        case INFLATING:
        case DEFER_EVENT:
          this._loop = false;
          return;
      }
    } while (this._loop);

    if (!this._errored) cb();
  }

  /**
   * Reads the first two bytes of a frame.
   *
   * @param {Function} cb Callback
   * @private
   */
  getInfo(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    const buf = this.consume(2);

    if ((buf[0] & 0x30) !== 0x00) {
      const error = this.createError(
        RangeError,
        'RSV2 and RSV3 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_2_3'
      );

      cb(error);
      return;
    }

    const compressed = (buf[0] & 0x40) === 0x40;

    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
      const error = this.createError(
        RangeError,
        'RSV1 must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_RSV_1'
      );

      cb(error);
      return;
    }

    this._fin = (buf[0] & 0x80) === 0x80;
    this._opcode = buf[0] & 0x0f;
    this._payloadLength = buf[1] & 0x7f;

    if (this._opcode === 0x00) {
      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (!this._fragmented) {
        const error = this.createError(
          RangeError,
          'invalid opcode 0',
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._opcode = this._fragmented;
    } else if (this._opcode === 0x01 || this._opcode === 0x02) {
      if (this._fragmented) {
        const error = this.createError(
          RangeError,
          `invalid opcode ${this._opcode}`,
          true,
          1002,
          'WS_ERR_INVALID_OPCODE'
        );

        cb(error);
        return;
      }

      this._compressed = compressed;
    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
      if (!this._fin) {
        const error = this.createError(
          RangeError,
          'FIN must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_FIN'
        );

        cb(error);
        return;
      }

      if (compressed) {
        const error = this.createError(
          RangeError,
          'RSV1 must be clear',
          true,
          1002,
          'WS_ERR_UNEXPECTED_RSV_1'
        );

        cb(error);
        return;
      }

      if (
        this._payloadLength > 0x7d ||
        (this._opcode === 0x08 && this._payloadLength === 1)
      ) {
        const error = this.createError(
          RangeError,
          `invalid payload length ${this._payloadLength}`,
          true,
          1002,
          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'
        );

        cb(error);
        return;
      }
    } else {
      const error = this.createError(
        RangeError,
        `invalid opcode ${this._opcode}`,
        true,
        1002,
        'WS_ERR_INVALID_OPCODE'
      );

      cb(error);
      return;
    }

    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
    this._masked = (buf[1] & 0x80) === 0x80;

    if (this._isServer) {
      if (!this._masked) {
        const error = this.createError(
          RangeError,
          'MASK must be set',
          true,
          1002,
          'WS_ERR_EXPECTED_MASK'
        );

        cb(error);
        return;
      }
    } else if (this._masked) {
      const error = this.createError(
        RangeError,
        'MASK must be clear',
        true,
        1002,
        'WS_ERR_UNEXPECTED_MASK'
      );

      cb(error);
      return;
    }

    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
    else this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+16).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength16(cb) {
    if (this._bufferedBytes < 2) {
      this._loop = false;
      return;
    }

    this._payloadLength = this.consume(2).readUInt16BE(0);
    this.haveLength(cb);
  }

  /**
   * Gets extended payload length (7+64).
   *
   * @param {Function} cb Callback
   * @private
   */
  getPayloadLength64(cb) {
    if (this._bufferedBytes < 8) {
      this._loop = false;
      return;
    }

    const buf = this.consume(8);
    const num = buf.readUInt32BE(0);

    //
    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
    // if payload length is greater than this number.
    //
    if (num > Math.pow(2, 53 - 32) - 1) {
      const error = this.createError(
        RangeError,
        'Unsupported WebSocket frame: payload length > 2^53 - 1',
        false,
        1009,
        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'
      );

      cb(error);
      return;
    }

    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
    this.haveLength(cb);
  }

  /**
   * Payload length has been read.
   *
   * @param {Function} cb Callback
   * @private
   */
  haveLength(cb) {
    if (this._payloadLength && this._opcode < 0x08) {
      this._totalPayloadLength += this._payloadLength;
      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
        const error = this.createError(
          RangeError,
          'Max payload size exceeded',
          false,
          1009,
          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
        );

        cb(error);
        return;
      }
    }

    if (this._masked) this._state = GET_MASK;
    else this._state = GET_DATA;
  }

  /**
   * Reads mask bytes.
   *
   * @private
   */
  getMask() {
    if (this._bufferedBytes < 4) {
      this._loop = false;
      return;
    }

    this._mask = this.consume(4);
    this._state = GET_DATA;
  }

  /**
   * Reads data bytes.
   *
   * @param {Function} cb Callback
   * @private
   */
  getData(cb) {
    let data = EMPTY_BUFFER;

    if (this._payloadLength) {
      if (this._bufferedBytes < this._payloadLength) {
        this._loop = false;
        return;
      }

      data = this.consume(this._payloadLength);

      if (
        this._masked &&
        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0
      ) {
        unmask(data, this._mask);
      }
    }

    if (this._opcode > 0x07) {
      this.controlMessage(data, cb);
      return;
    }

    if (this._compressed) {
      this._state = INFLATING;
      this.decompress(data, cb);
      return;
    }

    if (data.length) {
      //
      // This message is not compressed so its length is the sum of the payload
      // length of all fragments.
      //
      this._messageLength = this._totalPayloadLength;
      this._fragments.push(data);
    }

    this.dataMessage(cb);
  }

  /**
   * Decompresses data.
   *
   * @param {Buffer} data Compressed data
   * @param {Function} cb Callback
   * @private
   */
  decompress(data, cb) {
    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];

    perMessageDeflate.decompress(data, this._fin, (err, buf) => {
      if (err) return cb(err);

      if (buf.length) {
        this._messageLength += buf.length;
        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
          const error = this.createError(
            RangeError,
            'Max payload size exceeded',
            false,
            1009,
            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'
          );

          cb(error);
          return;
        }

        this._fragments.push(buf);
      }

      this.dataMessage(cb);
      if (this._state === GET_INFO) this.startLoop(cb);
    });
  }

  /**
   * Handles a data message.
   *
   * @param {Function} cb Callback
   * @private
   */
  dataMessage(cb) {
    if (!this._fin) {
      this._state = GET_INFO;
      return;
    }

    const messageLength = this._messageLength;
    const fragments = this._fragments;

    this._totalPayloadLength = 0;
    this._messageLength = 0;
    this._fragmented = 0;
    this._fragments = [];

    if (this._opcode === 2) {
      let data;

      if (this._binaryType === 'nodebuffer') {
        data = concat(fragments, messageLength);
      } else if (this._binaryType === 'arraybuffer') {
        data = toArrayBuffer(concat(fragments, messageLength));
      } else if (this._binaryType === 'blob') {
        data = new Blob(fragments);
      } else {
        data = fragments;
      }

      if (this._allowSynchronousEvents) {
        this.emit('message', data, true);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', data, true);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    } else {
      const buf = concat(fragments, messageLength);

      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
        const error = this.createError(
          Error,
          'invalid UTF-8 sequence',
          true,
          1007,
          'WS_ERR_INVALID_UTF8'
        );

        cb(error);
        return;
      }

      if (this._state === INFLATING || this._allowSynchronousEvents) {
        this.emit('message', buf, false);
        this._state = GET_INFO;
      } else {
        this._state = DEFER_EVENT;
        setImmediate(() => {
          this.emit('message', buf, false);
          this._state = GET_INFO;
          this.startLoop(cb);
        });
      }
    }
  }

  /**
   * Handles a control message.
   *
   * @param {Buffer} data Data to handle
   * @return {(Error|RangeError|undefined)} A possible error
   * @private
   */
  controlMessage(data, cb) {
    if (this._opcode === 0x08) {
      if (data.length === 0) {
        this._loop = false;
        this.emit('conclude', 1005, EMPTY_BUFFER);
        this.end();
      } else {
        const code = data.readUInt16BE(0);

        if (!isValidStatusCode(code)) {
          const error = this.createError(
            RangeError,
            `invalid status code ${code}`,
            true,
            1002,
            'WS_ERR_INVALID_CLOSE_CODE'
          );

          cb(error);
          return;
        }

        const buf = new FastBuffer(
          data.buffer,
          data.byteOffset + 2,
          data.length - 2
        );

        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
          const error = this.createError(
            Error,
            'invalid UTF-8 sequence',
            true,
            1007,
            'WS_ERR_INVALID_UTF8'
          );

          cb(error);
          return;
        }

        this._loop = false;
        this.emit('conclude', code, buf);
        this.end();
      }

      this._state = GET_INFO;
      return;
    }

    if (this._allowSynchronousEvents) {
      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
      this._state = GET_INFO;
    } else {
      this._state = DEFER_EVENT;
      setImmediate(() => {
        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);
        this._state = GET_INFO;
        this.startLoop(cb);
      });
    }
  }

  /**
   * Builds an error object.
   *
   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
   * @param {String} message The error message
   * @param {Boolean} prefix Specifies whether or not to add a default prefix to
   *     `message`
   * @param {Number} statusCode The status code
   * @param {String} errorCode The exposed error code
   * @return {(Error|RangeError)} The error
   * @private
   */
  createError(ErrorCtor, message, prefix, statusCode, errorCode) {
    this._loop = false;
    this._errored = true;

    const err = new ErrorCtor(
      prefix ? `Invalid WebSocket frame: ${message}` : message
    );

    Error.captureStackTrace(err, this.createError);
    err.code = errorCode;
    err[kStatusCode] = statusCode;
    return err;
  }
}

module.exports = Receiver;


/***/ }),

/***/ 6504:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var parseUrl = (__webpack_require__(7016).parse);

var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443,
};

var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length &&
    this.indexOf(s, this.length - s.length) !== -1;
};

/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */
function getProxyForUrl(url) {
  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
    return '';  // Don't proxy URLs without a valid scheme or host.
  }

  proto = proto.split(':', 1)[0];
  // Stripping ports in this way instead of using parsedUrl.hostname to make
  // sure that the brackets around IPv6 addresses are kept.
  hostname = hostname.replace(/:\d*$/, '');
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return '';  // Don't proxy URLs that match NO_PROXY.
  }

  var proxy =
    getEnv('npm_config_' + proto + '_proxy') ||
    getEnv(proto + '_proxy') ||
    getEnv('npm_config_proxy') ||
    getEnv('all_proxy');
  if (proxy && proxy.indexOf('://') === -1) {
    // Missing scheme in proxy, default to the requested URL's scheme.
    proxy = proto + '://' + proxy;
  }
  return proxy;
}

/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */
function shouldProxy(hostname, port) {
  var NO_PROXY =
    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
  if (!NO_PROXY) {
    return true;  // Always proxy if NO_PROXY is not set.
  }
  if (NO_PROXY === '*') {
    return false;  // Never proxy if wildcard is set.
  }

  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;  // Skip zero-length hosts.
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;  // Skip if ports don't match.
    }

    if (!/^[.*]/.test(parsedProxyHostname)) {
      // No wildcards, so stop proxying if there is an exact match.
      return hostname !== parsedProxyHostname;
    }

    if (parsedProxyHostname.charAt(0) === '*') {
      // Remove leading wildcard.
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    // Stop proxying if the hostname ends with the no_proxy host.
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}

/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}

exports.getProxyForUrl = getProxyForUrl;


/***/ }),

/***/ 6549:
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),

/***/ 6585:
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),

/***/ 6743:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(9353);

module.exports = Function.prototype.bind || implementation;


/***/ }),

/***/ 6809:
/***/ ((module) => {

"use strict";
module.exports = require("utf-8-validate");

/***/ }),

/***/ 6928:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 6982:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 7016:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 7119:
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),

/***/ 7176:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(3126);
var gOPD = __webpack_require__(5795);

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),

/***/ 7507:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var debug;

module.exports = function () {
  if (!debug) {
    try {
      /* eslint global-require: off */
      debug = __webpack_require__(5753)("follow-redirects");
    }
    catch (error) { /* */ }
    if (typeof debug !== "function") {
      debug = function () { /* */ };
    }
  }
  debug.apply(null, arguments);
};


/***/ }),

/***/ 7598:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(1813)


/***/ }),

/***/ 7687:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const os = __webpack_require__(857);
const tty = __webpack_require__(2018);
const hasFlag = __webpack_require__(5884);

const {env} = process;

let forceColor;
if (hasFlag('no-color') ||
	hasFlag('no-colors') ||
	hasFlag('color=false') ||
	hasFlag('color=never')) {
	forceColor = 0;
} else if (hasFlag('color') ||
	hasFlag('colors') ||
	hasFlag('color=true') ||
	hasFlag('color=always')) {
	forceColor = 1;
}

if ('FORCE_COLOR' in env) {
	if (env.FORCE_COLOR === 'true') {
		forceColor = 1;
	} else if (env.FORCE_COLOR === 'false') {
		forceColor = 0;
	} else {
		forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3
	};
}

function supportsColor(haveStream, streamIsTTY) {
	if (forceColor === 0) {
		return 0;
	}

	if (hasFlag('color=16m') ||
		hasFlag('color=full') ||
		hasFlag('color=truecolor')) {
		return 3;
	}

	if (hasFlag('color=256')) {
		return 2;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (process.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = os.release().split('.');
		if (
			Number(osRelease[0]) >= 10 &&
			Number(osRelease[2]) >= 10586
		) {
			return Number(osRelease[2]) >= 14931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'GITHUB_ACTIONS', 'BUILDKITE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app':
				return version >= 3 ? 3 : 2;
			case 'Apple_Terminal':
				return 2;
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function getSupportLevel(stream) {
	const level = supportsColor(stream, stream && stream.isTTY);
	return translateLevel(level);
}

module.exports = {
	supportsColor: getSupportLevel,
	stdout: translateLevel(supportsColor(true, tty.isatty(1))),
	stderr: translateLevel(supportsColor(true, tty.isatty(2)))
};


/***/ }),

/***/ 7833:
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	// eslint-disable-next-line no-return-assign
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(736)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),

/***/ 8002:
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),

/***/ 8051:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(2313)
  , abort = __webpack_require__(4555)
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),

/***/ 8068:
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),

/***/ 8069:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(2203).Stream);
var util = __webpack_require__(9023);

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),

/***/ 8237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { tokenChars } = __webpack_require__(5880);

/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */
function parse(header) {
  const protocols = new Set();
  let start = -1;
  let end = -1;
  let i = 0;

  for (i; i < header.length; i++) {
    const code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (
      i !== 0 &&
      (code === 0x20 /* ' ' */ || code === 0x09) /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c /* ',' */) {
      if (start === -1) {
        throw new SyntaxError(`Unexpected character at index ${i}`);
      }

      if (end === -1) end = i;

      const protocol = header.slice(start, end);

      if (protocols.has(protocol)) {
        throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
      }

      protocols.add(protocol);
      start = end = -1;
    } else {
      throw new SyntaxError(`Unexpected character at index ${i}`);
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  const protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError(`The "${protocol}" subprotocol is duplicated`);
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = { parse };


/***/ }),

/***/ 8611:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 8648:
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),

/***/ 8798:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(8051)
  , initState  = __webpack_require__(9500)
  , terminator = __webpack_require__(6276)
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),

/***/ 8968:
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),

/***/ 9023:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 9092:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(1333);

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),

/***/ 9278:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 9290:
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),

/***/ 9353:
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),

/***/ 9383:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),

/***/ 9500:
/***/ ((module) => {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),

/***/ 9538:
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),

/***/ 9605:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(453);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasToStringTag = __webpack_require__(9092)();
var hasOwn = __webpack_require__(9957);
var $TypeError = __webpack_require__(9675);

var toStringTag = hasToStringTag ? Symbol.toStringTag : null;

/** @type {import('.')} */
module.exports = function setToStringTag(object, value) {
	var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
	var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
	if (
		(typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean')
		|| (typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean')
	) {
		throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
	}
	if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
		if ($defineProperty) {
			$defineProperty(object, toStringTag, {
				configurable: !nonConfigurable,
				enumerable: false,
				value: value,
				writable: false
			});
		} else {
			object[toStringTag] = value; // eslint-disable-line no-param-reassign
		}
	}
};


/***/ }),

/***/ 9612:
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),

/***/ 9675:
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),

/***/ 9896:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 9957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(6743);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".extension.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			792: 1
/******/ 		};
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 		
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  activate: () => (/* binding */ activate),
  deactivate: () => (/* binding */ deactivate)
});

// NAMESPACE OBJECT: ./node_modules/axios/lib/platform/common/utils.js
var common_utils_namespaceObject = {};
__webpack_require__.r(common_utils_namespaceObject);
__webpack_require__.d(common_utils_namespaceObject, {
  hasBrowserEnv: () => (hasBrowserEnv),
  hasStandardBrowserEnv: () => (hasStandardBrowserEnv),
  hasStandardBrowserWebWorkerEnv: () => (hasStandardBrowserWebWorkerEnv),
  navigator: () => (_navigator),
  origin: () => (origin)
});

// EXTERNAL MODULE: external "vscode"
var external_vscode_ = __webpack_require__(1398);
// EXTERNAL MODULE: external "path"
var external_path_ = __webpack_require__(6928);
;// ./node_modules/axios/lib/helpers/bind.js


function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

;// ./node_modules/axios/lib/utils.js




// utils is a library of generic helper functions non-specific to axios

const {toString: utils_toString} = Object.prototype;
const {getPrototypeOf} = Object;
const {iterator, toStringTag} = Symbol;

const kindOf = (cache => thing => {
    const str = utils_toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
}

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
}

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  }

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
}

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
}

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
}

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
}

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
}


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
}

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];

  const _iterator = generator.call(obj);

  let result;

  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
}

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
}

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const utils_hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
}

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
}

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  }

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
}

const noop = () => {}

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
}

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  }

  return visit(obj, 0);
}

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************


const isIterable = (thing) => thing != null && isFunction(thing[iterator]);


/* harmony default export */ const utils = ({
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: utils_hasOwnProperty,
  hasOwnProp: utils_hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
});

;// ./node_modules/axios/lib/core/AxiosError.js




/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const AxiosError_prototype = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(AxiosError_prototype, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(AxiosError_prototype);

  utils.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/* harmony default export */ const core_AxiosError = (AxiosError);

// EXTERNAL MODULE: ./node_modules/form-data/lib/form_data.js
var form_data = __webpack_require__(737);
;// ./node_modules/axios/lib/platform/node/classes/FormData.js


/* harmony default export */ const classes_FormData = (form_data);

;// ./node_modules/axios/lib/helpers/toFormData.js




// temporary hotfix to avoid circular references until AxiosURLSearchParams is refactored


/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (classes_FormData || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);

  if (!utils.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils.isDate(value)) {
      return value.toISOString();
    }

    if (!useBlob && utils.isBlob(value)) {
      throw new core_AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils.isArray(value) && isFlatArray(value)) ||
        ((utils.isFileList(value) || utils.endsWith(key, '[]')) && (arr = utils.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils.forEach(value, function each(el, key) {
      const result = !(utils.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/* harmony default export */ const helpers_toFormData = (toFormData);

;// ./node_modules/axios/lib/helpers/AxiosURLSearchParams.js




/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && helpers_toFormData(params, this, options);
}

const AxiosURLSearchParams_prototype = AxiosURLSearchParams.prototype;

AxiosURLSearchParams_prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

AxiosURLSearchParams_prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/* harmony default export */ const helpers_AxiosURLSearchParams = (AxiosURLSearchParams);

;// ./node_modules/axios/lib/helpers/buildURL.js





/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function buildURL_encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || buildURL_encode;

  if (utils.isFunction(options)) {
    options = {
      serialize: options
    };
  } 

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ?
      params.toString() :
      new helpers_AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

;// ./node_modules/axios/lib/core/InterceptorManager.js




class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

/* harmony default export */ const core_InterceptorManager = (InterceptorManager);

;// ./node_modules/axios/lib/defaults/transitional.js


/* harmony default export */ const defaults_transitional = ({
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
});

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6982);
// EXTERNAL MODULE: external "url"
var external_url_ = __webpack_require__(7016);
;// ./node_modules/axios/lib/platform/node/classes/URLSearchParams.js



/* harmony default export */ const URLSearchParams = (external_url_.URLSearchParams);

;// ./node_modules/axios/lib/platform/node/index.js




const ALPHA = 'abcdefghijklmnopqrstuvwxyz'

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
}

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  const randomValues = new Uint32Array(size);
  external_crypto_.randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }

  return str;
}


/* harmony default export */ const node = ({
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams,
    FormData: classes_FormData,
    Blob: typeof Blob !== 'undefined' && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: [ 'http', 'https', 'file', 'data' ]
});

;// ./node_modules/axios/lib/platform/common/utils.js
const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';



;// ./node_modules/axios/lib/platform/index.js



/* harmony default export */ const platform = ({
  ...common_utils_namespaceObject,
  ...node
});

;// ./node_modules/axios/lib/helpers/toURLEncodedForm.js






function toURLEncodedForm(data, options) {
  return helpers_toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

;// ./node_modules/axios/lib/helpers/formDataToJSON.js




/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};

    utils.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/* harmony default export */ const helpers_formDataToJSON = (formDataToJSON);

;// ./node_modules/axios/lib/defaults/index.js










/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: defaults_transitional,

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils.isObject(data);

    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(helpers_formDataToJSON(data)) : data;
    }

    if (utils.isArrayBuffer(data) ||
      utils.isBuffer(data) ||
      utils.isStream(data) ||
      utils.isFile(data) ||
      utils.isBlob(data) ||
      utils.isReadableStream(data)
    ) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return helpers_toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (utils.isResponse(data) || utils.isReadableStream(data)) {
      return data;
    }

    if (data && utils.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw core_AxiosError.from(e, core_AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

/* harmony default export */ const lib_defaults = (defaults);

;// ./node_modules/axios/lib/helpers/parseHeaders.js




// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
/* harmony default export */ const parseHeaders = (rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
});

;// ./node_modules/axios/lib/core/AxiosHeaders.js





const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils.isString(value)) return;

  if (utils.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite)
    } else if(utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils.isObject(header) && utils.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils.isArray(entry)) {
          throw TypeError('Object iterator must return a key-value pair');
        }

        obj[key = entry[0]] = (dest = obj[key]) ?
          (utils.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
      }

      setHeaders(obj, valueOrRewrite)
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  getSetCookie() {
    return this.get("set-cookie") || [];
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils.freezeMethods(AxiosHeaders);

/* harmony default export */ const core_AxiosHeaders = (AxiosHeaders);

;// ./node_modules/axios/lib/core/transformData.js






/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || lib_defaults;
  const context = response || config;
  const headers = core_AxiosHeaders.from(context.headers);
  let data = context.data;

  utils.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

;// ./node_modules/axios/lib/cancel/isCancel.js


function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

;// ./node_modules/axios/lib/cancel/CanceledError.js





/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  core_AxiosError.call(this, message == null ? 'canceled' : message, core_AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils.inherits(CanceledError, core_AxiosError, {
  __CANCEL__: true
});

/* harmony default export */ const cancel_CanceledError = (CanceledError);

;// ./node_modules/axios/lib/core/settle.js




/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new core_AxiosError(
      'Request failed with status code ' + response.status,
      [core_AxiosError.ERR_BAD_REQUEST, core_AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

;// ./node_modules/axios/lib/helpers/isAbsoluteURL.js


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

;// ./node_modules/axios/lib/helpers/combineURLs.js


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

;// ./node_modules/axios/lib/core/buildFullPath.js





/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// EXTERNAL MODULE: ./node_modules/proxy-from-env/index.js
var proxy_from_env = __webpack_require__(6504);
// EXTERNAL MODULE: external "http"
var external_http_ = __webpack_require__(8611);
// EXTERNAL MODULE: external "https"
var external_https_ = __webpack_require__(5692);
// EXTERNAL MODULE: external "util"
var external_util_ = __webpack_require__(9023);
// EXTERNAL MODULE: ./node_modules/follow-redirects/index.js
var follow_redirects = __webpack_require__(3164);
// EXTERNAL MODULE: external "zlib"
var external_zlib_ = __webpack_require__(3106);
;// ./node_modules/axios/lib/env/data.js
const VERSION = "1.9.0";
;// ./node_modules/axios/lib/helpers/parseProtocol.js


function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

;// ./node_modules/axios/lib/helpers/fromDataURI.js






const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

/**
 * Parse data uri to a Buffer or Blob
 *
 * @param {String} uri
 * @param {?Boolean} asBlob
 * @param {?Object} options
 * @param {?Function} options.Blob
 *
 * @returns {Buffer|Blob}
 */
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol = parseProtocol(uri);

  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }

  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;

    const match = DATA_URL_PATTERN.exec(uri);

    if (!match) {
      throw new core_AxiosError('Invalid URL', core_AxiosError.ERR_INVALID_URL);
    }

    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');

    if (asBlob) {
      if (!_Blob) {
        throw new core_AxiosError('Blob is not supported', core_AxiosError.ERR_NOT_SUPPORT);
      }

      return new _Blob([buffer], {type: mime});
    }

    return buffer;
  }

  throw new core_AxiosError('Unsupported protocol ' + protocol, core_AxiosError.ERR_NOT_SUPPORT);
}

// EXTERNAL MODULE: external "stream"
var external_stream_ = __webpack_require__(2203);
;// ./node_modules/axios/lib/helpers/AxiosTransformStream.js





const kInternals = Symbol('internals');

class AxiosTransformStream extends external_stream_.Transform{
  constructor(options) {
    options = utils.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils.isUndefined(source[prop]);
    });

    super({
      readableHighWaterMark: options.chunkSize
    });

    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };

    this.on('newListener', event => {
      if (event === 'progress') {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }

  _read(size) {
    const internals = this[kInternals];

    if (internals.onReadCallback) {
      internals.onReadCallback();
    }

    return super._read(size);
  }

  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;

    const readableHighWaterMark = this.readableHighWaterMark;

    const timeWindow = internals.timeWindow;

    const divider = 1000 / timeWindow;
    const bytesThreshold = (maxRate / divider);
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;

    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;

      internals.isCaptured && this.emit('progress', internals.bytesSeen);

      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    }

    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;

      if (maxRate) {
        const now = Date.now();

        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }

        bytesLeft = bytesThreshold - internals.bytes;
      }

      if (maxRate) {
        if (bytesLeft <= 0) {
          // next time window
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }

        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }

      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }

      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };

    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }

      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}

/* harmony default export */ const helpers_AxiosTransformStream = (AxiosTransformStream);

// EXTERNAL MODULE: external "events"
var external_events_ = __webpack_require__(4434);
;// ./node_modules/axios/lib/helpers/readBlob.js
const {asyncIterator} = Symbol;

const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream()
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer()
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
}

/* harmony default export */ const helpers_readBlob = (readBlob);

;// ./node_modules/axios/lib/helpers/formDataToStream.js






const BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + '-_';

const textEncoder = typeof TextEncoder === 'function' ? new TextEncoder() : new external_util_.TextEncoder();

const CRLF = '\r\n';
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const {escapeName} = this.constructor;
    const isStringValue = utils.isString(value);

    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${
      !isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''
    }${CRLF}`;

    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`
    }

    this.headers = textEncoder.encode(headers + CRLF);

    this.contentLength = isStringValue ? value.byteLength : value.size;

    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;

    this.name = name;
    this.value = value;
  }

  async *encode(){
    yield this.headers;

    const {value} = this;

    if(utils.isTypedArray(value)) {
      yield value;
    } else {
      yield* helpers_readBlob(value);
    }

    yield CRLF_BYTES;
  }

  static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        '\r' : '%0D',
        '\n' : '%0A',
        '"' : '%22',
      }[match]));
  }
}

const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = 'form-data-boundary',
    size = 25,
    boundary = tag + '-' + platform.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};

  if(!utils.isFormData(form)) {
    throw TypeError('FormData instance required');
  }

  if (boundary.length < 1 || boundary.length > 70) {
    throw Error('boundary must be 10-70 characters long')
  }

  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);
  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF);
  let contentLength = footerBytes.byteLength;

  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });

  contentLength += boundaryBytes.byteLength * parts.length;

  contentLength = utils.toFiniteNumber(contentLength);

  const computedHeaders = {
    'Content-Type': `multipart/form-data; boundary=${boundary}`
  }

  if (Number.isFinite(contentLength)) {
    computedHeaders['Content-Length'] = contentLength;
  }

  headersHandler && headersHandler(computedHeaders);

  return external_stream_.Readable.from((async function *() {
    for(const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }

    yield footerBytes;
  })());
};

/* harmony default export */ const helpers_formDataToStream = (formDataToStream);

;// ./node_modules/axios/lib/helpers/ZlibHeaderTransformStream.js




class ZlibHeaderTransformStream extends external_stream_.Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }

  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;

      // Add Default Compression headers if no zlib headers are present
      if (chunk[0] !== 120) { // Hex: 78
        const header = Buffer.alloc(2);
        header[0] = 120; // Hex: 78
        header[1] = 156; // Hex: 9C 
        this.push(header, encoding);
      }
    }

    this.__transform(chunk, encoding, callback);
  }
}

/* harmony default export */ const helpers_ZlibHeaderTransformStream = (ZlibHeaderTransformStream);

;// ./node_modules/axios/lib/helpers/callbackify.js


const callbackify = (fn, reducer) => {
  return utils.isAsyncFn(fn) ? function (...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
}

/* harmony default export */ const helpers_callbackify = (callbackify);

;// ./node_modules/axios/lib/helpers/speedometer.js


/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/* harmony default export */ const helpers_speedometer = (speedometer);

;// ./node_modules/axios/lib/helpers/throttle.js
/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  }

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs)
        }, threshold - passed);
      }
    }
  }

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

/* harmony default export */ const helpers_throttle = (throttle);

;// ./node_modules/axios/lib/helpers/progressEventReducer.js




const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = helpers_speedometer(50, 250);

  return helpers_throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
}

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
}

const asyncDecorator = (fn) => (...args) => utils.asap(() => fn(...args));

;// ./node_modules/axios/lib/adapters/http.js




























const zlibOptions = {
  flush: external_zlib_.constants.Z_SYNC_FLUSH,
  finishFlush: external_zlib_.constants.Z_SYNC_FLUSH
};

const brotliOptions = {
  flush: external_zlib_.constants.BROTLI_OPERATION_FLUSH,
  finishFlush: external_zlib_.constants.BROTLI_OPERATION_FLUSH
}

const isBrotliSupported = utils.isFunction(external_zlib_.createBrotliDecompress);

const {http: httpFollow, https: httpsFollow} = follow_redirects;

const isHttps = /https:?/;

const supportedProtocols = platform.protocols.map(protocol => {
  return protocol + ':';
});

const flushOnFinish = (stream, [throttled, flush]) => {
  stream
    .on('end', flush)
    .on('error', flush);

  return throttled;
}

/**
 * If the proxy or config beforeRedirects functions are defined, call them with the options
 * object.
 *
 * @param {Object<string, any>} options - The options object that was passed to the request.
 *
 * @returns {Object<string, any>}
 */
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}

/**
 * If the proxy or config afterRedirects functions are defined, call them with the options
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
 * @param {string} location
 *
 * @returns {http.ClientRequestArgs}
 */
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxy_from_env.getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    // Basic proxy authorization
    if (proxy.username) {
      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
    }

    if (proxy.auth) {
      // Support proxy auth object form
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
      }
      const base64 = Buffer
        .from(proxy.auth, 'utf8')
        .toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }

    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    // Replace 'host' since options is not a URL object
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;
    }
  }

  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    // Configure proxy for redirected request, passing the original config proxy to apply
    // the exact same logic as if the redirected request was performed by axios directly.
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}

const isHttpAdapterSupported = typeof process !== 'undefined' && utils.kindOf(process) === 'process';

// temporary hotfix

const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;

    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    }

    const _resolve = (value) => {
      done(value);
      resolve(value);
    };

    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    }

    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);
  })
};

const resolveFamily = ({address, family}) => {
  if (!utils.isString(address)) {
    throw TypeError('address must be a string');
  }
  return ({
    address,
    family: family || (address.indexOf('.') < 0 ? 6 : 4)
  });
}

const buildAddressEntry = (address, family) => resolveFamily(utils.isObject(address) ? address : {address, family});

/*eslint consistent-return:0*/
/* harmony default export */ const http = (isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let {data, lookup, family} = config;
    const {responseType, responseEncoding} = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;

    if (lookup) {
      const _lookup = helpers_callbackify(lookup, (value) => utils.isArray(value) ? value : [value]);
      // hotfix to support opt.all option which is required for node 20.x
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }

          const addresses = utils.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];

          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      }
    }

    // temporary internal emitter until the AxiosRequest class will be implemented
    const emitter = new external_events_.EventEmitter();

    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', abort);
      }

      emitter.removeAllListeners();
    }

    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });

    function abort(reason) {
      emitter.emit('abort', !reason || reason.type ? new cancel_CanceledError(null, config, req) : reason);
    }

    emitter.once('abort', reject);

    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
      }
    }

    // Parse url
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);
    const protocol = parsed.protocol || supportedProtocols[0];

    if (protocol === 'data:') {
      let convertedData;

      if (method !== 'GET') {
        return settle(resolve, reject, {
          status: 405,
          statusText: 'method not allowed',
          headers: {},
          config
        });
      }

      try {
        convertedData = fromDataURI(config.url, responseType === 'blob', {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw core_AxiosError.from(err, core_AxiosError.ERR_BAD_REQUEST, config);
      }

      if (responseType === 'text') {
        convertedData = convertedData.toString(responseEncoding);

        if (!responseEncoding || responseEncoding === 'utf8') {
          convertedData = utils.stripBOM(convertedData);
        }
      } else if (responseType === 'stream') {
        convertedData = external_stream_.Readable.from(convertedData);
      }

      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: 'OK',
        headers: new core_AxiosHeaders(),
        config
      });
    }

    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new core_AxiosError(
        'Unsupported protocol ' + protocol,
        core_AxiosError.ERR_BAD_REQUEST,
        config
      ));
    }

    const headers = core_AxiosHeaders.from(config.headers).normalize();

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    // User-Agent is specified; handle case where no UA header is desired
    // Only set header if it hasn't been set in config
    headers.set('User-Agent', 'axios/' + VERSION, false);

    const {onUploadProgress, onDownloadProgress} = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;

    // support for spec compliant FormData objects
    if (utils.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);

      data = helpers_formDataToStream(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
      // support for https://www.npmjs.com/package/form-data api
    } else if (utils.isFormData(data) && utils.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());

      if (!headers.hasContentLength()) {
        try {
          const knownLength = await external_util_.promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          /*eslint no-empty:0*/
        } catch (e) {
        }
      }
    } else if (utils.isBlob(data) || utils.isFile(data)) {
      data.size && headers.setContentType(data.type || 'application/octet-stream');
      headers.setContentLength(data.size || 0);
      data = external_stream_.Readable.from(helpers_readBlob(data));
    } else if (data && !utils.isStream(data)) {
      if (Buffer.isBuffer(data)) {
        // Nothing to do...
      } else if (utils.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(new core_AxiosError(
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          core_AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }

      // Add Content-Length header if data exists
      headers.setContentLength(data.length, false);

      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new core_AxiosError(
          'Request body larger than maxBodyLength limit',
          core_AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
    }

    const contentLength = utils.toFiniteNumber(headers.getContentLength());

    if (utils.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }

    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils.isStream(data)) {
        data = external_stream_.Readable.from(data, {objectMode: false});
      }

      data = external_stream_.pipeline([data, new helpers_AxiosTransformStream({
        maxRate: utils.toFiniteNumber(maxUploadRate)
      })], utils.noop);

      onUploadProgress && data.on('progress', flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }

    // HTTP basic authentication
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password || '';
      auth = username + ':' + password;
    }

    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ':' + urlPassword;
    }

    auth && headers.delete('authorization');

    let path;

    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, '');
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }

    headers.set(
      'Accept-Encoding',
      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false
      );

    const options = {
      path,
      method: method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };

    // cacheable-lookup integration hotfix
    !utils.isUndefined(lookup) && (options.lookup = lookup);

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? external_https_ : external_http_;
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
      options.maxBodyLength = Infinity;
    }

    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }

    // Create the request
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;

      const streams = [res];

      const responseLength = +res.headers['content-length'];

      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new helpers_AxiosTransformStream({
          maxRate: utils.toFiniteNumber(maxDownloadRate)
        });

        onDownloadProgress && transformStream.on('progress', flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));

        streams.push(transformStream);
      }

      // decompress the response body transparently if required
      let responseStream = res;

      // return the last request in case of redirects
      const lastRequest = res.req || req;

      // if decompress disabled we should not decompress
      if (config.decompress !== false && res.headers['content-encoding']) {
        // if no content, but headers still say that it is encoded,
        // remove the header not confuse downstream operations
        if (method === 'HEAD' || res.statusCode === 204) {
          delete res.headers['content-encoding'];
        }

        switch ((res.headers['content-encoding'] || '').toLowerCase()) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'x-gzip':
        case 'compress':
        case 'x-compress':
          // add the unzipper to the body stream processing pipeline
          streams.push(external_zlib_.createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'deflate':
          streams.push(new helpers_ZlibHeaderTransformStream());

          // add the unzipper to the body stream processing pipeline
          streams.push(external_zlib_.createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'br':
          if (isBrotliSupported) {
            streams.push(external_zlib_.createBrotliDecompress(brotliOptions));
            delete res.headers['content-encoding'];
          }
        }
      }

      responseStream = streams.length > 1 ? external_stream_.pipeline(streams, utils.noop) : streams[0];

      const offListeners = external_stream_.finished(responseStream, () => {
        offListeners();
        onFinished();
      });

      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new core_AxiosHeaders(res.headers),
        config,
        request: lastRequest
      };

      if (responseType === 'stream') {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;

        responseStream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destroy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            responseStream.destroy();
            reject(new core_AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              core_AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });

        responseStream.on('aborted', function handlerStreamAborted() {
          if (rejected) {
            return;
          }

          const err = new core_AxiosError(
            'stream has been aborted',
            core_AxiosError.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });

        responseStream.on('error', function handleStreamError(err) {
          if (req.destroyed) return;
          reject(core_AxiosError.from(err, null, config, lastRequest));
        });

        responseStream.on('end', function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== 'arraybuffer') {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === 'utf8') {
                responseData = utils.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(core_AxiosError.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }

      emitter.once('abort', err => {
        if (!responseStream.destroyed) {
          responseStream.emit('error', err);
          responseStream.destroy();
        }
      });
    });

    emitter.once('abort', err => {
      reject(err);
      req.destroy(err);
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      // @todo remove
      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
      reject(core_AxiosError.from(err, null, config, req));
    });

    // set tcp keep alive to prevent drop connection by peer
    req.on('socket', function handleRequestSocket(socket) {
      // default interval of sending ack packet is 1 minute
      socket.setKeepAlive(true, 1000 * 60);
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      const timeout = parseInt(config.timeout, 10);

      if (Number.isNaN(timeout)) {
        reject(new core_AxiosError(
          'error trying to parse `config.timeout` to int',
          core_AxiosError.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devouring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || defaults_transitional;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new core_AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }


    // Send the request
    if (utils.isStream(data)) {
      let ended = false;
      let errored = false;

      data.on('end', () => {
        ended = true;
      });

      data.once('error', err => {
        errored = true;
        req.destroy(err);
      });

      data.on('close', () => {
        if (!ended && !errored) {
          abort(new cancel_CanceledError('Request stream has been aborted', config, req));
        }
      });

      data.pipe(req);
    } else {
      req.end(data);
    }
  });
});

const __setProxy = (/* unused pure expression or super */ null && (setProxy));

;// ./node_modules/axios/lib/helpers/isURLSameOrigin.js


/* harmony default export */ const isURLSameOrigin = (platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
  url = new URL(url, platform.origin);

  return (
    origin.protocol === url.protocol &&
    origin.host === url.host &&
    (isMSIE || origin.port === url.port)
  );
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true);

;// ./node_modules/axios/lib/helpers/cookies.js



/* harmony default export */ const cookies = (platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils.isString(path) && cookie.push('path=' + path);

      utils.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  });


;// ./node_modules/axios/lib/core/mergeConfig.js





const headersToObject = (thing) => thing instanceof core_AxiosHeaders ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, prop, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({caseless}, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop , caseless) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(a, b, prop , caseless);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a, prop , caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
  };

  utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

;// ./node_modules/axios/lib/helpers/resolveConfig.js









/* harmony default export */ const resolveConfig = ((config) => {
  const newConfig = mergeConfig({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = core_AxiosHeaders.from(headers);

  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (utils.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
});


;// ./node_modules/axios/lib/adapters/xhr.js











const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

/* harmony default export */ const xhr = (isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = core_AxiosHeaders.from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = core_AxiosHeaders.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new core_AxiosError('Request aborted', core_AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || defaults_transitional;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new core_AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? core_AxiosError.ETIMEDOUT : core_AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new cancel_CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(_config.url);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new core_AxiosError('Unsupported protocol ' + protocol + ':', core_AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
});

;// ./node_modules/axios/lib/helpers/composeSignals.js




const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof core_AxiosError ? err : new cancel_CanceledError(err instanceof Error ? err.message : err));
      }
    }

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new core_AxiosError(`timeout ${timeout} of ms exceeded`, core_AxiosError.ETIMEDOUT))
    }, timeout)

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    }

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => utils.asap(unsubscribe);

    return signal;
  }
}

/* harmony default export */ const helpers_composeSignals = (composeSignals);

;// ./node_modules/axios/lib/helpers/trackStream.js

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
}

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
}

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
}

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  }

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
}

;// ./node_modules/axios/lib/adapters/fetch.js










const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
}

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => utils.isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils.isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new core_AxiosError(`Response type '${type}' is not supported`, core_AxiosError.ERR_NOT_SUPPORT, config);
      })
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(utils.isBlob(body)) {
    return body.size;
  }

  if(utils.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(utils.isArrayBufferView(body) || utils.isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(utils.isURLSearchParams(body)) {
    body = body + '';
  }

  if(utils.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
}

const resolveBodyLength = async (headers, body) => {
  const length = utils.toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
}

/* harmony default export */ const adapters_fetch = (isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = helpers_composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (utils.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader)
      }

      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );

        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!utils.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = utils.toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];

      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[utils.findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: core_AxiosHeaders.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      })
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new core_AxiosError('Network Error', core_AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw core_AxiosError.from(err, err && err.code, config, request);
  }
}));



;// ./node_modules/axios/lib/adapters/adapters.js






const knownAdapters = {
  http: http,
  xhr: xhr,
  fetch: adapters_fetch
}

utils.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils.isFunction(adapter) || adapter === null || adapter === false;

/* harmony default export */ const adapters = ({
  getAdapter: (adapters) => {
    adapters = utils.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new core_AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new core_AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
});

;// ./node_modules/axios/lib/core/dispatchRequest.js









/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new cancel_CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = core_AxiosHeaders.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || lib_defaults.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = core_AxiosHeaders.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = core_AxiosHeaders.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

;// ./node_modules/axios/lib/helpers/validator.js





const validators = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new core_AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        core_AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  }
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new core_AxiosError('options must be an object', core_AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new core_AxiosError('option ' + opt + ' must be ' + result, core_AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new core_AxiosError('Unknown option ' + opt, core_AxiosError.ERR_BAD_OPTION);
    }
  }
}

/* harmony default export */ const validator = ({
  assertOptions,
  validators
});

;// ./node_modules/axios/lib/core/Axios.js











const Axios_validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new core_InterceptorManager(),
      response: new core_InterceptorManager()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};

        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        forcedJSONParsing: Axios_validators.transitional(Axios_validators.boolean),
        clarifyTimeoutError: Axios_validators.transitional(Axios_validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        }
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: Axios_validators.function,
          serialize: Axios_validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) {
      // do nothing
    } else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }

    validator.assertOptions(config, {
      baseUrl: Axios_validators.spelling('baseURL'),
      withXsrfToken: Axios_validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = core_AxiosHeaders.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

/* harmony default export */ const core_Axios = (Axios);

;// ./node_modules/axios/lib/cancel/CancelToken.js




/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new cancel_CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

/* harmony default export */ const cancel_CancelToken = (CancelToken);

;// ./node_modules/axios/lib/helpers/spread.js


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

;// ./node_modules/axios/lib/helpers/isAxiosError.js




/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils.isObject(payload) && (payload.isAxiosError === true);
}

;// ./node_modules/axios/lib/helpers/HttpStatusCode.js
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

/* harmony default export */ const helpers_HttpStatusCode = (HttpStatusCode);

;// ./node_modules/axios/lib/axios.js




















/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new core_Axios(defaultConfig);
  const instance = bind(core_Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, core_Axios.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(lib_defaults);

// Expose Axios class to allow class inheritance
axios.Axios = core_Axios;

// Expose Cancel & CancelToken
axios.CanceledError = cancel_CanceledError;
axios.CancelToken = cancel_CancelToken;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = helpers_toFormData;

// Expose AxiosError class
axios.AxiosError = core_AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = core_AxiosHeaders;

axios.formToJSON = thing => helpers_formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = helpers_HttpStatusCode;

axios.default = axios;

// this module should only have a default export
/* harmony default export */ const lib_axios = (axios);

// EXTERNAL MODULE: ./node_modules/ws/lib/stream.js
var stream = __webpack_require__(3719);
// EXTERNAL MODULE: ./node_modules/ws/lib/receiver.js
var receiver = __webpack_require__(6286);
// EXTERNAL MODULE: ./node_modules/ws/lib/sender.js
var sender = __webpack_require__(914);
// EXTERNAL MODULE: ./node_modules/ws/lib/websocket.js
var websocket = __webpack_require__(1060);
// EXTERNAL MODULE: ./node_modules/ws/lib/websocket-server.js
var websocket_server = __webpack_require__(1722);
;// ./node_modules/ws/wrapper.mjs







/* harmony default export */ const wrapper = ((/* unused pure expression or super */ null && (WebSocket)));

;// ./src/types/chat.ts
/**
 * Message roles representing different participants in a conversation
 */
var MessageRole;
(function (MessageRole) {
    MessageRole["User"] = "user";
    MessageRole["Assistant"] = "assistant";
    MessageRole["System"] = "system"; // System messages (e.g., errors, notifications)
})(MessageRole || (MessageRole = {}));
/**
 * Supported LLM models
 */
var LLMModel;
(function (LLMModel) {
    // OpenAI models (ìµœì‹  ëª¨ë¸ë“¤)
    LLMModel["GPT_4_1_MINI"] = "openai/gpt-4.1-mini";
    LLMModel["GPT_4_1_PREVIEW"] = "openai/gpt-4.1-preview";
    LLMModel["GPT_4O"] = "openai/gpt-4o";
    LLMModel["GPT_3_5_TURBO"] = "openai/gpt-3.5-turbo";
    // Anthropic models (Claude ëª¨ë¸ë“¤)
    LLMModel["CLAUDE_3_OPUS"] = "anthropic/claude-3-opus-20240229";
    LLMModel["CLAUDE_3_SONNET"] = "anthropic/claude-3-sonnet-20240229";
    LLMModel["CLAUDE_3_HAIKU"] = "anthropic/claude-3-haiku-20240307";
    // ì¶”ê°€ ëª¨ë¸ë“¤
    LLMModel["GEMINI_PRO"] = "google/gemini-pro";
    LLMModel["GEMMA_7B"] = "google/gemma-7b-it";
    LLMModel["QWEN_72B"] = "qwen/qwen-72b-chat";
    LLMModel["DEEPSEEK"] = "deepseek/deepseek-coder";
    // ë¬´ë£Œ ëª¨ë¸ë“¤
    LLMModel["MISTRAL_7B"] = "mistralai/mistral-7b-instruct";
    LLMModel["LLAMA3_8B"] = "meta-llama/llama-3-8b-instruct"; // ë¬´ë£Œ ì˜¤í”ˆì†ŒìŠ¤ ëª¨ë¸
})(LLMModel || (LLMModel = {}));

;// ./src/core/services/serviceConfig.ts
/**
 * ì„œë¹„ìŠ¤ ì„¤ì • ê´€ë¦¬ìž
 *
 * Git, Jira, S3, SWDP ë“±ì˜ ì™¸ë¶€ ì„œë¹„ìŠ¤ ì—°ê²° ì„¤ì •ì„ ê´€ë¦¬í•©ë‹ˆë‹¤.
 * ê° ì„œë¹„ìŠ¤ë³„ URL, ì¸ì¦ ì •ë³´ ë“±ì„ VSCode ì„¤ì •ì—ì„œ ê°€ì ¸ì˜¤ê³  ê²€ì¦í•©ë‹ˆë‹¤.
 */

/**
 * ì„œë¹„ìŠ¤ ì¸ì¦ ë°©ì‹ ìœ í˜•
 */
var AuthType;
(function (AuthType) {
    AuthType["None"] = "none";
    AuthType["Basic"] = "basic";
    AuthType["OAuth"] = "oauth";
    AuthType["Token"] = "token";
    AuthType["AWS"] = "aws";
})(AuthType || (AuthType = {}));
/**
 * ì„œë¹„ìŠ¤ ìœ í˜•
 */
var ServiceType;
(function (ServiceType) {
    ServiceType["Git"] = "git";
    ServiceType["Bitbucket"] = "bitbucket";
    ServiceType["Jira"] = "jira";
    ServiceType["S3"] = "pocket";
    ServiceType["SWDP"] = "swdp";
    ServiceType["Vault"] = "vault";
    ServiceType["Unknown"] = "unknown";
})(ServiceType || (ServiceType = {}));
/**
 * ì„œë¹„ìŠ¤ ì„¤ì • ê´€ë¦¬ìž í´ëž˜ìŠ¤
 */
class ServiceConfigManager {
    context;
    configs = new Map();
    disposables = [];
    /**
     * ìƒì„±ìž
     * @param context VSCode í™•ìž¥ ì»¨í…ìŠ¤íŠ¸
     */
    constructor(context) {
        this.context = context;
        // ì´ˆê¸° ì„¤ì • ë¡œë“œ
        this.loadAllConfigs();
        // ì„¤ì • ë³€ê²½ ê°ì§€
        this.disposables.push(external_vscode_.workspace.onDidChangeConfiguration(e => {
            let configChanged = false;
            for (const serviceType of Object.values(ServiceType)) {
                if (e.affectsConfiguration(`ape.${serviceType}`)) {
                    this.loadServiceConfig(serviceType);
                    configChanged = true;
                }
            }
            if (configChanged) {
                // ì„¤ì • ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
                this.onConfigChange();
            }
        }));
    }
    /**
     * ì„¤ì • ë³€ê²½ ì‹œ í˜¸ì¶œë  ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬
     * @private
     */
    onConfigChange() {
        // ì„¤ì • ë³€ê²½ ì´ë²¤íŠ¸ë¥¼ êµ¬ë…ìžì—ê²Œ ì•Œë¦¼
        // í–¥í›„ EventEmitter ì¶”ê°€ ê°€ëŠ¥
    }
    /**
     * ëª¨ë“  ì„œë¹„ìŠ¤ ì„¤ì • ë¡œë“œ
     * @private
     */
    loadAllConfigs() {
        for (const serviceType of Object.values(ServiceType)) {
            this.loadServiceConfig(serviceType);
        }
    }
    /**
     * íŠ¹ì • ì„œë¹„ìŠ¤ ì„¤ì • ë¡œë“œ
     * @param serviceType ì„œë¹„ìŠ¤ ìœ í˜•
     * @private
     */
    loadServiceConfig(serviceType) {
        const config = external_vscode_.workspace.getConfiguration(`ape.${serviceType}`);
        const serviceConfig = {
            enabled: config.get('enabled', false),
            url: config.get('url', ''),
            authType: config.get('authType', AuthType.None),
            username: config.get('username', ''),
            password: config.get('password', ''),
            token: config.get('token', ''),
            useMock: config.get('useMock', true),
            additionalParams: {}
        };
        // VAULT ì„œë¹„ìŠ¤ì¸ ê²½ìš° ë””ë ‰í† ë¦¬ ê²½ë¡œ ì¶”ê°€
        if (serviceType === ServiceType.Vault) {
            serviceConfig.additionalParams = {
                vaultDirectory: config.get('vaultDirectory', '.ape-vault')
            };
        }
        else {
            serviceConfig.additionalParams = config.get('additionalParams', {});
        }
        this.configs.set(serviceType, serviceConfig);
    }
    /**
     * ì„œë¹„ìŠ¤ ì„¤ì • ê°€ì ¸ì˜¤ê¸°
     * @param serviceType ì„œë¹„ìŠ¤ ìœ í˜•
     */
    getServiceConfig(serviceType) {
        // ì„¤ì •ì´ ì—†ìœ¼ë©´ ìƒˆë¡œ ë¡œë“œ
        if (!this.configs.has(serviceType)) {
            this.loadServiceConfig(serviceType);
        }
        return this.configs.get(serviceType);
    }
    /**
     * ì„œë¹„ìŠ¤ ì„¤ì • ì—…ë°ì´íŠ¸
     * @param serviceType ì„œë¹„ìŠ¤ ìœ í˜•
     * @param config ìƒˆ ì„¤ì •
     */
    async updateServiceConfig(serviceType, config) {
        try {
            const vscodeConfig = external_vscode_.workspace.getConfiguration(`ape.${serviceType}`);
            // ê° í•„ë“œ ì—…ë°ì´íŠ¸
            for (const [key, value] of Object.entries(config)) {
                if (value !== undefined) {
                    await vscodeConfig.update(key, value, external_vscode_.ConfigurationTarget.Global);
                }
            }
            // ì„¤ì • ë‹¤ì‹œ ë¡œë“œ
            this.loadServiceConfig(serviceType);
            return true;
        }
        catch (error) {
            console.error(`ì„œë¹„ìŠ¤ ì„¤ì • ì—…ë°ì´íŠ¸ ì˜¤ë¥˜ (${serviceType}):`, error);
            return false;
        }
    }
    /**
     * ì„œë¹„ìŠ¤ ì„¤ì • ê²€ì¦
     * @param serviceType ì„œë¹„ìŠ¤ ìœ í˜•
     */
    validateServiceConfig(serviceType) {
        const config = this.getServiceConfig(serviceType);
        const errors = [];
        // ê¸°ë³¸ ê²€ì¦: ì„œë¹„ìŠ¤ê°€ í™œì„±í™”ë˜ì–´ ìžˆëŠ” ê²½ìš° URL í•„ìˆ˜
        if (config.enabled && !config.useMock) {
            if (!config.url) {
                errors.push(`${serviceType} ì„œë¹„ìŠ¤ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
            }
            else if (!this.isValidUrl(config.url)) {
                errors.push(`${serviceType} ì„œë¹„ìŠ¤ URL í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤: ${config.url}`);
            }
            // ì¸ì¦ ìœ í˜•ì— ë”°ë¥¸ ê²€ì¦
            if (config.authType === AuthType.Basic) {
                if (!config.username) {
                    errors.push(`${serviceType} ì„œë¹„ìŠ¤ ì‚¬ìš©ìž ì´ë¦„ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
                }
                if (!config.password) {
                    errors.push(`${serviceType} ì„œë¹„ìŠ¤ ë¹„ë°€ë²ˆí˜¸ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
                }
            }
            else if (config.authType === AuthType.Token) {
                if (!config.token) {
                    errors.push(`${serviceType} ì„œë¹„ìŠ¤ í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
                }
            }
            else if (config.authType === AuthType.OAuth) {
                if (!config.token) {
                    errors.push(`${serviceType} ì„œë¹„ìŠ¤ OAuth í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
                }
            }
            else if (config.authType === AuthType.AWS) {
                const params = config.additionalParams || {};
                if (!params.accessKeyId) {
                    errors.push(`${serviceType} ì„œë¹„ìŠ¤ AWS ì•¡ì„¸ìŠ¤ í‚¤ IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
                }
                if (!params.secretAccessKey) {
                    errors.push(`${serviceType} ì„œë¹„ìŠ¤ AWS ì‹œí¬ë¦¿ ì•¡ì„¸ìŠ¤ í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
                }
                if (!params.region) {
                    errors.push(`${serviceType} ì„œë¹„ìŠ¤ AWS ë¦¬ì „ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`);
                }
            }
        }
        return errors;
    }
    /**
     * URL ìœ íš¨ì„± ê²€ì‚¬
     * @param url ê²€ì‚¬í•  URL
     * @private
     */
    isValidUrl(url) {
        try {
            new URL(url);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * ì„œë¹„ìŠ¤ ì—°ê²° í…ŒìŠ¤íŠ¸
     * @param serviceType ì„œë¹„ìŠ¤ ìœ í˜•
     */
    async testConnection(serviceType) {
        const config = this.getServiceConfig(serviceType);
        // ëª¨ì˜ ëª¨ë“œì¸ ê²½ìš° í•­ìƒ ì„±ê³µ
        if (config.useMock) {
            return {
                success: true,
                message: `${serviceType} ì„œë¹„ìŠ¤ê°€ ëª¨ì˜ ëª¨ë“œë¡œ ì„¤ì •ë˜ì–´ ìžˆìŠµë‹ˆë‹¤. ì‹¤ì œ ì„œë²„ì— ì—°ê²°í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`
            };
        }
        // ìœ íš¨ì„± ê²€ì‚¬
        const errors = this.validateServiceConfig(serviceType);
        if (errors.length > 0) {
            return {
                success: false,
                message: `ì„¤ì • ì˜¤ë¥˜: ${errors.join(' ')}`
            };
        }
        // ì‹¤ì œ ì—°ê²° í…ŒìŠ¤íŠ¸ëŠ” ê° ì„œë¹„ìŠ¤ë³„ í´ëž˜ìŠ¤ì—ì„œ êµ¬í˜„
        return {
            success: true,
            message: `${serviceType} ì„œë¹„ìŠ¤ ì„¤ì •ì´ ìœ íš¨í•©ë‹ˆë‹¤. ì‹¤ì œ ì—°ê²° í…ŒìŠ¤íŠ¸ëŠ” ê° ì„œë¹„ìŠ¤ í´ëž˜ìŠ¤ì—ì„œ ìˆ˜í–‰í•©ë‹ˆë‹¤.`
        };
    }
    /**
     * ë¦¬ì†ŒìŠ¤ í•´ì œ
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}

;// ./src/core/services/serviceError.ts
/**
 * ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ëª¨ë“ˆ
 *
 * ì™¸ë¶€ ì„œë¹„ìŠ¤ ì—°ê²° ë° ì‚¬ìš© ì¤‘ ë°œìƒí•˜ëŠ” ì˜¤ë¥˜ë¥¼ ì²˜ë¦¬í•˜ëŠ” ê¸°ëŠ¥ ì œê³µ
 * ì¼ê´€ëœ ì˜¤ë¥˜ ì²˜ë¦¬ì™€ ì‚¬ìš©ìž ì¹œí™”ì ì¸ ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ìœ„í•œ ìœ í‹¸ë¦¬í‹°
 */


/**
 * ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ìœ í˜• ì—´ê±°í˜•
 */
var ServiceErrorType;
(function (ServiceErrorType) {
    // ì—°ê²° ê´€ë ¨ ì˜¤ë¥˜
    ServiceErrorType["ConnectionFailed"] = "connection_failed";
    ServiceErrorType["Timeout"] = "timeout";
    // ì¸ì¦ ê´€ë ¨ ì˜¤ë¥˜
    ServiceErrorType["AuthenticationFailed"] = "authentication_failed";
    ServiceErrorType["TokenExpired"] = "token_expired";
    ServiceErrorType["PermissionDenied"] = "permission_denied";
    // ë¦¬ì†ŒìŠ¤ ê´€ë ¨ ì˜¤ë¥˜
    ServiceErrorType["ResourceNotFound"] = "resource_not_found";
    ServiceErrorType["InvalidResource"] = "invalid_resource";
    // ìš”ì²­ ê´€ë ¨ ì˜¤ë¥˜
    ServiceErrorType["InvalidRequest"] = "invalid_request";
    ServiceErrorType["BadRequest"] = "bad_request";
    ServiceErrorType["RateLimited"] = "rate_limited";
    // ì„œë²„ ê´€ë ¨ ì˜¤ë¥˜
    ServiceErrorType["ServerError"] = "server_error";
    ServiceErrorType["ServiceUnavailable"] = "service_unavailable";
    // í™˜ê²½ ê´€ë ¨ ì˜¤ë¥˜
    ServiceErrorType["ConfigurationError"] = "configuration_error";
    // ê¸°íƒ€ ì˜¤ë¥˜
    ServiceErrorType["Unknown"] = "unknown";
})(ServiceErrorType || (ServiceErrorType = {}));
/**
 * ì„œë¹„ìŠ¤ ì˜¤ë¥˜ í´ëž˜ìŠ¤
 */
class ServiceError extends Error {
    type;
    serviceType;
    details;
    timestamp;
    /**
     * ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ìƒì„±ìž
     * @param message ì˜¤ë¥˜ ë©”ì‹œì§€
     * @param originalError ì›ë³¸ ì˜¤ë¥˜ (ì˜µì…˜)
     * @param serviceType ì„œë¹„ìŠ¤ íƒ€ìž… (ê¸°ë³¸ê°’: Unknown)
     * @param errorType ì˜¤ë¥˜ íƒ€ìž… (ê¸°ë³¸ê°’: Unknown)
     */
    constructor(message, originalError, serviceType = ServiceType.Unknown, errorType = ServiceErrorType.Unknown) {
        super(message);
        this.name = 'ServiceError';
        this.message = message;
        this.type = errorType;
        this.serviceType = serviceType;
        this.details = originalError;
        this.timestamp = new Date();
        // Error ê°ì²´ì˜ í”„ë¡œí† íƒ€ìž… ì²´ì¸ ìœ ì§€
        Object.setPrototypeOf(this, ServiceError.prototype);
    }
}
/**
 * ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ê´€ë¦¬ìž í´ëž˜ìŠ¤
 */
class ServiceErrorManager {
    static _lastErrors = new Map();
    /**
     * ì˜¤ë¥˜ ìƒì„± ë° ë“±ë¡
     * @param serviceType ì„œë¹„ìŠ¤ ìœ í˜•
     * @param errorType ì˜¤ë¥˜ ìœ í˜•
     * @param message ì˜¤ë¥˜ ë©”ì‹œì§€
     * @param details ì¶”ê°€ ì„¸ë¶€ ì •ë³´
     * @returns ìƒì„±ëœ ì„œë¹„ìŠ¤ ì˜¤ë¥˜
     */
    static createError(serviceType, errorType, message, details) {
        const error = new ServiceError(message, details, serviceType, errorType);
        // í•´ë‹¹ ì„œë¹„ìŠ¤ì˜ ë§ˆì§€ë§‰ ì˜¤ë¥˜ ì €ìž¥
        this._lastErrors.set(serviceType, error);
        // ì½˜ì†”ì— ì˜¤ë¥˜ ê¸°ë¡
        console.error(`[${serviceType}] ${errorType}: ${message}`, details || '');
        return error;
    }
    /**
     * ë§ˆì§€ë§‰ ì˜¤ë¥˜ ê°€ì ¸ì˜¤ê¸°
     * @param serviceType ì„œë¹„ìŠ¤ ìœ í˜•
     * @returns ë§ˆì§€ë§‰ ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ë˜ëŠ” null
     */
    static getLastError(serviceType) {
        return this._lastErrors.get(serviceType) || null;
    }
    /**
     * ëª¨ë“  ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ê°€ì ¸ì˜¤ê¸°
     * @returns ëª¨ë“  ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ë§µ
     */
    static getAllErrors() {
        return new Map(this._lastErrors);
    }
    /**
     * ì„œë¹„ìŠ¤ ì˜¤ë¥˜ë¥¼ ì‚¬ìš©ìž ì¹œí™”ì ì¸ ë©”ì‹œì§€ë¡œ ë³€í™˜
     * @param error ì„œë¹„ìŠ¤ ì˜¤ë¥˜
     * @returns ì‚¬ìš©ìž ì¹œí™”ì ì¸ ì˜¤ë¥˜ ë©”ì‹œì§€
     */
    static getUserFriendlyMessage(error) {
        // ì„œë¹„ìŠ¤ ìœ í˜•ë³„ í•œê¸€ ì´ë¦„
        const serviceNames = {
            [ServiceType.Git]: 'Git',
            [ServiceType.Bitbucket]: 'Bitbucket',
            [ServiceType.Jira]: 'Jira',
            [ServiceType.S3]: 'Pocket/S3',
            [ServiceType.SWDP]: 'SWDP',
            [ServiceType.Vault]: 'VAULT',
            [ServiceType.Unknown]: 'ì•Œ ìˆ˜ ì—†ëŠ” ì„œë¹„ìŠ¤'
        };
        const serviceName = serviceNames[error.serviceType] || error.serviceType;
        // ì˜¤ë¥˜ ìœ í˜•ë³„ ê¸°ë³¸ ë©”ì‹œì§€
        switch (error.type) {
            case ServiceErrorType.ConnectionFailed:
                return `${serviceName} ì„œë²„ ì—°ê²°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. URLì„ í™•ì¸í•˜ì„¸ìš”: ${error.details?.url || ''}`;
            case ServiceErrorType.Timeout:
                return `${serviceName} ì„œë²„ ì‘ë‹µ ì‹œê°„ì´ ì´ˆê³¼ë˜ì—ˆìŠµë‹ˆë‹¤. ì„œë²„ ìƒíƒœë‚˜ ë„¤íŠ¸ì›Œí¬ë¥¼ í™•ì¸í•˜ì„¸ìš”.`;
            case ServiceErrorType.AuthenticationFailed:
                return `${serviceName} ì¸ì¦ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì•„ì´ë””ì™€ ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.`;
            case ServiceErrorType.TokenExpired:
                return `${serviceName} ì¸ì¦ í† í°ì´ ë§Œë£Œë˜ì—ˆìŠµë‹ˆë‹¤. í† í°ì„ ê°±ì‹ í•˜ì„¸ìš”.`;
            case ServiceErrorType.PermissionDenied:
                return `${serviceName} ì ‘ê·¼ ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤. ê³„ì • ê¶Œí•œì„ í™•ì¸í•˜ì„¸ìš”.`;
            case ServiceErrorType.ResourceNotFound:
                return `${serviceName}ì—ì„œ ìš”ì²­í•œ ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`;
            case ServiceErrorType.InvalidResource:
                return `${serviceName}ì— ìž˜ëª»ëœ ë¦¬ì†ŒìŠ¤ê°€ ìš”ì²­ë˜ì—ˆìŠµë‹ˆë‹¤.`;
            case ServiceErrorType.InvalidRequest:
            case ServiceErrorType.BadRequest:
                return `${serviceName}ì— ìž˜ëª»ëœ ìš”ì²­ì´ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.`;
            case ServiceErrorType.RateLimited:
                return `${serviceName} ìš”ì²­ í•œë„ë¥¼ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. ìž ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.`;
            case ServiceErrorType.ServerError:
                return `${serviceName} ì„œë²„ì— ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì„œë²„ ê´€ë¦¬ìžì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.`;
            case ServiceErrorType.ServiceUnavailable:
                return `${serviceName} ì„œë¹„ìŠ¤ë¥¼ í˜„ìž¬ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì„œë¹„ìŠ¤ ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”.`;
            case ServiceErrorType.ConfigurationError:
                return `${serviceName} ì„¤ì • ì˜¤ë¥˜: ${error.message}`;
            case ServiceErrorType.Unknown:
            default:
                return `${serviceName} ì˜¤ë¥˜: ${error.message}`;
        }
    }
    /**
     * ì˜¤ë¥˜ë¥¼ ì‚¬ìš©ìžì—ê²Œ í‘œì‹œ
     * @param error ì„œë¹„ìŠ¤ ì˜¤ë¥˜
     * @param showDetailAction ì„¸ë¶€ ì •ë³´ í‘œì‹œ ì•¡ì…˜ í¬í•¨ ì—¬ë¶€
     */
    static async showErrorToUser(error, showDetailAction = true) {
        const userMessage = this.getUserFriendlyMessage(error);
        if (showDetailAction) {
            const selection = await external_vscode_.window.showErrorMessage(userMessage, 'ì„¸ë¶€ ì •ë³´', 'ë‹«ê¸°');
            if (selection === 'ì„¸ë¶€ ì •ë³´') {
                // ì„¸ë¶€ ì •ë³´ë¥¼ ì¶œë ¥ ì±„ë„ì— í‘œì‹œ
                const outputChannel = external_vscode_.window.createOutputChannel(`APE ${error.serviceType} ì˜¤ë¥˜`);
                outputChannel.appendLine(`ì‹œê°„: ${error.timestamp.toLocaleString()}`);
                outputChannel.appendLine(`ì„œë¹„ìŠ¤: ${error.serviceType}`);
                outputChannel.appendLine(`ì˜¤ë¥˜ ìœ í˜•: ${error.type}`);
                outputChannel.appendLine(`ë©”ì‹œì§€: ${error.message}`);
                if (error.details) {
                    outputChannel.appendLine('\nì„¸ë¶€ ì •ë³´:');
                    outputChannel.appendLine(JSON.stringify(error.details, null, 2));
                }
                outputChannel.show();
            }
        }
        else {
            external_vscode_.window.showErrorMessage(userMessage);
        }
    }
    /**
     * HTTP ìƒíƒœ ì½”ë“œë¥¼ ServiceErrorTypeìœ¼ë¡œ ë³€í™˜
     * @param statusCode HTTP ìƒíƒœ ì½”ë“œ
     * @returns ëŒ€ì‘í•˜ëŠ” ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ìœ í˜•
     */
    static errorTypeFromHttpStatus(statusCode) {
        if (statusCode >= 500) {
            return ServiceErrorType.ServerError;
        }
        switch (statusCode) {
            case 400:
                return ServiceErrorType.BadRequest;
            case 401:
                return ServiceErrorType.AuthenticationFailed;
            case 403:
                return ServiceErrorType.PermissionDenied;
            case 404:
                return ServiceErrorType.ResourceNotFound;
            case 408:
                return ServiceErrorType.Timeout;
            case 429:
                return ServiceErrorType.RateLimited;
            default:
                return ServiceErrorType.Unknown;
        }
    }
}

;// ./src/core/services/vaultService.ts
/**
 * VAULT ì„œë¹„ìŠ¤
 *
 * VAULT ì»¨í…ìŠ¤íŠ¸ ë° ì•„ì´í…œì„ ê´€ë¦¬í•˜ëŠ” ì„œë¹„ìŠ¤ìž…ë‹ˆë‹¤.
 * ì»¨í…ìŠ¤íŠ¸ ì €ìž¥, ë¶ˆëŸ¬ì˜¤ê¸°, ì•„ì´í…œ ê´€ë¦¬ ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 */



/**
 * VAULT ì»¨í…ìŠ¤íŠ¸ íƒ€ìž…
 */
var VaultContextType;
(function (VaultContextType) {
    VaultContextType["System"] = "system";
    VaultContextType["Project"] = "project";
    VaultContextType["Personal"] = "personal";
    VaultContextType["Shared"] = "shared";
    VaultContextType["Template"] = "template";
})(VaultContextType || (VaultContextType = {}));
/**
 * VAULT ì„œë¹„ìŠ¤ í´ëž˜ìŠ¤
 */
class VaultService {
    context;
    configManager;
    _onDidChangeVault = new external_vscode_.EventEmitter();
    onDidChangeVault = this._onDidChangeVault.event;
    contexts = new Map();
    disposables = [];
    vaultDir;
    fs = __webpack_require__(9896);
    path = __webpack_require__(6928);
    /**
     * ìƒì„±ìž
     * @param context VSCode í™•ìž¥ ì»¨í…ìŠ¤íŠ¸
     * @param configManager ì„œë¹„ìŠ¤ ì„¤ì • ê´€ë¦¬ìž
     */
    constructor(context, configManager) {
        this.context = context;
        this.configManager = configManager;
        // VAULT ë””ë ‰í† ë¦¬ ê²½ë¡œ ì„¤ì •
        const config = this.configManager.getServiceConfig(ServiceType.Vault);
        this.vaultDir = config.additionalParams?.vaultDirectory || '.ape-vault';
        // ì ˆëŒ€ ê²½ë¡œê°€ ì•„ë‹ˆë©´ í™ˆ ë””ë ‰í† ë¦¬ ê¸°ì¤€ìœ¼ë¡œ ì„¤ì •
        if (!this.path.isAbsolute(this.vaultDir)) {
            this.vaultDir = this.path.join(this.getUserHomeDir(), this.vaultDir);
        }
        // VAULT ë””ë ‰í† ë¦¬ ì¡´ìž¬ í™•ì¸ ë° ìƒì„±
        this.ensureVaultDirectory();
        // ì„¤ì • ë³€ê²½ ì´ë²¤íŠ¸ êµ¬ë…
        this.disposables.push(external_vscode_.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.vault')) {
                // ì„¤ì •ì´ ë³€ê²½ë˜ë©´ ë””ë ‰í† ë¦¬ ê²½ë¡œ ì—…ë°ì´íŠ¸
                const newConfig = this.configManager.getServiceConfig(ServiceType.Vault);
                const newDir = newConfig.additionalParams?.vaultDirectory || '.ape-vault';
                if (newDir !== this.vaultDir) {
                    this.vaultDir = this.path.isAbsolute(newDir)
                        ? newDir
                        : this.path.join(this.getUserHomeDir(), newDir);
                    this.ensureVaultDirectory();
                    this.loadAllContexts();
                }
                else {
                    this.loadAllContexts();
                }
            }
        }));
        // ì´ˆê¸° ë°ì´í„° ë¡œë“œ
        this.loadAllContexts();
    }
    /**
     * ì‚¬ìš©ìž í™ˆ ë””ë ‰í† ë¦¬ ê°€ì ¸ì˜¤ê¸°
     */
    getUserHomeDir() {
        return process.env.HOME || process.env.USERPROFILE || '.';
    }
    /**
     * VAULT ë””ë ‰í† ë¦¬ ì¡´ìž¬ í™•ì¸ ë° ìƒì„±
     */
    ensureVaultDirectory() {
        try {
            // ë©”ì¸ VAULT ë””ë ‰í† ë¦¬
            if (!this.fs.existsSync(this.vaultDir)) {
                this.fs.mkdirSync(this.vaultDir, { recursive: true });
                console.log(`VAULT ë””ë ‰í† ë¦¬ ìƒì„±ë¨: ${this.vaultDir}`);
            }
            // ì»¨í…ìŠ¤íŠ¸ íƒ€ìž…ë³„ í•˜ìœ„ ë””ë ‰í† ë¦¬
            const contextTypeDirs = Object.values(VaultContextType);
            for (const dir of contextTypeDirs) {
                const typePath = this.path.join(this.vaultDir, dir);
                if (!this.fs.existsSync(typePath)) {
                    this.fs.mkdirSync(typePath, { recursive: true });
                }
            }
        }
        catch (error) {
            console.error('VAULT ë””ë ‰í† ë¦¬ ìƒì„± ì˜¤ë¥˜:', error);
            external_vscode_.window.showErrorMessage(`VAULT ë””ë ‰í† ë¦¬ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${error}`);
        }
    }
    /**
     * ëª¨ë“  ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ
     */
    async loadAllContexts() {
        try {
            this.contexts.clear();
            const config = this.configManager.getServiceConfig(ServiceType.Vault);
            if (config.useMock) {
                // ëª¨ì˜ ë°ì´í„° ë¡œë“œ
                this.loadMockContexts();
            }
            else if (config.enabled) {
                // íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ ë°ì´í„° ë¡œë“œ
                await this.loadContextsFromFileSystem();
                // ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
                if (this.contexts.size === 0) {
                    this.createDefaultContexts();
                }
            }
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeVault.fire();
        }
        catch (error) {
            console.error('VAULT ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ ì˜¤ë¥˜:', error);
            external_vscode_.window.showErrorMessage(`VAULT ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`);
        }
    }
    /**
     * íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ
     */
    async loadContextsFromFileSystem() {
        try {
            // ê° ì»¨í…ìŠ¤íŠ¸ íƒ€ìž… ë””ë ‰í† ë¦¬ ì²˜ë¦¬
            for (const contextType of Object.values(VaultContextType)) {
                const typeDir = this.path.join(this.vaultDir, contextType);
                // ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ê±´ë„ˆë›°ê¸°
                if (!this.fs.existsSync(typeDir)) {
                    continue;
                }
                // ì»¨í…ìŠ¤íŠ¸ ë©”íƒ€ë°ì´í„° íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                const contextFiles = this.fs.readdirSync(typeDir)
                    .filter((file) => file.endsWith('.context.json'));
                // ê° ì»¨í…ìŠ¤íŠ¸ íŒŒì¼ ë¡œë“œ
                for (const fileName of contextFiles) {
                    try {
                        const filePath = this.path.join(typeDir, fileName);
                        const data = this.fs.readFileSync(filePath, 'utf8');
                        const contextData = JSON.parse(data);
                        // ë‚ ì§œ ë¬¸ìžì—´ì„ Date ê°ì²´ë¡œ ë³€í™˜
                        contextData.createdAt = new Date(contextData.createdAt);
                        contextData.updatedAt = new Date(contextData.updatedAt);
                        // ì»¨í…ìŠ¤íŠ¸ ì•„ì´í…œ ë¡œë“œ
                        contextData.items = await this.loadContextItems(contextData.id, contextType);
                        // ì»¨í…ìŠ¤íŠ¸ ë§µì— ì¶”ê°€
                        this.contexts.set(contextData.id, contextData);
                    }
                    catch (error) {
                        console.error(`ì»¨í…ìŠ¤íŠ¸ íŒŒì¼ ë¡œë“œ ì˜¤ë¥˜ (${fileName}):`, error);
                    }
                }
            }
        }
        catch (error) {
            console.error('íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ ì»¨í…ìŠ¤íŠ¸ ë¡œë“œ ì˜¤ë¥˜:', error);
            throw error;
        }
    }
    /**
     * íŠ¹ì • ì»¨í…ìŠ¤íŠ¸ì˜ ì•„ì´í…œ ë¡œë“œ
     * @param contextId ì»¨í…ìŠ¤íŠ¸ ID
     * @param contextType ì»¨í…ìŠ¤íŠ¸ íƒ€ìž…
     */
    async loadContextItems(contextId, contextType) {
        const items = [];
        const itemsDir = this.path.join(this.vaultDir, contextType, contextId);
        // ì•„ì´í…œ ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜
        if (!this.fs.existsSync(itemsDir)) {
            return items;
        }
        // ì•„ì´í…œ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        const itemFiles = this.fs.readdirSync(itemsDir)
            .filter((file) => file.endsWith('.item.json'));
        // ê° ì•„ì´í…œ íŒŒì¼ ë¡œë“œ
        for (const fileName of itemFiles) {
            try {
                const filePath = this.path.join(itemsDir, fileName);
                const data = this.fs.readFileSync(filePath, 'utf8');
                const itemData = JSON.parse(data);
                // ë‚ ì§œ ë¬¸ìžì—´ì„ Date ê°ì²´ë¡œ ë³€í™˜
                itemData.createdAt = new Date(itemData.createdAt);
                itemData.updatedAt = new Date(itemData.updatedAt);
                // ì½˜í…ì¸  íŒŒì¼ ë¡œë“œ
                const contentFilePath = this.path.join(itemsDir, `${itemData.id}.content.md`);
                if (this.fs.existsSync(contentFilePath)) {
                    itemData.content = this.fs.readFileSync(contentFilePath, 'utf8');
                }
                items.push(itemData);
            }
            catch (error) {
                console.error(`ì•„ì´í…œ íŒŒì¼ ë¡œë“œ ì˜¤ë¥˜ (${fileName}):`, error);
            }
        }
        return items;
    }
    /**
     * ê¸°ë³¸ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
     */
    createDefaultContexts() {
        // ëª¨ì˜ ë°ì´í„° ë¡œë“œí•˜ì—¬ ê¸°ë³¸ ì»¨í…ìŠ¤íŠ¸ë¡œ ì €ìž¥
        this.loadMockContexts();
        // ê° ì»¨í…ìŠ¤íŠ¸ ì €ìž¥
        this.contexts.forEach(context => {
            this.saveContextToFileSystem(context);
        });
    }
    /**
     * ì»¨í…ìŠ¤íŠ¸ë¥¼ íŒŒì¼ ì‹œìŠ¤í…œì— ì €ìž¥
     * @param context ì €ìž¥í•  ì»¨í…ìŠ¤íŠ¸
     */
    saveContextToFileSystem(context) {
        try {
            // ì»¨í…ìŠ¤íŠ¸ íƒ€ìž… ë””ë ‰í† ë¦¬ ê²½ë¡œ
            const typeDir = this.path.join(this.vaultDir, context.type);
            // ì»¨í…ìŠ¤íŠ¸ ë©”íƒ€ë°ì´í„° ì €ìž¥
            const contextMetadata = { ...context };
            delete contextMetadata.items; // ì•„ì´í…œì€ ë³„ë„ë¡œ ì €ìž¥
            const contextFilePath = this.path.join(typeDir, `${context.id}.context.json`);
            this.fs.writeFileSync(contextFilePath, JSON.stringify(contextMetadata, null, 2), 'utf8');
            // ì»¨í…ìŠ¤íŠ¸ ì•„ì´í…œ ë””ë ‰í† ë¦¬ ìƒì„±
            const itemsDir = this.path.join(typeDir, context.id);
            if (!this.fs.existsSync(itemsDir)) {
                this.fs.mkdirSync(itemsDir, { recursive: true });
            }
            // ê° ì•„ì´í…œ ì €ìž¥
            context.items.forEach(item => {
                this.saveItemToFileSystem(item, context.id, context.type);
            });
        }
        catch (error) {
            console.error(`ì»¨í…ìŠ¤íŠ¸ ì €ìž¥ ì˜¤ë¥˜ (${context.id}):`, error);
        }
    }
    /**
     * ì•„ì´í…œì„ íŒŒì¼ ì‹œìŠ¤í…œì— ì €ìž¥
     * @param item ì €ìž¥í•  ì•„ì´í…œ
     * @param contextId ì»¨í…ìŠ¤íŠ¸ ID
     * @param contextType ì»¨í…ìŠ¤íŠ¸ íƒ€ìž…
     */
    saveItemToFileSystem(item, contextId, contextType) {
        try {
            // ì•„ì´í…œ ë””ë ‰í† ë¦¬ ê²½ë¡œ
            const itemsDir = this.path.join(this.vaultDir, contextType, contextId);
            // ì•„ì´í…œ ë©”íƒ€ë°ì´í„° ì €ìž¥
            const itemMetadata = { ...item };
            const content = itemMetadata.content;
            delete itemMetadata.content; // ë‚´ìš©ì€ ë³„ë„ íŒŒì¼ë¡œ ì €ìž¥
            const itemFilePath = this.path.join(itemsDir, `${item.id}.item.json`);
            this.fs.writeFileSync(itemFilePath, JSON.stringify(itemMetadata, null, 2), 'utf8');
            // ì•„ì´í…œ ë‚´ìš© ì €ìž¥
            const contentFilePath = this.path.join(itemsDir, `${item.id}.content.md`);
            this.fs.writeFileSync(contentFilePath, content, 'utf8');
        }
        catch (error) {
            console.error(`ì•„ì´í…œ ì €ìž¥ ì˜¤ë¥˜ (${item.id}):`, error);
        }
    }
    /**
     * ëª¨ì˜ ì»¨í…ìŠ¤íŠ¸ ë°ì´í„° ë¡œë“œ
     */
    loadMockContexts() {
        this.contexts.clear();
        // ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸
        const systemContext = {
            id: 'system-context',
            name: 'ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸',
            description: 'ì‹œìŠ¤í…œ ê¸°ë³¸ ì»¨í…ìŠ¤íŠ¸ìž…ë‹ˆë‹¤.',
            type: VaultContextType.System,
            createdAt: new Date('2023-01-01'),
            updatedAt: new Date('2023-01-01'),
            items: [
                {
                    id: 'system-item-1',
                    name: 'ê¸°ë³¸ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸',
                    description: 'í‘œì¤€ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ìž…ë‹ˆë‹¤.',
                    content: 'You are an AI assistant. Answer questions concisely and accurately.',
                    createdAt: new Date('2023-01-01'),
                    updatedAt: new Date('2023-01-01'),
                    contextType: VaultContextType.System,
                    contextId: 'system-context',
                    tags: ['system', 'default', 'prompt']
                },
                {
                    id: 'system-item-2',
                    name: 'ì½”ë“œ ë¦¬ë·° í”„ë¡¬í”„íŠ¸',
                    description: 'ì½”ë“œ ë¦¬ë·°ìš© ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ìž…ë‹ˆë‹¤.',
                    content: 'You are a code review assistant. Analyze the provided code and give feedback.',
                    createdAt: new Date('2023-01-02'),
                    updatedAt: new Date('2023-01-02'),
                    contextType: VaultContextType.System,
                    contextId: 'system-context',
                    tags: ['system', 'code-review', 'prompt']
                }
            ]
        };
        // í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸
        const projectContext = {
            id: 'project-context',
            name: 'APE í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸',
            description: 'APE í”„ë¡œì íŠ¸ ê´€ë ¨ ì»¨í…ìŠ¤íŠ¸ìž…ë‹ˆë‹¤.',
            type: VaultContextType.Project,
            createdAt: new Date('2023-02-01'),
            updatedAt: new Date('2023-02-01'),
            items: [
                {
                    id: 'project-item-1',
                    name: 'í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜',
                    description: 'APE í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜ ì„¤ëª…ìž…ë‹ˆë‹¤.',
                    content: 'APE í”„ë¡œì íŠ¸ëŠ” ë‹¤ìŒê³¼ ê°™ì€ êµ¬ì¡°ë¡œ ì´ë£¨ì–´ì ¸ ìžˆìŠµë‹ˆë‹¤. Core ëª¨ë“ˆ, UI ëª¨ë“ˆ, ì„œë¹„ìŠ¤ ëª¨ë“ˆ...',
                    createdAt: new Date('2023-02-01'),
                    updatedAt: new Date('2023-02-01'),
                    contextType: VaultContextType.Project,
                    contextId: 'project-context',
                    tags: ['project', 'architecture', 'documentation']
                },
                {
                    id: 'project-item-2',
                    name: 'ê°œë°œ ê°€ì´ë“œë¼ì¸',
                    description: 'í”„ë¡œì íŠ¸ ê°œë°œ ê°€ì´ë“œë¼ì¸ìž…ë‹ˆë‹¤.',
                    content: 'ì½”ë“œ ìž‘ì„± ì‹œ ë‹¤ìŒ ê°€ì´ë“œë¼ì¸ì„ ë”°ë¼ì£¼ì„¸ìš”. 1. í•¨ìˆ˜ëŠ” ë‹¨ì¼ ì±…ìž„ì„ ê°€ì§‘ë‹ˆë‹¤...',
                    createdAt: new Date('2023-02-02'),
                    updatedAt: new Date('2023-02-02'),
                    contextType: VaultContextType.Project,
                    contextId: 'project-context',
                    tags: ['project', 'guidelines', 'development']
                }
            ]
        };
        // ê°œì¸ ì»¨í…ìŠ¤íŠ¸
        const personalContext = {
            id: 'personal-context',
            name: 'ê°œì¸ ì»¨í…ìŠ¤íŠ¸',
            description: 'ê°œì¸ì ì¸ ìž‘ì—… ë§¥ë½ìž…ë‹ˆë‹¤.',
            type: VaultContextType.Personal,
            createdAt: new Date('2023-03-01'),
            updatedAt: new Date('2023-03-01'),
            items: [
                {
                    id: 'personal-item-1',
                    name: 'ë‚´ ìž‘ì—… ë©”ëª¨',
                    description: 'í˜„ìž¬ ìž‘ì—… ë©”ëª¨ìž…ë‹ˆë‹¤.',
                    content: 'íŠ¸ë¦¬ë·° ê¸°ëŠ¥ êµ¬í˜„ ì¤‘ì´ë©°, ë‹¤ìŒ ë‹¨ê³„ë¡œ ì»¨í…ìŠ¤íŠ¸ ì²˜ë¦¬ ê¸°ëŠ¥ êµ¬í˜„ ì˜ˆì •...',
                    createdAt: new Date('2023-03-01'),
                    updatedAt: new Date('2023-03-01'),
                    contextType: VaultContextType.Personal,
                    contextId: 'personal-context',
                    tags: ['personal', 'memo', 'work']
                }
            ]
        };
        // ê³µìœ  ì»¨í…ìŠ¤íŠ¸
        const sharedContext = {
            id: 'shared-context',
            name: 'íŒ€ ê³µìœ  ì»¨í…ìŠ¤íŠ¸',
            description: 'íŒ€ ê°„ ê³µìœ ë˜ëŠ” ì»¨í…ìŠ¤íŠ¸ìž…ë‹ˆë‹¤.',
            type: VaultContextType.Shared,
            createdAt: new Date('2023-04-01'),
            updatedAt: new Date('2023-04-01'),
            items: [
                {
                    id: 'shared-item-1',
                    name: 'íŒ€ íšŒì˜ë¡',
                    description: 'ìµœê·¼ íŒ€ íšŒì˜ë¡ìž…ë‹ˆë‹¤.',
                    content: 'ë‚ ì§œ: 2023-04-01\nì°¸ì„ìž: ...\nì•ˆê±´: í”„ë¡œì íŠ¸ ì§„í–‰ ìƒí™© ê³µìœ  ë° ì´ìŠˆ ë…¼ì˜...',
                    createdAt: new Date('2023-04-01'),
                    updatedAt: new Date('2023-04-01'),
                    contextType: VaultContextType.Shared,
                    contextId: 'shared-context',
                    tags: ['shared', 'meeting', 'team']
                }
            ]
        };
        // í…œí”Œë¦¿ ì»¨í…ìŠ¤íŠ¸
        const templateContext = {
            id: 'template-context',
            name: 'í…œí”Œë¦¿ ì»¨í…ìŠ¤íŠ¸',
            description: 'ìž¬ì‚¬ìš© ê°€ëŠ¥í•œ í…œí”Œë¦¿ ëª¨ìŒìž…ë‹ˆë‹¤.',
            type: VaultContextType.Template,
            createdAt: new Date('2023-05-01'),
            updatedAt: new Date('2023-05-01'),
            items: [
                {
                    id: 'template-item-1',
                    name: 'ì½”ë“œ ìƒì„± í…œí”Œë¦¿',
                    description: 'í‘œì¤€ ì½”ë“œ ìƒì„± í…œí”Œë¦¿ìž…ë‹ˆë‹¤.',
                    content: 'ë‹¤ìŒ í…œí”Œë¦¿ì„ ì‚¬ìš©í•˜ì—¬ [ê¸°ëŠ¥ëª…]ì„ êµ¬í˜„í•˜ëŠ” ì½”ë“œë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”...',
                    createdAt: new Date('2023-05-01'),
                    updatedAt: new Date('2023-05-01'),
                    contextType: VaultContextType.Template,
                    contextId: 'template-context',
                    tags: ['template', 'code-generation']
                },
                {
                    id: 'template-item-2',
                    name: 'ë¬¸ì„œ í…œí”Œë¦¿',
                    description: 'ê¸°ìˆ  ë¬¸ì„œ í…œí”Œë¦¿ìž…ë‹ˆë‹¤.',
                    content: '# [ë¬¸ì„œ ì œëª©]\n\n## ê°œìš”\n\n## ì•„í‚¤í…ì²˜\n\n## ê¸°ëŠ¥ ì„¤ëª…\n\n## ì£¼ì˜ì‚¬í•­',
                    createdAt: new Date('2023-05-02'),
                    updatedAt: new Date('2023-05-02'),
                    contextType: VaultContextType.Template,
                    contextId: 'template-context',
                    tags: ['template', 'documentation']
                }
            ]
        };
        // ì»¨í…ìŠ¤íŠ¸ ë§µì— ì¶”ê°€
        this.contexts.set(systemContext.id, systemContext);
        this.contexts.set(projectContext.id, projectContext);
        this.contexts.set(personalContext.id, personalContext);
        this.contexts.set(sharedContext.id, sharedContext);
        this.contexts.set(templateContext.id, templateContext);
    }
    /**
     * ëª¨ë“  ì»¨í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
     */
    getAllContexts() {
        return Array.from(this.contexts.values());
    }
    /**
     * ì»¨í…ìŠ¤íŠ¸ íƒ€ìž…ë³„ ì»¨í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
     * @param type ì»¨í…ìŠ¤íŠ¸ íƒ€ìž…
     */
    getContextsByType(type) {
        return Array.from(this.contexts.values()).filter(context => context.type === type);
    }
    /**
     * ì»¨í…ìŠ¤íŠ¸ IDë¡œ ì»¨í…ìŠ¤íŠ¸ ê°€ì ¸ì˜¤ê¸°
     * @param contextId ì»¨í…ìŠ¤íŠ¸ ID
     */
    getContextById(contextId) {
        return this.contexts.get(contextId);
    }
    /**
     * ì»¨í…ìŠ¤íŠ¸ ìƒì„±
     * @param name ì»¨í…ìŠ¤íŠ¸ ì´ë¦„
     * @param type ì»¨í…ìŠ¤íŠ¸ íƒ€ìž…
     * @param description ì„¤ëª… (ì„ íƒ)
     */
    async createContext(name, type, description) {
        try {
            const config = this.configManager.getServiceConfig(ServiceType.Vault);
            if (!config.enabled) {
                throw new ServiceError('VAULT ì„œë¹„ìŠ¤ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.', 'vault-disabled');
            }
            const newContext = {
                id: `${type}-${Date.now()}`,
                name,
                description,
                type,
                createdAt: new Date(),
                updatedAt: new Date(),
                items: []
            };
            if (!config.useMock) {
                // íŒŒì¼ ì‹œìŠ¤í…œì— ì»¨í…ìŠ¤íŠ¸ ì €ìž¥
                this.saveContextToFileSystem(newContext);
            }
            // ì»¨í…ìŠ¤íŠ¸ ë§µì— ì¶”ê°€
            this.contexts.set(newContext.id, newContext);
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeVault.fire();
            return newContext;
        }
        catch (error) {
            console.error('VAULT ì»¨í…ìŠ¤íŠ¸ ìƒì„± ì˜¤ë¥˜:', error);
            throw new ServiceError(`VAULT ì»¨í…ìŠ¤íŠ¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'vault-context-creation-failed');
        }
    }
    /**
     * ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
     * @param contextId ì»¨í…ìŠ¤íŠ¸ ID
     * @param updates ì—…ë°ì´íŠ¸í•  í•„ë“œ
     */
    async updateContext(contextId, updates) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new ServiceError(`IDê°€ ${contextId}ì¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'vault-context-not-found');
            }
            const config = this.configManager.getServiceConfig(ServiceType.Vault);
            if (!config.enabled) {
                throw new ServiceError('VAULT ì„œë¹„ìŠ¤ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.', 'vault-disabled');
            }
            // ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            const updatedContext = {
                ...context,
                ...updates,
                updatedAt: new Date()
            };
            if (!config.useMock) {
                // íŒŒì¼ ì‹œìŠ¤í…œì— ì—…ë°ì´íŠ¸ëœ ì»¨í…ìŠ¤íŠ¸ ì €ìž¥
                this.saveContextToFileSystem(updatedContext);
            }
            // ì»¨í…ìŠ¤íŠ¸ ë§µ ì—…ë°ì´íŠ¸
            this.contexts.set(contextId, updatedContext);
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeVault.fire();
            return updatedContext;
        }
        catch (error) {
            console.error('VAULT ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
            throw new ServiceError(`VAULT ì»¨í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'vault-context-update-failed');
        }
    }
    /**
     * ì»¨í…ìŠ¤íŠ¸ ì‚­ì œ
     * @param contextId ì»¨í…ìŠ¤íŠ¸ ID
     */
    async deleteContext(contextId) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new ServiceError(`IDê°€ ${contextId}ì¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'vault-context-not-found');
            }
            // ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸ëŠ” ì‚­ì œ ë¶ˆê°€
            if (context.type === VaultContextType.System) {
                throw new ServiceError('ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸ëŠ” ì‚­ì œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', 'vault-system-context-deletion-forbidden');
            }
            const config = this.configManager.getServiceConfig(ServiceType.Vault);
            if (!config.enabled) {
                throw new ServiceError('VAULT ì„œë¹„ìŠ¤ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.', 'vault-disabled');
            }
            if (!config.useMock) {
                // íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ ì»¨í…ìŠ¤íŠ¸ ì‚­ì œ
                this.deleteContextFromFileSystem(context);
            }
            // ì»¨í…ìŠ¤íŠ¸ ë§µì—ì„œ ì œê±°
            this.contexts.delete(contextId);
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeVault.fire();
            return true;
        }
        catch (error) {
            console.error('VAULT ì»¨í…ìŠ¤íŠ¸ ì‚­ì œ ì˜¤ë¥˜:', error);
            throw new ServiceError(`VAULT ì»¨í…ìŠ¤íŠ¸ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'vault-context-deletion-failed');
        }
    }
    /**
     * íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ ì»¨í…ìŠ¤íŠ¸ ì‚­ì œ
     * @param context ì‚­ì œí•  ì»¨í…ìŠ¤íŠ¸
     */
    deleteContextFromFileSystem(context) {
        try {
            // ì»¨í…ìŠ¤íŠ¸ íƒ€ìž… ë””ë ‰í† ë¦¬ ê²½ë¡œ
            const typeDir = this.path.join(this.vaultDir, context.type);
            // ì»¨í…ìŠ¤íŠ¸ ë©”íƒ€ë°ì´í„° íŒŒì¼ ì‚­ì œ
            const contextFilePath = this.path.join(typeDir, `${context.id}.context.json`);
            if (this.fs.existsSync(contextFilePath)) {
                this.fs.unlinkSync(contextFilePath);
            }
            // ì»¨í…ìŠ¤íŠ¸ ì•„ì´í…œ ë””ë ‰í† ë¦¬ ì‚­ì œ (ìž¬ê·€ì ìœ¼ë¡œ)
            const itemsDir = this.path.join(typeDir, context.id);
            if (this.fs.existsSync(itemsDir)) {
                this.deleteDirectoryRecursive(itemsDir);
            }
        }
        catch (error) {
            console.error(`ì»¨í…ìŠ¤íŠ¸ íŒŒì¼ ì‚­ì œ ì˜¤ë¥˜ (${context.id}):`, error);
            throw error;
        }
    }
    /**
     * ë””ë ‰í† ë¦¬ ìž¬ê·€ì  ì‚­ì œ
     * @param dirPath ì‚­ì œí•  ë””ë ‰í† ë¦¬ ê²½ë¡œ
     */
    deleteDirectoryRecursive(dirPath) {
        if (this.fs.existsSync(dirPath)) {
            this.fs.readdirSync(dirPath).forEach((file) => {
                const curPath = this.path.join(dirPath, file);
                if (this.fs.lstatSync(curPath).isDirectory()) {
                    // ìž¬ê·€ì  í˜¸ì¶œë¡œ í•˜ìœ„ ë””ë ‰í† ë¦¬ ì‚­ì œ
                    this.deleteDirectoryRecursive(curPath);
                }
                else {
                    // íŒŒì¼ ì‚­ì œ
                    this.fs.unlinkSync(curPath);
                }
            });
            // ë””ë ‰í† ë¦¬ ìžì²´ ì‚­ì œ
            this.fs.rmdirSync(dirPath);
        }
    }
    /**
     * ì•„ì´í…œ ìƒì„±
     * @param contextId ì»¨í…ìŠ¤íŠ¸ ID
     * @param item ì•„ì´í…œ ì •ë³´
     */
    async createItem(contextId, item) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new ServiceError(`IDê°€ ${contextId}ì¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'vault-context-not-found');
            }
            const config = this.configManager.getServiceConfig(ServiceType.Vault);
            if (!config.enabled) {
                throw new ServiceError('VAULT ì„œë¹„ìŠ¤ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.', 'vault-disabled');
            }
            const newItem = {
                ...item,
                id: `${contextId}-item-${Date.now()}`,
                createdAt: new Date(),
                updatedAt: new Date(),
                contextId: contextId
            };
            if (!config.useMock) {
                // íŒŒì¼ ì‹œìŠ¤í…œì— ì•„ì´í…œ ì €ìž¥
                this.saveItemToFileSystem(newItem, contextId, context.type);
            }
            // ì»¨í…ìŠ¤íŠ¸ ì•„ì´í…œ ì¶”ê°€
            context.items.push(newItem);
            context.updatedAt = new Date();
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeVault.fire();
            return newItem;
        }
        catch (error) {
            console.error('VAULT ì•„ì´í…œ ìƒì„± ì˜¤ë¥˜:', error);
            throw new ServiceError(`VAULT ì•„ì´í…œ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'vault-item-creation-failed');
        }
    }
    /**
     * ì•„ì´í…œ ì—…ë°ì´íŠ¸
     * @param contextId ì»¨í…ìŠ¤íŠ¸ ID
     * @param itemId ì•„ì´í…œ ID
     * @param updates ì—…ë°ì´íŠ¸í•  í•„ë“œ
     */
    async updateItem(contextId, itemId, updates) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new ServiceError(`IDê°€ ${contextId}ì¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'vault-context-not-found');
            }
            const itemIndex = context.items.findIndex(item => item.id === itemId);
            if (itemIndex === -1) {
                throw new ServiceError(`IDê°€ ${itemId}ì¸ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'vault-item-not-found');
            }
            const config = this.configManager.getServiceConfig(ServiceType.Vault);
            if (!config.enabled) {
                throw new ServiceError('VAULT ì„œë¹„ìŠ¤ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.', 'vault-disabled');
            }
            // ì•„ì´í…œ ì—…ë°ì´íŠ¸
            const item = context.items[itemIndex];
            const updatedItem = {
                ...item,
                ...updates,
                updatedAt: new Date()
            };
            if (!config.useMock) {
                // íŒŒì¼ ì‹œìŠ¤í…œì— ì—…ë°ì´íŠ¸ëœ ì•„ì´í…œ ì €ìž¥
                this.saveItemToFileSystem(updatedItem, contextId, context.type);
            }
            // ì»¨í…ìŠ¤íŠ¸ ì•„ì´í…œ ì—…ë°ì´íŠ¸
            context.items[itemIndex] = updatedItem;
            context.updatedAt = new Date();
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeVault.fire();
            return updatedItem;
        }
        catch (error) {
            console.error('VAULT ì•„ì´í…œ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
            throw new ServiceError(`VAULT ì•„ì´í…œ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'vault-item-update-failed');
        }
    }
    /**
     * ì•„ì´í…œ ì‚­ì œ
     * @param contextId ì»¨í…ìŠ¤íŠ¸ ID
     * @param itemId ì•„ì´í…œ ID
     */
    async deleteItem(contextId, itemId) {
        try {
            const context = this.contexts.get(contextId);
            if (!context) {
                throw new ServiceError(`IDê°€ ${contextId}ì¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'vault-context-not-found');
            }
            const itemIndex = context.items.findIndex(item => item.id === itemId);
            if (itemIndex === -1) {
                throw new ServiceError(`IDê°€ ${itemId}ì¸ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'vault-item-not-found');
            }
            const config = this.configManager.getServiceConfig(ServiceType.Vault);
            if (!config.enabled) {
                throw new ServiceError('VAULT ì„œë¹„ìŠ¤ê°€ ë¹„í™œì„±í™”ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.', 'vault-disabled');
            }
            if (!config.useMock) {
                // íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ ì•„ì´í…œ ì‚­ì œ
                this.deleteItemFromFileSystem(context.items[itemIndex], contextId, context.type);
            }
            // ì»¨í…ìŠ¤íŠ¸ ì•„ì´í…œ ì‚­ì œ
            context.items.splice(itemIndex, 1);
            context.updatedAt = new Date();
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeVault.fire();
            return true;
        }
        catch (error) {
            console.error('VAULT ì•„ì´í…œ ì‚­ì œ ì˜¤ë¥˜:', error);
            throw new ServiceError(`VAULT ì•„ì´í…œ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'vault-item-deletion-failed');
        }
    }
    /**
     * íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ ì•„ì´í…œ ì‚­ì œ
     * @param item ì‚­ì œí•  ì•„ì´í…œ
     * @param contextId ì»¨í…ìŠ¤íŠ¸ ID
     * @param contextType ì»¨í…ìŠ¤íŠ¸ íƒ€ìž…
     */
    deleteItemFromFileSystem(item, contextId, contextType) {
        try {
            // ì•„ì´í…œ ë””ë ‰í† ë¦¬ ê²½ë¡œ
            const itemsDir = this.path.join(this.vaultDir, contextType, contextId);
            // ì•„ì´í…œ ë©”íƒ€ë°ì´í„° íŒŒì¼ ì‚­ì œ
            const itemFilePath = this.path.join(itemsDir, `${item.id}.item.json`);
            if (this.fs.existsSync(itemFilePath)) {
                this.fs.unlinkSync(itemFilePath);
            }
            // ì•„ì´í…œ ë‚´ìš© íŒŒì¼ ì‚­ì œ
            const contentFilePath = this.path.join(itemsDir, `${item.id}.content.md`);
            if (this.fs.existsSync(contentFilePath)) {
                this.fs.unlinkSync(contentFilePath);
            }
        }
        catch (error) {
            console.error(`ì•„ì´í…œ íŒŒì¼ ì‚­ì œ ì˜¤ë¥˜ (${item.id}):`, error);
            throw error;
        }
    }
    /**
     * ì•„ì´í…œ ê²€ìƒ‰
     * @param query ê²€ìƒ‰ì–´
     * @param filters í•„í„° (ì»¨í…ìŠ¤íŠ¸ íƒ€ìž…, íƒœê·¸ ë“±)
     */
    searchItems(query, filters) {
        const allContexts = this.getAllContexts();
        let filteredContexts = allContexts;
        // ì»¨í…ìŠ¤íŠ¸ íƒ€ìž… í•„í„°ë§
        if (filters?.contextTypes && filters.contextTypes.length > 0) {
            filteredContexts = filteredContexts.filter(context => filters.contextTypes.includes(context.type));
        }
        // ì»¨í…ìŠ¤íŠ¸ ID í•„í„°ë§
        if (filters?.contextIds && filters.contextIds.length > 0) {
            filteredContexts = filteredContexts.filter(context => filters.contextIds.includes(context.id));
        }
        // ëª¨ë“  ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸°
        let items = filteredContexts.flatMap(context => context.items);
        // íƒœê·¸ í•„í„°ë§
        if (filters?.tags && filters.tags.length > 0) {
            items = items.filter(item => {
                if (!item.tags)
                    return false;
                return filters.tags.some(tag => item.tags.includes(tag));
            });
        }
        // ê²€ìƒ‰ì–´ê°€ ìžˆëŠ” ê²½ìš° ì•„ì´í…œ ê²€ìƒ‰
        if (query) {
            const lowerQuery = query.toLowerCase();
            items = items.filter(item => item.name.toLowerCase().includes(lowerQuery) ||
                (item.description && item.description.toLowerCase().includes(lowerQuery)) ||
                item.content.toLowerCase().includes(lowerQuery) ||
                (item.tags && item.tags.some(tag => tag.toLowerCase().includes(lowerQuery))));
        }
        return items;
    }
    /**
     * ì•„ì´í…œì„ LLM ì»¨í…ìŠ¤íŠ¸ë¡œ ë³€í™˜
     * @param item ì•„ì´í…œ
     */
    itemToLLMContext(item) {
        // ê¸°ë³¸ í˜•ì‹: ì•„ì´í…œ ë‚´ìš© ê·¸ëŒ€ë¡œ ë°˜í™˜
        return item.content;
    }
    /**
     * ë¦¬ì†ŒìŠ¤ í•´ì œ
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}

;// ./src/core/llm/vaultIntegration.ts
/**
 * VAULT ì„œë¹„ìŠ¤ì™€ LLM ì„œë¹„ìŠ¤ í†µí•© ëª¨ë“ˆ
 *
 * VAULT ì»¨í…ìŠ¤íŠ¸ë¥¼ LLM ìš”ì²­ì— ì ìš©í•˜ëŠ” ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 */


/**
 * VAULT ì»¨í…ìŠ¤íŠ¸ë¥¼ LLM ìš”ì²­ì— ì ìš©
 * @param messages ì›ë³¸ ë©”ì‹œì§€ ë°°ì—´
 * @param vaultService VAULT ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
 * @param options VAULT ì»¨í…ìŠ¤íŠ¸ ì ìš© ì˜µì…˜
 * @returns VAULT ì»¨í…ìŠ¤íŠ¸ê°€ ì ìš©ëœ ë©”ì‹œì§€ ë°°ì—´
 */
function applyVaultContext(messages, vaultService, options) {
    if (!options) {
        return messages;
    }
    // ì¡°ê±´ì— ë§žëŠ” ì•„ì´í…œ ê²€ìƒ‰
    const items = findRelevantVaultItems(vaultService, options);
    if (items.length === 0) {
        return messages;
    }
    // ì»¨í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ìƒì„±
    const contextMessages = createContextMessages(items);
    // ê²°í•© ë°©ì‹ì— ë”°ë¼ ë©”ì‹œì§€ ë°°ì—´ ì—…ë°ì´íŠ¸
    return combineMessages(messages, contextMessages, options.combinationMode || 'prepend');
}
/**
 * ì¡°ê±´ì— ë§žëŠ” VAULT ì•„ì´í…œ ì°¾ê¸°
 */
function findRelevantVaultItems(vaultService, options) {
    let result = [];
    // 1. ì•„ì´í…œ IDë¡œ ì§ì ‘ ì¡°íšŒ (ê°€ìž¥ ìš°ì„ ìˆœìœ„ ë†’ìŒ)
    if (options.itemIds && options.itemIds.length > 0) {
        const allContexts = vaultService.getAllContexts();
        for (const context of allContexts) {
            const matchingItems = context.items.filter(item => options.itemIds.includes(item.id));
            result.push(...matchingItems);
        }
        // ì•„ì´í…œ IDê°€ ì§€ì •ëœ ê²½ìš° ë‹¤ë¥¸ í•„í„°ëŠ” ì ìš©í•˜ì§€ ì•ŠìŒ
        return result;
    }
    // 2. ì»¨í…ìŠ¤íŠ¸ IDë¡œ í•´ë‹¹ ì»¨í…ìŠ¤íŠ¸ì˜ ëª¨ë“  ì•„ì´í…œ ì¡°íšŒ
    if (options.contextIds && options.contextIds.length > 0) {
        for (const contextId of options.contextIds) {
            const context = vaultService.getContextById(contextId);
            if (context) {
                result.push(...context.items);
            }
        }
        // ì—¬ê¸°ì„œ ë°”ë¡œ ë°˜í™˜í•˜ì§€ ì•Šê³  ì•„ëž˜ í•„í„°ë¥¼ ì¶”ê°€ë¡œ ì ìš©
    }
    // 3. ì»¨í…ìŠ¤íŠ¸ ìœ í˜•ìœ¼ë¡œ ì¡°íšŒ (contextIdsê°€ ì—†ëŠ” ê²½ìš°)
    if ((!options.contextIds || options.contextIds.length === 0) &&
        options.contextTypes && options.contextTypes.length > 0) {
        for (const contextType of options.contextTypes) {
            const contexts = vaultService.getContextsByType(contextType);
            for (const context of contexts) {
                result.push(...context.items);
            }
        }
    }
    // 4. ì•„ë¬´ ì»¨í…ìŠ¤íŠ¸ë„ ì§€ì •ë˜ì§€ ì•Šì€ ê²½ìš°, ê²€ìƒ‰ì–´ë‚˜ íƒœê·¸ê°€ ìžˆìœ¼ë©´ ì „ì²´ ê²€ìƒ‰
    if ((!options.contextIds || options.contextIds.length === 0) &&
        (!options.contextTypes || options.contextTypes.length === 0) &&
        (options.searchQuery || (options.tags && options.tags.length > 0))) {
        result = vaultService.searchItems(options.searchQuery || '', { tags: options.tags });
    }
    // ì¶”ê°€ í•„í„°: íƒœê·¸ë¡œ í•„í„°ë§ (ì´ë¯¸ ë‹¤ë¥¸ ê¸°ì¤€ìœ¼ë¡œ í•„í„°ëœ ì•„ì´í…œë“¤ì— ëŒ€í•´)
    if (options.tags && options.tags.length > 0) {
        result = result.filter(item => {
            if (!item.tags)
                return false;
            return options.tags.some(tag => item.tags.includes(tag));
        });
    }
    // ì¶”ê°€ í•„í„°: ê²€ìƒ‰ì–´ë¡œ í•„í„°ë§ (ì´ë¯¸ ë‹¤ë¥¸ ê¸°ì¤€ìœ¼ë¡œ í•„í„°ëœ ì•„ì´í…œë“¤ì— ëŒ€í•´)
    if (options.searchQuery) {
        const query = options.searchQuery.toLowerCase();
        result = result.filter(item => item.name.toLowerCase().includes(query) ||
            (item.description && item.description.toLowerCase().includes(query)) ||
            item.content.toLowerCase().includes(query) ||
            (item.tags && item.tags.some(tag => tag.toLowerCase().includes(query))));
    }
    return result;
}
/**
 * VAULT ì•„ì´í…œë“¤ë¡œë¶€í„° ì»¨í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ìƒì„±
 */
function createContextMessages(items) {
    const contextMessages = [];
    // ê° ì•„ì´í…œë§ˆë‹¤ ë©”ì‹œì§€ ìƒì„±
    for (const item of items) {
        // ì•„ì´í…œì˜ ì»¨í…ìŠ¤íŠ¸ ìœ í˜•ì— ë”°ë¼ ì ì ˆí•œ ì—­í•  ì§€ì •
        let role = MessageRole.System;
        if (item.contextType === VaultContextType.Personal ||
            item.contextType === VaultContextType.Project ||
            item.contextType === VaultContextType.Shared) {
            role = MessageRole.User;
        }
        contextMessages.push({
            id: `vault_${item.id}_${Date.now()}`,
            role,
            content: formatItemContent(item),
            timestamp: new Date(),
            metadata: {
                isVaultContext: true,
                vaultItemId: item.id,
                vaultContextType: item.contextType,
                vaultTags: item.tags
            }
        });
    }
    return contextMessages;
}
/**
 * VAULT ì•„ì´í…œ ì½˜í…ì¸  í¬ë§·íŒ…
 */
function formatItemContent(item) {
    // ê¸°ë³¸ì ìœ¼ë¡œ ì½˜í…ì¸ ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©
    let content = item.content;
    // ì•„ì´í…œ ìœ í˜•ì— ë”°ë¼ íŠ¹ë³„í•œ í¬ë§·íŒ… ì ìš©
    if (item.contextType === VaultContextType.System) {
        // ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ë¡œ ì‚¬ìš©
        return content;
    }
    else if (item.contextType === VaultContextType.Template) {
        // í…œí”Œë¦¿ì€ ê·¸ëŒ€ë¡œ ì‚¬ìš©
        return content;
    }
    else {
        // ë‹¤ë¥¸ ìœ í˜•ë“¤ì€ ë©”íƒ€ë°ì´í„° ì¶”ê°€
        const header = `VAULT ì»¨í…ìŠ¤íŠ¸: ${item.name}\n`;
        const tags = item.tags?.length ? `íƒœê·¸: ${item.tags.join(', ')}\n` : '';
        return `${header}${tags}${content}`;
    }
}
/**
 * ì›ë³¸ ë©”ì‹œì§€ì™€ ì»¨í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ê²°í•©
 */
function combineMessages(originalMessages, contextMessages, mode) {
    if (mode === 'replace') {
        return contextMessages;
    }
    else if (mode === 'append') {
        return [...originalMessages, ...contextMessages];
    }
    else { // prepend (ê¸°ë³¸ê°’)
        return [...contextMessages, ...originalMessages];
    }
}

;// ./src/core/llm/rulesIntegration.ts
/**
 * Rules í†µí•© ëª¨ë“ˆ
 *
 * LLM ì„œë¹„ìŠ¤ì— Rules ê¸°ëŠ¥ì„ í†µí•©í•˜ëŠ” ëª¨ë“ˆìž…ë‹ˆë‹¤.
 * LLM ìš”ì²­ ì‹œ Rules ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ë¥¼ ì ìš©í•©ë‹ˆë‹¤.
 */

/**
 * Rules ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ë¥¼ ë©”ì‹œì§€ì— ì ìš©
 * @param messages ë©”ì‹œì§€ ë°°ì—´
 * @param rulesService Rules ì„œë¹„ìŠ¤
 * @param options Rules ì˜µì…˜
 * @returns Rulesê°€ ì ìš©ëœ ë©”ì‹œì§€ ë°°ì—´
 */
function applyRulesContext(messages, rulesService, options) {
    // Rules ì˜µì…˜ì´ ëª…ì‹œì ìœ¼ë¡œ falseê°€ ì•„ë‹ˆë©´ Rules ì ìš©
    const includeRules = options?.includeRules !== false;
    if (!includeRules || !rulesService) {
        return messages;
    }
    try {
        // í™œì„±í™”ëœ Rulesê°€ ìžˆëŠ”ì§€ í™•ì¸
        const activeRules = rulesService.getActiveRules();
        if (activeRules.length === 0) {
            return messages;
        }
        // Rules ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ìƒì„±
        const rulesPrompt = rulesService.getRulesAsSystemPrompt();
        if (!rulesPrompt) {
            return messages;
        }
        // ê¸°ì¡´ ì‹œìŠ¤í…œ ë©”ì‹œì§€ê°€ ìžˆëŠ”ì§€ í™•ì¸
        const systemMessageIndex = messages.findIndex(msg => msg.role === MessageRole.System);
        if (systemMessageIndex >= 0) {
            // ê¸°ì¡´ ì‹œìŠ¤í…œ ë©”ì‹œì§€ê°€ ìžˆìœ¼ë©´ Rules í”„ë¡¬í”„íŠ¸ë¥¼ ì¶”ê°€
            const updatedMessages = [...messages];
            const existingSystemMessage = updatedMessages[systemMessageIndex];
            updatedMessages[systemMessageIndex] = {
                ...existingSystemMessage,
                content: `${rulesPrompt}\n\n${existingSystemMessage.content}`
            };
            return updatedMessages;
        }
        else {
            // ì‹œìŠ¤í…œ ë©”ì‹œì§€ê°€ ì—†ìœ¼ë©´ ìƒˆ ì‹œìŠ¤í…œ ë©”ì‹œì§€ë¥¼ ì¶”ê°€
            return [
                {
                    id: `system_rules_${Date.now()}`,
                    role: MessageRole.System,
                    content: rulesPrompt,
                    timestamp: new Date()
                },
                ...messages
            ];
        }
    }
    catch (error) {
        console.error('Rules ì ìš© ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        return messages;
    }
}

;// ./src/core/llm/llmService.ts






// Define constants for WebSocket states
const WS_OPEN = 1;
/**
 * LLM connection type
 */
var ConnectionType;
(function (ConnectionType) {
    ConnectionType["HTTP"] = "http";
    ConnectionType["WebSocket"] = "websocket";
})(ConnectionType || (ConnectionType = {}));
/**
 * Service for interacting with LLM APIs
 */
class LLMService {
    _context;
    _modelManager;
    _endpoint;
    _connectionType;
    _wsConnection = null;
    _cancelTokenSource = null;
    _configListener;
    _modelChangeListener;
    /**
     * Creates a new LLMService instance
     * @param _context The VSCode extension context
     * @param _modelManager The model manager service
     */
    _vaultService = null;
    _rulesService = null;
    /**
     * ìƒì„±ìž
     * @param _context VSCode í™•ìž¥ ì»¨í…ìŠ¤íŠ¸
     * @param _modelManager ëª¨ë¸ ê´€ë¦¬ìž
     */
    constructor(_context, _modelManager) {
        this._context = _context;
        this._modelManager = _modelManager;
        // Initialize properties
        this._endpoint = '';
        this._connectionType = ConnectionType.HTTP;
        console.log('LLMService ì´ˆê¸°í™” ì‹œìž‘...');
        // Load configuration
        this._loadConfiguration();
        // Listen for configuration changes
        this._configListener = external_vscode_.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration('ape.llm') &&
                !event.affectsConfiguration('ape.llm.defaultModel')) { // Only handle non-model configs
                console.log('LLM ì„¤ì • ë³€ê²½ ê°ì§€:', event);
                this._loadConfiguration();
            }
        });
        // Listen for model changes from ModelManager
        this._modelChangeListener = this._modelManager.onDidChangeModel(event => {
            console.log(`ëª¨ë¸ ë³€ê²½ ê°ì§€: ${event.oldModel} -> ${event.newModel}`);
            // No need to update internal state as we'll always use modelManager.getActiveModel()
        });
        console.log('LLMService ì´ˆê¸°í™” ì™„ë£Œ, ê¸°ë³¸ ëª¨ë¸:', this.getActiveModel());
    }
    /**
     * VAULT ì„œë¹„ìŠ¤ ì„¤ì •
     * @param vaultService VAULT ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
     */
    setVaultService(vaultService) {
        this._vaultService = vaultService;
    }
    /**
     * Rules ì„œë¹„ìŠ¤ ì„¤ì •
     * @param rulesService Rules ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
     */
    setRulesService(rulesService) {
        this._rulesService = rulesService;
    }
    /**
     * Reloads configuration from VSCode settings
     */
    _apiKey = '';
    _loadConfiguration() {
        const config = external_vscode_.workspace.getConfiguration('ape.llm');
        const newEndpoint = config.get('endpoint', 'https://openrouter.ai/api/v1/chat/completions');
        const newApiKey = config.get('apiKey', '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');
        // Only update endpoint and API key if changed
        if (this._endpoint !== newEndpoint) {
            this._endpoint = newEndpoint;
        }
        if (this._apiKey !== newApiKey) {
            this._apiKey = newApiKey;
        }
        // Update connection type
        const newConnectionType = this._endpoint && this._endpoint.startsWith('ws')
            ? ConnectionType.WebSocket
            : ConnectionType.HTTP;
        if (this._connectionType !== newConnectionType) {
            this._connectionType = newConnectionType;
            // Handle WebSocket connection changes
            if (this._connectionType === ConnectionType.WebSocket && this._wsConnection) {
                this._wsConnection.close();
                this._wsConnection = null;
            }
        }
    }
    /**
     * Gets the currently active LLM model
     * @returns The active LLM model
     */
    getActiveModel() {
        return this._modelManager.getActiveModel();
    }
    /**
     * Changes the active LLM model
     * @param model The model to switch to
     */
    async setActiveModel(model) {
        return this._modelManager.setActiveModel(model);
    }
    /**
     * Gets all available LLM models
     * @returns Array of available LLM models
     */
    getAvailableModels() {
        return this._modelManager.getAvailableModels();
    }
    /**
     * Gets a user-friendly display name for a model
     * @param modelId The model ID
     * @returns A formatted display name
     */
    getModelDisplayName(modelId) {
        return this._modelManager.getModelDisplayName(modelId);
    }
    /**
     * Sends a request to the LLM and gets a response
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to LLMResult containing the LLM response
     */
    async sendRequest(messages, options) {
        try {
            // ëª¨ë¸ ì§€ì • (ë””ë²„ê¹… ëª©ì ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤)
            // options?.model || this.getActiveModel();
            if (this._connectionType === ConnectionType.WebSocket) {
                const response = await this._sendWebSocketRequest(messages, options);
                return { success: true, data: response };
            }
            else {
                const response = await this._sendHttpRequest(messages, options);
                return { success: true, data: response };
            }
        }
        catch (error) {
            console.error('Error sending LLM request:', error);
            return {
                success: false,
                error: error instanceof Error
                    ? error
                    : new Error(`Failed to communicate with LLM service: ${String(error)}`)
            };
        }
    }
    /**
     * Streams a response from the LLM
     * @param messages Messages to send
     * @param streamCallback Callback for streaming chunks and completion
     * @param options Request options
     * @returns Promise that resolves to LLMResult indicating streaming success or failure
     */
    async streamResponse(messages, streamCallback, options) {
        try {
            // ëª¨ë¸ ì§€ì • (ë””ë²„ê¹… ëª©ì ìœ¼ë¡œ ì‚¬ìš©ë©ë‹ˆë‹¤)
            // options?.model || this.getActiveModel();
            if (this._connectionType === ConnectionType.WebSocket) {
                await this._streamWebSocketResponse(messages, streamCallback, options);
                return { success: true };
            }
            else {
                await this._streamHttpResponse(messages, streamCallback, options);
                return { success: true };
            }
        }
        catch (error) {
            console.error('Error streaming LLM response:', error);
            return {
                success: false,
                error: error instanceof Error
                    ? error
                    : new Error(`Failed to stream from LLM service: ${String(error)}`)
            };
        }
    }
    /**
     * Cancels an ongoing streaming response
     */
    cancelStream() {
        if (this._connectionType === ConnectionType.HTTP && this._cancelTokenSource) {
            this._cancelTokenSource.cancel('Operation canceled by user');
            this._cancelTokenSource = null;
        }
        else if (this._connectionType === ConnectionType.WebSocket && this._wsConnection) {
            // Send cancel message if supported
            this._wsConnection.send(JSON.stringify({ type: 'cancel' }));
        }
    }
    /**
     * HTTP implementation of sendRequest
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to the LLM response
     */
    async _sendHttpRequest(messages, options) {
        const formattedMessages = this._formatMessagesForAPI(messages, options);
        // OpenRouter API ìš”ì²­ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        const openRouterMessages = formattedMessages.map(msg => ({
            role: msg.role,
            content: msg.content
        }));
        const request = {
            model: options?.model || this.getActiveModel(),
            messages: openRouterMessages,
            temperature: options?.temperature || 0.7,
            max_tokens: options?.maxTokens || 1000,
            stream: false
        };
        // OpenRouter API ìš”ì²­ì— í•„ìš”í•œ í—¤ë” ì¶”ê°€
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this._apiKey}`,
            'HTTP-Referer': 'APE-Extension',
            'X-Title': 'APE (Agentic Pipeline Engine)'
        };
        console.log("LLM ìš”ì²­:", JSON.stringify(request, null, 2));
        const response = await lib_axios.post(this._endpoint, request, { headers });
        console.log("LLM ì‘ë‹µ:", JSON.stringify(response.data, null, 2));
        return this._processHttpResponse(response.data);
    }
    /**
     * WebSocket implementation of sendRequest
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to the LLM response
     */
    async _sendWebSocketRequest(messages, options) {
        return new Promise((resolve, reject) => {
            this._ensureWebSocketConnection();
            if (!this._wsConnection) {
                reject(new Error('Failed to establish WebSocket connection'));
                return;
            }
            const formattedMessages = this._formatMessagesForAPI(messages, options);
            const request = {
                messages: formattedMessages,
                model: options?.model || this.getActiveModel(),
                temperature: options?.temperature,
                maxTokens: options?.maxTokens,
                stream: false,
                parameters: options?.modelParameters
            };
            // Generate a unique request ID
            const requestId = `req_${Date.now()}`;
            // Set up one-time message handler for this request
            const messageHandler = (data) => {
                try {
                    const dataStr = data.toString();
                    const response = JSON.parse(dataStr);
                    // Check if this is the response to our request
                    if (response.requestId === requestId) {
                        // Remove the listener once we get our response
                        if (this._wsConnection) {
                            this._wsConnection.removeListener('message', messageHandler);
                        }
                        if (response.error) {
                            reject(new Error(response.error));
                        }
                        else {
                            resolve(this._processWebSocketResponse(response));
                        }
                    }
                }
                catch (error) {
                    reject(error);
                }
            };
            // Add the message handler
            this._wsConnection.on('message', messageHandler);
            // Send the request with the request ID
            this._wsConnection.send(JSON.stringify({
                ...request,
                requestId
            }));
            // Set a timeout in case of no response
            const timeoutId = setTimeout(() => {
                if (this._wsConnection) {
                    this._wsConnection.removeListener('message', messageHandler);
                }
                reject(new Error('Request timed out'));
            }, 30000); // 30 seconds timeout
            // Also set up an error handler
            const errorHandler = (error) => {
                clearTimeout(timeoutId);
                this._wsConnection?.removeListener('message', messageHandler);
                this._wsConnection?.removeListener('error', errorHandler);
                reject(error);
            };
            this._wsConnection.on('error', errorHandler);
        });
    }
    /**
     * HTTP implementation of streamResponse
     * @param messages Messages to send
     * @param streamCallback Callback for streaming chunks and completion
     * @param options Request options
     */
    async _streamHttpResponse(messages, streamCallback, options) {
        const formattedMessages = this._formatMessagesForAPI(messages, options);
        // OpenRouter API ìš”ì²­ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
        const openRouterMessages = formattedMessages.map(msg => ({
            role: msg.role,
            content: msg.content
        }));
        const request = {
            model: options?.model || this.getActiveModel(),
            messages: openRouterMessages,
            temperature: options?.temperature || 0.7,
            max_tokens: options?.maxTokens || 1000,
            stream: true
        };
        // OpenRouter API ìš”ì²­ì— í•„ìš”í•œ í—¤ë” ì¶”ê°€
        const headers = {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${this._apiKey}`,
            'HTTP-Referer': 'APE-Extension',
            'X-Title': 'APE (Agentic Pipeline Engine)'
        };
        // Create a cancellation token
        this._cancelTokenSource = lib_axios.CancelToken.source();
        try {
            // ëˆ„ì  í…ìŠ¤íŠ¸ëŠ” ë””ë²„ê¹… ëª©ì ìœ¼ë¡œ ì‚¬ìš©ë  ìˆ˜ ìžˆìŒ
            const response = await lib_axios.post(this._endpoint, request, {
                responseType: 'stream',
                cancelToken: this._cancelTokenSource.token,
                headers: headers
            });
            response.data.on('data', (chunk) => {
                const lines = chunk.toString().split('\n').filter(Boolean);
                for (const line of lines) {
                    if (line.startsWith('data: ')) {
                        const data = line.substring('data: '.length);
                        if (data === '[DONE]') {
                            streamCallback('', true); // ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ ì‹ í˜¸
                        }
                        else {
                            try {
                                const parsed = JSON.parse(data);
                                if (parsed.choices && parsed.choices.length > 0) {
                                    const content = parsed.choices[0].delta?.content ||
                                        parsed.choices[0].message?.content || '';
                                    if (content) {
                                        streamCallback(content, false);
                                    }
                                }
                            }
                            catch (err) {
                                console.error('Stream parsing error:', err);
                            }
                        }
                    }
                }
            });
            response.data.on('end', () => {
                this._cancelTokenSource = null;
                streamCallback('', true); // ìŠ¤íŠ¸ë¦¼ ì™„ë£Œ ì‹ í˜¸
            });
            response.data.on('error', (err) => {
                this._cancelTokenSource = null;
                console.error('Stream error:', err);
                streamCallback('', true);
            });
        }
        catch (error) {
            this._cancelTokenSource = null;
            if (lib_axios.isCancel(error)) {
                // Request was canceled intentionally
                streamCallback('', true); // Signal completion with empty chunk and done=true
            }
            else {
                // Real error
                throw error;
            }
        }
    }
    /**
     * WebSocket implementation of streamResponse
     * @param messages Messages to send
     * @param streamCallback Callback for streaming chunks and completion
     * @param options Request options
     */
    async _streamWebSocketResponse(messages, streamCallback, options) {
        return new Promise((resolve, reject) => {
            this._ensureWebSocketConnection();
            if (!this._wsConnection) {
                reject(new Error('Failed to establish WebSocket connection'));
                return;
            }
            const formattedMessages = this._formatMessagesForAPI(messages, options);
            const request = {
                messages: formattedMessages,
                model: options?.model || this.getActiveModel(),
                temperature: options?.temperature,
                maxTokens: options?.maxTokens,
                stream: true,
                parameters: options?.modelParameters
            };
            // Generate a unique request ID
            const requestId = `req_${Date.now()}`;
            // Set up message handler for streaming
            const messageHandler = (data) => {
                try {
                    const dataStr = data.toString();
                    const response = JSON.parse(dataStr);
                    // Check if this is a response to our request
                    if (response.requestId === requestId) {
                        if (response.error) {
                            // Error response
                            if (this._wsConnection) {
                                this._wsConnection.removeListener('message', messageHandler);
                            }
                            reject(new Error(response.error));
                        }
                        else if (response.type === 'chunk') {
                            // Streaming chunk
                            streamCallback(response.content || '', false);
                        }
                        else if (response.type === 'complete') {
                            // Stream complete
                            if (this._wsConnection) {
                                this._wsConnection.removeListener('message', messageHandler);
                            }
                            streamCallback('', true); // Signal completion
                            resolve();
                        }
                    }
                }
                catch (error) {
                    if (this._wsConnection) {
                        this._wsConnection.removeListener('message', messageHandler);
                    }
                    reject(error);
                }
            };
            // Add the message handler
            this._wsConnection.on('message', messageHandler);
            // Send the streaming request
            this._wsConnection.send(JSON.stringify({
                ...request,
                requestId
            }));
            // Set a timeout for the entire streaming session
            const timeoutId = setTimeout(() => {
                if (this._wsConnection) {
                    this._wsConnection.removeListener('message', messageHandler);
                }
                reject(new Error('Streaming request timed out'));
            }, 300000); // 5 minutes timeout for streaming
            // Also set up an error handler
            const errorHandler = (error) => {
                clearTimeout(timeoutId);
                this._wsConnection?.removeListener('message', messageHandler);
                this._wsConnection?.removeListener('error', errorHandler);
                reject(error);
            };
            this._wsConnection.on('error', errorHandler);
        });
    }
    /**
     * Ensures a WebSocket connection is established
     */
    _ensureWebSocketConnection() {
        if (this._connectionType !== ConnectionType.WebSocket) {
            return;
        }
        if (!this._wsConnection || this._wsConnection.readyState !== WS_OPEN) {
            try {
                // Create a new WebSocket connection
                this._wsConnection = new websocket(this._endpoint);
                // Set up event handlers
                if (this._wsConnection) {
                    this._wsConnection.on('error', (error) => {
                        console.error('WebSocket error:', error);
                        this._wsConnection = null;
                    });
                    this._wsConnection.on('close', () => {
                        this._wsConnection = null;
                    });
                    // Wait for connection to be established
                    this._wsConnection.on('open', () => {
                        console.log('WebSocket connection established');
                    });
                }
            }
            catch (error) {
                console.error('Failed to create WebSocket connection:', error);
                this._wsConnection = null;
            }
        }
    }
    /**
     * Formats messages for the API
     * @param messages Messages to format
     * @param options Optional request options
     * @returns Formatted messages array
     */
    _formatMessagesForAPI(messages, options) {
        let formattedMessages = [...messages];
        // Add system prompt as a system message if provided
        if (options?.systemPrompt) {
            formattedMessages.unshift({
                id: `system_${Date.now()}`,
                role: MessageRole.System,
                content: options.systemPrompt,
                timestamp: new Date()
            });
        }
        // Add context messages if provided
        if (options?.contextMessages && options.contextMessages.length > 0) {
            formattedMessages = [...options.contextMessages, ...formattedMessages];
        }
        // Apply VAULT context if available and requested
        if (this._vaultService && options?.vaultOptions) {
            const vaultOptions = options.vaultOptions;
            // vaultOptionsê°€ undefinedì¼ ìˆ˜ ì—†ì§€ë§Œ íƒ€ìž… ì—ëŸ¬ë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ ê¸°ë³¸ ê°ì²´ ì œê³µ
            formattedMessages = applyVaultContext(formattedMessages, this._vaultService, vaultOptions || {});
        }
        // Apply Rules if available
        if (this._rulesService) {
            const rulesOptions = options?.rulesOptions;
            formattedMessages = applyRulesContext(formattedMessages, this._rulesService, rulesOptions);
        }
        // Return formatted messages
        return formattedMessages;
    }
    /**
     * Processes an HTTP API response
     * @param responseData Raw response data
     * @returns Processed LLM response
     */
    _processHttpResponse(responseData) {
        // OpenRouter/OpenAI í˜•ì‹ ì‘ë‹µ ì²˜ë¦¬ (choices ë°°ì—´ ì‚¬ìš©)
        if (responseData.choices && Array.isArray(responseData.choices)) {
            const content = responseData.choices[0]?.message?.content || '';
            return {
                message: {
                    id: responseData.id || `msg_${Date.now()}`,
                    role: MessageRole.Assistant,
                    content: content,
                    timestamp: new Date(),
                    metadata: {
                        model: responseData.model || this.getActiveModel()
                    }
                },
                usage: responseData.usage || {
                    promptTokens: 0,
                    completionTokens: 0,
                    totalTokens: 0
                },
                metadata: responseData.metadata || {},
                content: content // í˜¸í™˜ì„±ì„ ìœ„í•´ ì¶”ê°€
            };
        }
        // ê¸°ì¡´ ì‘ë‹µ í˜•ì‹ ì²˜ë¦¬
        else {
            return {
                message: {
                    id: responseData.message?.id || `msg_${Date.now()}`,
                    role: MessageRole.Assistant,
                    content: responseData.content || responseData.message?.content || '',
                    timestamp: new Date(),
                    metadata: responseData.message?.metadata || {
                        model: responseData.model || this.getActiveModel()
                    }
                },
                usage: responseData.usage || {
                    promptTokens: 0,
                    completionTokens: 0,
                    totalTokens: 0
                },
                metadata: responseData.metadata || {}
            };
        }
    }
    /**
     * Processes a WebSocket API response
     * @param responseData Raw response data
     * @returns Processed LLM response
     */
    _processWebSocketResponse(responseData) {
        // Process according to the WebSocket response format
        return {
            message: {
                id: responseData.message?.id || `msg_${Date.now()}`,
                role: MessageRole.Assistant,
                content: responseData.content || responseData.message?.content || '',
                timestamp: new Date(),
                metadata: responseData.message?.metadata || {
                    model: responseData.model || this.getActiveModel()
                }
            },
            usage: responseData.usage || {
                promptTokens: 0,
                completionTokens: 0,
                totalTokens: 0
            },
            metadata: responseData.metadata || {}
        };
    }
    /**
     * Processes a streaming chunk
     * @param chunk Raw chunk data
     * @returns Processed chunk as a string
     */
    _processStreamChunk(chunk) {
        // Process based on the API's streaming format
        try {
            if (typeof chunk === 'string') {
                // Try to parse as JSON if it's a string
                const data = JSON.parse(chunk);
                return data.content || data.text || data.chunk || '';
            }
            else if (typeof chunk === 'object') {
                // Already a parsed object
                return chunk.content || chunk.text || chunk.chunk || '';
            }
        }
        catch {
            // If parsing fails, return as is
            return chunk.toString();
        }
        return '';
    }
    /**
     * Gets a simple completion from the LLM for a prompt
     * @param prompt The prompt to send to the LLM
     * @param options Optional request options
     * @returns Promise that resolves to LLMResult containing the completion text
     */
    async getCompletion(prompt, options) {
        try {
            // Create a simple message with the prompt
            const messages = [
                {
                    id: `user_${Date.now()}`,
                    role: MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            // Send the request
            const result = await this.sendRequest(messages, options);
            if (result.success && result.data) {
                return {
                    success: true,
                    data: result.data.message.content
                };
            }
            else {
                return {
                    success: false,
                    error: result.error || new Error('Failed to get completion')
                };
            }
        }
        catch (error) {
            console.error('Error getting completion:', error);
            return {
                success: false,
                error: error instanceof Error
                    ? error
                    : new Error(`Failed to get completion: ${String(error)}`)
            };
        }
    }
    /**
     * Disposes resources
     */
    dispose() {
        // Dispose event listeners
        this._configListener.dispose();
        this._modelChangeListener.dispose();
        // Cancel any ongoing operations
        if (this._cancelTokenSource) {
            this._cancelTokenSource.cancel('Extension deactivated');
            this._cancelTokenSource = null;
        }
        // Close WebSocket connection
        if (this._wsConnection) {
            this._wsConnection.close();
            this._wsConnection = null;
        }
    }
}

;// external "fs/promises"
const promises_namespaceObject = require("fs/promises");
// EXTERNAL MODULE: external "fs"
var external_fs_ = __webpack_require__(9896);
;// ./src/core/memory/memoryService.ts





/**
 * Memory service manages storing and retrieving conversation data
 */
class MemoryService {
    _context;
    _sessions = new Map();
    _currentSessionId = null;
    _storageDir;
    _maxMessages;
    _sessionDuration;
    _configListener;
    /**
     * Creates a new MemoryService instance
     * @param _context The VSCode extension context
     */
    constructor(_context) {
        this._context = _context;
        // Initialize properties
        this._maxMessages = 30;
        this._sessionDuration = 240;
        // Create storage directory
        this._storageDir = external_path_.join(_context.globalStoragePath, 'memory');
        this._ensureStorageDirectory();
        // Load configuration
        this._loadConfiguration();
        // Initialize with default session
        this._initializeDefaultSession();
        // Listen for configuration changes
        this._configListener = external_vscode_.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.memory')) {
                this._loadConfiguration();
            }
        });
    }
    /**
     * Loads configuration from VSCode settings
     */
    _loadConfiguration() {
        const config = external_vscode_.workspace.getConfiguration('ape.memory');
        this._maxMessages = config.get('maxMessages', 30);
        this._sessionDuration = config.get('sessionDuration', 240); // minutes
    }
    /**
     * Creates storage directory if it doesn't exist
     */
    _ensureStorageDirectory() {
        if (!(0,external_fs_.existsSync)(this._storageDir)) {
            (0,external_fs_.mkdirSync)(this._storageDir, { recursive: true });
        }
    }
    /**
     * Initializes default session
     */
    async _initializeDefaultSession() {
        const defaultSessionId = 'default';
        try {
            // Check if default session exists
            const existingSession = await this._loadSession(defaultSessionId);
            if (existingSession) {
                this._sessions.set(defaultSessionId, existingSession);
                // ê¸°ì¡´ ì„¸ì…˜ì„ ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ì—ë„ ì €ìž¥
                await this._saveSessionToWorkspace(existingSession);
            }
            else {
                // Create new default session
                const newSession = {
                    id: defaultSessionId,
                    name: 'Default Session',
                    createdAt: new Date(),
                    updatedAt: new Date(),
                    messages: []
                };
                this._sessions.set(defaultSessionId, newSession);
                await this._saveSession(newSession);
            }
            this._currentSessionId = defaultSessionId;
        }
        catch (error) {
            console.error('Failed to initialize default session:', error);
            // Create an in-memory default session as fallback
            this._sessions.set(defaultSessionId, {
                id: defaultSessionId,
                name: 'Default Session',
                createdAt: new Date(),
                updatedAt: new Date(),
                messages: []
            });
            this._currentSessionId = defaultSessionId;
        }
    }
    /**
     * Gets the current session ID
     * @returns Current session ID or null if no session is active
     */
    getCurrentSessionId() {
        return this._currentSessionId;
    }
    /**
     * Gets the current session
     * @returns Current session or null if no session is active
     */
    getCurrentSession() {
        if (!this._currentSessionId) {
            return null;
        }
        return this._sessions.get(this._currentSessionId) || null;
    }
    /**
     * Gets messages from the current session
     * @returns Promise that resolves to a MemoryResult containing messages
     */
    async getMessages() {
        try {
            if (!this._currentSessionId) {
                return { success: true, data: [] };
            }
            const session = this._sessions.get(this._currentSessionId);
            return {
                success: true,
                data: session ? session.messages : []
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Adds a message to the current session
     * @param message Message to add
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async addMessage(message) {
        try {
            if (!this._currentSessionId) {
                return {
                    success: false,
                    error: new Error('No active session')
                };
            }
            const session = this._sessions.get(this._currentSessionId);
            if (session) {
                // Add message to the session
                session.messages.push(message);
                // Limit messages if needed
                if (this._maxMessages > 0 && session.messages.length > this._maxMessages) {
                    // Keep the most recent messages
                    session.messages = session.messages.slice(-this._maxMessages);
                }
                // Update session timestamp
                session.updatedAt = new Date();
                // Save session
                await this._saveSession(session);
                return { success: true };
            }
            else {
                return {
                    success: false,
                    error: new Error('Session not found')
                };
            }
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Saves messages to the current session
     * @param messages Messages to save
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async saveMessages(messages) {
        try {
            if (!this._currentSessionId) {
                return {
                    success: false,
                    error: new Error('No active session')
                };
            }
            const session = this._sessions.get(this._currentSessionId);
            if (session) {
                // Replace messages in the session
                session.messages = messages;
                // Limit messages if needed
                if (this._maxMessages > 0 && session.messages.length > this._maxMessages) {
                    // Keep the most recent messages
                    session.messages = session.messages.slice(-this._maxMessages);
                }
                // Update session timestamp
                session.updatedAt = new Date();
                // Save session
                await this._saveSession(session);
                return { success: true };
            }
            else {
                return {
                    success: false,
                    error: new Error('Session not found')
                };
            }
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Creates a new chat session
     * @param name Session name
     * @param options Optional session options
     * @returns Promise that resolves to a MemoryResult containing the session ID
     */
    async createSession(name, options) {
        try {
            const sessionId = `session_${Date.now()}`;
            const newSession = {
                id: sessionId,
                name,
                createdAt: new Date(),
                updatedAt: new Date(),
                messages: [],
                metadata: options?.metadata
            };
            this._sessions.set(sessionId, newSession);
            await this._saveSession(newSession);
            return {
                success: true,
                data: sessionId
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Switches to a different session
     * @param sessionId Session ID to switch to
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async switchSession(sessionId) {
        try {
            // If session is not loaded, try to load it
            if (!this._sessions.has(sessionId)) {
                const session = await this._loadSession(sessionId);
                if (!session) {
                    return {
                        success: false,
                        error: new Error(`Session ${sessionId} not found`)
                    };
                }
                this._sessions.set(sessionId, session);
            }
            this._currentSessionId = sessionId;
            return {
                success: true,
                data: true
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Gets all available sessions
     * @returns Promise that resolves to a MemoryResult containing session summaries
     */
    async getSessions() {
        try {
            // Load all sessions from storage
            await this._loadAllSessions();
            const sessionSummaries = Array.from(this._sessions.values()).map(session => ({
                id: session.id,
                name: session.name,
                createdAt: session.createdAt,
                updatedAt: session.updatedAt,
                messageCount: session.messages.length,
                summary: session.metadata?.summary || this._summarizeConversation(session.messages)
            }));
            return {
                success: true,
                data: sessionSummaries
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Gets a specific session by ID
     * @param sessionId Session ID to get
     * @returns Promise that resolves to a MemoryResult containing the session
     */
    async getSession(sessionId) {
        try {
            // If session is not loaded, try to load it
            if (!this._sessions.has(sessionId)) {
                const session = await this._loadSession(sessionId);
                if (!session) {
                    return {
                        success: false,
                        error: new Error(`Session ${sessionId} not found`)
                    };
                }
                this._sessions.set(sessionId, session);
            }
            const session = this._sessions.get(sessionId);
            if (!session) {
                return {
                    success: false,
                    error: new Error(`Session ${sessionId} not found`)
                };
            }
            return {
                success: true,
                data: session
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Updates a session's properties (not including messages)
     * @param sessionId Session ID to update
     * @param updates Object containing updates to apply
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async updateSession(sessionId, updates) {
        try {
            const sessionResult = await this.getSession(sessionId);
            if (!sessionResult.success || !sessionResult.data) {
                return {
                    success: false,
                    error: sessionResult.error || new Error(`Session ${sessionId} not found`)
                };
            }
            const session = sessionResult.data;
            // Apply updates
            if (updates.name) {
                session.name = updates.name;
            }
            if (updates.metadata) {
                session.metadata = {
                    ...session.metadata,
                    ...updates.metadata
                };
            }
            // Update timestamp
            session.updatedAt = new Date();
            // Save session
            await this._saveSession(session);
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Deletes a session
     * @param sessionId Session ID to delete
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async deleteSession(sessionId) {
        try {
            // Don't allow deleting the default session
            if (sessionId === 'default') {
                return {
                    success: false,
                    error: new Error('Cannot delete the default session')
                };
            }
            // Remove from memory
            this._sessions.delete(sessionId);
            // If this was the current session, switch to default
            if (this._currentSessionId === sessionId) {
                await this.switchSession('default');
            }
            // Remove from disk
            const sessionFile = external_path_.join(this._storageDir, `${sessionId}.json`);
            if ((0,external_fs_.existsSync)(sessionFile)) {
                await promises_namespaceObject.unlink(sessionFile);
            }
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Clears messages from the current session
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async clearMessages() {
        try {
            if (!this._currentSessionId) {
                return {
                    success: false,
                    error: new Error('No active session')
                };
            }
            const session = this._sessions.get(this._currentSessionId);
            if (session) {
                session.messages = [];
                session.updatedAt = new Date();
                await this._saveSession(session);
                return { success: true };
            }
            else {
                return {
                    success: false,
                    error: new Error('Session not found')
                };
            }
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Archives old sessions based on session duration configuration
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async archiveOldSessions() {
        try {
            // Load all sessions from storage
            await this._loadAllSessions();
            const now = new Date();
            const archiveThreshold = new Date(now.getTime() - this._sessionDuration * 60 * 1000);
            let archivedCount = 0;
            for (const [sessionId, session] of this._sessions.entries()) {
                // Skip the default session and current session
                if (sessionId === 'default' || sessionId === this._currentSessionId) {
                    continue;
                }
                // Archive sessions older than the threshold
                if (session.updatedAt < archiveThreshold) {
                    // Create an archive copy
                    const archiveDir = external_path_.join(this._storageDir, 'archive');
                    if (!(0,external_fs_.existsSync)(archiveDir)) {
                        (0,external_fs_.mkdirSync)(archiveDir, { recursive: true });
                    }
                    // Generate summary if not already present
                    if (!session.metadata) {
                        session.metadata = {};
                    }
                    if (!session.metadata.summary) {
                        session.metadata.summary = this._summarizeConversation(session.messages);
                    }
                    // Save to archive
                    const archiveFile = external_path_.join(archiveDir, `${session.id}_${Math.floor(session.updatedAt.getTime() / 1000)}.json`);
                    await promises_namespaceObject.writeFile(archiveFile, JSON.stringify(session, null, 2), 'utf-8');
                    // Remove from active sessions
                    this._sessions.delete(sessionId);
                    // Remove from disk
                    const sessionFile = external_path_.join(this._storageDir, `${sessionId}.json`);
                    if ((0,external_fs_.existsSync)(sessionFile)) {
                        await promises_namespaceObject.unlink(sessionFile);
                    }
                    archivedCount++;
                }
            }
            return {
                success: true,
                data: archivedCount
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Exports a session to a file
     * @param sessionId Session ID to export
     * @param filePath File path to export to
     * @returns Promise that resolves to a MemoryResult indicating success or failure
     */
    async exportSession(sessionId, filePath) {
        try {
            const sessionResult = await this.getSession(sessionId);
            if (!sessionResult.success || !sessionResult.data) {
                return {
                    success: false,
                    error: sessionResult.error || new Error(`Session ${sessionId} not found`)
                };
            }
            const session = sessionResult.data;
            // Export to file
            await promises_namespaceObject.writeFile(filePath, JSON.stringify(session, null, 2), 'utf-8');
            return { success: true };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Imports a session from a file
     * @param filePath File path to import from
     * @param setAsCurrent Whether to set the imported session as current
     * @returns Promise that resolves to a MemoryResult containing the session ID
     */
    async importSession(filePath, setAsCurrent = false) {
        try {
            // Read and parse file
            const data = await promises_namespaceObject.readFile(filePath, 'utf-8');
            const sessionData = JSON.parse(data);
            // Validate session data
            if (!sessionData.id || !sessionData.name || !sessionData.createdAt || !sessionData.updatedAt) {
                return {
                    success: false,
                    error: new Error('Invalid session data')
                };
            }
            // Convert date strings to Date objects
            sessionData.createdAt = new Date(sessionData.createdAt);
            sessionData.updatedAt = new Date(sessionData.updatedAt);
            if (sessionData.messages) {
                sessionData.messages.forEach((message) => {
                    message.timestamp = new Date(message.timestamp);
                });
            }
            // Generate a new ID to avoid conflicts
            const originalId = sessionData.id;
            sessionData.id = `imported_${Date.now()}`;
            // Add a note about the import
            if (!sessionData.metadata) {
                sessionData.metadata = {};
            }
            sessionData.metadata.importedFrom = originalId;
            sessionData.metadata.importedAt = new Date();
            // Save the session
            this._sessions.set(sessionData.id, sessionData);
            await this._saveSession(sessionData);
            // Switch to the imported session if requested
            if (setAsCurrent) {
                this._currentSessionId = sessionData.id;
            }
            return {
                success: true,
                data: sessionData.id
            };
        }
        catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error : new Error(String(error))
            };
        }
    }
    /**
     * Loads a specific session from storage
     * @param sessionId Session ID to load
     * @returns Promise that resolves to a ChatSession or null
     */
    async _loadSession(sessionId) {
        const sessionFile = external_path_.join(this._storageDir, `${sessionId}.json`);
        try {
            if ((0,external_fs_.existsSync)(sessionFile)) {
                const data = await promises_namespaceObject.readFile(sessionFile, 'utf-8');
                const sessionData = JSON.parse(data);
                // Convert date strings back to Date objects
                sessionData.createdAt = new Date(sessionData.createdAt);
                sessionData.updatedAt = new Date(sessionData.updatedAt);
                if (sessionData.messages) {
                    sessionData.messages.forEach((message) => {
                        message.timestamp = new Date(message.timestamp);
                    });
                }
                return sessionData;
            }
        }
        catch (error) {
            console.error(`Error loading session ${sessionId}:`, error);
        }
        return null;
    }
    /**
     * Saves a session to storage
     * @param session Session to save
     * @returns Promise that resolves when the session is saved
     */
    async _saveSession(session) {
        const sessionFile = external_path_.join(this._storageDir, `${session.id}.json`);
        try {
            const sessionJson = JSON.stringify(session, null, 2);
            await promises_namespaceObject.writeFile(sessionFile, sessionJson, 'utf-8');
            // ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ .ape/vault/chat-history ë””ë ‰í† ë¦¬ì—ë„ ì €ìž¥
            await this._saveSessionToWorkspace(session);
        }
        catch (error) {
            console.error(`Error saving session ${session.id}:`, error);
            throw error;
        }
    }
    /**
     * ì„¸ì…˜ì„ ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ì˜ .ape/vault/chat-history ë””ë ‰í† ë¦¬ì— ì €ìž¥
     */
    async _saveSessionToWorkspace(session) {
        try {
            // ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ í´ë” í™•ì¸
            const workspaceFolder = external_vscode_.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                return; // ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ê°€ ì—†ìœ¼ë©´ ì¢…ë£Œ
            }
            // .ape/vault/chat-history ë””ë ‰í† ë¦¬ ê²½ë¡œ
            const chatHistoryDir = external_path_.join(workspaceFolder.uri.fsPath, '.ape', 'vault', 'chat-history');
            // ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ìƒì„±
            if (!(0,external_fs_.existsSync)(chatHistoryDir)) {
                (0,external_fs_.mkdirSync)(chatHistoryDir, { recursive: true });
            }
            // ë©”íƒ€ë°ì´í„° íŒŒì¼ ê²½ë¡œ
            const metaFile = external_path_.join(chatHistoryDir, `${session.id}.meta.json`);
            // ì„¸ì…˜ ë‚´ìš© íŒŒì¼ ê²½ë¡œ
            const contentFile = external_path_.join(chatHistoryDir, `${session.id}.json`);
            // ìš”ì•½ ìƒì„± (ì²« ë²ˆì§¸ ì‚¬ìš©ìž ë©”ì‹œì§€ ê¸°ë°˜)
            const firstUserMessage = session.messages.find(m => m.role === MessageRole.User);
            const summary = firstUserMessage
                ? firstUserMessage.content.substring(0, 50) + (firstUserMessage.content.length > 50 ? '...' : '')
                : 'ìƒˆ ëŒ€í™”';
            // ì„¸ì…˜ ì œëª© ì„¤ì •
            const title = session.metadata?.summary || session.name || summary || `ëŒ€í™” (${new Date().toLocaleString()})`;
            // ë©”íƒ€ë°ì´í„° ìƒì„±
            const metadata = {
                id: session.id,
                title: title,
                createdAt: session.createdAt,
                updatedAt: session.updatedAt,
                messageCount: session.messages.length,
                summary: summary
            };
            // íŒŒì¼ ì €ìž¥
            await promises_namespaceObject.writeFile(metaFile, JSON.stringify(metadata, null, 2), 'utf-8');
            await promises_namespaceObject.writeFile(contentFile, JSON.stringify(session, null, 2), 'utf-8');
        }
        catch (error) {
            console.error(`Error saving session to workspace ${session.id}:`, error);
            // ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ ì €ìž¥ ì‹¤íŒ¨ëŠ” ë¬´ì‹œí•˜ê³  ê³„ì† ì§„í–‰
        }
    }
    /**
     * Loads all sessions from storage
     * @returns Promise that resolves when all sessions are loaded
     */
    async _loadAllSessions() {
        try {
            if (!(0,external_fs_.existsSync)(this._storageDir)) {
                return;
            }
            const files = await promises_namespaceObject.readdir(this._storageDir);
            for (const file of files) {
                if (file.endsWith('.json')) {
                    const sessionId = external_path_.basename(file, '.json');
                    // Don't reload sessions we already have in memory
                    if (!this._sessions.has(sessionId)) {
                        const session = await this._loadSession(sessionId);
                        if (session) {
                            this._sessions.set(sessionId, session);
                        }
                    }
                }
            }
        }
        catch (error) {
            console.error('Error loading sessions:', error);
            throw error;
        }
    }
    /**
     * Summarizes a conversation for long-term memory
     * @param messages Messages to summarize
     * @returns Summary of the conversation
     */
    _summarizeConversation(messages) {
        if (messages.length === 0) {
            return 'Empty conversation';
        }
        // Find the first user message
        const firstUserMessage = messages.find(m => m.role === MessageRole.User);
        if (!firstUserMessage) {
            return `Conversation with ${messages.length} messages`;
        }
        // Get first user message content
        const content = firstUserMessage.content;
        const truncatedContent = content.substring(0, 50) + (content.length > 50 ? '...' : '');
        // Count messages by role
        const userMessages = messages.filter(m => m.role === MessageRole.User).length;
        const assistantMessages = messages.filter(m => m.role === MessageRole.Assistant).length;
        return `Conversation with ${userMessages} user and ${assistantMessages} assistant messages. Started with: "${truncatedContent}"`;
    }
    /**
     * Disposes resources
     */
    dispose() {
        // Dispose configuration change listener
        this._configListener.dispose();
        // Save any unsaved sessions
        for (const session of this._sessions.values()) {
            this._saveSession(session).catch(error => {
                console.error(`Error saving session ${session.id} during disposal:`, error);
            });
        }
    }
}

;// external "child_process"
const external_child_process_namespaceObject = require("child_process");
;// ./src/core/git/conflictSolver.ts
/**
 * Git Conflict Solver
 *
 * Git ì¶©ëŒì„ ìžë™ìœ¼ë¡œ í•´ê²°í•˜ëŠ” ê³ ê¸‰ ëª¨ë“ˆ
 */






const execAsync = (0,external_util_.promisify)(external_child_process_namespaceObject.exec);
/**
 * ì¶©ëŒ í•´ê²° ì „ëžµ ìœ í˜•
 */
var ConflictStrategy;
(function (ConflictStrategy) {
    ConflictStrategy["AUTO"] = "auto";
    ConflictStrategy["OURS"] = "ours";
    ConflictStrategy["THEIRS"] = "theirs";
    ConflictStrategy["MERGE"] = "merge";
    ConflictStrategy["LLM"] = "llm"; // LLM ê¸°ë°˜ ì§€ëŠ¥í˜• ë³‘í•©
})(ConflictStrategy || (ConflictStrategy = {}));
/**
 * Git ì¶©ëŒ í•´ê²°ê¸°
 */
class ConflictSolver {
    llmService;
    workspaceRoot;
    /**
     * ìƒì„±ìž
     */
    constructor(llmService) {
        this.llmService = llmService;
        // ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ ë£¨íŠ¸ ì„¤ì •
        this.workspaceRoot = external_vscode_.workspace.workspaceFolders?.[0]?.uri.fsPath;
    }
    /**
     * í˜„ìž¬ ì €ìž¥ì†Œì˜ ì¶©ëŒ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
     */
    async getConflictingFiles() {
        if (!this.workspaceRoot) {
            return [];
        }
        try {
            // Git ì¶©ëŒ íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            const { stdout } = await execAsync('git diff --name-only --diff-filter=U', {
                cwd: this.workspaceRoot
            });
            return stdout.trim().split('\n').filter(file => file.trim() !== '');
        }
        catch (error) {
            console.error('ì¶©ëŒ íŒŒì¼ ì¡°íšŒ ì˜¤ë¥˜:', error);
            return [];
        }
    }
    /**
     * ì§€ì •ëœ ì „ëžµìœ¼ë¡œ ëª¨ë“  ì¶©ëŒ í•´ê²°
     */
    async resolveAllConflicts(strategy = ConflictStrategy.AUTO) {
        const conflictFiles = await this.getConflictingFiles();
        if (conflictFiles.length === 0) {
            return 0;
        }
        let resolvedCount = 0;
        // ì§„í–‰ ìƒí™© UI
        const progressOptions = {
            location: external_vscode_.ProgressLocation.Notification,
            title: 'ì¶©ëŒ í•´ê²° ì¤‘...',
            cancellable: true
        };
        await external_vscode_.window.withProgress(progressOptions, async (progress, token) => {
            let i = 0;
            for (const file of conflictFiles) {
                if (token.isCancellationRequested) {
                    break;
                }
                progress.report({
                    message: `${file} (${i + 1}/${conflictFiles.length})`,
                    increment: 100 / conflictFiles.length
                });
                const resolveSuccess = await this.resolveConflictsInFile(external_path_.join(this.workspaceRoot, file), strategy);
                if (resolveSuccess) {
                    resolvedCount++;
                }
                i++;
            }
            return resolvedCount;
        });
        return resolvedCount;
    }
    /**
     * ë‹¨ì¼ íŒŒì¼ì˜ ì¶©ëŒ í•´ê²°
     */
    async resolveConflictsInFile(filePath, strategy = ConflictStrategy.AUTO) {
        try {
            // íŒŒì¼ ë‚´ìš© ì½ê¸°
            const content = external_fs_.readFileSync(filePath, 'utf-8');
            // ì¶©ëŒ ì •ë³´ íŒŒì‹±
            const conflictInfo = this.parseConflicts(filePath, content);
            if (conflictInfo.conflicts.length === 0) {
                return false;
            }
            // íŒŒì¼ í™•ìž¥ìž í™•ì¸
            const fileExt = external_path_.extname(filePath).substring(1);
            // ì¶©ëŒ í•´ê²°
            const resolvedContent = await this.resolveContent(content, conflictInfo, strategy, fileExt);
            // í•´ê²°ëœ ë‚´ìš© ì €ìž¥
            external_fs_.writeFileSync(filePath, resolvedContent, 'utf-8');
            // Gitì— ì¶”ê°€
            if (this.workspaceRoot) {
                await execAsync(`git add "${filePath}"`, { cwd: this.workspaceRoot });
            }
            return true;
        }
        catch (error) {
            console.error(`íŒŒì¼ ì¶©ëŒ í•´ê²° ì˜¤ë¥˜ (${filePath}):`, error);
            return false;
        }
    }
    /**
     * ì¶©ëŒ ì •ë³´ íŒŒì‹±
     */
    parseConflicts(filePath, content) {
        const result = {
            filePath,
            conflicts: []
        };
        // ì¶©ëŒ íŒ¨í„´
        const conflictPattern = /<<<<<<< HEAD\r?\n([\s\S]*?)\r?\n=======\r?\n([\s\S]*?)\r?\n>>>>>>> (.*?)(\r?\n|$)/g;
        // ë¼ì¸ ìˆ˜ ê³„ì‚°ì€ ë³„ë„ë¡œ í•„ìš”í•  ë•Œ êµ¬í˜„
        let match;
        while ((match = conflictPattern.exec(content)) !== null) {
            const fullMatch = match[0];
            const ours = match[1];
            const theirs = match[2];
            const branch = match[3];
            // ì‹œìž‘ ë° ì¢…ë£Œ ë¼ì¸ ë²ˆí˜¸ ê³„ì‚°
            const startPos = content.substring(0, match.index).split(/\r?\n/).length - 1;
            const endPos = startPos + fullMatch.split(/\r?\n/).length - 1;
            result.conflicts.push({
                ours,
                theirs,
                marker: fullMatch,
                branch,
                startLine: startPos,
                endLine: endPos
            });
        }
        return result;
    }
    /**
     * ì¶©ëŒ ë‚´ìš© í•´ê²°
     */
    async resolveContent(content, conflictInfo, strategy, fileType) {
        let resolvedContent = content;
        // ê° ì¶©ëŒ ë¶€ë¶„ì— ëŒ€í•´ ì²˜ë¦¬
        for (const conflict of conflictInfo.conflicts) {
            // ì‹¤ì œ ì „ëžµì´ AUTOì¸ ê²½ìš° íŒŒì¼ ìœ í˜•ê³¼ ì¶©ëŒ ë‚´ìš©ì— ë”°ë¼ ìµœì  ì „ëžµ ì„ íƒ
            const actualStrategy = strategy === ConflictStrategy.AUTO
                ? this.determineStrategy(conflict, fileType)
                : strategy;
            // ì „ëžµì— ë”°ë¥¸ ì¶©ëŒ í•´ê²°
            const mergeResult = await this.applyStrategy(conflict, actualStrategy, fileType);
            if (mergeResult.success && mergeResult.resolvedContent) {
                // ì¶©ëŒ ë§ˆì»¤ë¥¼ í•´ê²°ëœ ë‚´ìš©ìœ¼ë¡œ êµì²´
                resolvedContent = resolvedContent.replace(conflict.marker, mergeResult.resolvedContent);
            }
        }
        return resolvedContent;
    }
    /**
     * ì¶©ëŒì— ê°€ìž¥ ì í•©í•œ ì „ëžµ ê²°ì •
     */
    determineStrategy(conflict, fileType) {
        // ë‘ ë³€ê²½ ì‚¬í•­ì´ ë™ì¼í•œ ê²½ìš°
        if (conflict.ours.trim() === conflict.theirs.trim()) {
            return ConflictStrategy.OURS;
        }
        // í•œìª½ì´ ë‹¤ë¥¸ ìª½ì„ í¬í•¨í•˜ëŠ” ê²½ìš°
        if (conflict.ours.includes(conflict.theirs)) {
            return ConflictStrategy.OURS;
        }
        if (conflict.theirs.includes(conflict.ours)) {
            return ConflictStrategy.THEIRS;
        }
        // ì–‘ìª½ ë³€ê²½ì‚¬í•­ì˜ ê·œëª¨ ë¹„êµ
        const oursLines = conflict.ours.split(/\r?\n/).length;
        const theirsLines = conflict.theirs.split(/\r?\n/).length;
        // í¬ê¸° ì°¨ì´ê°€ í¬ë©´ í° ìª½ ì„ íƒ
        if (oursLines > theirsLines * 2) {
            return ConflictStrategy.OURS;
        }
        if (theirsLines > oursLines * 2) {
            return ConflictStrategy.THEIRS;
        }
        // ì½”ë“œ íŒŒì¼ì¸ ê²½ìš° ì§€ëŠ¥í˜• ë³‘í•© ì‹œë„
        if (['js', 'ts', 'jsx', 'tsx', 'py', 'java', 'c', 'cpp', 'cs', 'go', 'rb', 'php'].includes(fileType)) {
            return ConflictStrategy.LLM;
        }
        // ê¸°íƒ€ íŒŒì¼ì˜ ê²½ìš° ë‹¨ìˆœ ë³‘í•©
        return ConflictStrategy.MERGE;
    }
    /**
     * ì¶©ëŒ í•´ê²° ì „ëžµ ì ìš©
     */
    async applyStrategy(conflict, strategy, fileType) {
        switch (strategy) {
            case ConflictStrategy.OURS:
                return {
                    success: true,
                    resolvedContent: conflict.ours
                };
            case ConflictStrategy.THEIRS:
                return {
                    success: true,
                    resolvedContent: conflict.theirs
                };
            case ConflictStrategy.MERGE:
                return this.mergeChanges(conflict);
            case ConflictStrategy.LLM:
                return await this.llmBasedMerge(conflict, fileType);
            default:
                return {
                    success: false,
                    message: 'ì§€ì›ë˜ì§€ ì•ŠëŠ” ì „ëžµ'
                };
        }
    }
    /**
     * ê¸°ë³¸ ë³‘í•© ì „ëžµ
     */
    mergeChanges(conflict) {
        // ì¤„ ë‹¨ìœ„ ë³‘í•© ìˆ˜í–‰
        const oursLines = conflict.ours.split(/\r?\n/);
        const theirsLines = conflict.theirs.split(/\r?\n/);
        // ê³µí†µ ì¤„ ì°¾ê¸°
        const commonLines = oursLines.filter(line => theirsLines.includes(line));
        // ë‘ ë³€ê²½ì‚¬í•­ì˜ ê³ ìœ  ì¤„ ì¶”ì¶œ
        const uniqueOurs = oursLines.filter(line => !theirsLines.includes(line));
        const uniqueTheirs = theirsLines.filter(line => !oursLines.includes(line));
        // ì¤‘ë³µ ì—†ì´ ëª¨ë“  ì¤„ ê²°í•©
        const combinedLines = [...commonLines, ...uniqueOurs, ...uniqueTheirs];
        return {
            success: true,
            resolvedContent: combinedLines.join('\n')
        };
    }
    /**
     * LLM ê¸°ë°˜ ì§€ëŠ¥í˜• ë³‘í•©
     */
    async llmBasedMerge(conflict, fileType) {
        try {
            // LLM ì„œë¹„ìŠ¤ì— í”„ë¡¬í”„íŠ¸ ìƒì„±
            const prompt = `
ë‘ ì½”ë“œ ë³€ê²½ì‚¬í•­ì„ ë³‘í•©í•´ì•¼ í•©ë‹ˆë‹¤. íŒŒì¼ íƒ€ìž…ì€ ${fileType}ìž…ë‹ˆë‹¤.
ì¶©ëŒì´ ë°œìƒí•œ ì½”ë“œ ë¶€ë¶„ì— ëŒ€í•´ ìµœì„ ì˜ ë³‘í•© ê²°ê³¼ë¥¼ ìƒì„±í•´ì£¼ì„¸ìš”.
ì½”ë“œì˜ ì˜ë¯¸ì™€ ê¸°ëŠ¥ì„ ìœ ì§€í•˜ë©´ì„œ ë‘ ë³€ê²½ì‚¬í•­ì„ í†µí•©í•´ì•¼ í•©ë‹ˆë‹¤.

í˜„ìž¬ ë¸Œëžœì¹˜ ì½”ë“œ:
\`\`\`${fileType}
${conflict.ours}
\`\`\`

ë‹¤ë¥¸ ë¸Œëžœì¹˜ (${conflict.branch}) ì½”ë“œ:
\`\`\`${fileType}
${conflict.theirs}
\`\`\`

ë³‘í•© ê²°ê³¼ë¥¼ ì§ì ‘ ì œê³µí•´ì£¼ì„¸ìš”. ë³‘í•© ë§ˆì»¤ë‚˜ ì„¤ëª… ì—†ì´ ì½”ë“œë§Œ ê²°ê³¼ë¡œ ë°˜í™˜í•´ì£¼ì„¸ìš”.`;
            // LLMì— ìš”ì²­
            const messages = [
                {
                    id: `msg_conflict_${Date.now()}`,
                    role: MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            const response = await this.llmService.sendRequest(messages);
            if (response.success && response.data) {
                // ì½”ë“œ ë¸”ë¡ì—ì„œ ì½”ë“œ ì¶”ì¶œ
                const codeBlockRegex = /```(?:[a-z]*\n)?([\s\S]*?)```/;
                const content = response.data.content || '';
                const contentMatch = content.match(codeBlockRegex);
                const resolvedContent = contentMatch
                    ? contentMatch[1].trim()
                    : content.trim();
                return {
                    success: true,
                    resolvedContent
                };
            }
            else {
                throw new Error('LLM ì„œë¹„ìŠ¤ ì‘ë‹µ ì‹¤íŒ¨');
            }
        }
        catch (error) {
            console.error('LLM ê¸°ë°˜ ë³‘í•© ì˜¤ë¥˜:', error);
            // LLM ì˜¤ë¥˜ ì‹œ ê¸°ë³¸ ë³‘í•© ì „ëžµìœ¼ë¡œ ëŒ€ì²´
            return this.mergeChanges(conflict);
        }
    }
}

;// ./src/core/git/commands.ts
/**
 * Git ëª…ë ¹ì–´ ëª¨ë“ˆ
 *
 * Git ê´€ë ¨ ëª…ë ¹ì–´ë“¤ì„ ì •ì˜í•©ë‹ˆë‹¤.
 */


/**
 * Git ëª…ë ¹ì–´ ëª©ë¡ ìƒì„±
 */
function createGitCommands() {
    const commands = [];
    // Git ëª…ë ¹ì–´ ì •ì˜
    commands.push({
        name: 'git',
        aliases: ['g', 'ê¹ƒ', 'ê¹ƒìž‘ì—…'],
        description: 'Git ìž‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤',
        examples: ['/git status', '/git commit', '/git auto', '/git consolidate', '/ê¹ƒ ìƒíƒœ', '/ê¹ƒ í†µí•©'],
        category: 'git',
        priority: 3,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand) {
                // Git í•˜ìœ„ ëª…ë ¹ì–´ ëª©ë¡ í‘œì‹œ (ìŠ¬ëž™/ë””ìŠ¤ì½”ë“œ ìŠ¤íƒ€ì¼ ìžë™ì™„ì„±)
                const gitSubcommands = [
                    { command: 'status', description: 'Git ì €ìž¥ì†Œ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤' },
                    { command: 'commit', description: 'ë³€ê²½ ì‚¬í•­ì„ ì»¤ë°‹í•©ë‹ˆë‹¤' },
                    { command: 'auto', description: 'ìžë™ ì»¤ë°‹ ê¸°ëŠ¥ì„ ì¼œê±°ë‚˜ ë•ë‹ˆë‹¤' },
                    { command: 'auto-on', description: 'ìžë™ ì»¤ë°‹ ê¸°ëŠ¥ì„ ì¼­ë‹ˆë‹¤' },
                    { command: 'auto-off', description: 'ìžë™ ì»¤ë°‹ ê¸°ëŠ¥ì„ ë•ë‹ˆë‹¤' },
                    { command: 'consolidate', description: 'ìž„ì‹œ ì»¤ë°‹ë“¤ì„ í•˜ë‚˜ì˜ ì •ì‹ ì»¤ë°‹ìœ¼ë¡œ í†µí•©í•©ë‹ˆë‹¤' },
                    { command: 'solve', description: 'ì›¹ë·°ë¥¼ í†µí•œ Git ì¶©ëŒ í•´ê²° ì œì•ˆì„ ì œê³µí•©ë‹ˆë‹¤' },
                    { command: 'solve-auto', description: 'ëª¨ë“  Git ì¶©ëŒì„ ìžë™ìœ¼ë¡œ í•´ê²°í•©ë‹ˆë‹¤' },
                    { command: 'solve-ours', description: 'ëª¨ë“  Git ì¶©ëŒì„ í˜„ìž¬ ë¸Œëžœì¹˜ì˜ ì½”ë“œë¡œ í•´ê²°í•©ë‹ˆë‹¤' },
                    { command: 'solve-theirs', description: 'ëª¨ë“  Git ì¶©ëŒì„ ë‹¤ë¥¸ ë¸Œëžœì¹˜ì˜ ì½”ë“œë¡œ í•´ê²°í•©ë‹ˆë‹¤' },
                    { command: 'solve-llm', description: 'LLMì„ ì‚¬ìš©í•´ Git ì¶©ëŒì„ ì§€ëŠ¥ì ìœ¼ë¡œ í•´ê²°í•©ë‹ˆë‹¤' }
                ];
                // ëª…ë ¹ì–´ ì œì•ˆì„ ì±„íŒ… ì¸í„°íŽ˜ì´ìŠ¤ì˜ ìžë™ì™„ì„± UIì— í‘œì‹œ
                const suggestions = gitSubcommands.map(cmd => ({
                    label: `/git ${cmd.command}`,
                    description: cmd.description,
                    category: 'git',
                    insertText: `/git ${cmd.command} `
                }));
                // ëª…ë ¹ì–´ ì œì•ˆ í‘œì‹œ - ì±„íŒ… ìž…ë ¥ì°½ ìžë™ì™„ì„± UIì— í‘œì‹œ
                external_vscode_.commands.executeCommand('ape.showCommandSuggestions', suggestions);
                // VSCodeì˜ í€µí”½ UIë„ í•¨ê»˜ í‘œì‹œ (ë°±ì—… ë°©ë²•)
                external_vscode_.window.showQuickPick(gitSubcommands.map(cmd => ({
                    label: cmd.command,
                    description: cmd.description,
                    detail: `Git í•˜ìœ„ ëª…ë ¹ì–´: ${cmd.command}`
                })), {
                    placeHolder: 'Git ëª…ë ¹ì–´ë¥¼ ì„ íƒí•˜ì„¸ìš”',
                    matchOnDescription: true
                }).then(selected => {
                    if (selected) {
                        // ì„ íƒí•œ ëª…ë ¹ì–´ë¥¼ ì±„íŒ… ìž…ë ¥ì°½ì— ì‚½ìž…
                        external_vscode_.commands.executeCommand('ape.insertToChatInput', `/git ${selected.label}`);
                    }
                });
            }
            else if (subCommand === 'status' || subCommand === 'ìƒíƒœ') {
                // Git ìƒíƒœ í™•ì¸
                await external_vscode_.commands.executeCommand('ape.git.showStatus');
            }
            else if (subCommand === 'commit' || subCommand === 'ì»¤ë°‹' || subCommand === 'ì €ìž¥') {
                // Git ì»¤ë°‹
                await external_vscode_.commands.executeCommand('ape.git.commit');
            }
            else if (subCommand === 'auto' || subCommand === 'ìžë™' || subCommand === 'ìžë™ì»¤ë°‹') {
                // ìžë™ ì»¤ë°‹ í† ê¸€
                await external_vscode_.commands.executeCommand('ape.git.toggleAutoCommit');
            }
            else if (subCommand === 'auto-on' || subCommand === 'autoon' || subCommand === 'ìžë™ì¼œê¸°' || subCommand === 'ìžë™ì»¤ë°‹ì¼œê¸°') {
                // ìžë™ ì»¤ë°‹ ì¼œê¸°
                await external_vscode_.workspace.getConfiguration('ape.git')
                    .update('autoCommit', true, external_vscode_.ConfigurationTarget.Workspace);
                external_vscode_.window.showInformationMessage('ìžë™ ì»¤ë°‹ì´ ì¼œì¡ŒìŠµë‹ˆë‹¤');
            }
            else if (subCommand === 'auto-off' || subCommand === 'autooff' || subCommand === 'ìžë™ë„ê¸°' || subCommand === 'ìžë™ì»¤ë°‹ë„ê¸°') {
                // ìžë™ ì»¤ë°‹ ë„ê¸°
                await external_vscode_.workspace.getConfiguration('ape.git')
                    .update('autoCommit', false, external_vscode_.ConfigurationTarget.Workspace);
                external_vscode_.window.showInformationMessage('ìžë™ ì»¤ë°‹ì´ êº¼ì¡ŒìŠµë‹ˆë‹¤');
            }
            else if (subCommand === 'consolidate' || subCommand === 'squash' || subCommand === 'í†µí•©' || subCommand === 'ìž„ì‹œí†µí•©' || subCommand === 'í†µí•©ì»¤ë°‹') {
                // ìž„ì‹œ ì»¤ë°‹ í†µí•©
                await external_vscode_.commands.executeCommand('ape.git.consolidateTemporaryCommits');
            }
            else if (subCommand === 'solve' || subCommand === 'conflict' || subCommand === 'conflicts' || subCommand === 'ì¶©ëŒ' || subCommand === 'ì¶©ëŒí•´ê²°') {
                // ì¶©ëŒ í•´ê²° - ì›¹ë·° ë²„ì „ (ìƒˆë¡œ ì¶”ê°€)
                await external_vscode_.commands.executeCommand('ape.git.solveConflictsWithReport');
            }
            else if (subCommand === 'solve-auto' || subCommand === 'ì¶©ëŒìžë™í•´ê²°') {
                // ì¶©ëŒ ìžë™ í•´ê²° (ê¸°ì¡´ ë°©ì‹)
                await external_vscode_.commands.executeCommand('ape.git.resolveConflict');
            }
            else if (subCommand === 'solve-ours' || subCommand === 'ì¶©ëŒë‚´ê²ƒì„ íƒ') {
                // ì¶©ëŒ í•´ê²° - í˜„ìž¬ ë¸Œëžœì¹˜ ì„ íƒ
                await external_vscode_.commands.executeCommand('ape.git.resolveConflictWithStrategy', ConflictStrategy.OURS);
            }
            else if (subCommand === 'solve-theirs' || subCommand === 'ì¶©ëŒì €ê²ƒì„ íƒ') {
                // ì¶©ëŒ í•´ê²° - ëŒ€ìƒ ë¸Œëžœì¹˜ ì„ íƒ
                await external_vscode_.commands.executeCommand('ape.git.resolveConflictWithStrategy', ConflictStrategy.THEIRS);
            }
            else if (subCommand === 'solve-llm' || subCommand === 'ì¶©ëŒì§€ëŠ¥í•´ê²°') {
                // ì¶©ëŒ í•´ê²° - LLM ì§€ëŠ¥í˜• ë³‘í•©
                await external_vscode_.commands.executeCommand('ape.git.resolveConflictWithStrategy', ConflictStrategy.LLM);
            }
            else {
                external_vscode_.window.showErrorMessage('ì•Œ ìˆ˜ ì—†ëŠ” Git í•˜ìœ„ ëª…ë ¹ì–´ìž…ë‹ˆë‹¤');
            }
        },
        provideCompletions: (partialArgs) => {
            const subCommands = [
                // ê¸°ì¡´ ëª…ë ¹ì–´
                'status', 'commit', 'auto', 'auto-on', 'auto-off', 'consolidate', 'squash',
                // ì¶©ëŒ í•´ê²° ê´€ë ¨ ëª…ë ¹ì–´
                'solve', 'conflict', 'conflicts', 'solve-auto', 'solve-ours', 'solve-theirs', 'solve-llm',
                // í•œêµ­ì–´ ëª…ë ¹ì–´
                'ìƒíƒœ', 'ì»¤ë°‹', 'ì €ìž¥', 'ìžë™', 'ìžë™ì»¤ë°‹', 'ìžë™ì¼œê¸°', 'ìžë™ë„ê¸°', 'ìžë™ì»¤ë°‹ì¼œê¸°', 'ìžë™ì»¤ë°‹ë„ê¸°', 'í†µí•©', 'ìž„ì‹œí†µí•©', 'í†µí•©ì»¤ë°‹',
                'ì¶©ëŒ', 'ì¶©ëŒí•´ê²°', 'ì¶©ëŒìžë™í•´ê²°', 'ì¶©ëŒë‚´ê²ƒì„ íƒ', 'ì¶©ëŒì €ê²ƒì„ íƒ', 'ì¶©ëŒì§€ëŠ¥í•´ê²°'
            ];
            // ì²« ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„±
            if (!partialArgs.includes(' ')) {
                return subCommands.filter(cmd => cmd.startsWith(partialArgs.toLowerCase()));
            }
            return [];
        }
    });
    return commands;
}

;// ./src/core/commands/vaultCommands.ts
/**
 * VAULT ê´€ë ¨ ìŠ¬ëž˜ì‹œ ì»¤ë§¨ë“œ ì •ì˜
 */


/**
 * VAULT ëª…ë ¹ì–´ ìƒì„±
 * @param vaultService VAULT ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
 */
function createVaultCommands(vaultService) {
    const commands = [];
    // VAULT ë©”ì¸ ëª…ë ¹ì–´
    commands.push({
        name: 'vault',
        aliases: ['ì»¨í…ìŠ¤íŠ¸', 'ë³¼íŠ¸', 'ctx', 'context'],
        description: 'VAULT ì»¨í…ìŠ¤íŠ¸ ë° ì•„ì´í…œì„ ê´€ë¦¬í•©ë‹ˆë‹¤',
        examples: ['/vault list', '/vault show system-context', '/vault use system-item-1', '/vault create personal ë‚´ ìž‘ì—… ë©”ëª¨'],
        category: 'utility',
        priority: 5,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand) {
                // Vault í•˜ìœ„ ëª…ë ¹ì–´ ëª©ë¡ í‘œì‹œ (ìŠ¬ëž™/ë””ìŠ¤ì½”ë“œ ìŠ¤íƒ€ì¼ ìžë™ì™„ì„±)
                const vaultSubcommands = [
                    { command: 'list', description: 'ëª¨ë“  ì»¨í…ìŠ¤íŠ¸ ë° ì•„ì´í…œ ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤' },
                    { command: 'show', description: 'íŠ¹ì • ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œ ë‚´ìš©ì„ í‘œì‹œí•©ë‹ˆë‹¤' },
                    { command: 'use', description: 'ì•„ì´í…œì„ ì‚¬ìš©í•˜ì—¬ ì±„íŒ…ì°½ì— ë‚´ìš©ì„ ì‚½ìž…í•©ë‹ˆë‹¤' },
                    { command: 'create', description: 'ìƒˆ ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œì„ ìƒì„±í•©ë‹ˆë‹¤' },
                    { command: 'delete', description: 'ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œì„ ì‚­ì œí•©ë‹ˆë‹¤' },
                    { command: 'search', description: 'ì»¨í…ìŠ¤íŠ¸ ë‚´ì—ì„œ ì•„ì´í…œì„ ê²€ìƒ‰í•©ë‹ˆë‹¤' }
                ];
                // ëª…ë ¹ì–´ ì œì•ˆì„ ì±„íŒ… ì¸í„°íŽ˜ì´ìŠ¤ì˜ ìžë™ì™„ì„± UIì— í‘œì‹œ
                const suggestions = vaultSubcommands.map(cmd => ({
                    label: `/vault ${cmd.command}`,
                    description: cmd.description,
                    category: 'utility',
                    insertText: `/vault ${cmd.command} `
                }));
                // ëª…ë ¹ì–´ ì œì•ˆ í‘œì‹œ - ì±„íŒ… ìž…ë ¥ì°½ ìžë™ì™„ì„± UIì— í‘œì‹œ
                external_vscode_.commands.executeCommand('ape.showCommandSuggestions', suggestions);
                // VSCodeì˜ í€µí”½ UIë„ í•¨ê»˜ í‘œì‹œ (ë°±ì—… ë°©ë²•)
                external_vscode_.window.showQuickPick(vaultSubcommands.map(cmd => ({
                    label: cmd.command,
                    description: cmd.description,
                    detail: `Vault í•˜ìœ„ ëª…ë ¹ì–´: ${cmd.command}`
                })), {
                    placeHolder: 'Vault ëª…ë ¹ì–´ë¥¼ ì„ íƒí•˜ì„¸ìš”',
                    matchOnDescription: true
                }).then(selected => {
                    if (selected) {
                        // ì„ íƒí•œ ëª…ë ¹ì–´ë¥¼ ì±„íŒ… ìž…ë ¥ì°½ì— ì‚½ìž…
                        external_vscode_.commands.executeCommand('ape.insertToChatInput', `/vault ${selected.label}`);
                    }
                });
            }
            else if (subCommand === 'list' || subCommand === 'ëª©ë¡') {
                // ì»¨í…ìŠ¤íŠ¸ ëª©ë¡ í‘œì‹œ
                await showContextList(vaultService);
            }
            else if (subCommand === 'show' || subCommand === 'ë³´ê¸°' || subCommand === 'view') {
                // ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œ ìƒì„¸ ë³´ê¸°
                const id = context.args[1];
                if (!id) {
                    external_vscode_.window.showErrorMessage('í‘œì‹œí•  ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œ IDë¥¼ ì§€ì •í•´ì£¼ì„¸ìš”');
                    return;
                }
                await showContextOrItem(vaultService, id);
            }
            else if (subCommand === 'use' || subCommand === 'ì‚¬ìš©') {
                // ì•„ì´í…œ ì‚¬ìš© (ì±„íŒ…ì°½ì— ë‚´ìš© ì‚½ìž…)
                const itemId = context.args[1];
                if (!itemId) {
                    external_vscode_.window.showErrorMessage('ì‚¬ìš©í•  ì•„ì´í…œ IDë¥¼ ì§€ì •í•´ì£¼ì„¸ìš”');
                    return;
                }
                await useVaultItem(vaultService, itemId);
            }
            else if (subCommand === 'create' || subCommand === 'ìƒì„±' || subCommand === 'new' || subCommand === 'ìƒˆë¡œë§Œë“¤ê¸°') {
                // ìƒˆ ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œ ìƒì„±
                const type = context.args[1]?.toLowerCase();
                const name = context.args.slice(2).join(' ');
                if (!type || !name) {
                    external_vscode_.window.showErrorMessage('ì»¨í…ìŠ¤íŠ¸ ìœ í˜•ê³¼ ì´ë¦„ì„ ì§€ì •í•´ì£¼ì„¸ìš”');
                    return;
                }
                await createContextOrItem(vaultService, type, name);
            }
            else if (subCommand === 'delete' || subCommand === 'ì‚­ì œ' || subCommand === 'remove') {
                // ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œ ì‚­ì œ
                const id = context.args[1];
                if (!id) {
                    external_vscode_.window.showErrorMessage('ì‚­ì œí•  ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œ IDë¥¼ ì§€ì •í•´ì£¼ì„¸ìš”');
                    return;
                }
                await deleteContextOrItem(vaultService, id);
            }
            else if (subCommand === 'search' || subCommand === 'ê²€ìƒ‰') {
                // ì•„ì´í…œ ê²€ìƒ‰
                const query = context.args.slice(1).join(' ');
                if (!query) {
                    external_vscode_.window.showErrorMessage('ê²€ìƒ‰ì–´ë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”');
                    return;
                }
                await searchVaultItems(vaultService, query);
            }
            else {
                external_vscode_.window.showErrorMessage(`ì•Œ ìˆ˜ ì—†ëŠ” VAULT í•˜ìœ„ ëª…ë ¹ì–´ìž…ë‹ˆë‹¤: ${subCommand}`);
            }
        },
        provideCompletions: (partialArgs) => {
            const parts = partialArgs.split(' ');
            // ì²« ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„± (í•˜ìœ„ ëª…ë ¹ì–´)
            if (parts.length <= 1) {
                const options = ['list', 'show', 'use', 'create', 'delete', 'search', 'ëª©ë¡', 'ë³´ê¸°', 'ì‚¬ìš©', 'ìƒì„±', 'ì‚­ì œ', 'ê²€ìƒ‰'];
                return options.filter(option => option.toLowerCase().startsWith(parts[0].toLowerCase() || ''));
            }
            // ë‘ ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„±
            if (parts.length === 2) {
                const subCommand = parts[0].toLowerCase();
                if (subCommand === 'create' || subCommand === 'ìƒì„±' || subCommand === 'new' || subCommand === 'ìƒˆë¡œë§Œë“¤ê¸°') {
                    // ì»¨í…ìŠ¤íŠ¸ ìœ í˜• ì œì•ˆ
                    const typeOptions = ['system', 'project', 'personal', 'shared', 'template', 'ì‹œìŠ¤í…œ', 'í”„ë¡œì íŠ¸', 'ê°œì¸', 'ê³µìœ ', 'í…œí”Œë¦¿'];
                    return typeOptions.filter(option => option.toLowerCase().startsWith(parts[1].toLowerCase() || ''));
                }
                else if (subCommand === 'show' || subCommand === 'ë³´ê¸°' || subCommand === 'view' ||
                    subCommand === 'use' || subCommand === 'ì‚¬ìš©' ||
                    subCommand === 'delete' || subCommand === 'ì‚­ì œ' || subCommand === 'remove') {
                    // ì»¨í…ìŠ¤íŠ¸/ì•„ì´í…œ ID ì œì•ˆ - ì‹¤ì œë¡œëŠ” vaultServiceì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨
                    // ëª¨ì˜ ë°ì´í„° ì‚¬ìš©
                    const idOptions = ['system-context', 'project-context', 'personal-context', 'shared-context', 'template-context',
                        'system-item-1', 'system-item-2', 'project-item-1', 'project-item-2', 'personal-item-1'];
                    return idOptions.filter(option => option.toLowerCase().startsWith(parts[1].toLowerCase() || ''));
                }
            }
            return [];
        }
    });
    return commands;
}
/**
 * ì»¨í…ìŠ¤íŠ¸ ëª©ë¡ í‘œì‹œ
 */
async function showContextList(vaultService, context) {
    try {
        const allContexts = vaultService.getAllContexts();
        if (allContexts.length === 0) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: 'VAULTì— ì €ìž¥ëœ ì»¨í…ìŠ¤íŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.'
            });
            return;
        }
        let content = '## VAULT ì»¨í…ìŠ¤íŠ¸ ëª©ë¡\n\n';
        // ì»¨í…ìŠ¤íŠ¸ íƒ€ìž…ë³„ ê·¸ë£¹í™”
        const groupedContexts = {
            'system': [],
            'project': [],
            'personal': [],
            'shared': [],
            'template': []
        };
        allContexts.forEach((ctx) => {
            groupedContexts[ctx.type].push(ctx);
        });
        // íƒ€ìž…ë³„ë¡œ í‘œì‹œ
        for (const [type, contexts] of Object.entries(groupedContexts)) {
            if (contexts.length > 0) {
                // íƒ€ìž…ëª… í•œê¸€ë¡œ ë³€í™˜
                let typeKorean = '';
                switch (type) {
                    case 'system':
                        typeKorean = 'ì‹œìŠ¤í…œ';
                        break;
                    case 'project':
                        typeKorean = 'í”„ë¡œì íŠ¸';
                        break;
                    case 'personal':
                        typeKorean = 'ê°œì¸';
                        break;
                    case 'shared':
                        typeKorean = 'ê³µìœ ';
                        break;
                    case 'template':
                        typeKorean = 'í…œí”Œë¦¿';
                        break;
                    default: typeKorean = type;
                }
                content += `### ${typeKorean} ì»¨í…ìŠ¤íŠ¸\n\n`;
                contexts.forEach(context => {
                    content += `- **${context.name}** (ID: \`${context.id}\`): ${context.items.length}ê°œ í•­ëª©`;
                    if (context.description) {
                        content += ` - ${context.description}`;
                    }
                    content += '\n';
                    // í•´ë‹¹ ì»¨í…ìŠ¤íŠ¸ì˜ ì•„ì´í…œë“¤ í‘œì‹œ
                    if (context.items.length > 0) {
                        content += '  - ì•„ì´í…œ ëª©ë¡:\n';
                        context.items.forEach((item) => {
                            content += `    - ${item.name} (ID: \`${item.id}\`)`;
                            if (item.description) {
                                content += ` - ${item.description}`;
                            }
                            content += '\n';
                        });
                    }
                    content += '\n';
                });
            }
        }
        // ì»¨í…ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²• ì•ˆë‚´
        content += '\n### ì‚¬ìš© ë°©ë²•\n\n';
        content += '- ì»¨í…ìŠ¤íŠ¸ ìƒì„¸ ì •ë³´ ë³´ê¸°: `/vault show [ì»¨í…ìŠ¤íŠ¸ID]`\n';
        content += '- ì•„ì´í…œ ë‚´ìš© ë³´ê¸°: `/vault show [ì•„ì´í…œID]`\n';
        content += '- ì•„ì´í…œ ì‚¬ìš©í•˜ê¸°: `/vault use [ì•„ì´í…œID]`\n';
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        console.error('ì»¨í…ìŠ¤íŠ¸ ëª©ë¡ í‘œì‹œ ì˜¤ë¥˜:', error);
        external_vscode_.window.showErrorMessage('ì»¨í…ìŠ¤íŠ¸ ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}
/**
 * ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œ ìƒì„¸ ë³´ê¸°
 */
async function showContextOrItem(vaultService, id) {
    try {
        // ë¨¼ì € ì»¨í…ìŠ¤íŠ¸ ê²€ìƒ‰
        const context = vaultService.getContextById(id);
        if (context) {
            // ì»¨í…ìŠ¤íŠ¸ ì •ë³´ í‘œì‹œ
            let content = `## ì»¨í…ìŠ¤íŠ¸: ${context.name}\n\n`;
            content += `- **ID**: \`${context.id}\`\n`;
            content += `- **ìœ í˜•**: ${getContextTypeKorean(context.type)}\n`;
            if (context.description) {
                content += `- **ì„¤ëª…**: ${context.description}\n`;
            }
            content += `- **ìƒì„±ì¼**: ${formatDate(context.createdAt)}\n`;
            content += `- **ìˆ˜ì •ì¼**: ${formatDate(context.updatedAt)}\n`;
            content += `- **í•­ëª© ìˆ˜**: ${context.items.length}ê°œ\n\n`;
            if (context.items.length > 0) {
                content += '### í¬í•¨ëœ ì•„ì´í…œ\n\n';
                context.items.forEach((item) => {
                    content += `- **${item.name}** (ID: \`${item.id}\`)`;
                    if (item.description) {
                        content += ` - ${item.description}`;
                    }
                    content += '\n';
                });
            }
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content
            });
            return;
        }
        // ì•„ì´í…œ ê²€ìƒ‰
        const allContexts = vaultService.getAllContexts();
        for (const context of allContexts) {
            const item = context.items.find((item) => item.id === id);
            if (item) {
                // ì•„ì´í…œ ì •ë³´ í‘œì‹œ
                let content = `## ì•„ì´í…œ: ${item.name}\n\n`;
                content += `- **ID**: \`${item.id}\`\n`;
                content += `- **ì»¨í…ìŠ¤íŠ¸**: ${context.name} (${getContextTypeKorean(context.type)})\n`;
                if (item.description) {
                    content += `- **ì„¤ëª…**: ${item.description}\n`;
                }
                content += `- **ìƒì„±ì¼**: ${formatDate(item.createdAt)}\n`;
                content += `- **ìˆ˜ì •ì¼**: ${formatDate(item.updatedAt)}\n`;
                if (item.tags && item.tags.length > 0) {
                    content += `- **íƒœê·¸**: ${item.tags.join(', ')}\n`;
                }
                content += '\n### ë‚´ìš©\n\n';
                content += '```\n' + item.content + '\n```\n\n';
                content += 'ì´ ì•„ì´í…œì„ ì‚¬ìš©í•˜ë ¤ë©´ `/vault use ' + item.id + '` ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”.';
                await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content
                });
                return;
            }
        }
        // ì»¨í…ìŠ¤íŠ¸ë‚˜ ì•„ì´í…œì„ ì°¾ì§€ ëª»í•œ ê²½ìš°
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `IDê°€ \`${id}\`ì¸ ì»¨í…ìŠ¤íŠ¸ë‚˜ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
        });
    }
    catch (error) {
        console.error('ì»¨í…ìŠ¤íŠ¸/ì•„ì´í…œ í‘œì‹œ ì˜¤ë¥˜:', error);
        external_vscode_.window.showErrorMessage('ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}
/**
 * ì•„ì´í…œ ì‚¬ìš© (ì±„íŒ…ì°½ì— ë‚´ìš© ì‚½ìž…)
 */
async function useVaultItem(vaultService, itemId) {
    try {
        // ì•„ì´í…œ ê²€ìƒ‰
        const allContexts = vaultService.getAllContexts();
        for (const context of allContexts) {
            const item = context.items.find((item) => item.id === itemId);
            if (item) {
                // ì•„ì´í…œ ë‚´ìš©ì„ LLMì—ê²Œ ì œê³µ
                await external_vscode_.commands.executeCommand('ape.sendUserMessage', {
                    content: item.content
                });
                return;
            }
        }
        // ì•„ì´í…œì„ ì°¾ì§€ ëª»í•œ ê²½ìš°
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `IDê°€ \`${itemId}\`ì¸ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
        });
    }
    catch (error) {
        console.error('ì•„ì´í…œ ì‚¬ìš© ì˜¤ë¥˜:', error);
        external_vscode_.window.showErrorMessage('ì•„ì´í…œì„ ì‚¬ìš©í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}
/**
 * ìƒˆ ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œ ìƒì„±
 */
async function createContextOrItem(vaultService, typeStr, name) {
    try {
        // ì»¨í…ìŠ¤íŠ¸ ìœ í˜• ê²°ì •
        let contextType;
        switch (typeStr.toLowerCase()) {
            case 'system':
            case 'ì‹œìŠ¤í…œ':
                contextType = VaultContextType.System;
                break;
            case 'project':
            case 'í”„ë¡œì íŠ¸':
                contextType = VaultContextType.Project;
                break;
            case 'personal':
            case 'ê°œì¸':
                contextType = VaultContextType.Personal;
                break;
            case 'shared':
            case 'ê³µìœ ':
                contextType = VaultContextType.Shared;
                break;
            case 'template':
            case 'í…œí”Œë¦¿':
                contextType = VaultContextType.Template;
                break;
            default:
                // ì»¨í…ìŠ¤íŠ¸ IDì¸ì§€ í™•ì¸ (ì•„ì´í…œ ìƒì„± ëª¨ë“œ)
                const context = vaultService.getContextById(typeStr);
                if (context) {
                    // ì•„ì´í…œ ìƒì„± ëª¨ë“œ
                    await createItem(vaultService, context, name);
                    return;
                }
                // ìœ íš¨í•˜ì§€ ì•Šì€ ìœ í˜•
                external_vscode_.window.showErrorMessage('ìœ íš¨í•˜ì§€ ì•Šì€ ì»¨í…ìŠ¤íŠ¸ ìœ í˜•ì´ë‚˜ IDìž…ë‹ˆë‹¤');
                return;
        }
        // ì»¨í…ìŠ¤íŠ¸ ìƒì„±
        await createContext(vaultService, contextType, name);
    }
    catch (error) {
        console.error('ì»¨í…ìŠ¤íŠ¸/ì•„ì´í…œ ìƒì„± ì˜¤ë¥˜:', error);
        external_vscode_.window.showErrorMessage('ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œì„ ìƒì„±í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}
/**
 * ìƒˆ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
 */
async function createContext(vaultService, type, name) {
    try {
        // ì„¤ëª… ìž…ë ¥ ë°›ê¸°
        const description = await external_vscode_.window.showInputBox({
            prompt: 'ì»¨í…ìŠ¤íŠ¸ ì„¤ëª…ì„ ìž…ë ¥í•˜ì„¸ìš” (ì„ íƒì‚¬í•­)',
            placeHolder: 'ì»¨í…ìŠ¤íŠ¸ì— ëŒ€í•œ ì„¤ëª…'
        });
        // ì»¨í…ìŠ¤íŠ¸ ìƒì„±
        const newContext = await vaultService.createContext(name, type, description);
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `${getContextTypeKorean(type)} ì»¨í…ìŠ¤íŠ¸ "${name}"ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. (ID: \`${newContext.id}\`)`
        });
    }
    catch (error) {
        console.error('ì»¨í…ìŠ¤íŠ¸ ìƒì„± ì˜¤ë¥˜:', error);
        external_vscode_.window.showErrorMessage('ì»¨í…ìŠ¤íŠ¸ë¥¼ ìƒì„±í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}
/**
 * ìƒˆ ì•„ì´í…œ ìƒì„±
 */
async function createItem(vaultService, context, name) {
    try {
        // ì„¤ëª… ìž…ë ¥ ë°›ê¸°
        const description = await external_vscode_.window.showInputBox({
            prompt: 'ì•„ì´í…œ ì„¤ëª…ì„ ìž…ë ¥í•˜ì„¸ìš” (ì„ íƒì‚¬í•­)',
            placeHolder: 'ì•„ì´í…œì— ëŒ€í•œ ì„¤ëª…'
        });
        // íƒœê·¸ ìž…ë ¥ ë°›ê¸°
        const tagsInput = await external_vscode_.window.showInputBox({
            prompt: 'íƒœê·¸ë¥¼ ìž…ë ¥í•˜ì„¸ìš” (ì‰¼í‘œë¡œ êµ¬ë¶„, ì„ íƒì‚¬í•­)',
            placeHolder: 'tag1, tag2, tag3'
        });
        const tags = tagsInput ? tagsInput.split(',').map(tag => tag.trim()) : undefined;
        // ë‚´ìš© ìž…ë ¥ ë°›ê¸° (ì—ë””í„° ì—´ê¸°)
        const document = await external_vscode_.workspace.openTextDocument({
            content: '',
            language: 'markdown'
        });
        const editor = await external_vscode_.window.showTextDocument(document);
        // ì‚¬ìš©ìžê°€ ë‚´ìš© íŽ¸ì§‘ì„ ì™„ë£Œí•  ë•Œê¹Œì§€ ëŒ€ê¸°
        const content = await new Promise(resolve => {
            const disposable = external_vscode_.workspace.onDidCloseTextDocument(closedDoc => {
                if (closedDoc === document) {
                    resolve(document.getText());
                    disposable.dispose();
                }
            });
        });
        if (!content.trim()) {
            external_vscode_.window.showErrorMessage('ì•„ì´í…œ ë‚´ìš©ì´ ë¹„ì–´ ìžˆìŠµë‹ˆë‹¤. ì•„ì´í…œ ìƒì„±ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.');
            return;
        }
        // ì•„ì´í…œ ìƒì„±
        const newItem = await vaultService.createItem(context.id, {
            name,
            description,
            content,
            tags,
            contextType: context.type
        });
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `"${context.name}" ì»¨í…ìŠ¤íŠ¸ì— "${name}" ì•„ì´í…œì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. (ID: \`${newItem.id}\`)`
        });
    }
    catch (error) {
        console.error('ì•„ì´í…œ ìƒì„± ì˜¤ë¥˜:', error);
        external_vscode_.window.showErrorMessage('ì•„ì´í…œì„ ìƒì„±í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}
/**
 * ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œ ì‚­ì œ
 */
async function deleteContextOrItem(vaultService, id) {
    try {
        // ì»¨í…ìŠ¤íŠ¸ì¸ì§€ í™•ì¸
        const context = vaultService.getContextById(id);
        if (context) {
            // ì»¨í…ìŠ¤íŠ¸ ì‚­ì œ í™•ì¸
            const confirmed = await external_vscode_.window.showWarningMessage(`"${context.name}" ì»¨í…ìŠ¤íŠ¸ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ìž‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìœ¼ë©°, í¬í•¨ëœ ëª¨ë“  ì•„ì´í…œì´ í•¨ê»˜ ì‚­ì œë©ë‹ˆë‹¤.`, { modal: true }, 'ì‚­ì œ');
            if (confirmed !== 'ì‚­ì œ') {
                await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: 'ì»¨í…ìŠ¤íŠ¸ ì‚­ì œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.'
                });
                return;
            }
            // ì»¨í…ìŠ¤íŠ¸ ì‚­ì œ
            await vaultService.deleteContext(id);
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `"${context.name}" ì»¨í…ìŠ¤íŠ¸ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // ì•„ì´í…œ ê²€ìƒ‰
        const allContexts = vaultService.getAllContexts();
        for (const ctx of allContexts) {
            const itemIndex = ctx.items.findIndex((item) => item.id === id);
            if (itemIndex !== -1) {
                const item = ctx.items[itemIndex];
                // ì•„ì´í…œ ì‚­ì œ í™•ì¸
                const confirmed = await external_vscode_.window.showWarningMessage(`"${item.name}" ì•„ì´í…œì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ìž‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, { modal: true }, 'ì‚­ì œ');
                if (confirmed !== 'ì‚­ì œ') {
                    await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: 'ì•„ì´í…œ ì‚­ì œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.'
                    });
                    return;
                }
                // ì•„ì´í…œ ì‚­ì œ
                await vaultService.deleteItem(ctx.id, id);
                await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: `"${item.name}" ì•„ì´í…œì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`
                });
                return;
            }
        }
        // ì»¨í…ìŠ¤íŠ¸ë‚˜ ì•„ì´í…œì„ ì°¾ì§€ ëª»í•œ ê²½ìš°
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `IDê°€ \`${id}\`ì¸ ì»¨í…ìŠ¤íŠ¸ë‚˜ ì•„ì´í…œì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
        });
    }
    catch (error) {
        console.error('ì»¨í…ìŠ¤íŠ¸/ì•„ì´í…œ ì‚­ì œ ì˜¤ë¥˜:', error);
        external_vscode_.window.showErrorMessage('ì»¨í…ìŠ¤íŠ¸ ë˜ëŠ” ì•„ì´í…œì„ ì‚­ì œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}
/**
 * ì•„ì´í…œ ê²€ìƒ‰
 */
async function searchVaultItems(vaultService, query) {
    try {
        // ì•„ì´í…œ ê²€ìƒ‰
        const items = vaultService.searchItems(query);
        if (items.length === 0) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `"${query}" ê²€ìƒ‰ì–´ì™€ ì¼ì¹˜í•˜ëŠ” ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // ê²°ê³¼ í‘œì‹œ
        let content = `## "${query}" ê²€ìƒ‰ ê²°ê³¼\n\n`;
        content += `ì´ ${items.length}ê°œì˜ ì•„ì´í…œì´ ê²€ìƒ‰ë˜ì—ˆìŠµë‹ˆë‹¤.\n\n`;
        // ì•„ì´í…œ ê·¸ë£¹í™” (ì»¨í…ìŠ¤íŠ¸ë³„)
        const groupedItems = {};
        items.forEach((item) => {
            if (!groupedItems[item.contextId || 'unknown']) {
                groupedItems[item.contextId || 'unknown'] = [];
            }
            groupedItems[item.contextId || 'unknown'].push(item);
        });
        // ì»¨í…ìŠ¤íŠ¸ë³„ë¡œ í‘œì‹œ
        for (const [contextId, ctxItems] of Object.entries(groupedItems)) {
            const context = vaultService.getContextById(contextId);
            if (context) {
                content += `### ${context.name} (${getContextTypeKorean(context.type)})\n\n`;
                ctxItems.forEach((item) => {
                    content += `- **${item.name}** (ID: \`${item.id}\`)`;
                    if (item.description) {
                        content += ` - ${item.description}`;
                    }
                    content += '\n';
                    if (item.tags && item.tags.length > 0) {
                        content += `  - íƒœê·¸: ${item.tags.join(', ')}\n`;
                    }
                    // ë‚´ìš© ì¼ë¶€ í‘œì‹œ (ìµœëŒ€ 100ìž)
                    const previewContent = item.content.length > 100
                        ? item.content.substring(0, 100) + '...'
                        : item.content;
                    content += `  - ë‚´ìš© ë¯¸ë¦¬ë³´ê¸°: ${previewContent.replace(/\n/g, ' ')}\n\n`;
                });
            }
        }
        content += 'ìžì„¸ížˆ ë³´ë ¤ë©´ `/vault show [ì•„ì´í…œID]` ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.';
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        console.error('ì•„ì´í…œ ê²€ìƒ‰ ì˜¤ë¥˜:', error);
        external_vscode_.window.showErrorMessage('ì•„ì´í…œì„ ê²€ìƒ‰í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤');
    }
}
/**
 * ì»¨í…ìŠ¤íŠ¸ ìœ í˜•ì˜ í•œê¸€ ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
 */
function getContextTypeKorean(type) {
    switch (type) {
        case VaultContextType.System: return 'ì‹œìŠ¤í…œ';
        case VaultContextType.Project: return 'í”„ë¡œì íŠ¸';
        case VaultContextType.Personal: return 'ê°œì¸';
        case VaultContextType.Shared: return 'ê³µìœ ';
        case VaultContextType.Template: return 'í…œí”Œë¦¿';
        default: return String(type);
    }
}
/**
 * ë‚ ì§œ í¬ë§·íŒ…
 */
function formatDate(date) {
    const d = typeof date === 'string' ? new Date(date) : date;
    return d.toLocaleDateString() + ' ' + d.toLocaleTimeString();
}

;// ./src/core/commands/rulesCommands.ts
/**
 * Rules ìŠ¬ëž˜ì‹œ ì»¤ë§¨ë“œ ì •ì˜
 */

/**
 * Rules ìŠ¬ëž˜ì‹œ ì»¤ë§¨ë“œ ëª©ë¡ ìƒì„±
 */
function createRulesCommands(rulesService) {
    if (!rulesService) {
        return [];
    }
    const commands = [];
    // rules ëª…ë ¹ì–´: Rules ê´€ë¦¬ ê¸°ëŠ¥ ì œê³µ
    commands.push({
        name: 'rules',
        aliases: ['rule', 'ape-rules', 'ë£°', 'ê·œì¹™', 'ê·œì¹™ê´€ë¦¬'],
        description: 'APE Rulesë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤ (ëª©ë¡, í™œì„±í™”, ë¹„í™œì„±í™”, ìƒì„±, ì‚­ì œ)',
        examples: [
            '/rules list',
            '/rules active',
            '/rules inactive',
            '/rules activate ê·œì¹™ì´ë¦„',
            '/rules deactivate ê·œì¹™ì´ë¦„',
            '/rules create ê·œì¹™ì´ë¦„',
            '/rules delete ê·œì¹™ì´ë¦„',
            '/rules open ê·œì¹™ì´ë¦„',
            '/rules info'
        ],
        category: 'advanced',
        priority: 15,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand) {
                // Rules í•˜ìœ„ ëª…ë ¹ì–´ ëª©ë¡ í‘œì‹œ (ìŠ¬ëž™/ë””ìŠ¤ì½”ë“œ ìŠ¤íƒ€ì¼ ìžë™ì™„ì„±)
                const rulesSubcommands = [
                    { command: 'list', description: 'ëª¨ë“  Rules ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤' },
                    { command: 'active', description: 'í™œì„±í™”ëœ Rules ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤' },
                    { command: 'inactive', description: 'ë¹„í™œì„±í™”ëœ Rules ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤' },
                    { command: 'activate', description: 'ì§€ì •í•œ Ruleì„ í™œì„±í™”í•©ë‹ˆë‹¤' },
                    { command: 'deactivate', description: 'ì§€ì •í•œ Ruleì„ ë¹„í™œì„±í™”í•©ë‹ˆë‹¤' },
                    { command: 'create', description: 'ìƒˆ Ruleì„ ìƒì„±í•©ë‹ˆë‹¤' },
                    { command: 'delete', description: 'ì§€ì •í•œ Ruleì„ ì‚­ì œí•©ë‹ˆë‹¤' },
                    { command: 'open', description: 'ì§€ì •í•œ Rule íŒŒì¼ì„ ì—½ë‹ˆë‹¤' },
                    { command: 'info', description: 'Rules ì‹œìŠ¤í…œ ì •ë³´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤' }
                ];
                // ëª…ë ¹ì–´ ì œì•ˆì„ ì±„íŒ… ì¸í„°íŽ˜ì´ìŠ¤ì˜ ìžë™ì™„ì„± UIì— í‘œì‹œ
                const suggestions = rulesSubcommands.map(cmd => ({
                    label: `/rules ${cmd.command}`,
                    description: cmd.description,
                    category: 'advanced',
                    insertText: `/rules ${cmd.command} `
                }));
                // ëª…ë ¹ì–´ ì œì•ˆ í‘œì‹œ - ì±„íŒ… ìž…ë ¥ì°½ ìžë™ì™„ì„± UIì— í‘œì‹œ
                external_vscode_.commands.executeCommand('ape.showCommandSuggestions', suggestions);
                // VSCodeì˜ í€µí”½ UIë„ í•¨ê»˜ í‘œì‹œ (ë°±ì—… ë°©ë²•)
                external_vscode_.window.showQuickPick(rulesSubcommands.map(cmd => ({
                    label: cmd.command,
                    description: cmd.description,
                    detail: `Rules í•˜ìœ„ ëª…ë ¹ì–´: ${cmd.command}`
                })), {
                    placeHolder: 'Rules ëª…ë ¹ì–´ë¥¼ ì„ íƒí•˜ì„¸ìš”',
                    matchOnDescription: true
                }).then(selected => {
                    if (selected) {
                        // ì„ íƒí•œ ëª…ë ¹ì–´ë¥¼ ì±„íŒ… ìž…ë ¥ì°½ì— ì‚½ìž…
                        external_vscode_.commands.executeCommand('ape.insertToChatInput', `/rules ${selected.label}`);
                    }
                });
            }
            else if (subCommand === 'list' || subCommand === 'ëª©ë¡') {
                // Rules ëª©ë¡ í‘œì‹œ
                await listRules(rulesService);
            }
            else if (subCommand === 'active' || subCommand === 'í™œì„±' || subCommand === 'í™œì„±í™”ëª©ë¡') {
                // í™œì„±í™”ëœ Rules ëª©ë¡ í‘œì‹œ
                await listActiveRules(rulesService);
            }
            else if (subCommand === 'inactive' || subCommand === 'ë¹„í™œì„±' || subCommand === 'ë¹„í™œì„±í™”ëª©ë¡') {
                // ë¹„í™œì„±í™”ëœ Rules ëª©ë¡ í‘œì‹œ
                await listInactiveRules(rulesService);
            }
            else if (subCommand === 'activate' || subCommand === 'í™œì„±í™”') {
                // Rule í™œì„±í™”
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await activateRule(rulesService, ruleName);
                }
                else {
                    external_vscode_.window.showErrorMessage('í™œì„±í™”í•  Rule ì´ë¦„ì„ ì§€ì •í•´ì£¼ì„¸ìš”');
                }
            }
            else if (subCommand === 'deactivate' || subCommand === 'ë¹„í™œì„±í™”') {
                // Rule ë¹„í™œì„±í™”
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await deactivateRule(rulesService, ruleName);
                }
                else {
                    external_vscode_.window.showErrorMessage('ë¹„í™œì„±í™”í•  Rule ì´ë¦„ì„ ì§€ì •í•´ì£¼ì„¸ìš”');
                }
            }
            else if (subCommand === 'create' || subCommand === 'ìƒì„±' || subCommand === 'ë§Œë“¤ê¸°') {
                // Rule ìƒì„±
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await createRule(rulesService, ruleName);
                }
                else {
                    external_vscode_.window.showErrorMessage('ìƒˆ Rule ì´ë¦„ì„ ì§€ì •í•´ì£¼ì„¸ìš”');
                }
            }
            else if (subCommand === 'delete' || subCommand === 'ì‚­ì œ') {
                // Rule ì‚­ì œ
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await deleteRule(rulesService, ruleName);
                }
                else {
                    external_vscode_.window.showErrorMessage('ì‚­ì œí•  Rule ì´ë¦„ì„ ì§€ì •í•´ì£¼ì„¸ìš”');
                }
            }
            else if (subCommand === 'open' || subCommand === 'ì—´ê¸°') {
                // Rule íŒŒì¼ ì—´ê¸°
                const ruleName = context.args.slice(1).join(' ');
                if (ruleName) {
                    await openRuleFile(rulesService, ruleName);
                }
                else {
                    external_vscode_.window.showErrorMessage('ì—´ Rule ì´ë¦„ì„ ì§€ì •í•´ì£¼ì„¸ìš”');
                }
            }
            else if (subCommand === 'info' || subCommand === 'ì •ë³´') {
                // Rules ì •ë³´ í‘œì‹œ
                await showRulesInfo(rulesService);
            }
            else {
                external_vscode_.window.showErrorMessage(`ì•Œ ìˆ˜ ì—†ëŠ” Rules í•˜ìœ„ ëª…ë ¹ì–´ìž…ë‹ˆë‹¤: ${subCommand}`);
            }
        },
        provideCompletions: (partialArgs) => {
            const subCommands = [
                'list', 'active', 'inactive', 'activate', 'deactivate', 'create', 'delete', 'open', 'info',
                'ëª©ë¡', 'í™œì„±', 'ë¹„í™œì„±', 'í™œì„±í™”', 'ë¹„í™œì„±í™”', 'ìƒì„±', 'ë§Œë“¤ê¸°', 'ì‚­ì œ', 'ì—´ê¸°', 'ì •ë³´'
            ];
            const parts = partialArgs.split(' ');
            // ì²« ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„± (í•˜ìœ„ ëª…ë ¹ì–´)
            if (parts.length <= 1) {
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(parts[0]?.toLowerCase() || ''));
            }
            // ë‘ ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„± (Rule ì´ë¦„)
            if (parts.length === 2 && ['activate', 'deactivate', 'delete', 'open', 'í™œì„±í™”', 'ë¹„í™œì„±í™”', 'ì‚­ì œ', 'ì—´ê¸°'].includes(parts[0])) {
                // í˜„ìž¬ëŠ” ë¹„ì–´ìžˆëŠ” ë°°ì—´ ë°˜í™˜
                // ëª¨ë“  í™œì„±í™”ëœ/ë¹„í™œì„±í™”ëœ Rule ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ” ë°©ë²•ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•ŠìŒ
                return [];
            }
            return [];
        }
    });
    return commands;
}
/**
 * Rules ëª©ë¡ í‘œì‹œ
 */
async function listRules(rulesService) {
    try {
        const rules = rulesService.getAllRules();
        if (rules.length === 0) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: 'ë“±ë¡ëœ Ruleì´ ì—†ìŠµë‹ˆë‹¤. `/rules create ì´ë¦„`ìœ¼ë¡œ ìƒˆ Ruleì„ ìƒì„±í•˜ì„¸ìš”.'
            });
            return;
        }
        let content = '## APE Rules ëª©ë¡\n\n';
        // í™œì„±í™”ëœ Rules ë¨¼ì € í‘œì‹œ
        const activeRules = rules.filter(rule => rule.status === 'active');
        const inactiveRules = rules.filter(rule => rule.status === 'inactive');
        if (activeRules.length > 0) {
            content += '### ðŸŸ¢ í™œì„±í™”ëœ Rules\n\n';
            activeRules.forEach(rule => {
                content += `- **${rule.name}** - \`${rule.id}.md\`\n`;
            });
            content += '\n';
        }
        if (inactiveRules.length > 0) {
            content += '### âšª ë¹„í™œì„±í™”ëœ Rules\n\n';
            inactiveRules.forEach(rule => {
                content += `- **${rule.name}** - \`${rule.id}.md\`\n`;
            });
            content += '\n';
        }
        content += '\n**Rules ê´€ë¦¬ ëª…ë ¹ì–´**:\n';
        content += '- `/rules activate ê·œì¹™ì´ë¦„` - Rule í™œì„±í™”\n';
        content += '- `/rules deactivate ê·œì¹™ì´ë¦„` - Rule ë¹„í™œì„±í™”\n';
        content += '- `/rules create ê·œì¹™ì´ë¦„` - ìƒˆ Rule ìƒì„±\n';
        content += '- `/rules delete ê·œì¹™ì´ë¦„` - Rule ì‚­ì œ\n';
        content += '- `/rules open ê·œì¹™ì´ë¦„` - Rule íŒŒì¼ ì—´ê¸°\n';
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`Rules ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * í™œì„±í™”ëœ Rules ëª©ë¡ í‘œì‹œ
 */
async function listActiveRules(rulesService) {
    try {
        const activeRules = rulesService.getActiveRules();
        if (activeRules.length === 0) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: 'í˜„ìž¬ í™œì„±í™”ëœ Ruleì´ ì—†ìŠµë‹ˆë‹¤. `/rules activate ì´ë¦„`ìœ¼ë¡œ Ruleì„ í™œì„±í™”í•˜ì„¸ìš”.'
            });
            return;
        }
        let content = '## ðŸŸ¢ í™œì„±í™”ëœ APE Rules\n\n';
        activeRules.forEach(rule => {
            // ì²« 100ìž ë‚´ìš©ë§Œ í‘œì‹œ
            const previewContent = rule.content.length > 100
                ? rule.content.substring(0, 100) + '...'
                : rule.content;
            content += `### ${rule.name}\n\n`;
            content += `- **ID**: \`${rule.id}\`\n`;
            content += `- **íŒŒì¼**: \`${rule.filePath.split('/').pop()}\`\n`;
            content += `- **ë‚´ìš© ë¯¸ë¦¬ë³´ê¸°**:\n\n\`\`\`\n${previewContent}\n\`\`\`\n\n`;
        });
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`í™œì„±í™”ëœ Rules ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * ë¹„í™œì„±í™”ëœ Rules ëª©ë¡ í‘œì‹œ
 */
async function listInactiveRules(rulesService) {
    try {
        const allRules = rulesService.getAllRules();
        const activeRules = rulesService.getActiveRules();
        const inactiveRules = allRules.filter(rule => !activeRules.some(activeRule => activeRule.id === rule.id));
        if (inactiveRules.length === 0) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: 'í˜„ìž¬ ë¹„í™œì„±í™”ëœ Ruleì´ ì—†ìŠµë‹ˆë‹¤. ëª¨ë“  Rulesê°€ í™œì„±í™” ìƒíƒœìž…ë‹ˆë‹¤.'
            });
            return;
        }
        let content = '## âšª ë¹„í™œì„±í™”ëœ APE Rules\n\n';
        inactiveRules.forEach(rule => {
            // ì²« 100ìž ë‚´ìš©ë§Œ í‘œì‹œ
            const previewContent = rule.content.length > 100
                ? rule.content.substring(0, 100) + '...'
                : rule.content;
            content += `### ${rule.name}\n\n`;
            content += `- **ID**: \`${rule.id}\`\n`;
            content += `- **íŒŒì¼**: \`${rule.filePath.split('/').pop()}\`\n`;
            content += `- **ë‚´ìš© ë¯¸ë¦¬ë³´ê¸°**:\n\n\`\`\`\n${previewContent}\n\`\`\`\n\n`;
        });
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`ë¹„í™œì„±í™”ëœ Rules ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule í™œì„±í™”
 */
async function activateRule(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        // ì´ë¦„ ë˜ëŠ” IDë¡œ Rule ì°¾ê¸°
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}' ì´ë¦„ ë˜ëŠ” IDë¥¼ ê°€ì§„ Ruleì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. '/rules list'ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ Rulesë¥¼ í™•ì¸í•˜ì„¸ìš”.`
            });
            return;
        }
        // ì´ë¯¸ í™œì„±í™”ëœ ê²½ìš°
        if (rule.status === 'active') {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${rule.name}' Ruleì€ ì´ë¯¸ í™œì„±í™”ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // Rule í™œì„±í™”
        await rulesService.activateRule(rule.id);
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Ruleì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ì œ LLM ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— ì ìš©ë©ë‹ˆë‹¤.`
        });
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`Rule í™œì„±í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule ë¹„í™œì„±í™”
 */
async function deactivateRule(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        // ì´ë¦„ ë˜ëŠ” IDë¡œ Rule ì°¾ê¸°
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}' ì´ë¦„ ë˜ëŠ” IDë¥¼ ê°€ì§„ Ruleì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. '/rules list'ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ Rulesë¥¼ í™•ì¸í•˜ì„¸ìš”.`
            });
            return;
        }
        // ì´ë¯¸ ë¹„í™œì„±í™”ëœ ê²½ìš°
        if (rule.status === 'inactive') {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${rule.name}' Ruleì€ ì´ë¯¸ ë¹„í™œì„±í™”ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // Rule ë¹„í™œì„±í™”
        await rulesService.deactivateRule(rule.id);
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Ruleì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ë” ì´ìƒ LLM ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— ì ìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`
        });
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`Rule ë¹„í™œì„±í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * ìƒˆ Rule ìƒì„±
 */
async function createRule(rulesService, ruleName) {
    try {
        // Rule ë‚´ìš© í…œí”Œë¦¿
        const ruleContent = `# ${ruleName}\n\nì—¬ê¸°ì— LLMì— ì ìš©í•  ê·œì¹™ ë‚´ìš©ì„ ìž‘ì„±í•˜ì„¸ìš”.\n\nê·œì¹™ì€ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ìž‘ì„±ë©ë‹ˆë‹¤.\n\n## ì˜ˆì‹œ\n\n1. í•­ìƒ ì½”ë“œì— ì£¼ì„ì„ ì¶”ê°€í•´ì£¼ì„¸ìš”.\n2. ì‘ë‹µì€ ê°„ê²°í•˜ê²Œ ìœ ì§€í•´ì£¼ì„¸ìš”.\n3. ì—ëŸ¬ ì²˜ë¦¬ë¥¼ í•­ìƒ í¬í•¨í•´ì£¼ì„¸ìš”.`;
        // Rule ìƒì„±
        const rule = await rulesService.createRule(ruleName, ruleContent, false);
        // Rule íŒŒì¼ ì—´ê¸°
        await rulesService.openRuleFile(rule.id);
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Ruleì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. íŒŒì¼ì„ ìˆ˜ì •í•œ í›„ ì €ìž¥í•˜ê³ , '/rules activate ${rule.name}'ë¡œ í™œì„±í™”í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.`
        });
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`Rule ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule ì‚­ì œ
 */
async function deleteRule(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        // ì´ë¦„ ë˜ëŠ” IDë¡œ Rule ì°¾ê¸°
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}' ì´ë¦„ ë˜ëŠ” IDë¥¼ ê°€ì§„ Ruleì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. '/rules list'ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ Rulesë¥¼ í™•ì¸í•˜ì„¸ìš”.`
            });
            return;
        }
        // ì‚­ì œ í™•ì¸ (í”„ë¡¬í”„íŠ¸ ëŒ€í™”ìƒìž ì‚¬ìš©)
        const confirmation = await external_vscode_.window.showWarningMessage(`'${rule.name}' Ruleì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`, { modal: true }, 'ì‚­ì œ', 'ì·¨ì†Œ');
        if (confirmation !== 'ì‚­ì œ') {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${rule.name}' Rule ì‚­ì œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // Rule ì‚­ì œ
        await rulesService.deleteRule(rule.id);
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Ruleì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`
        });
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`Rule ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rule íŒŒì¼ ì—´ê¸°
 */
async function openRuleFile(rulesService, ruleName) {
    try {
        const rules = rulesService.getAllRules();
        // ì´ë¦„ ë˜ëŠ” IDë¡œ Rule ì°¾ê¸°
        const rule = rules.find(r => r.name.toLowerCase() === ruleName.toLowerCase() ||
            r.id.toLowerCase() === ruleName.toLowerCase());
        if (!rule) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `'${ruleName}' ì´ë¦„ ë˜ëŠ” IDë¥¼ ê°€ì§„ Ruleì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. '/rules list'ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ Rulesë¥¼ í™•ì¸í•˜ì„¸ìš”.`
            });
            return;
        }
        // Rule íŒŒì¼ ì—´ê¸°
        await rulesService.openRuleFile(rule.id);
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `'${rule.name}' Rule íŒŒì¼ì´ ì—´ë ¸ìŠµë‹ˆë‹¤.`
        });
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`Rule íŒŒì¼ ì—´ê¸° ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Rules ì •ë³´ í‘œì‹œ
 */
async function showRulesInfo(rulesService) {
    try {
        const rules = rulesService.getAllRules();
        const activeRules = rulesService.getActiveRules();
        let content = '## APE Rules ì •ë³´\n\n';
        content += `- **ì´ Rules ìˆ˜**: ${rules.length}ê°œ\n`;
        content += `- **í™œì„±í™”ëœ Rules**: ${activeRules.length}ê°œ\n`;
        content += `- **ë¹„í™œì„±í™”ëœ Rules**: ${rules.length - activeRules.length}ê°œ\n\n`;
        content += '### Rules ì‹œìŠ¤í…œì— ëŒ€í•˜ì—¬\n\n';
        content += 'APE RulesëŠ” LLMì— ì ìš©ë˜ëŠ” ê·œì¹™ì„ ê´€ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œìž…ë‹ˆë‹¤. ê° Ruleì€ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ì˜ íŒŒì¼ë¡œ ì €ìž¥ë˜ë©°, í™œì„±í™”ëœ RulesëŠ” LLM ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— ìžë™ìœ¼ë¡œ ì¶”ê°€ë©ë‹ˆë‹¤.\n\n';
        content += '### ì£¼ìš” ê¸°ëŠ¥\n\n';
        content += '- **ëª©ë¡ ë³´ê¸°**: `/rules list` - ëª¨ë“  Rules ëª©ë¡ í‘œì‹œ\n';
        content += '- **í™œì„±í™”ëœ Rules**: `/rules active` - í™œì„±í™”ëœ Rules ëª©ë¡ í‘œì‹œ\n';
        content += '- **ë¹„í™œì„±í™”ëœ Rules**: `/rules inactive` - ë¹„í™œì„±í™”ëœ Rules ëª©ë¡ í‘œì‹œ\n';
        content += '- **Rule í™œì„±í™”**: `/rules activate ì´ë¦„` - ì§€ì •í•œ Rule í™œì„±í™”\n';
        content += '- **Rule ë¹„í™œì„±í™”**: `/rules deactivate ì´ë¦„` - ì§€ì •í•œ Rule ë¹„í™œì„±í™”\n';
        content += '- **Rule ìƒì„±**: `/rules create ì´ë¦„` - ìƒˆ Rule ìƒì„±\n';
        content += '- **Rule ì‚­ì œ**: `/rules delete ì´ë¦„` - ì§€ì •í•œ Rule ì‚­ì œ\n';
        content += '- **Rule íŒŒì¼ ì—´ê¸°**: `/rules open ì´ë¦„` - ì§€ì •í•œ Rule íŒŒì¼ ì—´ê¸°\n';
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`Rules ì •ë³´ í‘œì‹œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
    }
}

;// ./src/core/services/serviceResult.ts
/**
 * ì„œë¹„ìŠ¤ ê²°ê³¼ ëª¨ë“ˆ
 *
 * ì™¸ë¶€ ì„œë¹„ìŠ¤ í˜¸ì¶œì˜ ê²°ê³¼ë¥¼ í‘œì¤€í™”ëœ í˜•ì‹ìœ¼ë¡œ ì²˜ë¦¬í•˜ëŠ” ì¸í„°íŽ˜ì´ìŠ¤ ì •ì˜
 * ì„±ê³µ/ì‹¤íŒ¨ ì—¬ë¶€, ë°ì´í„°, ì˜¤ë¥˜ ì •ë³´ë¥¼ ì¼ê´€ëœ ë°©ì‹ìœ¼ë¡œ ê´€ë¦¬
 */
/**
 * ì„±ê³µ ê²°ê³¼ ìƒì„± ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
 *
 * @param data ê²°ê³¼ ë°ì´í„°
 * @returns ì„±ê³µ ê²°ê³¼ ê°ì²´
 */
function createSuccessResult(data) {
    return {
        success: true,
        data
    };
}
/**
 * ì‹¤íŒ¨ ê²°ê³¼ ìƒì„± ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
 *
 * @param error ì˜¤ë¥˜ ì •ë³´
 * @returns ì‹¤íŒ¨ ê²°ê³¼ ê°ì²´
 */
function createErrorResult(error) {
    return {
        success: false,
        error
    };
}

;// ./src/core/services/jiraService.ts
/**
 * Jira ì„œë¹„ìŠ¤
 *
 * Jira APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì´ìŠˆ ì •ë³´ë¥¼ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ëŠ” ì„œë¹„ìŠ¤ìž…ë‹ˆë‹¤.
 * ë‚´ë¶€ë§ Jira ì„œë²„ì™€ í†µì‹ í•˜ë©°, ì‹¤ì œ ì„œë²„ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš° ëª¨ì˜(Mock) ë°ì´í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */





/**
 * Jira ì´ìŠˆ ìƒíƒœ ìœ í˜•
 */
var JiraIssueStatus;
(function (JiraIssueStatus) {
    JiraIssueStatus["ToDo"] = "todo";
    JiraIssueStatus["InProgress"] = "in-progress";
    JiraIssueStatus["Done"] = "done";
    JiraIssueStatus["InReview"] = "in-review";
    JiraIssueStatus["Blocked"] = "blocked";
    JiraIssueStatus["Unknown"] = "unknown";
})(JiraIssueStatus || (JiraIssueStatus = {}));
/**
 * Jira ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ìœ í˜•
 */
var JiraErrorType;
(function (JiraErrorType) {
    JiraErrorType["ConnectionFailed"] = "connection_failed";
    JiraErrorType["AuthenticationFailed"] = "authentication_failed";
    JiraErrorType["PermissionDenied"] = "permission_denied";
    JiraErrorType["ResourceNotFound"] = "resource_not_found";
    JiraErrorType["ServerError"] = "server_error";
    JiraErrorType["InvalidRequest"] = "invalid_request";
    JiraErrorType["Unknown"] = "unknown";
})(JiraErrorType || (JiraErrorType = {}));
/**
 * Jira ì„œë¹„ìŠ¤ í´ëž˜ìŠ¤
 */
class JiraService {
    context;
    serviceConfigManager;
    baseUrl = '';
    apiPath = '/rest/api/2';
    username = '';
    password = '';
    token = '';
    authType = AuthType.Basic;
    useMock = true;
    disposables = [];
    _lastError = null;
    /**
     * Jira ì„œë¹„ìŠ¤ ìƒì„±ìž
     * @param context VSCode í™•ìž¥ ì»¨í…ìŠ¤íŠ¸
     * @param serviceConfigManager ì„œë¹„ìŠ¤ ì„¤ì • ê´€ë¦¬ìž (ì„ íƒì )
     */
    constructor(context, serviceConfigManager) {
        this.context = context;
        this.serviceConfigManager = serviceConfigManager;
        // ì„¤ì • ë¡œë“œ
        this.loadConfiguration();
        // ì„¤ì • ë³€ê²½ ê°ì§€
        this.disposables.push(external_vscode_.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.jira')) {
                this.loadConfiguration();
            }
        }));
    }
    /**
     * ì„¤ì • ë‹¤ì‹œ ë¡œë“œ
     */
    loadConfiguration() {
        if (this.serviceConfigManager) {
            // ì„œë¹„ìŠ¤ ì„¤ì • ê´€ë¦¬ìžë¥¼ ì‚¬ìš©í•˜ì—¬ ì„¤ì • ë¡œë“œ
            const config = this.serviceConfigManager.getServiceConfig(ServiceType.Jira);
            this.baseUrl = config.url;
            this.authType = config.authType;
            this.username = config.username || '';
            this.password = config.password || '';
            this.token = config.token || '';
            this.useMock = config.useMock;
            // ì¶”ê°€ íŒŒë¼ë¯¸í„°ì—ì„œ API ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
            const additionalParams = config.additionalParams || {};
            this.apiPath = additionalParams.apiPath || '/rest/api/2';
        }
        else {
            // ì§ì ‘ VSCode ì„¤ì •ì—ì„œ ë¡œë“œ
            const config = external_vscode_.workspace.getConfiguration('ape.jira');
            this.baseUrl = config.get('url', '');
            this.apiPath = config.get('apiPath', '/rest/api/2');
            this.username = config.get('username', '');
            this.password = config.get('password', '');
            this.token = config.get('token', '');
            this.authType = config.get('authType', AuthType.Basic);
            this.useMock = config.get('useMock', false);
        }
        // í•„ìˆ˜ ì„¤ì •ì´ ì—†ìœ¼ë©´ ëª¨ì˜ ëª¨ë“œ ê°•ì œ í™œì„±í™”
        if (!this.baseUrl || (this.authType === AuthType.Basic && (!this.username || !this.password)) ||
            (this.authType === AuthType.Token && !this.token)) {
            this.useMock = true;
        }
    }
    /**
     * ë§ˆì§€ë§‰ ì˜¤ë¥˜ ê°€ì ¸ì˜¤ê¸°
     */
    get lastError() {
        return this._lastError;
    }
    /**
     * ì´ìŠˆ ì¡°íšŒ
     * @param issueKey Jira ì´ìŠˆ í‚¤ (ì˜ˆ: 'APE-123')
     * @returns Jira ì´ìŠˆ ì •ë³´ë¥¼ í¬í•¨í•œ ì„œë¹„ìŠ¤ ê²°ê³¼
     */
    async getIssue(issueKey) {
        try {
            // ë§ˆì§€ë§‰ ì˜¤ë¥˜ ì´ˆê¸°í™”
            this._lastError = null;
            // ëª¨ì˜ ëª¨ë“œì¸ ê²½ìš° ëª¨ì˜ ë°ì´í„° ë°˜í™˜
            if (this.useMock) {
                const mockIssue = this.getMockIssue(issueKey);
                return createSuccessResult(mockIssue);
            }
            // í•„ìˆ˜ ì„¤ì • í™•ì¸
            if (!this.baseUrl) {
                throw new Error('Jira ì„œë²„ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira ì¸ì¦ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì‚¬ìš©ìž ì´ë¦„ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Token && !this.token) {
                throw new Error('Jira ì¸ì¦ í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í† í° ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            // Jira REST API ì—”ë“œí¬ì¸íŠ¸
            const url = `${this.baseUrl}${this.apiPath}/issue/${issueKey}`;
            // API ìš”ì²­ ì„¤ì •
            const config = {};
            // ì¸ì¦ ìœ í˜•ì— ë”°ë¥¸ ì„¤ì •
            if (this.authType === AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API ìš”ì²­ ì‹¤í–‰
            const response = await lib_axios.get(url, config);
            // ì‘ë‹µ ë°ì´í„° íŒŒì‹±
            const issue = this.parseJiraIssue(response.data);
            return createSuccessResult(issue);
        }
        catch (error) {
            // ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¶„ë¥˜
            this.handleError(error, issueKey);
            // ì˜¤ë¥˜ ë¡œê·¸
            console.error(`Jira ì´ìŠˆ ì¡°íšŒ ì‹¤íŒ¨ (${issueKey}):`, error);
            // ì˜¤ë¥˜ ê²°ê³¼ ìƒì„±
            let serviceError;
            if (this._lastError) {
                // JiraErrorë¥¼ IServiceErrorë¡œ ë³€í™˜
                serviceError = ServiceErrorManager.createError(ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = ServiceErrorManager.createError(ServiceType.Jira, ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return createErrorResult(serviceError);
        }
    }
    /**
     * Jira ì´ìŠˆ ìƒì„±
     * @param issueData ì´ìŠˆ ë°ì´í„°
     * @returns ìƒì„±ëœ ì´ìŠˆ ì •ë³´ë¥¼ í¬í•¨í•œ ì„œë¹„ìŠ¤ ê²°ê³¼
     */
    async createIssue(issueData) {
        try {
            // ë§ˆì§€ë§‰ ì˜¤ë¥˜ ì´ˆê¸°í™”
            this._lastError = null;
            // ëª¨ì˜ ëª¨ë“œì¸ ê²½ìš° ëª¨ì˜ ë°ì´í„° ë°˜í™˜
            if (this.useMock) {
                const mockIssue = this.getMockIssue(`${issueData.projectKey}-${Math.floor(Math.random() * 1000)}`);
                return createSuccessResult(mockIssue);
            }
            // í•„ìˆ˜ ì„¤ì • í™•ì¸
            if (!this.baseUrl) {
                throw new Error('Jira ì„œë²„ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira ì¸ì¦ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì‚¬ìš©ìž ì´ë¦„ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Token && !this.token) {
                throw new Error('Jira ì¸ì¦ í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í† í° ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            // Jira REST API ì—”ë“œí¬ì¸íŠ¸
            const url = `${this.baseUrl}${this.apiPath}/issue`;
            // í•„ìˆ˜ í•„ë“œ í™•ì¸
            if (!issueData.projectKey) {
                throw new Error('Jira í”„ë¡œì íŠ¸ í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤.');
            }
            if (!issueData.issueType) {
                throw new Error('Jira ì´ìŠˆ ìœ í˜•ì´ í•„ìš”í•©ë‹ˆë‹¤.');
            }
            if (!issueData.summary) {
                throw new Error('Jira ì´ìŠˆ ìš”ì•½ì´ í•„ìš”í•©ë‹ˆë‹¤.');
            }
            // ìš”ì²­ ë°ì´í„° êµ¬ì„±
            const requestData = {
                fields: {
                    project: {
                        key: issueData.projectKey
                    },
                    issuetype: {
                        name: issueData.issueType
                    },
                    summary: issueData.summary,
                    description: issueData.description || '',
                    assignee: issueData.assignee ? { name: issueData.assignee } : undefined,
                    components: issueData.components?.map(name => ({ name })),
                    labels: issueData.labels,
                    duedate: issueData.dueDate
                }
            };
            // API ìš”ì²­ ì„¤ì •
            const config = {};
            // ì¸ì¦ ìœ í˜•ì— ë”°ë¥¸ ì„¤ì •
            if (this.authType === AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API ìš”ì²­ ì‹¤í–‰
            const response = await lib_axios.post(url, requestData, config);
            // ìƒì„±ëœ ì´ìŠˆ IDë¡œ ì´ìŠˆ ì¡°íšŒ
            const issueKey = response.data.key;
            const issueResult = await this.getIssue(issueKey);
            if (issueResult.success && issueResult.data) {
                return createSuccessResult(issueResult.data);
            }
            else {
                // ì´ìŠˆë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš° ê¸°ë³¸ ì •ë³´ë§Œ ë°˜í™˜
                const basicIssue = {
                    id: '0',
                    key: issueKey,
                    summary: issueData.summary,
                    description: issueData.description || '',
                    status: JiraIssueStatus.ToDo,
                    created: new Date().toISOString(),
                    updated: new Date().toISOString()
                };
                return createSuccessResult(basicIssue);
            }
        }
        catch (error) {
            // ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¶„ë¥˜
            this.handleError(error);
            // ì˜¤ë¥˜ ë¡œê·¸
            console.error('Jira ì´ìŠˆ ìƒì„± ì‹¤íŒ¨:', error);
            // ì˜¤ë¥˜ ê²°ê³¼ ìƒì„±
            let serviceError;
            if (this._lastError) {
                // JiraErrorë¥¼ IServiceErrorë¡œ ë³€í™˜
                serviceError = ServiceErrorManager.createError(ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = ServiceErrorManager.createError(ServiceType.Jira, ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return createErrorResult(serviceError);
        }
    }
    /**
     * Jira ì´ìŠˆ ìƒíƒœ ë³€ê²½
     * @param issueKey Jira ì´ìŠˆ í‚¤ (ì˜ˆ: 'APE-123')
     * @param status ë³€ê²½í•  ìƒíƒœ
     * @returns ì„±ê³µ ì—¬ë¶€ë¥¼ í¬í•¨í•œ ì„œë¹„ìŠ¤ ê²°ê³¼
     */
    async updateIssueStatus(issueKey, status) {
        try {
            // ë§ˆì§€ë§‰ ì˜¤ë¥˜ ì´ˆê¸°í™”
            this._lastError = null;
            // ëª¨ì˜ ëª¨ë“œì¸ ê²½ìš° ì„±ê³µ ë°˜í™˜
            if (this.useMock) {
                return createSuccessResult(true);
            }
            // í•„ìˆ˜ ì„¤ì • í™•ì¸
            if (!this.baseUrl) {
                throw new Error('Jira ì„œë²„ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira ì¸ì¦ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì‚¬ìš©ìž ì´ë¦„ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Token && !this.token) {
                throw new Error('Jira ì¸ì¦ í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í† í° ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            // ì´ìŠˆ ì „í™˜ì— í•„ìš”í•œ íŠ¸ëžœì§€ì…˜ ID ì¡°íšŒ
            const transitionId = await this.getTransitionIdForStatus(issueKey, status);
            if (!transitionId) {
                throw new Error(`ì´ìŠˆ ${issueKey}ì— ëŒ€í•´ ìƒíƒœ '${status}'ë¡œì˜ ì „í™˜ì´ í—ˆìš©ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.`);
            }
            // Jira REST API ì—”ë“œí¬ì¸íŠ¸
            const url = `${this.baseUrl}${this.apiPath}/issue/${issueKey}/transitions`;
            // ìš”ì²­ ë°ì´í„° êµ¬ì„±
            const requestData = {
                transition: {
                    id: transitionId
                }
            };
            // API ìš”ì²­ ì„¤ì •
            const config = {};
            // ì¸ì¦ ìœ í˜•ì— ë”°ë¥¸ ì„¤ì •
            if (this.authType === AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API ìš”ì²­ ì‹¤í–‰
            await lib_axios.post(url, requestData, config);
            return createSuccessResult(true);
        }
        catch (error) {
            // ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¶„ë¥˜
            this.handleError(error, issueKey);
            // ì˜¤ë¥˜ ë¡œê·¸
            console.error(`Jira ì´ìŠˆ ìƒíƒœ ë³€ê²½ ì‹¤íŒ¨ (${issueKey}):`, error);
            // ì˜¤ë¥˜ ê²°ê³¼ ìƒì„±
            let serviceError;
            if (this._lastError) {
                // JiraErrorë¥¼ IServiceErrorë¡œ ë³€í™˜
                serviceError = ServiceErrorManager.createError(ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = ServiceErrorManager.createError(ServiceType.Jira, ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return createErrorResult(serviceError);
        }
    }
    /**
     * Jira ì´ìŠˆ ê²€ìƒ‰
     * @param criteria ê²€ìƒ‰ ì¡°ê±´
     * @returns ê²€ìƒ‰ ê²°ê³¼ë¥¼ í¬í•¨í•œ ì„œë¹„ìŠ¤ ê²°ê³¼
     */
    async searchIssues(criteria) {
        try {
            // ë§ˆì§€ë§‰ ì˜¤ë¥˜ ì´ˆê¸°í™”
            this._lastError = null;
            // ê¸°ë³¸ê°’ ì„¤ì •
            const maxResults = criteria.maxResults || 50;
            const startAt = criteria.startAt || 0;
            // ëª¨ì˜ ëª¨ë“œì¸ ê²½ìš° ëª¨ì˜ ë°ì´í„° ë°˜í™˜
            if (this.useMock) {
                const mockResult = this.getMockSearchResult(criteria);
                return createSuccessResult(mockResult);
            }
            // í•„ìˆ˜ ì„¤ì • í™•ì¸
            if (!this.baseUrl) {
                throw new Error('Jira ì„œë²„ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira ì¸ì¦ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì‚¬ìš©ìž ì´ë¦„ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Token && !this.token) {
                throw new Error('Jira ì¸ì¦ í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í† í° ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            // JQL ê²€ìƒ‰ ì¿¼ë¦¬ êµ¬ì„±
            const jql = this.buildJqlQuery(criteria);
            // Jira REST API ì—”ë“œí¬ì¸íŠ¸
            const url = `${this.baseUrl}${this.apiPath}/search`;
            // ìš”ì²­ ë°ì´í„° êµ¬ì„±
            const requestData = {
                jql,
                startAt,
                maxResults,
                fields: [
                    'summary',
                    'description',
                    'status',
                    'assignee',
                    'reporter',
                    'created',
                    'updated',
                    'duedate',
                    'priority',
                    'labels',
                    'components',
                    'project'
                ]
            };
            // API ìš”ì²­ ì„¤ì •
            const config = {
                params: {
                    jql,
                    startAt,
                    maxResults,
                    fields: 'summary,description,status,assignee,reporter,created,updated,duedate,priority,labels,components,project'
                }
            };
            // ì¸ì¦ ìœ í˜•ì— ë”°ë¥¸ ì„¤ì •
            if (this.authType === AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API ìš”ì²­ ì‹¤í–‰
            const response = await lib_axios.get(url, config);
            // ì‘ë‹µ ë°ì´í„° íŒŒì‹±
            const data = response.data;
            const issues = (data.issues || []).map((issue) => this.parseJiraIssue(issue));
            const result = {
                issues,
                total: data.total || 0,
                startAt: data.startAt || 0,
                maxResults: data.maxResults || maxResults,
                hasMore: (data.startAt + issues.length) < data.total
            };
            return createSuccessResult(result);
        }
        catch (error) {
            // ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¶„ë¥˜
            this.handleError(error);
            // ì˜¤ë¥˜ ë¡œê·¸
            console.error('Jira ì´ìŠˆ ê²€ìƒ‰ ì‹¤íŒ¨:', error);
            // ì˜¤ë¥˜ ê²°ê³¼ ìƒì„±
            let serviceError;
            if (this._lastError) {
                // JiraErrorë¥¼ IServiceErrorë¡œ ë³€í™˜
                serviceError = ServiceErrorManager.createError(ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = ServiceErrorManager.createError(ServiceType.Jira, ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return createErrorResult(serviceError);
        }
    }
    /**
     * JQL ê²€ìƒ‰ ì¿¼ë¦¬ êµ¬ì„±
     * @param criteria ê²€ìƒ‰ ì¡°ê±´
     * @returns JQL ì¿¼ë¦¬ ë¬¸ìžì—´
     * @private
     */
    buildJqlQuery(criteria) {
        const conditions = [];
        // í”„ë¡œì íŠ¸ í•„í„°
        if (criteria.projectKey) {
            conditions.push(`project = "${criteria.projectKey}"`);
        }
        // ë‹´ë‹¹ìž í•„í„°
        if (criteria.assignee) {
            conditions.push(`assignee = "${criteria.assignee}"`);
        }
        // ë³´ê³ ìž í•„í„°
        if (criteria.reporter) {
            conditions.push(`reporter = "${criteria.reporter}"`);
        }
        // ìƒíƒœ í•„í„°
        if (criteria.status) {
            if (Array.isArray(criteria.status)) {
                if (criteria.status.length > 0) {
                    const statuses = criteria.status.map(s => `"${s}"`).join(',');
                    conditions.push(`status IN (${statuses})`);
                }
            }
            else {
                conditions.push(`status = "${criteria.status}"`);
            }
        }
        // ë¼ë²¨ í•„í„°
        if (criteria.labels && criteria.labels.length > 0) {
            const labelConditions = criteria.labels.map(label => `labels = "${label}"`).join(' AND ');
            conditions.push(`(${labelConditions})`);
        }
        // ì»´í¬ë„ŒíŠ¸ í•„í„°
        if (criteria.components && criteria.components.length > 0) {
            const componentConditions = criteria.components.map(component => `component = "${component}"`).join(' OR ');
            conditions.push(`(${componentConditions})`);
        }
        // í…ìŠ¤íŠ¸ ê²€ìƒ‰ í•„í„°
        if (criteria.text) {
            conditions.push(`(summary ~ "${criteria.text}" OR description ~ "${criteria.text}")`);
        }
        // ìƒì„±ì¼ í•„í„°
        if (criteria.createdAfter) {
            conditions.push(`created >= "${criteria.createdAfter}"`);
        }
        // ìˆ˜ì •ì¼ í•„í„°
        if (criteria.updatedAfter) {
            conditions.push(`updated >= "${criteria.updatedAfter}"`);
        }
        // ì¡°ê±´ì´ ì—†ìœ¼ë©´ ëª¨ë“  ì´ìŠˆ ê²€ìƒ‰
        if (conditions.length === 0) {
            return 'order by created DESC';
        }
        // ìµœì¢… JQL ì¿¼ë¦¬ ë°˜í™˜
        return `${conditions.join(' AND ')} order by created DESC`;
    }
    /**
     * ëª¨ì˜ ê²€ìƒ‰ ê²°ê³¼ ìƒì„±
     * @param criteria ê²€ìƒ‰ ì¡°ê±´
     * @returns ëª¨ì˜ ê²€ìƒ‰ ê²°ê³¼
     * @private
     */
    getMockSearchResult(criteria) {
        // ìµœëŒ€ ê²°ê³¼ ìˆ˜ ë° ì‹œìž‘ ìœ„ì¹˜ ì„¤ì •
        const maxResults = criteria.maxResults || 50;
        const startAt = criteria.startAt || 0;
        // ëª¨ì˜ ì´ìŠˆ ìƒì„±
        const mockIssues = [];
        const totalIssues = 100; // ëª¨ì˜ ë°ì´í„°ì˜ ì „ì²´ ì´ìŠˆ ìˆ˜
        // ì‹¤ì œë¡œ ë°˜í™˜í•  ì´ìŠˆ ìˆ˜ ê³„ì‚°
        const count = Math.min(maxResults, totalIssues - startAt);
        // í”„ë¡œì íŠ¸ í‚¤ ê°€ì ¸ì˜¤ê¸° (ê¸°ë³¸ê°’: 'APE')
        const projectKey = criteria.projectKey || 'APE';
        // ëª¨ì˜ ì´ìŠˆ ìƒì„±
        for (let i = 0; i < count; i++) {
            const issueNumber = startAt + i + 1;
            const issueKey = `${projectKey}-${issueNumber}`;
            const mockIssue = this.getMockIssue(issueKey);
            // ê²€ìƒ‰ ì¡°ê±´ì— ë”°ë¥¸ í•„í„°ë§
            let includeIssue = true;
            // ìƒíƒœ í•„í„°
            if (criteria.status) {
                if (Array.isArray(criteria.status)) {
                    includeIssue = criteria.status.includes(mockIssue.status);
                }
                else {
                    includeIssue = mockIssue.status === criteria.status;
                }
            }
            // í…ìŠ¤íŠ¸ ê²€ìƒ‰ í•„í„°
            if (includeIssue && criteria.text) {
                const text = criteria.text.toLowerCase();
                includeIssue =
                    mockIssue.summary.toLowerCase().includes(text) ||
                        (mockIssue.description?.toLowerCase().includes(text) || false);
            }
            // ì´ìŠˆê°€ í•„í„° ì¡°ê±´ì— ë¶€í•©í•˜ë©´ ê²°ê³¼ì— ì¶”ê°€
            if (includeIssue) {
                // ìš”ì²­ëœ ê²€ìƒ‰ ì¡°ê±´ì— ë§žì¶”ì–´ ì´ìŠˆ ì†ì„± ìˆ˜ì •
                if (criteria.assignee) {
                    mockIssue.assignee = {
                        name: criteria.assignee,
                        displayName: `${criteria.assignee} ì‚¬ìš©ìž`
                    };
                }
                // í”„ë¡œì íŠ¸ ì •ë³´ ì¶”ê°€
                mockIssue.project = {
                    id: '10000',
                    key: projectKey,
                    name: `${projectKey} í”„ë¡œì íŠ¸`
                };
                mockIssues.push(mockIssue);
            }
        }
        return {
            issues: mockIssues,
            total: totalIssues,
            startAt,
            maxResults,
            hasMore: (startAt + count) < totalIssues
        };
    }
    /**
     * Jira í”„ë¡œì íŠ¸ ìš”ì•½ ì¡°íšŒ
     * @param projectKey í”„ë¡œì íŠ¸ í‚¤ (ì„ íƒì , ìž…ë ¥ë˜ì§€ ì•Šìœ¼ë©´ ëª¨ë“  í”„ë¡œì íŠ¸ ìš”ì•½)
     * @param maxRecentIssues ìµœê·¼ ì´ìŠˆ ëª©ë¡ ìµœëŒ€ ìˆ˜ (ê¸°ë³¸ê°’: 5)
     * @param maxOldIssues ì˜¤ëž˜ëœ ë¯¸í•´ê²° ì´ìŠˆ ëª©ë¡ ìµœëŒ€ ìˆ˜ (ê¸°ë³¸ê°’: 5)
     * @returns Jira ìš”ì•½ ì •ë³´ë¥¼ í¬í•¨í•œ ì„œë¹„ìŠ¤ ê²°ê³¼
     */
    async getProjectSummary(projectKey, maxRecentIssues = 5, maxOldIssues = 5) {
        try {
            // ë§ˆì§€ë§‰ ì˜¤ë¥˜ ì´ˆê¸°í™”
            this._lastError = null;
            // ëª¨ì˜ ëª¨ë“œì¸ ê²½ìš° ëª¨ì˜ ë°ì´í„° ë°˜í™˜
            if (this.useMock) {
                const mockSummary = this.getMockSummary(projectKey, maxRecentIssues, maxOldIssues);
                return createSuccessResult(mockSummary);
            }
            // í•„ìˆ˜ ì„¤ì • í™•ì¸
            if (!this.baseUrl) {
                throw new Error('Jira ì„œë²„ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('Jira ì¸ì¦ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì‚¬ìš©ìž ì´ë¦„ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Token && !this.token) {
                throw new Error('Jira ì¸ì¦ í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í† í° ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            // í”„ë¡œì íŠ¸ ë‚´ ëª¨ë“  ì´ìŠˆ ì¡°íšŒ
            const searchCriteria = {
                projectKey: projectKey,
                maxResults: 1000 // ì¶©ë¶„ížˆ í° ê°’ìœ¼ë¡œ ì„¤ì •
            };
            const searchResult = await this.searchIssues(searchCriteria);
            if (!searchResult.success || !searchResult.data) {
                throw new Error('ì´ìŠˆ ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
            }
            const issues = searchResult.data.issues;
            // ì „ì²´ ì´ìŠˆ ìˆ˜
            const totalIssues = issues.length;
            // ìƒíƒœë³„ ì´ìŠˆ ìˆ˜ ê³„ì‚°
            const issuesByStatus = {
                [JiraIssueStatus.ToDo]: 0,
                [JiraIssueStatus.InProgress]: 0,
                [JiraIssueStatus.InReview]: 0,
                [JiraIssueStatus.Done]: 0,
                [JiraIssueStatus.Blocked]: 0,
                [JiraIssueStatus.Unknown]: 0
            };
            // ë‹´ë‹¹ìžë³„ ì´ìŠˆ ìˆ˜ ê³„ì‚°
            const issuesByAssignee = {};
            // ìš°ì„ ìˆœìœ„ë³„ ì´ìŠˆ ìˆ˜ ê³„ì‚°
            const issuesByPriority = {};
            // ìµœê·¼ ì´ìŠˆ ë° ì˜¤ëž˜ëœ ë¯¸í•´ê²° ì´ìŠˆ ëª©ë¡ ì¤€ë¹„
            let recentIssues = [];
            let unresolvedIssues = [];
            // ì´ìŠˆ í•´ê²° ì‹œê°„ ê³„ì‚°ì„ ìœ„í•œ ì¤€ë¹„
            let resolvedCount = 0;
            let totalResolutionTime = 0;
            // ëª¨ë“  ì´ìŠˆë¥¼ ë°˜ë³µí•˜ë©° í†µê³„ ìˆ˜ì§‘
            for (const issue of issues) {
                // ìƒíƒœë³„ ì´ìŠˆ ìˆ˜ ì—…ë°ì´íŠ¸
                const status = issue.status;
                issuesByStatus[status] = (issuesByStatus[status] || 0) + 1;
                // ë‹´ë‹¹ìžë³„ ì´ìŠˆ ìˆ˜ ì—…ë°ì´íŠ¸
                if (issue.assignee) {
                    const assigneeName = issue.assignee.displayName || issue.assignee.name;
                    issuesByAssignee[assigneeName] = (issuesByAssignee[assigneeName] || 0) + 1;
                }
                else {
                    issuesByAssignee['ë¯¸í• ë‹¹'] = (issuesByAssignee['ë¯¸í• ë‹¹'] || 0) + 1;
                }
                // ìš°ì„ ìˆœìœ„ë³„ ì´ìŠˆ ìˆ˜ ì—…ë°ì´íŠ¸
                if (issue.priority) {
                    const priorityName = issue.priority.name;
                    issuesByPriority[priorityName] = (issuesByPriority[priorityName] || 0) + 1;
                }
                else {
                    issuesByPriority['ë¯¸ì§€ì •'] = (issuesByPriority['ë¯¸ì§€ì •'] || 0) + 1;
                }
                // ë¯¸í•´ê²° ì´ìŠˆ ëª©ë¡ ì—…ë°ì´íŠ¸
                if (issue.status !== JiraIssueStatus.Done) {
                    unresolvedIssues.push(issue);
                }
                else {
                    // í•´ê²°ëœ ì´ìŠˆì˜ í•´ê²° ì‹œê°„ ê³„ì‚°
                    const created = new Date(issue.created).getTime();
                    const updated = new Date(issue.updated).getTime();
                    const resolutionTime = updated - created;
                    if (resolutionTime > 0) {
                        totalResolutionTime += resolutionTime;
                        resolvedCount++;
                    }
                }
            }
            // ìµœê·¼ ì´ìŠˆ ì •ë ¬ (ìƒì„±ì¼ ê¸°ì¤€)
            recentIssues = [...issues].sort((a, b) => new Date(b.created).getTime() - new Date(a.created).getTime()).slice(0, maxRecentIssues);
            // ì˜¤ëž˜ëœ ë¯¸í•´ê²° ì´ìŠˆ ì •ë ¬ (ìƒì„±ì¼ ê¸°ì¤€)
            const oldestUnresolvedIssues = unresolvedIssues
                .sort((a, b) => new Date(a.created).getTime() - new Date(b.created).getTime())
                .slice(0, maxOldIssues);
            // í‰ê·  í•´ê²° ì‹œê°„ ê³„ì‚° (ë°€ë¦¬ì´ˆ ë‹¨ìœ„)
            const averageResolutionTime = resolvedCount > 0 ? totalResolutionTime / resolvedCount : undefined;
            // í”„ë¡œì íŠ¸ ì™„ë£Œìœ¨ ê³„ì‚°
            const openIssues = totalIssues - (issuesByStatus[JiraIssueStatus.Done] || 0);
            const percentComplete = totalIssues > 0 ? Math.round((issuesByStatus[JiraIssueStatus.Done] || 0) * 100 / totalIssues) : 0;
            // ìš”ì•½ ì •ë³´ ë°˜í™˜
            const result = {
                totalIssues,
                issuesByStatus,
                issuesByAssignee,
                issuesByPriority,
                recentIssues,
                oldestUnresolvedIssues,
                averageResolutionTime,
                projectStats: projectKey ? {
                    projectKey,
                    totalIssues,
                    openIssues,
                    percentComplete
                } : undefined
            };
            return createSuccessResult(result);
        }
        catch (error) {
            // ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¶„ë¥˜
            this.handleError(error);
            // ì˜¤ë¥˜ ë¡œê·¸
            console.error('Jira í”„ë¡œì íŠ¸ ìš”ì•½ ì¡°íšŒ ì‹¤íŒ¨:', error);
            // ì˜¤ë¥˜ ê²°ê³¼ ìƒì„±
            let serviceError;
            if (this._lastError) {
                // JiraErrorë¥¼ IServiceErrorë¡œ ë³€í™˜
                serviceError = ServiceErrorManager.createError(ServiceType.Jira, this._lastError.type, this._lastError.message, this._lastError.details);
            }
            else {
                serviceError = ServiceErrorManager.createError(ServiceType.Jira, ServiceErrorType.Unknown, error instanceof Error ? error.message : String(error));
            }
            return createErrorResult(serviceError);
        }
    }
    /**
     * ëª¨ì˜ ìš”ì•½ ì •ë³´ ìƒì„±
     * @param projectKey í”„ë¡œì íŠ¸ í‚¤
     * @param maxRecentIssues ìµœê·¼ ì´ìŠˆ ìˆ˜
     * @param maxOldIssues ì˜¤ëž˜ëœ ë¯¸í•´ê²° ì´ìŠˆ ìˆ˜
     * @returns ëª¨ì˜ ìš”ì•½ ì •ë³´
     * @private
     */
    getMockSummary(projectKey, maxRecentIssues = 5, maxOldIssues = 5) {
        // ê¸°ë³¸ í”„ë¡œì íŠ¸ í‚¤ ì„¤ì •
        const project = projectKey || 'APE';
        // ëª¨ì˜ ì´ìŠˆ ìƒì„±
        const mockIssues = [];
        const totalIssues = 50; // ëª¨ì˜ ë°ì´í„°ì˜ ì „ì²´ ì´ìŠˆ ìˆ˜
        // ëª¨ì˜ ì´ìŠˆ ìƒì„±
        for (let i = 0; i < totalIssues; i++) {
            const issueNumber = i + 1;
            const issueKey = `${project}-${issueNumber}`;
            const mockIssue = this.getMockIssue(issueKey);
            // í”„ë¡œì íŠ¸ ì •ë³´ ì¶”ê°€
            mockIssue.project = {
                id: '10000',
                key: project,
                name: `${project} í”„ë¡œì íŠ¸`
            };
            mockIssues.push(mockIssue);
        }
        // ìƒíƒœë³„ ì´ìŠˆ ìˆ˜ ì„¤ì •
        const issuesByStatus = {
            [JiraIssueStatus.ToDo]: 15,
            [JiraIssueStatus.InProgress]: 10,
            [JiraIssueStatus.InReview]: 5,
            [JiraIssueStatus.Done]: 15,
            [JiraIssueStatus.Blocked]: 3,
            [JiraIssueStatus.Unknown]: 2
        };
        // ë‹´ë‹¹ìžë³„ ì´ìŠˆ ìˆ˜ ì„¤ì •
        const issuesByAssignee = {
            'í™ê¸¸ë™': 10,
            'ê¹€ê°œë°œ': 15,
            'ì´í…ŒìŠ¤í„°': 8,
            'ë°•ê´€ë¦¬ìž': 5,
            'ë¯¸í• ë‹¹': 12
        };
        // ìš°ì„ ìˆœìœ„ë³„ ì´ìŠˆ ìˆ˜ ì„¤ì •
        const issuesByPriority = {
            'Highest': 5,
            'High': 10,
            'Medium': 20,
            'Low': 10,
            'ë¯¸ì§€ì •': 5
        };
        // ìµœê·¼ ì´ìŠˆ ëª©ë¡ ì„¤ì •
        const recentIssues = mockIssues
            .slice(0, maxRecentIssues)
            .map(issue => {
            // ìµœê·¼ ì´ìŠˆëŠ” ìƒì„±ì¼ì„ í˜„ìž¬ ì‹œê°„ì— ê°€ê¹ê²Œ ì„¤ì •
            const now = new Date();
            const randomHours = Math.floor(Math.random() * 48); // ìµœê·¼ 48ì‹œê°„ ë‚´
            const createdDate = new Date(now.getTime() - randomHours * 60 * 60 * 1000);
            return {
                ...issue,
                created: createdDate.toISOString(),
                updated: createdDate.toISOString()
            };
        });
        // ì˜¤ëž˜ëœ ë¯¸í•´ê²° ì´ìŠˆ ëª©ë¡ ì„¤ì •
        const oldestUnresolvedIssues = mockIssues
            .filter(issue => issue.status !== JiraIssueStatus.Done)
            .slice(0, maxOldIssues)
            .map(issue => {
            // ì˜¤ëž˜ëœ ì´ìŠˆëŠ” ìƒì„±ì¼ì„ ëª‡ ê°œì›” ì „ìœ¼ë¡œ ì„¤ì •
            const now = new Date();
            const randomDays = 30 + Math.floor(Math.random() * 60); // 30-90ì¼ ì „
            const createdDate = new Date(now.getTime() - randomDays * 24 * 60 * 60 * 1000);
            return {
                ...issue,
                created: createdDate.toISOString(),
                updated: createdDate.toISOString(),
                status: [JiraIssueStatus.ToDo, JiraIssueStatus.Blocked][Math.floor(Math.random() * 2)]
            };
        });
        // í‰ê·  í•´ê²° ì‹œê°„ ì„¤ì • (3ì¼ì˜ ë°€ë¦¬ì´ˆ)
        const averageResolutionTime = 3 * 24 * 60 * 60 * 1000;
        return {
            totalIssues,
            issuesByStatus,
            issuesByAssignee,
            issuesByPriority,
            recentIssues,
            oldestUnresolvedIssues,
            averageResolutionTime,
            projectStats: projectKey ? {
                projectKey,
                totalIssues,
                openIssues: totalIssues - issuesByStatus[JiraIssueStatus.Done],
                percentComplete: Math.round(issuesByStatus[JiraIssueStatus.Done] * 100 / totalIssues)
            } : undefined
        };
    }
    /**
     * ì´ìŠˆ ìƒíƒœ ë³€ê²½ì— í•„ìš”í•œ íŠ¸ëžœì§€ì…˜ ID ê°€ì ¸ì˜¤ê¸°
     * @param issueKey Jira ì´ìŠˆ í‚¤
     * @param targetStatus ëª©í‘œ ìƒíƒœ
     * @returns íŠ¸ëžœì§€ì…˜ ID
     * @private
     */
    async getTransitionIdForStatus(issueKey, targetStatus) {
        try {
            // Jira REST API ì—”ë“œí¬ì¸íŠ¸
            const url = `${this.baseUrl}${this.apiPath}/issue/${issueKey}/transitions`;
            // API ìš”ì²­ ì„¤ì •
            const config = {};
            // ì¸ì¦ ìœ í˜•ì— ë”°ë¥¸ ì„¤ì •
            if (this.authType === AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API ìš”ì²­ ì‹¤í–‰
            const response = await lib_axios.get(url, config);
            // ì‚¬ìš© ê°€ëŠ¥í•œ íŠ¸ëžœì§€ì…˜ ì¤‘ì—ì„œ ëª©í‘œ ìƒíƒœì™€ ì¼ì¹˜í•˜ëŠ” ê²ƒ ì°¾ê¸°
            const transitions = response.data.transitions || [];
            // ìƒíƒœ ì´ë¦„ ì •ê·œí™” í•¨ìˆ˜
            const normalizeStatus = (status) => {
                return status.toLowerCase()
                    .replace(/\s+/g, '-')
                    .replace(/in\s+progress/i, 'in-progress')
                    .replace(/to\s+do/i, 'todo');
            };
            // ëª©í‘œ ìƒíƒœì™€ ì¼ì¹˜í•˜ëŠ” íŠ¸ëžœì§€ì…˜ ì°¾ê¸°
            const matchingTransition = transitions.find((t) => {
                const transitionStatus = normalizeStatus(t.to.name);
                return transitionStatus === targetStatus || transitionStatus.includes(targetStatus);
            });
            return matchingTransition ? matchingTransition.id : null;
        }
        catch (error) {
            console.error(`íŠ¸ëžœì§€ì…˜ ID ì¡°íšŒ ì‹¤íŒ¨ (${issueKey}):`, error);
            return null;
        }
    }
    /**
     * Jira API ì‘ë‹µì—ì„œ ì´ìŠˆ ì •ë³´ íŒŒì‹±
     * @param data API ì‘ë‹µ ë°ì´í„°
     * @returns íŒŒì‹±ëœ ì´ìŠˆ ì •ë³´
     * @private
     */
    parseJiraIssue(data) {
        const fields = data.fields || {};
        // ìƒíƒœ ì •ê·œí™”
        const normalizeStatus = (statusName) => {
            const lowerStatus = statusName.toLowerCase();
            if (lowerStatus.includes('todo') || lowerStatus.includes('to do') || lowerStatus.includes('open')) {
                return JiraIssueStatus.ToDo;
            }
            else if (lowerStatus.includes('progress')) {
                return JiraIssueStatus.InProgress;
            }
            else if (lowerStatus.includes('review')) {
                return JiraIssueStatus.InReview;
            }
            else if (lowerStatus.includes('done') || lowerStatus.includes('closed') || lowerStatus.includes('resolved')) {
                return JiraIssueStatus.Done;
            }
            else if (lowerStatus.includes('block')) {
                return JiraIssueStatus.Blocked;
            }
            else {
                return JiraIssueStatus.Unknown;
            }
        };
        const statusName = fields.status?.name || 'Unknown';
        const issue = {
            id: data.id,
            key: data.key,
            summary: fields.summary || '',
            description: fields.description || '',
            status: normalizeStatus(statusName),
            assignee: fields.assignee ? {
                name: fields.assignee.name,
                displayName: fields.assignee.displayName,
                email: fields.assignee.emailAddress
            } : undefined,
            reporter: fields.reporter ? {
                name: fields.reporter.name,
                displayName: fields.reporter.displayName,
                email: fields.reporter.emailAddress
            } : undefined,
            created: fields.created || '',
            updated: fields.updated || '',
            dueDate: fields.duedate,
            priority: fields.priority ? {
                id: fields.priority.id,
                name: fields.priority.name
            } : undefined,
            labels: fields.labels || [],
            components: (fields.components || []).map((c) => ({
                id: c.id,
                name: c.name
            }))
        };
        return issue;
    }
    /**
     * ëª¨ì˜ Jira ì´ìŠˆ ìƒì„±
     * @param issueKey ì´ìŠˆ í‚¤
     * @returns ëª¨ì˜ ì´ìŠˆ ë°ì´í„°
     * @private
     */
    getMockIssue(issueKey) {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const [_project, id] = issueKey.split('-');
        // ì´ìŠˆ ë²ˆí˜¸ì— ë”°ë¼ ë‹¤ë¥¸ ëª¨ì˜ ë°ì´í„° ìƒì„±
        const idNum = parseInt(id, 10) || 0;
        const mod = idNum % 5;
        let status;
        let summary;
        switch (mod) {
            case 0:
                status = JiraIssueStatus.ToDo;
                summary = 'ìƒˆë¡œìš´ ê¸°ëŠ¥ ê°œë°œ';
                break;
            case 1:
                status = JiraIssueStatus.InProgress;
                summary = 'ê¸°ì¡´ ê¸°ëŠ¥ ê°œì„ ';
                break;
            case 2:
                status = JiraIssueStatus.InReview;
                summary = 'ë²„ê·¸ ìˆ˜ì •';
                break;
            case 3:
                status = JiraIssueStatus.Done;
                summary = 'ë¬¸ì„œí™” ìž‘ì—…';
                break;
            case 4:
                status = JiraIssueStatus.Blocked;
                summary = 'ì„±ëŠ¥ ìµœì í™”';
                break;
            default:
                status = JiraIssueStatus.Unknown;
                summary = 'ê¸°íƒ€ ìž‘ì—…';
        }
        const now = new Date().toISOString();
        return {
            id: id,
            key: issueKey,
            summary: `[ëª¨ì˜ ë°ì´í„°] ${summary}`,
            description: 'ì´ê²ƒì€ ëª¨ì˜ Jira ì´ìŠˆìž…ë‹ˆë‹¤. ì‹¤ì œ Jiraì— ì—°ê²°ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.',
            status: status,
            assignee: {
                name: 'testuser',
                displayName: 'í…ŒìŠ¤íŠ¸ ì‚¬ìš©ìž'
            },
            reporter: {
                name: 'reporter',
                displayName: 'ë³´ê³ ìž'
            },
            created: now,
            updated: now,
            priority: {
                id: '3',
                name: 'Medium'
            },
            labels: ['mock', 'test'],
            components: [
                { id: '10000', name: 'UI' },
                { id: '10001', name: 'Backend' }
            ]
        };
    }
    /**
     * ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¶„ë¥˜
     * @param error ë°œìƒí•œ ì˜¤ë¥˜
     * @param resourceId ê´€ë ¨ ë¦¬ì†ŒìŠ¤ ID (ì„ íƒì )
     * @private
     */
    handleError(error, resourceId) {
        if (lib_axios.isAxiosError(error)) {
            const axiosError = error;
            if (!axiosError.response) {
                // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜
                this.setError(JiraErrorType.ConnectionFailed, `Jira ì„œë²„ ì—°ê²° ì‹¤íŒ¨: ${error.message}. ì„œë²„ URLì„ í™•ì¸í•˜ì„¸ìš”: ${this.baseUrl}`);
            }
            else {
                // HTTP ìƒíƒœ ì½”ë“œì— ë”°ë¥¸ ì˜¤ë¥˜ ë¶„ë¥˜
                const status = axiosError.response.status;
                if (status === 401 || status === 403) {
                    this.setError(JiraErrorType.AuthenticationFailed, `Jira ì¸ì¦ ì‹¤íŒ¨: ${error.message}. ì‚¬ìš©ìž ì´ë¦„ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.`);
                }
                else if (status === 404) {
                    this.setError(JiraErrorType.ResourceNotFound, `Jira ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤${resourceId ? ` (${resourceId})` : ''}: ${error.message}`);
                }
                else if (status >= 500) {
                    this.setError(JiraErrorType.ServerError, `Jira ì„œë²„ ì˜¤ë¥˜: ${error.message}. ì„œë²„ ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”.`);
                }
                else if (status === 400) {
                    this.setError(JiraErrorType.InvalidRequest, `Jira ìš”ì²­ì´ ìž˜ëª»ë˜ì—ˆìŠµë‹ˆë‹¤: ${error.message}`);
                }
                else {
                    this.setError(JiraErrorType.Unknown, `Jira ì˜¤ë¥˜: ${error.message}`);
                }
            }
        }
        else {
            // ì¼ë°˜ ì˜¤ë¥˜
            this.setError(JiraErrorType.Unknown, `Jira ì˜¤ë¥˜: ${error.message}`);
        }
    }
    /**
     * ì˜¤ë¥˜ ì„¤ì •
     * @param type ì˜¤ë¥˜ ìœ í˜•
     * @param message ì˜¤ë¥˜ ë©”ì‹œì§€
     * @param details ì¶”ê°€ ì„¸ë¶€ ì •ë³´
     * @private
     */
    setError(type, message, details) {
        this._lastError = {
            type,
            message,
            details
        };
        // ì½˜ì†”ì— ì˜¤ë¥˜ ê¸°ë¡
        console.error(`Jira ì˜¤ë¥˜ (${type}):`, message, details || '');
    }
    /**
     * ë¦¬ì†ŒìŠ¤ í•´ì œ
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}

;// ./src/core/commands/jiraCommands.ts
/**
 * Jira ê´€ë ¨ ìŠ¬ëž˜ì‹œ ëª…ë ¹ì–´ ì •ì˜
 */


/**
 * Jira ëª…ë ¹ì–´ ìƒì„±
 */
function createJiraCommands(jiraService) {
    const commands = [];
    // Jira ë©”ì¸ ëª…ë ¹ì–´
    commands.push({
        name: 'jira',
        aliases: ['j', 'ì§€ë¼', 'ì´ìŠˆ'],
        description: 'Jira ì´ìŠˆ ê´€ë ¨ ìž‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤',
        examples: ['/jira search', '/jira create', '/jira summary', '/jira status', '/ì§€ë¼ ê²€ìƒ‰'],
        category: 'utility',
        priority: 8,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand) {
                // í•˜ìœ„ ëª…ë ¹ì–´ ì—†ì´ ì‚¬ìš©ì‹œ ë„ì›€ë§ í‘œì‹œ
                const helpMessage = `
## Jira ëª…ë ¹ì–´ ë„ì›€ë§

Jira ê´€ë ¨ ìž‘ì—…ì„ ìˆ˜í–‰í•˜ê¸° ìœ„í•œ ëª…ë ¹ì–´ìž…ë‹ˆë‹¤. ë‹¤ìŒê³¼ ê°™ì€ í•˜ìœ„ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤:

- **/jira create** - ìƒˆ Jira ì´ìŠˆë¥¼ ìƒì„±í•©ë‹ˆë‹¤
- **/jira search** - Jira ì´ìŠˆë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤
- **/jira summary** - í”„ë¡œì íŠ¸ ìš”ì•½ ì •ë³´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤
- **/jira status** - Jira ì´ìŠˆì˜ ìƒíƒœë¥¼ ë³€ê²½í•©ë‹ˆë‹¤

ì‚¬ìš© ì˜ˆì‹œ: \`/jira search APE-\`, \`/jira create\`, \`/jira summary APE\`, \`/jira status APE-123 in-progress\`
        `;
                await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: helpMessage
                });
                return;
            }
            // í•˜ìœ„ ëª…ë ¹ì–´ ì²˜ë¦¬
            switch (subCommand) {
                case 'create':
                case 'ìƒì„±':
                case 'ë§Œë“¤ê¸°':
                    await handleJiraCreate(jiraService);
                    break;
                case 'search':
                case 'ê²€ìƒ‰':
                case 'ì°¾ê¸°':
                    await handleJiraSearch(jiraService, context);
                    break;
                case 'summary':
                case 'ìš”ì•½':
                case 'í†µê³„':
                    await handleJiraSummary(jiraService, context);
                    break;
                case 'status':
                case 'ìƒíƒœ':
                case 'ë³€ê²½':
                case 'update':
                    await handleJiraStatus(jiraService, context);
                    break;
                default:
                    external_vscode_.window.showErrorMessage(`ì•Œ ìˆ˜ ì—†ëŠ” Jira í•˜ìœ„ ëª…ë ¹ì–´: ${subCommand}`);
                    break;
            }
        },
        provideCompletions: (partialArgs) => {
            const parts = partialArgs.split(' ');
            // ì²« ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„± (í•˜ìœ„ ëª…ë ¹ì–´)
            if (parts.length <= 1) {
                const subCommands = ['create', 'search', 'summary', 'status', 'ìƒì„±', 'ê²€ìƒ‰', 'ìš”ì•½', 'ìƒíƒœ', 'ë³€ê²½'];
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(parts[0]?.toLowerCase() || ''));
            }
            // í•˜ìœ„ ëª…ë ¹ì–´ì— ë”°ë¥¸ ìžë™ì™„ì„±
            const subCommand = parts[0].toLowerCase();
            if (subCommand === 'search' || subCommand === 'ê²€ìƒ‰') {
                // ê²€ìƒ‰ì–´ ìžë™ì™„ì„±ì€ ì œê³µí•˜ì§€ ì•ŠìŒ
                return [];
            }
            else if (subCommand === 'summary' || subCommand === 'ìš”ì•½') {
                // í”„ë¡œì íŠ¸ í‚¤ ìžë™ì™„ì„±ì€ ì œê³µí•˜ì§€ ì•ŠìŒ (ë¬´ìˆ˜ížˆ ë§Žì„ ìˆ˜ ìžˆìŒ)
                return [];
            }
            else if (subCommand === 'status' || subCommand === 'ìƒíƒœ' || subCommand === 'ë³€ê²½') {
                // ì´ìŠˆ í‚¤ ìžë™ì™„ì„±ì€ ì œê³µí•˜ì§€ ì•ŠìŒ
                if (parts.length === 3) {
                    // ìƒíƒœ ê°’ ìžë™ì™„ì„±
                    const statusValues = ['todo', 'in-progress', 'in-review', 'done', 'blocked'];
                    return statusValues.filter(status => status.startsWith(parts[2].toLowerCase()));
                }
            }
            return [];
        }
    });
    return commands;
}
/**
 * Jira ì´ìŠˆ ìƒíƒœ ë³€ê²½ ì²˜ë¦¬
 */
async function handleJiraStatus(jiraService, context) {
    if (!jiraService) {
        external_vscode_.window.showErrorMessage('Jira ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    try {
        // ìƒíƒœ ë³€ê²½ì— í•„ìš”í•œ íŒŒë¼ë¯¸í„° í™•ì¸ (ì´ìŠˆ í‚¤ì™€ ìƒˆ ìƒíƒœ)
        const statusArgs = context?.args.slice(1) || [];
        if (statusArgs.length < 1) {
            // ì´ìŠˆ í‚¤ ìž…ë ¥ ë°›ê¸°
            const issueKey = await external_vscode_.window.showInputBox({
                prompt: 'Jira ì´ìŠˆ í‚¤ë¥¼ ìž…ë ¥í•˜ì„¸ìš”',
                placeHolder: 'ì˜ˆ: APE-123, PROJ-456 ë“±'
            });
            if (!issueKey)
                return; // ì·¨ì†Œë¨
            // ìƒíƒœê°’ ì„ íƒí•˜ê¸°
            const status = await external_vscode_.window.showQuickPick([
                { label: 'í• ì¼', value: 'todo' },
                { label: 'ì§„í–‰ì¤‘', value: 'in-progress' },
                { label: 'ê²€í† ì¤‘', value: 'in-review' },
                { label: 'ì™„ë£Œ', value: 'done' },
                { label: 'ì°¨ë‹¨ë¨', value: 'blocked' }
            ], { placeHolder: 'ë³€ê²½í•  ìƒíƒœë¥¼ ì„ íƒí•˜ì„¸ìš”' });
            if (!status)
                return; // ì·¨ì†Œë¨
            // ìƒíƒœ ë³€ê²½ ì‹¤í–‰
            return await executeStatusChange(jiraService, issueKey, status.value);
        }
        else {
            const issueKey = statusArgs[0];
            let status;
            if (statusArgs.length < 2) {
                // ìƒíƒœê°’ ì„ íƒí•˜ê¸°
                const selectedStatus = await external_vscode_.window.showQuickPick([
                    { label: 'í• ì¼', value: 'todo' },
                    { label: 'ì§„í–‰ì¤‘', value: 'in-progress' },
                    { label: 'ê²€í† ì¤‘', value: 'in-review' },
                    { label: 'ì™„ë£Œ', value: 'done' },
                    { label: 'ì°¨ë‹¨ë¨', value: 'blocked' }
                ], { placeHolder: 'ë³€ê²½í•  ìƒíƒœë¥¼ ì„ íƒí•˜ì„¸ìš”' });
                if (!selectedStatus)
                    return; // ì·¨ì†Œë¨
                status = selectedStatus.value;
            }
            else {
                status = statusArgs[1].toLowerCase();
            }
            // ìƒíƒœ ë³€ê²½ ì‹¤í–‰
            return await executeStatusChange(jiraService, issueKey, status);
        }
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`Jira ì´ìŠˆ ìƒíƒœ ë³€ê²½ ì˜¤ë¥˜: ${error instanceof Error ? error.message : String(error)}`);
        // ì±„íŒ…ì— ì˜¤ë¥˜ í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira ì´ìŠˆ ìƒíƒœ ë³€ê²½ ì˜¤ë¥˜\n\nì´ìŠˆ ìƒíƒœ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}
/**
 * ìƒíƒœ ë³€ê²½ ì‹¤í–‰ í•¨ìˆ˜
 */
async function executeStatusChange(jiraService, issueKey, statusStr) {
    // ìƒíƒœê°’ ê²€ì¦ ë° ë³€í™˜
    let status;
    // ìƒíƒœ ë¬¸ìžì—´ì„ JiraIssueStatus ì—´ê±°í˜•ìœ¼ë¡œ ë³€í™˜
    switch (statusStr.toLowerCase()) {
        case 'todo':
        case 'to-do':
        case 'to_do':
        case 'í• ì¼':
        case 'ëŒ€ê¸°':
            status = JiraIssueStatus.ToDo;
            break;
        case 'in-progress':
        case 'in_progress':
        case 'inprogress':
        case 'ì§„í–‰ì¤‘':
        case 'ì§„í–‰':
            status = JiraIssueStatus.InProgress;
            break;
        case 'in-review':
        case 'in_review':
        case 'inreview':
        case 'ê²€í† ì¤‘':
        case 'ë¦¬ë·°':
            status = JiraIssueStatus.InReview;
            break;
        case 'done':
        case 'complete':
        case 'completed':
        case 'ì™„ë£Œ':
        case 'ì¢…ë£Œ':
            status = JiraIssueStatus.Done;
            break;
        case 'blocked':
        case 'block':
        case 'ì°¨ë‹¨':
        case 'ì°¨ë‹¨ë¨':
            status = JiraIssueStatus.Blocked;
            break;
        default:
            throw new Error(`ì§€ì›ë˜ì§€ ì•ŠëŠ” ìƒíƒœê°’ìž…ë‹ˆë‹¤: ${statusStr}. ì§€ì›ë˜ëŠ” ìƒíƒœê°’: todo, in-progress, in-review, done, blocked`);
    }
    // í˜„ìž¬ ì´ìŠˆ ì •ë³´ ì¡°íšŒ
    const issueResult = await jiraService.getIssue(issueKey);
    if (!issueResult.success || !issueResult.data) {
        throw new Error(`ì´ìŠˆë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${issueKey}`);
    }
    const issue = issueResult.data;
    const currentStatus = issue.status;
    // ì´ë¯¸ ë™ì¼í•œ ìƒíƒœë©´ ë³€ê²½í•˜ì§€ ì•ŠìŒ
    if (currentStatus === status) {
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira ì´ìŠˆ ìƒíƒœ ì •ë³´\n\nì´ìŠˆ **${issueKey}** (${issue.summary})ëŠ” ì´ë¯¸ **${getStatusDisplayName(status)}** ìƒíƒœìž…ë‹ˆë‹¤.`
        });
        return;
    }
    // ìƒíƒœ ë³€ê²½ ì‹¤í–‰
    const result = await jiraService.updateIssueStatus(issueKey, status);
    if (result.success) {
        external_vscode_.window.showInformationMessage(`Jira ì´ìŠˆ ìƒíƒœê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤: ${issueKey}`);
        // ì±„íŒ…ì— ê²°ê³¼ í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira ì´ìŠˆ ìƒíƒœ ë³€ê²½ ì™„ë£Œ\n\nì´ìŠˆ **${issueKey}** (${issue.summary})ì˜ ìƒíƒœê°€ **${getStatusDisplayName(currentStatus)}**ì—ì„œ **${getStatusDisplayName(status)}**(ìœ¼)ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.`
        });
    }
    else {
        throw new Error(result.error?.message || 'ì´ìŠˆ ìƒíƒœ ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
    }
}
/**
 * ìƒíƒœ í‘œì‹œëª… ê°€ì ¸ì˜¤ê¸°
 */
function getStatusDisplayName(status) {
    switch (status) {
        case JiraIssueStatus.ToDo:
            return 'í• ì¼';
        case JiraIssueStatus.InProgress:
            return 'ì§„í–‰ì¤‘';
        case JiraIssueStatus.InReview:
            return 'ê²€í† ì¤‘';
        case JiraIssueStatus.Done:
            return 'ì™„ë£Œ';
        case JiraIssueStatus.Blocked:
            return 'ì°¨ë‹¨ë¨';
        default:
            return 'ì•Œ ìˆ˜ ì—†ìŒ';
    }
}
/**
 * Jira ì´ìŠˆ ìƒì„± ì²˜ë¦¬
 */
async function handleJiraCreate(jiraService) {
    if (!jiraService) {
        external_vscode_.window.showErrorMessage('Jira ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    try {
        // í”„ë¡œì íŠ¸ í‚¤ ìž…ë ¥ ë°›ê¸°
        const projectKey = await external_vscode_.window.showInputBox({
            prompt: 'Jira í”„ë¡œì íŠ¸ í‚¤ë¥¼ ìž…ë ¥í•˜ì„¸ìš”',
            placeHolder: 'ì˜ˆ: APE, DEV, TEST ë“±'
        });
        if (!projectKey)
            return; // ì·¨ì†Œë¨
        // ì´ìŠˆ ìœ í˜• ìž…ë ¥ ë°›ê¸°
        const issueType = await external_vscode_.window.showQuickPick(['Task', 'Bug', 'Story', 'Epic'], { placeHolder: 'ì´ìŠˆ ìœ í˜•ì„ ì„ íƒí•˜ì„¸ìš”' });
        if (!issueType)
            return; // ì·¨ì†Œë¨
        // ì´ìŠˆ ì œëª© ìž…ë ¥ ë°›ê¸°
        const summary = await external_vscode_.window.showInputBox({
            prompt: 'ì´ìŠˆ ì œëª©ì„ ìž…ë ¥í•˜ì„¸ìš”',
            placeHolder: 'ì´ìŠˆ ì œëª©'
        });
        if (!summary)
            return; // ì·¨ì†Œë¨
        // ì´ìŠˆ ì„¤ëª… ìž…ë ¥ ë°›ê¸°
        const description = await external_vscode_.window.showInputBox({
            prompt: 'ì´ìŠˆ ì„¤ëª…ì„ ìž…ë ¥í•˜ì„¸ìš” (ì„ íƒì‚¬í•­)',
            placeHolder: 'ì´ìŠˆ ì„¤ëª…'
        });
        // ì´ìŠˆ ìƒì„±
        const result = await jiraService.createIssue({
            projectKey,
            issueType,
            summary,
            description: description || ''
        });
        if (result.success && result.data) {
            external_vscode_.window.showInformationMessage(`Jira ì´ìŠˆê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤: ${result.data.key}`);
            // ì±„íŒ…ì— ê²°ê³¼ í‘œì‹œ
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `## Jira ì´ìŠˆ ìƒì„± ì™„ë£Œ\n\nì´ìŠˆ **${result.data.key}**ê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.\n\n- **ì œëª©**: ${summary}\n- **ìœ í˜•**: ${issueType}\n- **í”„ë¡œì íŠ¸**: ${projectKey}`
            });
        }
        else {
            throw new Error(result.error?.message || 'ì´ìŠˆ ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
        }
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`Jira ì´ìŠˆ ìƒì„± ì˜¤ë¥˜: ${error instanceof Error ? error.message : String(error)}`);
        // ì±„íŒ…ì— ì˜¤ë¥˜ í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira ì´ìŠˆ ìƒì„± ì˜¤ë¥˜\n\nì´ìŠˆ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}
/**
 * Jira ì´ìŠˆ ê²€ìƒ‰ ì²˜ë¦¬
 */
async function handleJiraSearch(jiraService, context) {
    if (!jiraService) {
        external_vscode_.window.showErrorMessage('Jira ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    try {
        // ê²€ìƒ‰ ì¡°ê±´ êµ¬ì„±
        const searchArgs = context?.args.slice(1) || [];
        const searchText = searchArgs.join(' ');
        // ê²€ìƒ‰ í…ìŠ¤íŠ¸ê°€ ì—†ìœ¼ë©´ ìž…ë ¥ ë°›ê¸°
        let finalSearchText = searchText;
        if (!finalSearchText) {
            finalSearchText = await external_vscode_.window.showInputBox({
                prompt: 'Jira ê²€ìƒ‰ì–´ë¥¼ ìž…ë ¥í•˜ì„¸ìš”',
                placeHolder: 'í”„ë¡œì íŠ¸ í‚¤, ì´ìŠˆ í‚¤, í…ìŠ¤íŠ¸ ë“± (ì˜ˆ: APE-123, Bug, ë¡œê·¸ì¸)'
            });
            if (!finalSearchText)
                return; // ì·¨ì†Œë¨
        }
        // ê²€ìƒ‰ ì¡°ê±´ íŒŒì‹± (ê°„ë‹¨ êµ¬í˜„)
        const searchCriteria = {};
        // í”„ë¡œì íŠ¸ í‚¤ íŒ¨í„´ í™•ì¸
        const projectKeyMatch = finalSearchText.match(/^([A-Z0-9]+-\d+|[A-Z0-9]+)$/);
        if (projectKeyMatch) {
            if (projectKeyMatch[0].includes('-')) {
                // íŠ¹ì • ì´ìŠˆ ê²€ìƒ‰
                const result = await jiraService.getIssue(projectKeyMatch[0]);
                if (result.success && result.data) {
                    // ì±„íŒ…ì— ê²°ê³¼ í‘œì‹œ
                    await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: `## Jira ì´ìŠˆ ê²€ìƒ‰ ê²°ê³¼\n\n### ${result.data.key}: ${result.data.summary}\n\n**ìƒíƒœ**: ${result.data.status}\n**ë‹´ë‹¹ìž**: ${result.data.assignee?.displayName || 'ì—†ìŒ'}\n**ë³´ê³ ìž**: ${result.data.reporter?.displayName || 'ì—†ìŒ'}\n\n${result.data.description || 'ì„¤ëª… ì—†ìŒ'}`
                    });
                    return;
                }
            }
            else {
                // í”„ë¡œì íŠ¸ ë‚´ ì´ìŠˆ ê²€ìƒ‰
                searchCriteria.projectKey = projectKeyMatch[0];
            }
        }
        else {
            // í…ìŠ¤íŠ¸ ê²€ìƒ‰
            searchCriteria.text = finalSearchText;
        }
        // ìµœëŒ€ ê²°ê³¼ ìˆ˜ ì œí•œ
        searchCriteria.maxResults = 10;
        // ê²€ìƒ‰ ì‹¤í–‰
        const result = await jiraService.searchIssues(searchCriteria);
        if (result.success && result.data) {
            if (result.data.issues.length === 0) {
                await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: `## Jira ì´ìŠˆ ê²€ìƒ‰ ê²°ê³¼\n\nê²€ìƒ‰ì–´ \`${finalSearchText}\`ì— í•´ë‹¹í•˜ëŠ” ì´ìŠˆë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
                });
                return;
            }
            // ê²°ê³¼ í¬ë§·íŒ…
            let content = `## Jira ì´ìŠˆ ê²€ìƒ‰ ê²°ê³¼\n\nê²€ìƒ‰ì–´: \`${finalSearchText}\`\n\nì´ **${result.data.total}**ê°œ ì´ìŠˆ ì¤‘ **${result.data.issues.length}**ê°œ í‘œì‹œ\n\n`;
            // ì´ìŠˆ ëª©ë¡ í‘œì‹œ
            result.data.issues.forEach(issue => {
                content += `### ${issue.key}: ${issue.summary}\n\n`;
                content += `**ìƒíƒœ**: ${issue.status} | **ë‹´ë‹¹ìž**: ${issue.assignee?.displayName || 'ì—†ìŒ'}\n\n`;
            });
            // ë” ë§Žì€ ê²°ê³¼ê°€ ìžˆëŠ” ê²½ìš° ì•ˆë‚´
            if (result.data.hasMore) {
                content += `\n> ë” ë§Žì€ ê²°ê³¼ê°€ ìžˆìŠµë‹ˆë‹¤. ê²€ìƒ‰ì–´ë¥¼ êµ¬ì²´ì ìœ¼ë¡œ ì§€ì •í•˜ê±°ë‚˜ Jira ì›¹ ì¸í„°íŽ˜ì´ìŠ¤ì—ì„œ í™•ì¸í•˜ì„¸ìš”.`;
            }
            // ì±„íŒ…ì— ê²°ê³¼ í‘œì‹œ
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content
            });
        }
        else {
            throw new Error(result.error?.message || 'ì´ìŠˆ ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
        }
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`Jira ì´ìŠˆ ê²€ìƒ‰ ì˜¤ë¥˜: ${error instanceof Error ? error.message : String(error)}`);
        // ì±„íŒ…ì— ì˜¤ë¥˜ í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira ì´ìŠˆ ê²€ìƒ‰ ì˜¤ë¥˜\n\nì´ìŠˆ ê²€ìƒ‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}
/**
 * Jira í”„ë¡œì íŠ¸ ìš”ì•½ ì²˜ë¦¬
 */
async function handleJiraSummary(jiraService, context) {
    if (!jiraService) {
        external_vscode_.window.showErrorMessage('Jira ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
        return;
    }
    try {
        // í”„ë¡œì íŠ¸ í‚¤ êµ¬ì„±
        const summaryArgs = context?.args.slice(1) || [];
        const projectKey = summaryArgs.join(' ');
        // í”„ë¡œì íŠ¸ í‚¤ê°€ ì—†ìœ¼ë©´ ìž…ë ¥ ë°›ê¸°
        let finalProjectKey = projectKey;
        if (!finalProjectKey) {
            finalProjectKey = await external_vscode_.window.showInputBox({
                prompt: 'Jira í”„ë¡œì íŠ¸ í‚¤ë¥¼ ìž…ë ¥í•˜ì„¸ìš”',
                placeHolder: 'ì˜ˆ: APE, DEV, TEST ë“±'
            });
            if (!finalProjectKey)
                return; // ì·¨ì†Œë¨
        }
        // ìš”ì•½ ì‹¤í–‰
        const result = await jiraService.getProjectSummary(finalProjectKey);
        if (result.success && result.data) {
            const summary = result.data;
            // ìƒíƒœë³„ ì´ìŠˆ ë¶„í¬ í¬ë§·íŒ…
            let statusDistribution = '';
            for (const [status, count] of Object.entries(summary.issuesByStatus)) {
                statusDistribution += `- **${status}**: ${count}ê°œ\n`;
            }
            // ë‹´ë‹¹ìžë³„ ì´ìŠˆ ë¶„í¬ í¬ë§·íŒ…
            let assigneeDistribution = '';
            for (const [assignee, count] of Object.entries(summary.issuesByAssignee)) {
                assigneeDistribution += `- **${assignee || 'ë¯¸í• ë‹¹'}**: ${count}ê°œ\n`;
            }
            // ìš°ì„ ìˆœìœ„ë³„ ì´ìŠˆ ë¶„í¬ í¬ë§·íŒ…
            let priorityDistribution = '';
            for (const [priority, count] of Object.entries(summary.issuesByPriority)) {
                priorityDistribution += `- **${priority || 'ë¯¸ì§€ì •'}**: ${count}ê°œ\n`;
            }
            // ìµœê·¼ ì´ìŠˆ ëª©ë¡ í¬ë§·íŒ…
            let recentIssues = '';
            summary.recentIssues.forEach(issue => {
                recentIssues += `- **${issue.key}**: ${issue.summary} (${issue.status})\n`;
            });
            // ë¯¸í•´ê²° ìƒíƒœì˜ ì˜¤ëž˜ëœ ì´ìŠˆ í¬ë§·íŒ…
            let oldestUnresolvedIssues = '';
            summary.oldestUnresolvedIssues.forEach(issue => {
                oldestUnresolvedIssues += `- **${issue.key}**: ${issue.summary} (${issue.status}, ìƒì„±: ${issue.created?.split('T')[0] || 'ë‚ ì§œ ë¯¸ìƒ'})\n`;
            });
            // ê²°ê³¼ ë‚´ìš© êµ¬ì„±
            let content = `## Jira í”„ë¡œì íŠ¸ ìš”ì•½: ${finalProjectKey}\n\n`;
            if (summary.projectStats) {
                content += `### í”„ë¡œì íŠ¸ í†µê³„\n\n`;
                content += `- **ì´ ì´ìŠˆ ìˆ˜**: ${summary.projectStats.totalIssues}ê°œ\n`;
                content += `- **ì—´ë¦° ì´ìŠˆ ìˆ˜**: ${summary.projectStats.openIssues}ê°œ\n`;
                content += `- **ì™„ë£Œìœ¨**: ${summary.projectStats.percentComplete.toFixed(1)}%\n\n`;
            }
            content += `### ìƒíƒœë³„ ì´ìŠˆ ë¶„í¬\n\n${statusDistribution}\n`;
            content += `### ë‹´ë‹¹ìžë³„ ì´ìŠˆ ë¶„í¬\n\n${assigneeDistribution}\n`;
            content += `### ìš°ì„ ìˆœìœ„ë³„ ì´ìŠˆ ë¶„í¬\n\n${priorityDistribution}\n`;
            if (recentIssues) {
                content += `### ìµœê·¼ ì´ìŠˆ\n\n${recentIssues}\n`;
            }
            if (oldestUnresolvedIssues) {
                content += `### ë¯¸í•´ê²° ìƒíƒœì˜ ì˜¤ëž˜ëœ ì´ìŠˆ\n\n${oldestUnresolvedIssues}\n`;
            }
            if (summary.averageResolutionTime !== undefined) {
                content += `### ì„±ëŠ¥ ì§€í‘œ\n\n`;
                content += `- **í‰ê·  í•´ê²° ì‹œê°„**: ${Math.round(summary.averageResolutionTime / 24)}ì¼\n`;
            }
            // ì±„íŒ…ì— ê²°ê³¼ í‘œì‹œ
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content
            });
        }
        else {
            throw new Error(result.error?.message || 'í”„ë¡œì íŠ¸ ìš”ì•½ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
        }
    }
    catch (error) {
        external_vscode_.window.showErrorMessage(`Jira í”„ë¡œì íŠ¸ ìš”ì•½ ì˜¤ë¥˜: ${error instanceof Error ? error.message : String(error)}`);
        // ì±„íŒ…ì— ì˜¤ë¥˜ í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## Jira í”„ë¡œì íŠ¸ ìš”ì•½ ì˜¤ë¥˜\n\ní”„ë¡œì íŠ¸ ìš”ì•½ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`
        });
    }
}

;// ./src/types/todo.ts
/**
 * TODO ì‹œìŠ¤í…œ íƒ€ìž… ì •ì˜
 *
 * APE í™•ìž¥ì˜ í•  ì¼ ê´€ë¦¬ ê¸°ëŠ¥ì— í•„ìš”í•œ íƒ€ìž…ê³¼ ì¸í„°íŽ˜ì´ìŠ¤ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 */
/**
 * í•  ì¼ ìš°ì„ ìˆœìœ„ ì—´ê±°í˜•
 */
var TodoPriority;
(function (TodoPriority) {
    TodoPriority["HIGH"] = "high";
    TodoPriority["MEDIUM"] = "medium";
    TodoPriority["LOW"] = "low";
})(TodoPriority || (TodoPriority = {}));
/**
 * í•  ì¼ ìƒíƒœ ì—´ê±°í˜•
 */
var TodoStatus;
(function (TodoStatus) {
    TodoStatus["PENDING"] = "pending";
    TodoStatus["IN_PROGRESS"] = "in-progress";
    TodoStatus["COMPLETED"] = "completed";
    TodoStatus["CANCELLED"] = "cancelled";
})(TodoStatus || (TodoStatus = {}));
/**
 * í•  ì¼ ì •ë ¬ ê¸°ì¤€ ì—´ê±°í˜•
 */
var TodoSortBy;
(function (TodoSortBy) {
    TodoSortBy["PRIORITY"] = "priority";
    TodoSortBy["DUE_DATE"] = "dueDate";
    TodoSortBy["CREATED_AT"] = "createdAt";
    TodoSortBy["UPDATED_AT"] = "updatedAt";
    TodoSortBy["STATUS"] = "status";
    TodoSortBy["TITLE"] = "title";
})(TodoSortBy || (TodoSortBy = {}));
/**
 * ì •ë ¬ ë°©í–¥ ì—´ê±°í˜•
 */
var SortDirection;
(function (SortDirection) {
    SortDirection["ASC"] = "asc";
    SortDirection["DESC"] = "desc";
})(SortDirection || (SortDirection = {}));

;// ./src/core/commands/todoCommands.ts
/**
 * Todo ìŠ¬ëž˜ì‹œ ì»¤ë§¨ë“œ ì •ì˜
 */


/**
 * Todo ëª…ë ¹ì–´ ìƒì„±
 */
function createTodoCommands(todoService) {
    if (!todoService) {
        return [];
    }
    const commands = [];
    // todo ëª…ë ¹ì–´: í•  ì¼ ê´€ë¦¬ ê¸°ëŠ¥ ì œê³µ
    commands.push({
        name: 'todo',
        aliases: ['todos', 'task', 'tasks', 'í• ì¼', 'íˆ¬ë‘', 'íƒœìŠ¤í¬', 'ìž‘ì—…'],
        description: 'í•  ì¼ í•­ëª©ì„ ê´€ë¦¬í•©ë‹ˆë‹¤ (ì¶”ê°€, ëª©ë¡, ë³€ê²½, ì‚­ì œ)',
        examples: [
            '/todo list',
            '/todo add ìƒˆ ìž‘ì—… ì¶”ê°€',
            '/todo update ìž‘ì—…ID ìˆ˜ì •í• ë‚´ìš©',
            '/todo status ìž‘ì—…ID completed',
            '/todo priority ìž‘ì—…ID high',
            '/todo delete ìž‘ì—…ID'
        ],
        category: 'utility',
        priority: 6,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand || subCommand === 'list' || subCommand === 'ëª©ë¡') {
                // í•  ì¼ ëª©ë¡ í‘œì‹œ
                await listTodos(todoService);
            }
            else if (subCommand === 'add' || subCommand === 'ì¶”ê°€' || subCommand === 'ìƒì„±') {
                // í•  ì¼ ì¶”ê°€
                const title = context.args.slice(1).join(' ');
                if (title) {
                    await addTodo(todoService, title);
                }
                else {
                    external_vscode_.window.showErrorMessage('ì¶”ê°€í•  í•  ì¼ ì œëª©ì„ ìž…ë ¥í•´ì£¼ì„¸ìš”');
                }
            }
            else if (subCommand === 'update' || subCommand === 'ìˆ˜ì •' || subCommand === 'ë³€ê²½') {
                // í•  ì¼ ìˆ˜ì •
                const todoId = context.args[1];
                const updateContent = context.args.slice(2).join(' ');
                if (!todoId) {
                    external_vscode_.window.showErrorMessage('ìˆ˜ì •í•  í•  ì¼ IDë¥¼ ì§€ì •í•´ì£¼ì„¸ìš”');
                    return;
                }
                if (!updateContent) {
                    external_vscode_.window.showErrorMessage('ìˆ˜ì •í•  ë‚´ìš©ì„ ìž…ë ¥í•´ì£¼ì„¸ìš”');
                    return;
                }
                await updateTodo(todoService, todoId, updateContent);
            }
            else if (subCommand === 'status' || subCommand === 'ìƒíƒœ') {
                // í•  ì¼ ìƒíƒœ ë³€ê²½
                const todoId = context.args[1];
                const statusStr = context.args[2]?.toLowerCase();
                if (!todoId) {
                    external_vscode_.window.showErrorMessage('ìƒíƒœë¥¼ ë³€ê²½í•  í•  ì¼ IDë¥¼ ì§€ì •í•´ì£¼ì„¸ìš”');
                    return;
                }
                if (!statusStr) {
                    external_vscode_.window.showErrorMessage('ë³€ê²½í•  ìƒíƒœë¥¼ ì§€ì •í•´ì£¼ì„¸ìš” (pending, in-progress, completed, cancelled)');
                    return;
                }
                await changeTodoStatus(todoService, todoId, statusStr);
            }
            else if (subCommand === 'priority' || subCommand === 'ìš°ì„ ìˆœìœ„') {
                // í•  ì¼ ìš°ì„ ìˆœìœ„ ë³€ê²½
                const todoId = context.args[1];
                const priorityStr = context.args[2]?.toLowerCase();
                if (!todoId) {
                    external_vscode_.window.showErrorMessage('ìš°ì„ ìˆœìœ„ë¥¼ ë³€ê²½í•  í•  ì¼ IDë¥¼ ì§€ì •í•´ì£¼ì„¸ìš”');
                    return;
                }
                if (!priorityStr) {
                    external_vscode_.window.showErrorMessage('ë³€ê²½í•  ìš°ì„ ìˆœìœ„ë¥¼ ì§€ì •í•´ì£¼ì„¸ìš” (high, medium, low)');
                    return;
                }
                await changeTodoPriority(todoService, todoId, priorityStr);
            }
            else if (subCommand === 'delete' || subCommand === 'ì‚­ì œ') {
                // í•  ì¼ ì‚­ì œ
                const todoId = context.args[1];
                if (!todoId) {
                    external_vscode_.window.showErrorMessage('ì‚­ì œí•  í•  ì¼ IDë¥¼ ì§€ì •í•´ì£¼ì„¸ìš”');
                    return;
                }
                await deleteTodo(todoService, todoId);
            }
            else if (subCommand === 'clear' || subCommand === 'ëª¨ë‘ì‚­ì œ' || subCommand === 'ì´ˆê¸°í™”') {
                // ëª¨ë“  í•  ì¼ í•­ëª© ì‚­ì œ
                await clearAllTodos(todoService);
            }
            else {
                external_vscode_.window.showErrorMessage(`ì•Œ ìˆ˜ ì—†ëŠ” í•  ì¼ í•˜ìœ„ ëª…ë ¹ì–´ìž…ë‹ˆë‹¤: ${subCommand}`);
            }
        },
        provideCompletions: (partialArgs) => {
            const subCommands = [
                'list', 'add', 'update', 'status', 'priority', 'delete', 'clear',
                'ëª©ë¡', 'ì¶”ê°€', 'ìˆ˜ì •', 'ìƒíƒœ', 'ìš°ì„ ìˆœìœ„', 'ì‚­ì œ', 'ì´ˆê¸°í™”'
            ];
            const parts = partialArgs.split(' ');
            // ì²« ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„± (í•˜ìœ„ ëª…ë ¹ì–´)
            if (parts.length <= 1) {
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(parts[0]?.toLowerCase() || ''));
            }
            // ì„¸ ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„± (ìƒíƒœë‚˜ ìš°ì„ ìˆœìœ„ ê°’)
            if (parts.length === 3) {
                const subCommand = parts[0].toLowerCase();
                if (subCommand === 'status' || subCommand === 'ìƒíƒœ') {
                    const statusValues = ['pending', 'in-progress', 'completed', 'cancelled', 'ëŒ€ê¸°ì¤‘', 'ì§„í–‰ì¤‘', 'ì™„ë£Œ', 'ì·¨ì†Œ'];
                    return statusValues.filter(status => status.toLowerCase().startsWith(parts[2].toLowerCase() || ''));
                }
                else if (subCommand === 'priority' || subCommand === 'ìš°ì„ ìˆœìœ„') {
                    const priorityValues = ['high', 'medium', 'low', 'ë†’ìŒ', 'ì¤‘ê°„', 'ë‚®ìŒ'];
                    return priorityValues.filter(priority => priority.toLowerCase().startsWith(parts[2].toLowerCase() || ''));
                }
            }
            return [];
        }
    });
    return commands;
}
/**
 * í•  ì¼ ëª©ë¡ í‘œì‹œ
 */
async function listTodos(todoService) {
    try {
        const todoList = todoService.getTodoList();
        if (todoList.items.length === 0) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: 'ë“±ë¡ëœ í•  ì¼ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤. `/todo add ì œëª©`ìœ¼ë¡œ ìƒˆ í•  ì¼ì„ ì¶”ê°€í•˜ì„¸ìš”.'
            });
            return;
        }
        let content = `## í•  ì¼ ëª©ë¡\n\n`;
        content += `- **ì§„í–‰ ì¤‘**: ${todoList.pendingCount}ê°œ\n`;
        content += `- **ì™„ë£Œ**: ${todoList.completedCount}ê°œ\n\n`;
        // ìƒíƒœë³„ë¡œ ê·¸ë£¹í™”
        const pending = todoList.items.filter(item => item.status === TodoStatus.PENDING);
        const inProgress = todoList.items.filter(item => item.status === TodoStatus.IN_PROGRESS);
        const completed = todoList.items.filter(item => item.status === TodoStatus.COMPLETED);
        const cancelled = todoList.items.filter(item => item.status === TodoStatus.CANCELLED);
        // ìš°ì„ ìˆœìœ„ í‘œì‹œ í•¨ìˆ˜
        const getPriorityIcon = (priority) => {
            switch (priority) {
                case TodoPriority.HIGH: return 'ðŸ”´';
                case TodoPriority.MEDIUM: return 'ðŸŸ¡';
                case TodoPriority.LOW: return 'ðŸŸ¢';
                default: return '';
            }
        };
        // ëŒ€ê¸° ì¤‘ì¸ í•­ëª©
        if (pending.length > 0) {
            content += `### â³ ëŒ€ê¸° ì¤‘\n\n`;
            pending.forEach(item => {
                content += `- ${getPriorityIcon(item.priority)} **${item.title}** (ID: \`${item.id}\`)`;
                if (item.description) {
                    content += ` - ${item.description}`;
                }
                content += '\n';
            });
            content += '\n';
        }
        // ì§„í–‰ ì¤‘ì¸ í•­ëª©
        if (inProgress.length > 0) {
            content += `### â–¶ï¸ ì§„í–‰ ì¤‘\n\n`;
            inProgress.forEach(item => {
                content += `- ${getPriorityIcon(item.priority)} **${item.title}** (ID: \`${item.id}\`)`;
                if (item.description) {
                    content += ` - ${item.description}`;
                }
                content += '\n';
            });
            content += '\n';
        }
        // ì™„ë£Œëœ í•­ëª©
        if (completed.length > 0) {
            content += `### âœ… ì™„ë£Œë¨\n\n`;
            completed.forEach(item => {
                content += `- ${getPriorityIcon(item.priority)} **${item.title}** (ID: \`${item.id}\`)`;
                if (item.description) {
                    content += ` - ${item.description}`;
                }
                if (item.completedAt) {
                    content += ` (ì™„ë£Œ: ${todoCommands_formatDate(item.completedAt)})`;
                }
                content += '\n';
            });
            content += '\n';
        }
        // ì·¨ì†Œëœ í•­ëª©
        if (cancelled.length > 0) {
            content += `### âŒ ì·¨ì†Œë¨\n\n`;
            cancelled.forEach(item => {
                content += `- ${getPriorityIcon(item.priority)} **${item.title}** (ID: \`${item.id}\`)`;
                if (item.description) {
                    content += ` - ${item.description}`;
                }
                content += '\n';
            });
            content += '\n';
        }
        content += '\n**í•  ì¼ ê´€ë¦¬ ëª…ë ¹ì–´**:\n';
        content += '- `/todo add ì œëª©` - ìƒˆ í•  ì¼ ì¶”ê°€\n';
        content += '- `/todo status ID ìƒíƒœ` - ìƒíƒœ ë³€ê²½ (pending, in-progress, completed, cancelled)\n';
        content += '- `/todo priority ID ìš°ì„ ìˆœìœ„` - ìš°ì„ ìˆœìœ„ ë³€ê²½ (high, medium, low)\n';
        content += '- `/todo update ID ìƒˆë‚´ìš©` - í•  ì¼ ë‚´ìš© ìˆ˜ì •\n';
        content += '- `/todo delete ID` - í•  ì¼ ì‚­ì œ\n';
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content
        });
    }
    catch (error) {
        console.error('í•  ì¼ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        external_vscode_.window.showErrorMessage(`í•  ì¼ ëª©ë¡ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * í•  ì¼ ì¶”ê°€
 */
async function addTodo(todoService, title) {
    try {
        // ì„¤ëª… ìž…ë ¥ ë°›ê¸° (ì„ íƒì‚¬í•­)
        const description = await external_vscode_.window.showInputBox({
            prompt: 'í•  ì¼ ì„¤ëª…ì„ ìž…ë ¥í•˜ì„¸ìš” (ì„ íƒì‚¬í•­)',
            placeHolder: 'ì„¸ë¶€ ë‚´ìš© ë˜ëŠ” ì„¤ëª…'
        });
        // ìš°ì„ ìˆœìœ„ ì„ íƒ (ê¸°ë³¸ê°’: ì¤‘ê°„)
        const priorities = [
            { label: 'ë†’ìŒ', value: TodoPriority.HIGH },
            { label: 'ì¤‘ê°„', value: TodoPriority.MEDIUM, picked: true },
            { label: 'ë‚®ìŒ', value: TodoPriority.LOW }
        ];
        const selectedPriority = await external_vscode_.window.showQuickPick(priorities.map(p => p.label), { placeHolder: 'ìš°ì„ ìˆœìœ„ë¥¼ ì„ íƒí•˜ì„¸ìš”', canPickMany: false });
        if (!selectedPriority) {
            return; // ì·¨ì†Œë¨
        }
        const priority = priorities.find(p => p.label === selectedPriority)?.value || TodoPriority.MEDIUM;
        // í•  ì¼ ì¶”ê°€
        const newTodo = todoService.addTodoItem({
            title,
            description,
            priority
        });
        // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `ìƒˆ í•  ì¼ "${title}"ì´(ê°€) ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤. (ID: \`${newTodo.id}\`, ìš°ì„ ìˆœìœ„: ${getPriorityLabel(priority)})`
        });
    }
    catch (error) {
        console.error('í•  ì¼ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        external_vscode_.window.showErrorMessage(`í•  ì¼ ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * í•  ì¼ ìˆ˜ì •
 */
async function updateTodo(todoService, todoId, newTitle) {
    try {
        // í•  ì¼ í™•ì¸
        const todo = todoService.getTodoItem(todoId);
        if (!todo) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `IDê°€ \`${todoId}\`ì¸ í•  ì¼ í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // í•  ì¼ ì œëª© ìˆ˜ì •
        todoService.updateTodoItem(todoId, { title: newTitle });
        // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `í•  ì¼ ë‚´ìš©ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.\n- ì´ì „: "${todo.title}"\n- ë³€ê²½: "${newTitle}"`
        });
    }
    catch (error) {
        console.error('í•  ì¼ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        external_vscode_.window.showErrorMessage(`í•  ì¼ ìˆ˜ì • ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * í•  ì¼ ìƒíƒœ ë³€ê²½
 */
async function changeTodoStatus(todoService, todoId, statusStr) {
    try {
        // í•  ì¼ í™•ì¸
        const todo = todoService.getTodoItem(todoId);
        if (!todo) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `IDê°€ \`${todoId}\`ì¸ í•  ì¼ í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // ìƒíƒœ ë¬¸ìžì—´ì„ ì—´ê±°í˜•ìœ¼ë¡œ ë³€í™˜
        let status;
        switch (statusStr.toLowerCase()) {
            case 'pending':
            case 'wait':
            case 'ëŒ€ê¸°':
            case 'ëŒ€ê¸°ì¤‘':
                status = TodoStatus.PENDING;
                break;
            case 'in-progress':
            case 'progress':
            case 'doing':
            case 'ì§„í–‰':
            case 'ì§„í–‰ì¤‘':
                status = TodoStatus.IN_PROGRESS;
                break;
            case 'completed':
            case 'complete':
            case 'done':
            case 'ì™„ë£Œ':
            case 'ì™„ë£Œë¨':
                status = TodoStatus.COMPLETED;
                break;
            case 'cancelled':
            case 'cancel':
            case 'ì·¨ì†Œ':
            case 'ì·¨ì†Œë¨':
                status = TodoStatus.CANCELLED;
                break;
            default:
                await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: `ì§€ì›í•˜ì§€ ì•ŠëŠ” ìƒíƒœìž…ë‹ˆë‹¤: ${statusStr}. ì§€ì›ë˜ëŠ” ìƒíƒœ: pending, in-progress, completed, cancelled`
                });
                return;
        }
        // ì´ë¯¸ ë™ì¼í•œ ìƒíƒœì¸ ê²½ìš°
        if (todo.status === status) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `í•  ì¼ "${todo.title}"ì€(ëŠ”) ì´ë¯¸ ${getStatusLabel(status)} ìƒíƒœìž…ë‹ˆë‹¤.`
            });
            return;
        }
        // í•  ì¼ ìƒíƒœ ë³€ê²½
        todoService.changeTodoStatus(todoId, status);
        // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `í•  ì¼ "${todo.title}"ì˜ ìƒíƒœê°€ ${getStatusLabel(todo.status)}ì—ì„œ ${getStatusLabel(status)}(ìœ¼)ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.`
        });
    }
    catch (error) {
        console.error('í•  ì¼ ìƒíƒœ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        external_vscode_.window.showErrorMessage(`í•  ì¼ ìƒíƒœ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * í•  ì¼ ìš°ì„ ìˆœìœ„ ë³€ê²½
 */
async function changeTodoPriority(todoService, todoId, priorityStr) {
    try {
        // í•  ì¼ í™•ì¸
        const todo = todoService.getTodoItem(todoId);
        if (!todo) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `IDê°€ \`${todoId}\`ì¸ í•  ì¼ í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // ìš°ì„ ìˆœìœ„ ë¬¸ìžì—´ì„ ì—´ê±°í˜•ìœ¼ë¡œ ë³€í™˜
        let priority;
        switch (priorityStr.toLowerCase()) {
            case 'high':
            case 'ë†’ìŒ':
            case 'ë†’ì€':
            case 'urgent':
            case 'ê¸´ê¸‰':
                priority = TodoPriority.HIGH;
                break;
            case 'medium':
            case 'mid':
            case 'normal':
            case 'ì¤‘ê°„':
            case 'ë³´í†µ':
                priority = TodoPriority.MEDIUM;
                break;
            case 'low':
            case 'ë‚®ìŒ':
            case 'ë‚®ì€':
                priority = TodoPriority.LOW;
                break;
            default:
                await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: `ì§€ì›í•˜ì§€ ì•ŠëŠ” ìš°ì„ ìˆœìœ„ìž…ë‹ˆë‹¤: ${priorityStr}. ì§€ì›ë˜ëŠ” ìš°ì„ ìˆœìœ„: high, medium, low`
                });
                return;
        }
        // ì´ë¯¸ ë™ì¼í•œ ìš°ì„ ìˆœìœ„ì¸ ê²½ìš°
        if (todo.priority === priority) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `í•  ì¼ "${todo.title}"ì€(ëŠ”) ì´ë¯¸ ${getPriorityLabel(priority)} ìš°ì„ ìˆœìœ„ìž…ë‹ˆë‹¤.`
            });
            return;
        }
        // í•  ì¼ ìš°ì„ ìˆœìœ„ ë³€ê²½
        todoService.changeTodoPriority(todoId, priority);
        // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `í•  ì¼ "${todo.title}"ì˜ ìš°ì„ ìˆœìœ„ê°€ ${getPriorityLabel(todo.priority)}ì—ì„œ ${getPriorityLabel(priority)}(ìœ¼)ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.`
        });
    }
    catch (error) {
        console.error('í•  ì¼ ìš°ì„ ìˆœìœ„ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        external_vscode_.window.showErrorMessage(`í•  ì¼ ìš°ì„ ìˆœìœ„ ë³€ê²½ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * í•  ì¼ ì‚­ì œ
 */
async function deleteTodo(todoService, todoId) {
    try {
        // í•  ì¼ í™•ì¸
        const todo = todoService.getTodoItem(todoId);
        if (!todo) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `IDê°€ \`${todoId}\`ì¸ í•  ì¼ í•­ëª©ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // ì‚­ì œ í™•ì¸
        const confirmation = await external_vscode_.window.showWarningMessage(`í•  ì¼ "${todo.title}"ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`, { modal: true }, 'ì‚­ì œ', 'ì·¨ì†Œ');
        if (confirmation !== 'ì‚­ì œ') {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `í•  ì¼ ì‚­ì œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // í•  ì¼ ì‚­ì œ
        const deleted = todoService.deleteTodoItem(todoId);
        // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
        if (deleted) {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `í•  ì¼ "${todo.title}"ì´(ê°€) ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`
            });
        }
        else {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `í•  ì¼ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.`
            });
        }
    }
    catch (error) {
        console.error('í•  ì¼ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        external_vscode_.window.showErrorMessage(`í•  ì¼ ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * ëª¨ë“  í•  ì¼ ì‚­ì œ
 */
async function clearAllTodos(todoService) {
    try {
        // ì‚­ì œ í™•ì¸
        const confirmation = await external_vscode_.window.showWarningMessage('ëª¨ë“  í•  ì¼ í•­ëª©ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ? ì´ ìž‘ì—…ì€ ë˜ëŒë¦´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.', { modal: true }, 'ì‚­ì œ', 'ì·¨ì†Œ');
        if (confirmation !== 'ì‚­ì œ') {
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `í•  ì¼ ì´ˆê¸°í™”ê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // ëª¨ë“  í•  ì¼ ì‚­ì œ
        todoService.clearAllTodos();
        // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `ëª¨ë“  í•  ì¼ í•­ëª©ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.`
        });
    }
    catch (error) {
        console.error('í•  ì¼ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
        external_vscode_.window.showErrorMessage(`í•  ì¼ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * ìš°ì„ ìˆœìœ„ ë¼ë²¨ ê°€ì ¸ì˜¤ê¸°
 */
function getPriorityLabel(priority) {
    switch (priority) {
        case TodoPriority.HIGH: return 'ë†’ìŒ';
        case TodoPriority.MEDIUM: return 'ì¤‘ê°„';
        case TodoPriority.LOW: return 'ë‚®ìŒ';
        default: return String(priority);
    }
}
/**
 * ìƒíƒœ ë¼ë²¨ ê°€ì ¸ì˜¤ê¸°
 */
function getStatusLabel(status) {
    switch (status) {
        case TodoStatus.PENDING: return 'ëŒ€ê¸°ì¤‘';
        case TodoStatus.IN_PROGRESS: return 'ì§„í–‰ì¤‘';
        case TodoStatus.COMPLETED: return 'ì™„ë£Œë¨';
        case TodoStatus.CANCELLED: return 'ì·¨ì†Œë¨';
        default: return String(status);
    }
}
/**
 * ë‚ ì§œ í¬ë§·íŒ…
 */
function todoCommands_formatDate(date) {
    if (!date)
        return '';
    const d = typeof date === 'string' ? new Date(date) : date;
    return d.toLocaleDateString();
}

;// ./src/core/commands/defaultCommands.ts
/**
 * ê¸°ë³¸ ìŠ¬ëž˜ì‹œ ì»¤ë§¨ë“œ ì •ì˜
 */









/**
 * ê¸°ë³¸ ìŠ¬ëž˜ì‹œ ì»¤ë§¨ë“œ ëª©ë¡ ìƒì„±
 */
function createDefaultCommands(services) {
    const commands = [];
    // VAULT ëª…ë ¹ì–´ ì¶”ê°€ (VAULT ì„œë¹„ìŠ¤ê°€ ìžˆëŠ” ê²½ìš°)
    if (services?.vaultService) {
        const vaultCommands = createVaultCommands(services.vaultService);
        commands.push(...vaultCommands);
    }
    // Rules ëª…ë ¹ì–´ ì¶”ê°€ (Rules ì„œë¹„ìŠ¤ê°€ ìžˆëŠ” ê²½ìš°)
    if (services?.rulesService) {
        const rulesCommands = createRulesCommands(services.rulesService);
        commands.push(...rulesCommands);
    }
    // Jira ëª…ë ¹ì–´ ì¶”ê°€ (Jira ì„œë¹„ìŠ¤ê°€ ìžˆëŠ” ê²½ìš°)
    if (services?.jiraService) {
        const jiraCommands = createJiraCommands(services.jiraService);
        commands.push(...jiraCommands);
    }
    // Todo ëª…ë ¹ì–´ ì¶”ê°€ (Todo ì„œë¹„ìŠ¤ê°€ ìžˆëŠ” ê²½ìš°)
    if (services?.todoService) {
        const todoCommands = createTodoCommands(services.todoService);
        commands.push(...todoCommands);
    }
    // ë„ì›€ë§ ëª…ë ¹ì–´
    commands.push({
        name: 'help',
        aliases: ['?', 'commands', 'ë„ì›€ë§', 'ë„ì›€', 'ëª…ë ¹ì–´', 'ì•Œë ¤ì¤˜', 'search', 'ê²€ìƒ‰'],
        description: 'ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´ ëª©ë¡ê³¼ ë„ì›€ë§ì„ í‘œì‹œí•©ë‹ˆë‹¤',
        examples: ['/help', '/help git', '/help search ì»¤ë°‹ ë°©ë²•', '/ë„ì›€ë§', '/ë„ì›€ë§ ê²€ìƒ‰ íŒŒì¼ ì—´ê¸°'],
        category: 'general',
        priority: 1,
        execute: async (context) => {
            // ë„ì›€ë§ í‘œì‹œ ëª…ë ¹ì€ SlashCommandManagerì—ì„œ ì²˜ë¦¬
            const firstArg = context.args[0]?.toLowerCase();
            if (firstArg === 'search' || firstArg === 'ê²€ìƒ‰' || firstArg === 'find' || firstArg === 'ì°¾ê¸°') {
                // ê²€ìƒ‰ ëª¨ë“œ: ìžì—°ì–´ ê²€ìƒ‰ìœ¼ë¡œ ì²˜ë¦¬
                const searchQuery = context.args.slice(1).join(' ');
                if (searchQuery) {
                    await external_vscode_.commands.executeCommand('ape.showCommandHelp', `search ${searchQuery}`);
                }
                else {
                    external_vscode_.window.showErrorMessage('ê²€ìƒ‰ì–´ë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”');
                }
            }
            else if (firstArg === 'faq' || firstArg === 'ìžì£¼ë¬»ëŠ”ì§ˆë¬¸') {
                // FAQ ëª¨ë“œ
                await external_vscode_.commands.executeCommand('ape.showCommandHelp', 'faq');
            }
            else if (firstArg === 'guide' || firstArg === 'guides' || firstArg === 'ê°€ì´ë“œ' || firstArg === 'ê°€ì´ë“œëª©ë¡') {
                // ê°€ì´ë“œ ëª©ë¡ ëª¨ë“œ
                if (context.args.length > 1) {
                    // íŠ¹ì • ê°€ì´ë“œ ì„ íƒ
                    const guideId = context.args[1];
                    await external_vscode_.commands.executeCommand('ape.showCommandHelp', `guide ${guideId}`);
                }
                else {
                    // ê°€ì´ë“œ ëª©ë¡
                    await external_vscode_.commands.executeCommand('ape.showCommandHelp', 'guides');
                }
            }
            else {
                // ê¸°ë³¸ ë„ì›€ë§ ë˜ëŠ” ì¹´í…Œê³ ë¦¬/ëª…ë ¹ì–´ ìƒì„¸ ë„ì›€ë§
                await external_vscode_.commands.executeCommand('ape.showCommandHelp', firstArg);
            }
        },
        provideCompletions: (partialArgs) => {
            const parts = partialArgs.split(' ');
            // ì²« ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„±
            if (parts.length <= 1) {
                const options = ['general', 'git', 'code', 'utility', 'advanced', 'search', 'find', 'faq', 'guide', 'guides', 'ê²€ìƒ‰', 'ì°¾ê¸°', 'ìžì£¼ë¬»ëŠ”ì§ˆë¬¸', 'ê°€ì´ë“œ'];
                return options.filter(option => option.toLowerCase().startsWith(parts[0].toLowerCase()));
            }
            // ë‘ ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„± (ê°€ì´ë“œì¸ ê²½ìš°)
            if ((parts[0] === 'guide' || parts[0] === 'guides' || parts[0] === 'ê°€ì´ë“œ') && parts.length === 2) {
                const guideOptions = ['auto-commit', 'git-integration', 'slash-commands', 'plugins'];
                return guideOptions.filter(option => option.toLowerCase().startsWith(parts[1].toLowerCase()));
            }
            return [];
        }
    });
    // ì±„íŒ… ë‚´ì—­ ì§€ìš°ê¸°
    commands.push({
        name: 'clear',
        aliases: ['cls', 'clean', 'ì§€ìš°ê¸°', 'ì´ˆê¸°í™”', 'í´ë¦¬ì–´'],
        description: 'ì±„íŒ… ë‚´ì—­ì„ ì§€ì›ë‹ˆë‹¤',
        category: 'general',
        priority: 2,
        execute: async () => {
            await external_vscode_.commands.executeCommand('ape.clearChat');
        }
    });
    // ëª¨ë¸ ë³€ê²½
    commands.push({
        name: 'model',
        aliases: ['use', 'ëª¨ë¸', 'ëª¨ë¸ë³€ê²½', 'ëª¨ë¸ì„ íƒ'],
        description: 'ì‚¬ìš©í•  LLM ëª¨ë¸ì„ ë³€ê²½í•©ë‹ˆë‹¤',
        examples: ['/model list', '/model use LLAMA4-MAVERICK', '/ëª¨ë¸ ëª©ë¡'],
        category: 'advanced',
        priority: 10,
        execute: async (context) => {
            const subCommand = context.args[0]?.toLowerCase();
            if (!subCommand) {
                // Model í•˜ìœ„ ëª…ë ¹ì–´ ëª©ë¡ í‘œì‹œ (ìŠ¬ëž™/ë””ìŠ¤ì½”ë“œ ìŠ¤íƒ€ì¼ ìžë™ì™„ì„±)
                const modelSubcommands = [
                    { command: 'list', description: 'ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸ ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤' },
                    { command: 'use', description: 'ì§€ì •í•œ ëª¨ë¸ë¡œ ë³€ê²½í•©ë‹ˆë‹¤' }
                ];
                // ëª…ë ¹ì–´ ì œì•ˆì„ ì±„íŒ… ì¸í„°íŽ˜ì´ìŠ¤ì˜ ìžë™ì™„ì„± UIì— í‘œì‹œ
                const suggestions = modelSubcommands.map(cmd => ({
                    label: `/model ${cmd.command}`,
                    description: cmd.description,
                    category: 'advanced',
                    insertText: `/model ${cmd.command} `
                }));
                // ëª…ë ¹ì–´ ì œì•ˆ í‘œì‹œ - ì±„íŒ… ìž…ë ¥ì°½ ìžë™ì™„ì„± UIì— í‘œì‹œ
                external_vscode_.commands.executeCommand('ape.showCommandSuggestions', suggestions);
                // VSCodeì˜ í€µí”½ UIë„ í•¨ê»˜ í‘œì‹œ (ë°±ì—… ë°©ë²•)
                external_vscode_.window.showQuickPick(modelSubcommands.map(cmd => ({
                    label: cmd.command,
                    description: cmd.description,
                    detail: `Model í•˜ìœ„ ëª…ë ¹ì–´: ${cmd.command}`
                })), {
                    placeHolder: 'Model ëª…ë ¹ì–´ë¥¼ ì„ íƒí•˜ì„¸ìš”',
                    matchOnDescription: true
                }).then(selected => {
                    if (selected) {
                        // ì„ íƒí•œ ëª…ë ¹ì–´ë¥¼ ì±„íŒ… ìž…ë ¥ì°½ì— ì‚½ìž…
                        external_vscode_.commands.executeCommand('ape.insertToChatInput', `/model ${selected.label}`);
                    }
                });
            }
            else if (subCommand === 'list' || subCommand === 'ëª©ë¡') {
                // ëª¨ë¸ ëª©ë¡ í‘œì‹œ
                await external_vscode_.commands.executeCommand('ape.selectModel');
            }
            else if (subCommand === 'use' || subCommand === 'switch' || subCommand === 'ì‚¬ìš©' || subCommand === 'ë³€ê²½') {
                // íŠ¹ì • ëª¨ë¸ë¡œ ë³€ê²½
                const modelName = context.args[1];
                if (modelName) {
                    await external_vscode_.commands.executeCommand('ape.switchModel', modelName);
                }
                else {
                    external_vscode_.window.showErrorMessage('ëª¨ë¸ ì´ë¦„ì„ ì§€ì •í•´ì£¼ì„¸ìš”');
                }
            }
            else {
                external_vscode_.window.showErrorMessage('ì•Œ ìˆ˜ ì—†ëŠ” í•˜ìœ„ ëª…ë ¹ì–´ìž…ë‹ˆë‹¤');
            }
        },
        provideCompletions: (partialArgs) => {
            // ê³ ì •ëœ ëª¨ë¸ ëª©ë¡ ì‚¬ìš©
            const models = [
                'openai/gpt-4.1-mini',
                'anthropic/claude-3-haiku-20240307',
                'anthropic/claude-3-sonnet-20240229',
                'perplexity/sonar-small-online',
                'mistralai/mistral-large-latest',
                'google/gemma-7b-it'
            ];
            const subCommands = ['list', 'use', 'switch', 'ëª©ë¡', 'ì‚¬ìš©', 'ë³€ê²½'];
            const parts = partialArgs.split(' ');
            // ì²« ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„±
            if (parts.length <= 1) {
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(partialArgs.toLowerCase()));
            }
            // ë‘ ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„± (ëª¨ë¸ ì´ë¦„)
            if (parts[0] === 'use' || parts[0] === 'switch' || parts[0] === 'ì‚¬ìš©' || parts[0] === 'ë³€ê²½') {
                const modelQuery = parts[1] || '';
                return models.filter((model) => model.toLowerCase().startsWith(modelQuery.toLowerCase()));
            }
            return [];
        }
    });
    // ì½”ë“œ ë¶„ì„
    commands.push({
        name: 'analyze',
        aliases: ['code', 'ë¶„ì„', 'ì½”ë“œ', 'ì½”ë“œë¶„ì„'],
        description: 'í˜„ìž¬ ì„ íƒëœ ì½”ë“œë¥¼ APEë¡œ ë¶„ì„í•©ë‹ˆë‹¤',
        examples: ['/analyze', '/code', '/ë¶„ì„'],
        category: 'code',
        priority: 5,
        execute: async () => {
            await external_vscode_.commands.executeCommand('ape.analyzeCode');
        }
    });
    // Git ëª…ë ¹ì–´ ì¶”ê°€
    const gitCommands = createGitCommands();
    commands.push(...gitCommands);
    // ì„¤ì •
    commands.push({
        name: 'settings',
        aliases: ['config', 'preferences', 'ì„¤ì •', 'í™˜ê²½ì„¤ì •', 'í”„ë¦¬í¼ëŸ°ìŠ¤'],
        description: 'APE ì„¤ì •ì„ ë³€ê²½í•©ë‹ˆë‹¤',
        category: 'utility',
        priority: 15,
        execute: async () => {
            await external_vscode_.commands.executeCommand('workbench.action.openSettings', 'ape');
        }
    });
    // Ask ëª…ë ¹ì–´ - ë‹¤ì–‘í•œ ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ëª¨ë“œë¥¼ ì œê³µí•˜ëŠ” LLM ê¸°ë°˜ ê°€ì´ë“œ
    commands.push({
        name: 'ask',
        aliases: ['ì§ˆë¬¸', 'ë¬¼ì–´ë³´ê¸°', 'ê°€ì´ë“œ', 'ì–´ë–»ê²Œ', 'ì–´ë–¡í•´', 'ë°©ë²•', 'ì¡°ì–¸'],
        description: 'LLMì„ ì‚¬ìš©í•˜ì—¬ ì§ˆë¬¸ì— ëŒ€í•œ ê°€ì´ë“œì™€ ë„ì›€ë§ì„ ì œê³µí•©ë‹ˆë‹¤',
        examples: ['/ask ì»¨í”Œë¦­ í•´ê²°í•˜ë ¤ë©´ ì–´ë–»ê²Œí•´?', '/ask --mode=ë””ë²„ê¹… ì½”ë“œê°€ ì˜¤ë¥˜ë¥¼ ë°œìƒì‹œì¼œìš”', '/ask --mode=git ìžë™ ì»¤ë°‹ ì–´ë–»ê²Œ ì‚¬ìš©í•˜ë‚˜ìš”?', '/ask --mode=í…ŒìŠ¤íŠ¸ ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ìž‘ì„± ë°©ë²•'],
        category: 'general',
        priority: 1,
        execute: async (context) => {
            try {
                // ëª¨ë“œ ì˜µì…˜ íŒŒì‹±
                let mode = 'general'; // ê¸°ë³¸ ëª¨ë“œ
                let question = '';
                // ëª¨ë“œ ì˜µì…˜ í™•ì¸ (--mode=ê°’ í˜•ì‹)
                const modeArg = context.args.find(arg => arg.startsWith('--mode='));
                if (modeArg) {
                    mode = modeArg.split('=')[1].trim();
                    // ëª¨ë“œ ì˜µì…˜ì„ ì œì™¸í•œ ë‚˜ë¨¸ì§€ ì¸ìžë¥¼ ì§ˆë¬¸ìœ¼ë¡œ ì‚¬ìš©
                    question = context.args.filter(arg => arg !== modeArg).join(' ').trim();
                }
                else {
                    question = context.args.join(' ').trim();
                }
                // ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“œ ëª©ë¡
                const availableModes = [
                    { id: 'general', name: 'ì¼ë°˜', description: 'ì¼ë°˜ì ì¸ ë„ì›€ë§ ë° ê°€ì´ë“œ ì œê³µ', icon: 'ðŸ“š' },
                    { id: 'debug', name: 'ë””ë²„ê¹…', description: 'ì½”ë“œ ë””ë²„ê¹… ë° ë¬¸ì œ í•´ê²° ê°€ì´ë“œ', icon: 'ðŸ”' },
                    { id: 'refactor', name: 'ë¦¬íŒ©í† ë§', description: 'ì½”ë“œ ê°œì„  ë° ë¦¬íŒ©í† ë§ ì œì•ˆ', icon: 'ðŸ”„' },
                    { id: 'jira', name: 'JIRA', description: 'JIRA ì´ìŠˆ ìž‘ì„± ë° ê´€ë¦¬ ê°€ì´ë“œ', icon: 'ðŸ“‹' },
                    { id: 'workflow', name: 'ì›Œí¬í”Œë¡œìš°', description: 'ìž‘ì—… ë‹¨ê³„ ë° ì ˆì°¨ ì•ˆë‚´', icon: 'ðŸ“' },
                    { id: 'code', name: 'ì½”ë“œ', description: 'ì½”ë“œ ìž‘ì„± ë° êµ¬í˜„ ê°€ì´ë“œ', icon: 'ðŸ’»' },
                    { id: 'git', name: 'Git', description: 'Git ê´€ë ¨ ëª…ë ¹ì–´ ë° ìž‘ì—… ê°€ì´ë“œ', icon: 'ðŸ”€' },
                    { id: 'explain', name: 'ì„¤ëª…', description: 'ì½”ë“œ ë° ê°œë… ì„¤ëª…', icon: 'ðŸ“–' },
                    { id: 'planning', name: 'ê³„íš', description: 'ê°œë°œ ìž‘ì—… ê³„íš ë° ë‹¨ê³„ ìˆ˜ë¦½', icon: 'ðŸ“Š' },
                    { id: 'testing', name: 'í…ŒìŠ¤íŠ¸', description: 'í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ìž‘ì„± ë° í…ŒìŠ¤íŠ¸ ì „ëžµ', icon: 'âœ…' }
                ];
                // ì§ˆë¬¸ì´ ì—†ëŠ” ê²½ìš° ëª¨ë“œ ì„ íƒ UI í‘œì‹œ
                if (!question) {
                    // ê°„ì†Œí™”ëœ ëª¨ë“œ ëª©ë¡
                    const modesList = availableModes.map(m => `${m.icon} ${m.name}: ${m.id}`).join('\n');
                    const modesHtml = `
          <div>
            <h3>ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ëª¨ë“œ</h3>
            <p>ì§ˆë¬¸ ì‹œ ë‹¤ìŒ ëª¨ë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤:</p>
            <pre>${modesList}</pre>
            <p>ì‚¬ìš©ë²•: <code>/ask --mode=[ëª¨ë“œëª…] [ì§ˆë¬¸]</code></p>
          </div>`;
                    await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: modesHtml
                    });
                    return;
                }
                // LLM ì„œë¹„ìŠ¤ ê°€ì ¸ì˜¤ê¸°
                let llmService;
                if (services && services.llmService) {
                    // ê°œë°œ í™˜ê²½ì—ì„œëŠ” services ê°ì²´ê°€ ì „ë‹¬ë¨
                    llmService = services.llmService;
                }
                else {
                    // ìµìŠ¤í…ì…˜ì—ì„œ ì„œë¹„ìŠ¤ ê°€ì ¸ì˜¤ê¸° ì‹œë„
                    const extension = external_vscode_.extensions.getExtension('ape-team.ape-extension');
                    if (extension && extension.isActive) {
                        llmService = extension.exports.llmService;
                    }
                }
                // LLM ì„œë¹„ìŠ¤ ì¡´ìž¬ í™•ì¸
                if (!llmService) {
                    external_vscode_.window.showErrorMessage('LLM ì„œë¹„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                // help.jsonê³¼ guide.json ë‚´ìš© ë¡œë“œ
                let helpData;
                let guideData;
                // ìµìŠ¤í…ì…˜ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                const extension = external_vscode_.extensions.getExtension('ape-team.ape-extension');
                if (!extension) {
                    throw new Error('APE ìµìŠ¤í…ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                }
                const extensionPath = extension.extensionPath;
                const helpPath = external_path_.join(extensionPath, 'src', 'data', 'help.json');
                const guidePath = external_path_.join(extensionPath, 'src', 'data', 'guide.json');
                try {
                    helpData = JSON.parse(external_fs_.readFileSync(helpPath, 'utf8'));
                }
                catch (error) {
                    console.error('help.json íŒŒì¼ ë¡œë“œ ì˜¤ë¥˜:', error);
                    // ê¸°ë³¸ ë°ì´í„° êµ¬ì¡° ì œê³µ
                    helpData = { categories: [], faq: [], guides: [] };
                }
                try {
                    guideData = JSON.parse(external_fs_.readFileSync(guidePath, 'utf8'));
                }
                catch (error) {
                    console.error('guide.json íŒŒì¼ ë¡œë“œ ì˜¤ë¥˜:', error);
                    // ê¸°ë³¸ ë°ì´í„° êµ¬ì¡° ì œê³µ
                    guideData = { workflows: [], commandGuides: [] };
                }
                // ì„ íƒí•œ ëª¨ë“œì— ë”°ë¼ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ìƒì„±
                let systemPrompt = '';
                let modeIcon = 'ðŸ“š';
                let modeName = 'ì¼ë°˜';
                // í˜„ìž¬ ëª¨ë“œì— í•´ë‹¹í•˜ëŠ” ì •ë³´ ì°¾ê¸°
                const currentMode = availableModes.find(m => m.id === mode.toLowerCase() || m.name === mode);
                if (currentMode) {
                    modeIcon = currentMode.icon;
                    modeName = currentMode.name;
                }
                switch (mode.toLowerCase()) {
                    case 'debug':
                    case 'ë””ë²„ê¹…':
                        systemPrompt = `ë‹¹ì‹ ì€ APE(Agentic Programming Extension)ì˜ ë””ë²„ê¹… ë„ìš°ë¯¸ìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžê°€ ì œì‹œí•œ ì½”ë“œ ë¬¸ì œë‚˜ ì˜¤ë¥˜ì— ëŒ€í•´ help.jsonê³¼ guide.jsonì— ìžˆëŠ” ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë””ë²„ê¹… ë°©ë²•ì„ ì•ˆë‚´í•´ì•¼ í•©ë‹ˆë‹¤.

ë‹µë³€ ì‹œ ë‹¤ìŒ ê·œì¹™ì„ ë”°ë¥´ì„¸ìš”:
1. ë¬¸ì œì˜ ìž ìž¬ì  ì›ì¸ì„ ë¶„ì„í•˜ê³  ì§„ë‹¨í•˜ì„¸ìš”
2. ì˜¤ë¥˜ ë©”ì‹œì§€ì˜ ì˜ë¯¸ë¥¼ ì„¤ëª…í•˜ì„¸ìš”
3. ë‹¨ê³„ë³„ ë””ë²„ê¹… ê³¼ì •ì„ êµ¬ì²´ì ìœ¼ë¡œ ì•ˆë‚´í•˜ì„¸ìš”
4. ê´€ë ¨ APE ëª…ë ¹ì–´ë‚˜ ë„êµ¬ê°€ ìžˆë‹¤ë©´ í•¨ê»˜ ì†Œê°œí•˜ì„¸ìš”
5. ë¬¸ì œ í•´ê²°ì„ ìœ„í•œ ê²€ì¦ ë°©ë²•ë„ ì œì‹œí•˜ì„¸ìš”

ë‹µë³€ í˜•ì‹:
[ë¬¸ì œ ì§„ë‹¨ ìš”ì•½]

[ê°€ëŠ¥í•œ ì›ì¸ ë¶„ì„]

[ë‹¨ê³„ë³„ ë””ë²„ê¹… ë°©ë²•]

[ê´€ë ¨ ëª…ë ¹ì–´ ë° ë„êµ¬]`;
                        break;
                    case 'refactor':
                    case 'ë¦¬íŒ©í† ë§':
                        systemPrompt = `ë‹¹ì‹ ì€ APE(Agentic Programming Extension)ì˜ ë¦¬íŒ©í† ë§ ë„ìš°ë¯¸ìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžì˜ ì½”ë“œ ê°œì„  ìš”ì²­ì— ëŒ€í•´ help.jsonê³¼ guide.jsonì— ìžˆëŠ” ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ë¦¬íŒ©í† ë§ ë°©ë²•ì„ ì•ˆë‚´í•´ì•¼ í•©ë‹ˆë‹¤.

ë‹µë³€ ì‹œ ë‹¤ìŒ ê·œì¹™ì„ ë”°ë¥´ì„¸ìš”:
1. ì½”ë“œì˜ í’ˆì§ˆ, ê°€ë…ì„±, ì„±ëŠ¥ ì¸¡ë©´ì—ì„œ ê°œì„ ì ì„ ë¶„ì„í•˜ì„¸ìš”
2. ë””ìžì¸ íŒ¨í„´ì´ë‚˜ ëª¨ë²” ì‚¬ë¡€ë¥¼ ì œì•ˆí•˜ì„¸ìš”
3. ë‹¨ê³„ë³„ ë¦¬íŒ©í† ë§ ê³¼ì •ì„ êµ¬ì²´ì ìœ¼ë¡œ ì•ˆë‚´í•˜ì„¸ìš”
4. ê´€ë ¨ APE ëª…ë ¹ì–´ë‚˜ ë„êµ¬ê°€ ìžˆë‹¤ë©´ í•¨ê»˜ ì†Œê°œí•˜ì„¸ìš”
5. ë¦¬íŒ©í† ë§ í›„ ì˜ˆìƒë˜ëŠ” ì´ì ì„ ì„¤ëª…í•˜ì„¸ìš”

ë‹µë³€ í˜•ì‹:
[ì½”ë“œ ë¶„ì„ ìš”ì•½]

[ê°œì„  ê°€ëŠ¥í•œ ë¶€ë¶„]

[ë¦¬íŒ©í† ë§ ì ‘ê·¼ ë°©ë²•]

[ê´€ë ¨ ëª…ë ¹ì–´ ë° ë„êµ¬]`;
                        break;
                    case 'jira':
                    case 'jira ì´ìŠˆ':
                        systemPrompt = `ë‹¹ì‹ ì€ APE(Agentic Programming Extension)ì˜ JIRA ë„ìš°ë¯¸ìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžì˜ JIRA ì´ìŠˆ ìž‘ì„± ë˜ëŠ” ê´€ë¦¬ ìš”ì²­ì— ëŒ€í•´ help.jsonê³¼ guide.jsonì— ìžˆëŠ” ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì•ˆë‚´í•´ì•¼ í•©ë‹ˆë‹¤.

ë‹µë³€ ì‹œ ë‹¤ìŒ ê·œì¹™ì„ ë”°ë¥´ì„¸ìš”:
1. JIRA ì´ìŠˆ ìž‘ì„±ì„ ìœ„í•œ êµ¬ì¡°í™”ëœ í…œí”Œë¦¿ì„ ì œê³µí•˜ì„¸ìš”
2. ì´ìŠˆ ì œëª©, ì„¤ëª…, ìž¬í˜„ ë‹¨ê³„, ê¸°ëŒ€ ê²°ê³¼ ë“± í•„ìš”í•œ í•­ëª©ì„ í¬í•¨í•˜ì„¸ìš”
3. APEì—ì„œ JIRA ê´€ë ¨ ëª…ë ¹ì–´ë‚˜ ê¸°ëŠ¥ì„ ì†Œê°œí•˜ì„¸ìš”
4. ì´ìŠˆ ì¶”ì  ë° ê´€ë¦¬ ëª¨ë²” ì‚¬ë¡€ë¥¼ ì œì•ˆí•˜ì„¸ìš”

ë‹µë³€ í˜•ì‹:
[JIRA ì´ìŠˆ í…œí”Œë¦¿]

[APE JIRA í†µí•© ê¸°ëŠ¥]

[JIRA ì´ìŠˆ ê´€ë¦¬ íŒ]`;
                        break;
                    case 'workflow':
                    case 'ì›Œí¬í”Œë¡œìš°':
                        systemPrompt = `ë‹¹ì‹ ì€ APE(Agentic Programming Extension)ì˜ ì›Œí¬í”Œë¡œìš° ë„ìš°ë¯¸ìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžì˜ ìž‘ì—… í”„ë¡œì„¸ìŠ¤ ê´€ë ¨ ì§ˆë¬¸ì— ëŒ€í•´ help.jsonê³¼ guide.jsonì— ìžˆëŠ” ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì›Œí¬í”Œë¡œìš°ë¥¼ ì•ˆë‚´í•´ì•¼ í•©ë‹ˆë‹¤.

ë‹µë³€ ì‹œ ë‹¤ìŒ ê·œì¹™ì„ ë”°ë¥´ì„¸ìš”:
1. ìž‘ì—… ëª©í‘œ ë‹¬ì„±ì„ ìœ„í•œ ëª…í™•í•œ ë‹¨ê³„ë³„ ì ˆì°¨ë¥¼ ì„¤ëª…í•˜ì„¸ìš”
2. ê° ë‹¨ê³„ë§ˆë‹¤ í•„ìš”í•œ APE ëª…ë ¹ì–´ë‚˜ ê¸°ëŠ¥ì„ ì—°ê²°í•˜ì„¸ìš”
3. ìž‘ì—… ê°„ ì˜ì¡´ì„±ê³¼ ìˆœì„œë¥¼ ëª…í™•ížˆ í•˜ì„¸ìš”
4. ì²´í¬í¬ì¸íŠ¸ë‚˜ ê²€ì¦ ë‹¨ê³„ë¥¼ í¬í•¨í•˜ì„¸ìš”
5. ìžë™í™” ê°€ëŠ¥í•œ ë¶€ë¶„ì´ ìžˆë‹¤ë©´ ì œì•ˆí•˜ì„¸ìš”

ë‹µë³€ í˜•ì‹:
[ì›Œí¬í”Œë¡œìš° ê°œìš”]

[ë‹¨ê³„ë³„ ìž‘ì—… ì ˆì°¨]

[ì¶”ì²œ ìžë™í™” ì˜µì…˜]

[ê´€ë ¨ ëª…ë ¹ì–´ ë° ë„êµ¬]`;
                        break;
                    case 'code':
                    case 'ì½”ë“œ':
                        systemPrompt = `ë‹¹ì‹ ì€ APE(Agentic Programming Extension)ì˜ ì½”ë“œ ìž‘ì„± ë„ìš°ë¯¸ìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžì˜ ì½”ë“œ êµ¬í˜„ ê´€ë ¨ ì§ˆë¬¸ì— ëŒ€í•´ help.jsonê³¼ guide.jsonì— ìžˆëŠ” ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ê°€ì´ë“œë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤.

ë‹µë³€ ì‹œ ë‹¤ìŒ ê·œì¹™ì„ ë”°ë¥´ì„¸ìš”:
1. êµ¬í˜„í•˜ë ¤ëŠ” ê¸°ëŠ¥ì— ëŒ€í•œ ì ‘ê·¼ ë°©ì‹ì„ ì œì•ˆí•˜ì„¸ìš”
2. í•„ìš”í•œ êµ¬ì„± ìš”ì†Œì™€ ì„¤ê³„ íŒ¨í„´ì„ ì„¤ëª…í•˜ì„¸ìš”
3. í•µì‹¬ ì½”ë“œ êµ¬í˜„ ë°©ë²•ì„ ë‹¨ê³„ë³„ë¡œ ì•ˆë‚´í•˜ì„¸ìš”
4. APEì—ì„œ ì œê³µí•˜ëŠ” ê´€ë ¨ ë„êµ¬ì™€ ëª…ë ¹ì–´ë¥¼ ì†Œê°œí•˜ì„¸ìš”
5. í…ŒìŠ¤íŠ¸ ë° ê²€ì¦ ë°©ë²•ë„ í¬í•¨í•˜ì„¸ìš”

ë‹µë³€ í˜•ì‹:
[ê¸°ëŠ¥ êµ¬í˜„ ì ‘ê·¼ ë°©ì‹]

[í•µì‹¬ êµ¬ì„± ìš”ì†Œ]

[êµ¬í˜„ ë‹¨ê³„]

[ê´€ë ¨ ëª…ë ¹ì–´ ë° ë„êµ¬]`;
                        break;
                    case 'git':
                        systemPrompt = `ë‹¹ì‹ ì€ APE(Agentic Programming Extension)ì˜ Git ë„ìš°ë¯¸ìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžì˜ Git ê´€ë ¨ ì§ˆë¬¸ì— ëŒ€í•´ help.jsonê³¼ guide.jsonì— ìžˆëŠ” ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ê°€ì´ë“œë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤.

ë‹µë³€ ì‹œ ë‹¤ìŒ ê·œì¹™ì„ ë”°ë¥´ì„¸ìš”:
1. Git ëª…ë ¹ì–´ì™€ ì›Œí¬í”Œë¡œìš°ì— ê´€í•œ ëª…í™•í•œ ì„¤ëª…ì„ ì œê³µí•˜ì„¸ìš”
2. APEì˜ Git ê´€ë ¨ ëª…ë ¹ì–´ì™€ ì‚¬ìš©ë²•ì„ ìƒì„¸í•˜ê²Œ ì•ˆë‚´í•˜ì„¸ìš”
3. ë¬¸ì œ ìƒí™©ë³„ í•´ê²° ë°©ë²•ì„ ë‹¨ê³„ë³„ë¡œ ì„¤ëª…í•˜ì„¸ìš”
4. Git ëª¨ë²” ì‚¬ë¡€ì™€ íŒì„ ê³µìœ í•˜ì„¸ìš”
5. APEì˜ ìžë™ ì»¤ë°‹, ì¶©ëŒ í•´ê²° ë“± íŠ¹í™” ê¸°ëŠ¥ì„ ê°•ì¡°í•˜ì„¸ìš”

ë‹µë³€ í˜•ì‹:
[í•µì‹¬ ë‹µë³€]

[ìƒì„¸ ì„¤ëª… ë° ë‹¨ê³„ë³„ ë°©ë²•]

[APE Git ëª…ë ¹ì–´ ê´€ë ¨ ì •ë³´]

[ì°¸ê³ í•  ìˆ˜ ìžˆëŠ” ëª¨ë²” ì‚¬ë¡€]`;
                        break;
                    case 'explain':
                    case 'ì„¤ëª…':
                        systemPrompt = `ë‹¹ì‹ ì€ APE(Agentic Programming Extension)ì˜ ê°œë… ì„¤ëª… ë„ìš°ë¯¸ìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžê°€ ì§ˆë¬¸í•œ ì½”ë“œë‚˜ ê°œë…ì— ëŒ€í•´ help.jsonê³¼ guide.jsonì— ìžˆëŠ” ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ëª…í™•í•œ ì„¤ëª…ì„ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤.

ë‹µë³€ ì‹œ ë‹¤ìŒ ê·œì¹™ì„ ë”°ë¥´ì„¸ìš”:
1. ê°œë…ì´ë‚˜ ì½”ë“œì˜ ëª©ì ê³¼ ê¸°ëŠ¥ì„ ëª…í™•ížˆ ì„¤ëª…í•˜ì„¸ìš”
2. í•µì‹¬ ì›ë¦¬ì™€ ìž‘ë™ ë°©ì‹ì„ ì´í•´í•˜ê¸° ì‰½ê²Œ í’€ì–´ì„œ ì„¤ëª…í•˜ì„¸ìš”
3. ì‹¤ì œ ì‚¬ìš© ì˜ˆì‹œì™€ ì ìš© ì‚¬ë¡€ë¥¼ ì œê³µí•˜ì„¸ìš”
4. ê´€ë ¨ëœ ë‹¤ë¥¸ ê°œë…ì´ë‚˜ íŒ¨í„´ê³¼ì˜ ê´€ê³„ë¥¼ ì„¤ëª…í•˜ì„¸ìš”
5. ê´€ë ¨ APE ê¸°ëŠ¥ì´ ìžˆë‹¤ë©´ í•¨ê»˜ ì†Œê°œí•˜ì„¸ìš”

ë‹µë³€ í˜•ì‹:
[ê°œë… ì •ì˜ - 1-2ë¬¸ìž¥]

[ìž‘ë™ ì›ë¦¬ ì„¤ëª…]

[ì‚¬ìš© ì‚¬ë¡€ ë° ì˜ˆì‹œ]

[ê´€ë ¨ ê°œë… ë° APE ê¸°ëŠ¥]`;
                        break;
                    case 'planning':
                    case 'ê³„íš':
                        systemPrompt = `ë‹¹ì‹ ì€ APE(Agentic Programming Extension)ì˜ ê°œë°œ ê³„íš ë„ìš°ë¯¸ìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžì˜ ê°œë°œ ê³„íš ê´€ë ¨ ì§ˆë¬¸ì— ëŒ€í•´ help.jsonê³¼ guide.jsonì— ìžˆëŠ” ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì²´ê³„ì ì¸ ê³„íš ìˆ˜ë¦½ì„ ë„ì™€ì•¼ í•©ë‹ˆë‹¤.

ë‹µë³€ ì‹œ ë‹¤ìŒ ê·œì¹™ì„ ë”°ë¥´ì„¸ìš”:
1. ëª©í‘œ ë‹¬ì„±ì„ ìœ„í•œ ëª…í™•í•œ ë‹¨ê³„ë³„ ê³„íšì„ ìˆ˜ë¦½í•˜ì„¸ìš”
2. ê° ë‹¨ê³„ì˜ ìš°ì„ ìˆœìœ„ì™€ ì˜ì¡´ì„±ì„ ê³ ë ¤í•˜ì„¸ìš”
3. ì¼ì • ì¶”ì •ê³¼ ë§ˆì¼ìŠ¤í†¤ì„ ì œì•ˆí•˜ì„¸ìš”
4. ìž ìž¬ì  ìœ„í—˜ ìš”ì†Œì™€ ëŒ€ì‘ ë°©ì•ˆì„ ë¶„ì„í•˜ì„¸ìš”
5. APE ê¸°ëŠ¥ì„ í™œìš©í•œ ìž‘ì—… íš¨ìœ¨í™” ë°©ì•ˆì„ ì œì•ˆí•˜ì„¸ìš”

ë‹µë³€ í˜•ì‹:
[ê³„íš ê°œìš”]

[ë‹¨ê³„ë³„ ìž‘ì—… ê³„íš]

[ì¼ì • ë° ë§ˆì¼ìŠ¤í†¤]

[ìœ„í—˜ ìš”ì†Œ ë° ëŒ€ì‘ ë°©ì•ˆ]

[APE ê¸°ëŠ¥ í™œìš© ë°©ì•ˆ]`;
                        break;
                    case 'testing':
                    case 'í…ŒìŠ¤íŠ¸':
                        systemPrompt = `ë‹¹ì‹ ì€ APE(Agentic Programming Extension)ì˜ í…ŒìŠ¤íŠ¸ ë„ìš°ë¯¸ìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžì˜ í…ŒìŠ¤íŠ¸ ê´€ë ¨ ì§ˆë¬¸ì— ëŒ€í•´ help.jsonê³¼ guide.jsonì— ìžˆëŠ” ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ í…ŒìŠ¤íŠ¸ ì „ëžµê³¼
êµ¬í˜„ ë°©ë²•ì„ ì•ˆë‚´í•´ì•¼ í•©ë‹ˆë‹¤.

ë‹µë³€ ì‹œ ë‹¤ìŒ ê·œì¹™ì„ ë”°ë¥´ì„¸ìš”:
1. í…ŒìŠ¤íŠ¸ ëŒ€ìƒì— ì í•©í•œ í…ŒìŠ¤íŠ¸ ìœ í˜•ê³¼ ë°©ë²•ë¡ ì„ ì¶”ì²œí•˜ì„¸ìš”
2. íš¨ê³¼ì ì¸ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì„¤ê³„ ë°©ë²•ì„ ì œì•ˆí•˜ì„¸ìš”
3. í…ŒìŠ¤íŠ¸ ì½”ë“œ ìž‘ì„± ì˜ˆì‹œì™€ ëª¨ë²” ì‚¬ë¡€ë¥¼ ì œê³µí•˜ì„¸ìš”
4. í…ŒìŠ¤íŠ¸ ìžë™í™”ì™€ CI/CD í†µí•© ë°©ì•ˆì„ ì•ˆë‚´í•˜ì„¸ìš”
5. APEì—ì„œ ì œê³µí•˜ëŠ” í…ŒìŠ¤íŠ¸ ê´€ë ¨ ë„êµ¬ì™€ ëª…ë ¹ì–´ë¥¼ ì†Œê°œí•˜ì„¸ìš”

ë‹µë³€ í˜•ì‹:
[í…ŒìŠ¤íŠ¸ ì „ëžµ ê°œìš”]

[í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ ì„¤ê³„]

[í…ŒìŠ¤íŠ¸ ì½”ë“œ ìž‘ì„± ë°©ë²•]

[í…ŒìŠ¤íŠ¸ ìžë™í™” ë°©ì•ˆ]

[ê´€ë ¨ APE ë„êµ¬ ë° ëª…ë ¹ì–´]`;
                        break;
                    case 'general':
                    case 'ì¼ë°˜':
                    default:
                        systemPrompt = `ë‹¹ì‹ ì€ APE(Agentic Programming Extension)ì˜ ê°€ì´ë“œ ë„ìš°ë¯¸ìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžì˜ ì§ˆë¬¸ì— ëŒ€í•´ help.jsonê³¼ guide.jsonì— ìžˆëŠ” ì •ë³´ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ëª…í™•í•˜ê³  êµ¬ì²´ì ì¸ ë‹µë³€ì„ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤.
ì§ˆë¬¸ê³¼ ê°€ìž¥ ê´€ë ¨ì„± ë†’ì€ ëª…ë ¹ì–´, ì›Œí¬í”Œë¡œìš°, ê°€ì´ë“œë¥¼ ì°¾ì•„ ë‹µë³€í•˜ì„¸ìš”.

ë‹µë³€ ì‹œ ë‹¤ìŒ ê·œì¹™ì„ ë”°ë¥´ì„¸ìš”:
1. ì‚¬ìš©ìž ì§ˆë¬¸ê³¼ ê´€ë ¨ëœ ëª…ë ¹ì–´ê°€ ìžˆë‹¤ë©´ ëª…ë ¹ì–´ ì´ë¦„, ì„¤ëª…, ì˜ˆì‹œë¥¼ í¬í•¨í•˜ì„¸ìš”
2. ëª…ë ¹ì–´ ì‚¬ìš©ë²•ê³¼ ë³„ì¹­ì„ ëª…í™•ížˆ ì„¤ëª…í•˜ì„¸ìš”
3. ê´€ë ¨ëœ ì›Œí¬í”Œë¡œìš°ê°€ ìžˆë‹¤ë©´ ë‹¨ê³„ë³„ë¡œ ì„¤ëª…í•˜ì„¸ìš”
4. ì‚¬ìš©ìžê°€ ì§ˆë¬¸í•œ ìž‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ë°©ë²•ì„ êµ¬ì²´ì ì¸ ì˜ˆì‹œì™€ í•¨ê»˜ ì œê³µí•˜ì„¸ìš”
5. ëª¨ë“  ë‹µë³€ì€ í•œêµ­ì–´ë¡œ ì œê³µí•©ë‹ˆë‹¤
6. ê´€ë ¨ ëª…ë ¹ì–´ê°€ ì—¬ëŸ¬ ê°œ ìžˆìœ¼ë©´ ê°€ìž¥ ì í•©í•œ ê²ƒì„ ì¤‘ì‹¬ìœ¼ë¡œ ì„¤ëª…í•˜ê³  ë‹¤ë¥¸ ê´€ë ¨ ëª…ë ¹ì–´ë„ ê°„ëžµížˆ ì–¸ê¸‰í•˜ì„¸ìš”
7. ë‹µë³€ì€ ê°„ê²°í•˜ê³  ëª…í™•í•˜ê²Œ ìž‘ì„±í•˜ì„¸ìš”
8. ê°€ì´ë“œì™€ ë„ì›€ë§ì— ì—†ëŠ” ë‚´ìš©ì— ëŒ€í•´ì„œëŠ” ì •í™•ížˆ ëª¨ë¥¸ë‹¤ê³  ë‹µë³€í•˜ì„¸ìš”

ë‹µë³€ í˜•ì‹:
[í•µì‹¬ ë‹µë³€ - 1-2ë¬¸ìž¥]

[ìƒì„¸ ì„¤ëª… ë° ë‹¨ê³„ë³„ ë°©ë²•]

[ì˜ˆì‹œ ë° ê´€ë ¨ ëª…ë ¹ì–´]`;
                        break;
                }
                // ì»¨í…ìŠ¤íŠ¸ ë©”ì‹œì§€ ìƒì„± (help.json, guide.json ë°ì´í„°)
                const helpCommandsStr = helpData.categories
                    .flatMap((category) => category.commands)
                    .map((cmd) => `${cmd.name}: ${cmd.description}\nì‚¬ìš©ë²•: ${cmd.usage || '/' + cmd.name}\nì˜ˆì‹œ: ${cmd.examples?.join(', ') || 'ì—†ìŒ'}\në³„ì¹­: ${cmd.aliases?.join(', ') || 'ì—†ìŒ'}\n`)
                    .join('\n');
                const faqStr = helpData.faq
                    .map((item) => `Q: ${item.question}\nA: ${item.answer}`)
                    .join('\n\n');
                const guidesStr = guideData.commandGuides
                    .map((guide) => `${guide.title}:\n${guide.content.replace(/#+\s/g, '')}`)
                    .join('\n\n');
                const workflowsStr = guideData.workflows
                    .map((workflow) => `${workflow.name}: ${workflow.description}\nê¶Œìž¥ ëª…ë ¹ì–´: ${workflow.recommendedCommands.map((cmd) => cmd.command).join(', ')}`)
                    .join('\n\n');
                // ì§ˆë¬¸ì„ LLMì— ì „ì†¡
                const messages = [
                    {
                        id: `system_${Date.now()}`,
                        role: MessageRole.System,
                        content: systemPrompt,
                        timestamp: new Date()
                    },
                    {
                        id: `context_1_${Date.now()}`,
                        role: MessageRole.User,
                        content: `ë‹¤ìŒì€ APEì˜ ëª…ë ¹ì–´ ëª©ë¡ìž…ë‹ˆë‹¤:\n\n${helpCommandsStr}`,
                        timestamp: new Date()
                    },
                    {
                        id: `context_2_${Date.now()}`,
                        role: MessageRole.User,
                        content: `ë‹¤ìŒì€ APEì˜ FAQ ëª©ë¡ìž…ë‹ˆë‹¤:\n\n${faqStr}`,
                        timestamp: new Date()
                    },
                    {
                        id: `context_3_${Date.now()}`,
                        role: MessageRole.User,
                        content: `ë‹¤ìŒì€ APEì˜ ê°€ì´ë“œ ëª©ë¡ìž…ë‹ˆë‹¤:\n\n${guidesStr}`,
                        timestamp: new Date()
                    },
                    {
                        id: `context_4_${Date.now()}`,
                        role: MessageRole.User,
                        content: `ë‹¤ìŒì€ APEì˜ ì›Œí¬í”Œë¡œìš° ëª©ë¡ìž…ë‹ˆë‹¤:\n\n${workflowsStr}`,
                        timestamp: new Date()
                    },
                    {
                        id: `question_${Date.now()}`,
                        role: MessageRole.User,
                        content: question,
                        timestamp: new Date()
                    }
                ];
                // ì§„í–‰ ì¤‘ ë©”ì‹œì§€ í‘œì‹œ
                await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: 'ì§ˆë¬¸ì„ ë¶„ì„í•˜ê³  ë‹µë³€ì„ ì¤€ë¹„í•˜ê³  ìžˆìŠµë‹ˆë‹¤...',
                    messageId: 'temp_loading'
                });
                // LLMì— ìš”ì²­ ì „ì†¡
                const response = await llmService.sendRequest(messages, { temperature: 0.2 });
                if (response.success && response.data) {
                    // í˜„ìž¬ ëª¨ë“œì— í•´ë‹¹í•˜ëŠ” ë±ƒì§€ ìƒì„±
                    const modeBadge = `<div style="display:inline-block; padding:5px 10px; background-color:#f0f0f0; border-radius:5px; margin-bottom:10px;">
            <span style="font-size:16px;">${modeIcon}</span> <strong>${modeName} ëª¨ë“œ</strong>
          </div>`;
                    // ëª¨ë“œ ì„ íƒê¸° UI ìƒì„± (ê°„ì†Œí™”)
                    const modeSelector = `<div style="margin-top:15px; color:#0066cc; cursor:pointer;">
            <span>ë‹¤ë¥¸ ëª¨ë“œë¡œ ì§ˆë¬¸í•˜ë ¤ë©´ '/ask --mode=[ëª¨ë“œëª…] ${question}' ëª…ë ¹ì–´ë¥¼ ìž…ë ¥í•˜ì„¸ìš”.</span>
          </div>`;
                    // ê°„ì†Œí™”ëœ ì‘ë‹µ í˜•ì‹
                    const formattedResponse = `${modeBadge}\n\n${response.data.message.content}\n\n${modeSelector}`;
                    // ê²°ê³¼ë¥¼ ì±„íŒ…ì°½ì— í‘œì‹œ
                    await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: formattedResponse,
                        replaceMessageId: 'temp_loading'
                    });
                }
                else {
                    // ì‹¤íŒ¨ ë©”ì‹œì§€ í‘œì‹œ
                    await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: 'ì£„ì†¡í•©ë‹ˆë‹¤. ì§ˆë¬¸ì— ë‹µë³€í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                        replaceMessageId: 'temp_loading'
                    });
                }
            }
            catch (error) {
                console.error('Ask ëª…ë ¹ì–´ ì˜¤ë¥˜:', error);
                external_vscode_.window.showErrorMessage(`ì§ˆë¬¸ ì‘ë‹µ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
                // ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì‹œ
                await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: 'ì£„ì†¡í•©ë‹ˆë‹¤. ì§ˆë¬¸ì— ë‹µë³€í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                    replaceMessageId: 'temp_loading'
                });
            }
        }
    });
    // ì‹œìŠ¤í…œ ìƒíƒœ ëª…ë ¹ì–´
    commands.push({
        name: 'system',
        aliases: ['sys', 'ì‹œìŠ¤í…œ', 'ìƒíƒœ'],
        description: 'ì‹œìŠ¤í…œ ì •ë³´ì™€ ë©”ëª¨ë¦¬ ìƒíƒœë¥¼ í‘œì‹œí•©ë‹ˆë‹¤',
        examples: ['/system', '/system memory', '/ì‹œìŠ¤í…œ'],
        category: 'utility',
        priority: 15,
        execute: async (context) => {
            try {
                const subCommand = context.args[0]?.toLowerCase();
                // ë©”ëª¨ë¦¬ ì„œë¹„ìŠ¤ì™€ LLM ì„œë¹„ìŠ¤ ì°¸ì¡°
                let memoryService;
                let llmService;
                if (services && services.memoryService && services.llmService) {
                    // ê°œë°œ í™˜ê²½ì—ì„œëŠ” services ê°ì²´ê°€ ì „ë‹¬ë¨
                    memoryService = services.memoryService;
                    llmService = services.llmService;
                }
                else {
                    // ìµìŠ¤í…ì…˜ì—ì„œ ì„œë¹„ìŠ¤ ê°€ì ¸ì˜¤ê¸° ì‹œë„
                    const extension = external_vscode_.extensions.getExtension('ape-team.ape-extension');
                    if (extension && extension.isActive) {
                        memoryService = extension.exports.memoryService;
                        llmService = extension.exports.llmService;
                    }
                }
                // ì„œë¹„ìŠ¤ ì¡´ìž¬ í™•ì¸
                if (!memoryService) {
                    external_vscode_.window.showErrorMessage('ë©”ëª¨ë¦¬ ì„œë¹„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                if (!llmService) {
                    external_vscode_.window.showErrorMessage('LLM ì„œë¹„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                // ì‹œìŠ¤í…œ ì •ë³´ êµ¬ì„± (ì¼ë°˜ í…ìŠ¤íŠ¸ í˜•ì‹)
                let output = `
+----------------------+
|  APE ì‹œìŠ¤í…œ ìƒíƒœ     |
+----------------------+
`;
                // í˜„ìž¬ ì„¸ì…˜ ì •ë³´
                const currentSession = memoryService.getCurrentSession();
                const messagesResult = await memoryService.getMessages();
                const messages = messagesResult.success ? messagesResult.data || [] : [];
                // í˜„ìž¬ ëª¨ë¸ ì •ë³´
                const currentModel = llmService.getActiveModel();
                const modelDisplayName = llmService.getModelDisplayName(currentModel);
                // ë©”ì‹œì§€ ìˆ˜ ê³„ì‚°
                const userMessages = messages.filter((m) => m.role === 'user').length;
                const assistantMessages = messages.filter((m) => m.role === 'assistant').length;
                const systemMessages = messages.filter((m) => m.role === 'system').length;
                // ê¸°ë³¸ ì‹œìŠ¤í…œ ì •ë³´ í‘œì‹œ (í…ìŠ¤íŠ¸ í˜•ì‹)
                output += '[ ì„¸ì…˜ ì •ë³´ ]\n\n';
                output += `í˜„ìž¬ ì„¸ì…˜: ${currentSession?.name || 'ê¸°ë³¸ ì„¸ì…˜'}\n`;
                output += `ì„¸ì…˜ ID: ${currentSession?.id || 'default'}\n`;
                output += `ìƒì„± ì‹œê°„: ${currentSession?.createdAt.toLocaleString() || 'ì•Œ ìˆ˜ ì—†ìŒ'}\n`;
                output += `ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: ${currentSession?.updatedAt.toLocaleString() || 'ì•Œ ìˆ˜ ì—†ìŒ'}\n\n`;
                output += '[ LLM ì •ë³´ ]\n\n';
                output += `í˜„ìž¬ ëª¨ë¸: ${modelDisplayName}\n`;
                output += `ëª¨ë¸ ID: ${currentModel}\n\n`;
                output += '[ ë©”ëª¨ë¦¬ í†µê³„ ]\n\n';
                output += `ì´ ë©”ì‹œì§€ ìˆ˜: ${messages.length}ê°œ\n`;
                output += `ì‚¬ìš©ìž ë©”ì‹œì§€: ${userMessages}ê°œ\n`;
                output += `ì–´ì‹œìŠ¤í„´íŠ¸ ë©”ì‹œì§€: ${assistantMessages}ê°œ\n`;
                output += `ì‹œìŠ¤í…œ ë©”ì‹œì§€: ${systemMessages}ê°œ\n\n`;
                // ë©”ëª¨ë¦¬ ìƒì„¸ ì •ë³´ (ë©”ëª¨ë¦¬ í•˜ìœ„ ëª…ë ¹ì–´ì¸ ê²½ìš°)
                if (!subCommand || subCommand === 'memory' || subCommand === 'ë©”ëª¨ë¦¬') {
                    output += '[ ë©”ëª¨ë¦¬ ì„¸ë¶€ ì •ë³´ ]\n\n';
                    // ìµœê·¼ ë©”ì‹œì§€ 5ê°œ í‘œì‹œ (ì¼ë°˜ í…ìŠ¤íŠ¸ í˜•ì‹)
                    if (messages.length > 0) {
                        output += 'ìµœê·¼ ë©”ì‹œì§€ (ìµœëŒ€ 5ê°œ):\n\n';
                        const recentMessages = messages.slice(-5).reverse();
                        for (const msg of recentMessages) {
                            let role = '';
                            switch (msg.role) {
                                case 'user':
                                    role = 'ì‚¬ìš©ìž';
                                    break;
                                case 'assistant':
                                    role = 'Claude';
                                    break;
                                case 'system':
                                    role = 'ì‹œìŠ¤í…œ';
                                    break;
                                default: role = msg.role;
                            }
                            // ë‚´ìš© ì¼ë¶€ë§Œ í‘œì‹œ
                            const content = String(msg.content).replace(/<[^>]*>/g, ''); // HTML íƒœê·¸ ì œê±°
                            const truncatedContent = content.substring(0, 30) + (content.length > 30 ? '...' : '');
                            const timestamp = msg.timestamp.toLocaleTimeString();
                            output += `* ${timestamp} | ${role}: ${truncatedContent}\n`;
                        }
                        output += '\n';
                    }
                }
                // ì‚¬ìš©ìžì—ê²Œ ì •ë³´ í‘œì‹œ
                await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: output
                });
            }
            catch (error) {
                console.error('ì‹œìŠ¤í…œ ìƒíƒœ ëª…ë ¹ì–´ ì˜¤ë¥˜:', error);
                external_vscode_.window.showErrorMessage(`ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
            }
        },
        provideCompletions: (partialArgs) => {
            const subCommands = ['memory', 'ë©”ëª¨ë¦¬'];
            const parts = partialArgs.split(' ');
            // ì²« ë²ˆì§¸ ì¸ìž ìžë™ì™„ì„±
            if (parts.length <= 1) {
                return subCommands.filter(cmd => cmd.toLowerCase().startsWith(parts[0]?.toLowerCase() || ''));
            }
            return [];
        }
    });
    // íŒŒì¼ ì—´ê¸°
    commands.push({
        name: 'open',
        aliases: ['file', 'ì—´ê¸°', 'íŒŒì¼', 'íŒŒì¼ì—´ê¸°'],
        description: 'íŒŒì¼ì„ ì—½ë‹ˆë‹¤',
        examples: ['/open package.json', '/open src/index.ts', '/íŒŒì¼ì—´ê¸° package.json'],
        category: 'utility',
        priority: 20,
        execute: async (context) => {
            const filePath = context.args.join(' ');
            if (!filePath) {
                external_vscode_.window.showErrorMessage('ì—´ íŒŒì¼ ê²½ë¡œë¥¼ ì§€ì •í•´ì£¼ì„¸ìš”');
                return;
            }
            try {
                const document = await external_vscode_.workspace.openTextDocument(filePath);
                await external_vscode_.window.showTextDocument(document);
            }
            catch {
                external_vscode_.window.showErrorMessage(`íŒŒì¼ì„ ì—´ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${filePath}`);
            }
        }
    });
    // ëŒ€í™” ë‚´ì—­ ì €ìž¥ ê¸°ëŠ¥
    commands.push({
        name: 'save',
        aliases: ['stack', 'history', 'save', 'ê¸°ë¡', 'ëŒ€í™”ê¸°ë¡', 'ì €ìž¥'],
        description: 'í˜„ìž¬ ì±„íŒ… ë‚´ì—­ì„ ì €ìž¥í•˜ê³  ê´€ë¦¬í•©ë‹ˆë‹¤',
        examples: ['/save', '/stack', '/history', '/ê¸°ë¡'],
        category: 'utility',
        priority: 25,
        execute: async () => {
            try {
                // ë©”ëª¨ë¦¬ ì„œë¹„ìŠ¤ ê°€ì ¸ì˜¤ê¸°
                const memoryService = external_vscode_.extensions.getExtension('ape-team.ape-extension')?.exports?.memoryService;
                if (!memoryService) {
                    external_vscode_.window.showErrorMessage('ë©”ëª¨ë¦¬ ì„œë¹„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                // VAULT ì„œë¹„ìŠ¤ ê°€ì ¸ì˜¤ê¸°
                const vaultService = external_vscode_.extensions.getExtension('ape-team.ape-extension')?.exports?.vaultService;
                if (!vaultService) {
                    external_vscode_.window.showErrorMessage('VAULT ì„œë¹„ìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                // LLM ì„œë¹„ìŠ¤ ê°€ì ¸ì˜¤ê¸°
                const llmService = external_vscode_.extensions.getExtension('ape-team.ape-extension')?.exports?.llmService;
                // í˜„ìž¬ ë©”ì‹œì§€ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                const messagesResult = await memoryService.getMessages();
                if (!messagesResult.success || !messagesResult.data) {
                    external_vscode_.window.showErrorMessage('ëŒ€í™” ë‚´ì—­ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                const messages = messagesResult.data;
                // ëŒ€í™” ë‚´ì—­ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ë³€í™˜
                let markdown = '';
                // í˜„ìž¬ ì‹œê°„ ì¶”ê°€
                const now = new Date();
                const dateStr = now.toISOString().split('T')[0];
                const timeStr = now.toTimeString().split(' ')[0];
                const timestamp = now.toISOString();
                markdown += `## ${dateStr} ${timeStr}\n\n`;
                // ë©”ì‹œì§€ ì—­ìˆœìœ¼ë¡œ ë³€í™˜ (ìµœì‹  ë©”ì‹œì§€ê°€ ìœ„ì— ì˜¤ë„ë¡)
                for (let i = messages.length - 1; i >= 0; i--) {
                    const message = messages[i];
                    // ì‹œìŠ¤í…œ ë©”ì‹œì§€ë‚˜ ì›°ì»´ ë©”ì‹œì§€ëŠ” ê±´ë„ˆë›°ê¸°
                    if (message.role === 'system' && message.content.includes('welcome-container')) {
                        continue;
                    }
                    // ì‚¬ìš©ìžë‚˜ ì–´ì‹œìŠ¤í„´íŠ¸ ë©”ì‹œì§€ë§Œ í¬í•¨
                    if (message.role === 'user' || message.role === 'assistant') {
                        const role = message.role === 'user' ? 'ì‚¬ìš©ìž' : 'Claude';
                        // HTML íƒœê·¸ ì œê±° (ê°„ë‹¨í•œ ë°©ì‹ìœ¼ë¡œ)
                        const contentStr = message.content.replace(/<[^>]*>/g, '');
                        markdown += `**${role}**: ${contentStr}\n\n`;
                        // êµ¬ë¶„ì„  ì¶”ê°€ (ë§ˆì§€ë§‰ ë©”ì‹œì§€ ì œì™¸)
                        if (i > 0) {
                            markdown += '---\n\n';
                        }
                    }
                }
                // ì±„íŒ… ë‚´ì—­ ì œëª© ìƒì„± (LLM ì„œë¹„ìŠ¤ ì‚¬ìš©)
                let chatTitle = `ì±„íŒ… ë‚´ì—­ ${dateStr} ${timeStr}`;
                if (llmService && messages.length > 0) {
                    try {
                        // ì²« ë²ˆì§¸ ì‚¬ìš©ìž ë©”ì‹œì§€ ì°¾ê¸°
                        const firstUserMessage = messages.find((m) => m.role === 'user');
                        if (firstUserMessage) {
                            // LLMì— ìš”ì•½ ìš”ì²­
                            const summaryPrompt = `ë‹¤ìŒ ë©”ì‹œì§€ì˜ ë‚´ìš©ì„ 20ìž ì´ë‚´ì˜ í•œêµ­ì–´ ì œëª©ìœ¼ë¡œ ìš”ì•½í•´ì£¼ì„¸ìš”: "${firstUserMessage.content.replace(/<[^>]*>/g, '').slice(0, 200)}${firstUserMessage.content.length > 200 ? '...' : ''}"`;
                            const summaryResult = await llmService.getSingleCompletion(summaryPrompt);
                            if (summaryResult && summaryResult.trim()) {
                                // ìš”ì•½ ê²°ê³¼ì—ì„œ ë”°ì˜´í‘œë‚˜ ê³µë°± ì œê±°
                                chatTitle = summaryResult.trim().replace(/^["']|["']$/g, '');
                            }
                        }
                    }
                    catch (error) {
                        console.error('ì±„íŒ… ì œëª© ìƒì„± ì˜¤ë¥˜:', error);
                        // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ ì œëª© ì‚¬ìš© (ì´ë¯¸ ì„¤ì •ë¨)
                    }
                }
                // UUID ìƒì„±
                const uuid = `chat_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
                // ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ ë£¨íŠ¸ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
                const workspaceFolder = external_vscode_.workspace.workspaceFolders?.[0];
                if (!workspaceFolder) {
                    external_vscode_.window.showErrorMessage('ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                // .ape/vault/chat-history ë””ë ‰í† ë¦¬ ê²½ë¡œ í™•ì¸ ë° ìƒì„±
                const chatHistoryDir = external_path_.join(workspaceFolder.uri.fsPath, '.ape', 'vault', 'chat-history');
                const chatHistoryUri = external_vscode_.Uri.file(chatHistoryDir);
                try {
                    await external_vscode_.workspace.fs.stat(chatHistoryUri);
                }
                catch {
                    // ë””ë ‰í† ë¦¬ê°€ ì—†ìœ¼ë©´ ìƒì„±
                    await external_vscode_.workspace.fs.createDirectory(chatHistoryUri);
                }
                // ì±„íŒ… ë‚´ì—­ íŒŒì¼ ê²½ë¡œ (UUID ì‚¬ìš©)
                const chatHistoryPath = external_vscode_.Uri.joinPath(chatHistoryUri, `${uuid}.md`);
                // ë©”íƒ€ë°ì´í„° íŒŒì¼ ê²½ë¡œ
                const metadataPath = external_vscode_.Uri.joinPath(chatHistoryUri, `${uuid}.meta.json`);
                // ë©”íƒ€ë°ì´í„° ìƒì„±
                const metadata = {
                    id: uuid,
                    title: chatTitle,
                    createdAt: timestamp,
                    updatedAt: timestamp,
                    messageCount: messages.length
                };
                // íŒŒì¼ ì €ìž¥ (ì±„íŒ… ë‚´ì—­)
                await external_vscode_.workspace.fs.writeFile(chatHistoryPath, Buffer.from(markdown, 'utf8'));
                // íŒŒì¼ ì €ìž¥ (ë©”íƒ€ë°ì´í„°)
                await external_vscode_.workspace.fs.writeFile(metadataPath, Buffer.from(JSON.stringify(metadata, null, 2), 'utf8'));
                // íŠ¸ë¦¬ ë·° ìƒˆë¡œê³ ì¹¨
                try {
                    await external_vscode_.commands.executeCommand('ape.refreshTreeView');
                }
                catch (error) {
                    console.error('íŠ¸ë¦¬ ë·° ìƒˆë¡œê³ ì¹¨ ì˜¤ë¥˜:', error);
                }
                // ê²°ê³¼ë¥¼ ì±„íŒ…ì°½ì— í‘œì‹œ
                await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                    role: 'assistant',
                    content: `ëŒ€í™” ë‚´ì—­ì´ **${chatTitle}**ìœ¼ë¡œ ì €ìž¥ë˜ì—ˆìŠµë‹ˆë‹¤. ì´ ${messages.length}ê°œì˜ ë©”ì‹œì§€ê°€ ê¸°ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.

ì±„íŒ… ë‚´ì—­ì€ íŠ¸ë¦¬ ë·°ì—ì„œ í™•ì¸í•˜ê³  ê´€ë¦¬í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.`
                });
            }
            catch (error) {
                console.error('ëŒ€í™” ë‚´ì—­ ì €ìž¥ ì˜¤ë¥˜:', error);
                external_vscode_.window.showErrorMessage(`ëŒ€í™” ë‚´ì—­ ì €ìž¥ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
            }
        }
    });
    // ëŒ€í™” ë‚´ì—­ ë³´ê¸° ê¸°ëŠ¥
    commands.push({
        name: 'show',
        aliases: ['view', 'display', 'ë³´ê¸°', 'ë‚´ì—­ë³´ê¸°', 'ëŒ€í™”ë³´ê¸°'],
        description: 'ì €ìž¥ëœ ì±„íŒ… ë‚´ì—­ì„ í™•ì¸í•©ë‹ˆë‹¤',
        examples: ['/show', '/view', '/ë³´ê¸°', '/show ì±„íŒ…ID'],
        category: 'utility',
        priority: 25,
        execute: async (context) => {
            try {
                // ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ ë£¨íŠ¸ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
                const workspaceFolder = external_vscode_.workspace.workspaceFolders?.[0];
                if (!workspaceFolder) {
                    external_vscode_.window.showErrorMessage('ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                    return;
                }
                // ì±„íŒ… ë‚´ì—­ í´ë” ê²½ë¡œ (.ape/vault/chat-history)
                const chatHistoryDir = external_path_.join(workspaceFolder.uri.fsPath, '.ape', 'vault', 'chat-history');
                const chatHistoryUri = external_vscode_.Uri.file(chatHistoryDir);
                // í´ë” ì¡´ìž¬ í™•ì¸
                try {
                    await external_vscode_.workspace.fs.stat(chatHistoryUri);
                }
                catch {
                    // í´ë”ê°€ ì—†ëŠ” ê²½ìš°
                    await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                        role: 'assistant',
                        content: 'ì €ìž¥ëœ ëŒ€í™” ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤. `/save` ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¨¼ì € ëŒ€í™” ë‚´ì—­ì„ ì €ìž¥í•´ì£¼ì„¸ìš”.'
                    });
                    return;
                }
                // ì±„íŒ… ID ì§€ì • ì—¬ë¶€
                const chatId = context.args[0];
                if (chatId) {
                    // íŠ¹ì • ì±„íŒ… ë‚´ì—­ í‘œì‹œ
                    await showSpecificChat(chatId, chatHistoryUri);
                }
                else {
                    // ì €ìž¥ëœ ëª¨ë“  ì±„íŒ… ë‚´ì—­ ëª©ë¡ í‘œì‹œ
                    await showChatList(chatHistoryUri);
                }
            }
            catch (error) {
                console.error('ëŒ€í™” ë‚´ì—­ í‘œì‹œ ì˜¤ë¥˜:', error);
                external_vscode_.window.showErrorMessage(`ëŒ€í™” ë‚´ì—­ í‘œì‹œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
            }
        },
        provideCompletions: (partialArgs) => {
            // ì´ ì‹œì ì—ì„œëŠ” ê°„ë‹¨í•œ ë¹ˆ ë°°ì—´ë§Œ ë°˜í™˜
            // ì‹¤ì œ ìžë™ì™„ì„±ì€ SlashCommandManagerì—ì„œ ì²˜ë¦¬í•  ë•Œ êµ¬í˜„
            return [];
        }
    });
    /**
     * íŠ¹ì • ì±„íŒ… ë‚´ì—­ í‘œì‹œ
     * @param chatId ì±„íŒ… ID
     * @param chatHistoryUri ì±„íŒ… ë‚´ì—­ í´ë” URI
     */
    async function showSpecificChat(chatId, chatHistoryUri) {
        // ë©”íƒ€ë°ì´í„° íŒŒì¼ ê²½ë¡œ
        const metadataPath = external_vscode_.Uri.joinPath(chatHistoryUri, `${chatId}.meta.json`);
        // ì±„íŒ… ë‚´ì—­ íŒŒì¼ ê²½ë¡œ
        const chatHistoryPath = external_vscode_.Uri.joinPath(chatHistoryUri, `${chatId}.md`);
        // íŒŒì¼ ì¡´ìž¬ í™•ì¸
        try {
            await external_vscode_.workspace.fs.stat(metadataPath);
            await external_vscode_.workspace.fs.stat(chatHistoryPath);
        }
        catch {
            // íŒŒì¼ì´ ì—†ëŠ” ê²½ìš°
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: `IDê°€ '${chatId}'ì¸ ì±„íŒ… ë‚´ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`
            });
            return;
        }
        // ë©”íƒ€ë°ì´í„° ì½ê¸°
        const metadataData = await external_vscode_.workspace.fs.readFile(metadataPath);
        const metadata = JSON.parse(Buffer.from(metadataData).toString('utf8'));
        // ì±„íŒ… ë‚´ì—­ ì½ê¸°
        const fileData = await external_vscode_.workspace.fs.readFile(chatHistoryPath);
        const content = Buffer.from(fileData).toString('utf8');
        // ê²°ê³¼ë¥¼ ì±„íŒ…ì°½ì— í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## ${metadata.title}\n\n\`\`\`markdown\n${content}\n\`\`\``
        });
    }
    /**
     * ì €ìž¥ëœ ì±„íŒ… ë‚´ì—­ ëª©ë¡ í‘œì‹œ
     * @param chatHistoryUri ì±„íŒ… ë‚´ì—­ í´ë” URI
     */
    async function showChatList(chatHistoryUri) {
        // ë©”íƒ€ë°ì´í„° íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
        const files = await external_vscode_.workspace.fs.readDirectory(chatHistoryUri);
        const metaFiles = files.filter(([name]) => name.endsWith('.meta.json'));
        if (metaFiles.length === 0) {
            // ì €ìž¥ëœ ì±„íŒ… ë‚´ì—­ì´ ì—†ëŠ” ê²½ìš°
            await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
                role: 'assistant',
                content: 'ì €ìž¥ëœ ëŒ€í™” ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤. `/save` ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ë¨¼ì € ëŒ€í™” ë‚´ì—­ì„ ì €ìž¥í•´ì£¼ì„¸ìš”.'
            });
            return;
        }
        // ë©”íƒ€ë°ì´í„° ì½ê¸°
        const chatList = [];
        for (const [fileName] of metaFiles) {
            const metadataPath = external_vscode_.Uri.joinPath(chatHistoryUri, fileName);
            const metadataData = await external_vscode_.workspace.fs.readFile(metadataPath);
            const metadata = JSON.parse(Buffer.from(metadataData).toString('utf8'));
            // ë‚ ì§œ í¬ë§·íŒ…
            const createdDate = new Date(metadata.createdAt);
            const dateStr = createdDate.toLocaleDateString();
            const timeStr = createdDate.toLocaleTimeString();
            chatList.push({
                id: metadata.id,
                title: metadata.title,
                createdAt: `${dateStr} ${timeStr}`,
                messageCount: metadata.messageCount
            });
        }
        // ìµœì‹ ìˆœ ì •ë ¬
        chatList.sort((a, b) => b.id.localeCompare(a.id));
        // ë§ˆí¬ë‹¤ìš´ í…Œì´ë¸” ìƒì„±
        let output = '## ì €ìž¥ëœ ì±„íŒ… ë‚´ì—­ ëª©ë¡\n\n';
        output += '| ì œëª© | ì €ìž¥ ì‹œê°„ | ë©”ì‹œì§€ ìˆ˜ | ëª…ë ¹ì–´ |\n';
        output += '|------|-------|----------|--------|\n';
        for (const chat of chatList) {
            output += `| ${chat.title} | ${chat.createdAt} | ${chat.messageCount}ê°œ | \`/show ${chat.id}\` |\n`;
        }
        output += '\níŠ¹ì • ì±„íŒ… ë‚´ì—­ì„ ë³´ë ¤ë©´ ìœ„ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.';
        // ê²°ê³¼ë¥¼ ì±„íŒ…ì°½ì— í‘œì‹œ
        await external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: output
        });
    }
    return commands;
}

;// ./src/data/helpSystemPrompt.ts
/**
 * ë„ì›€ë§ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸
 *
 * ì´ íŒŒì¼ì€ LLMì„ í†µí•œ ìŠ¤ë§ˆíŠ¸ ë„ì›€ë§ ì‹œìŠ¤í…œì— ì‚¬ìš©ë  í”„ë¡¬í”„íŠ¸ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 */
/**
 * ê¸°ë³¸ ë„ì›€ë§ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸
 */
const HELP_SYSTEM_PROMPT = (/* unused pure expression or super */ null && (`
ë‹¹ì‹ ì€ APE(Agentic Pipeline Engine) VS Code í™•ìž¥ í”„ë¡œê·¸ëž¨ì˜ AI ë¹„ì„œìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžì—ê²Œ ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´ì™€ ê¸°ëŠ¥ì„ ì•ˆë‚´í•˜ê³  ë„ì›€ì„ ì œê³µí•´ì£¼ì„¸ìš”.

# ëª…ë ¹ì–´ ëª©ë¡

## ì¼ë°˜ ëª…ë ¹ì–´
- /help, /? - ì´ ë„ì›€ë§ í‘œì‹œ
- /clear, /cls - ì±„íŒ… ë‚´ì—­ ì§€ìš°ê¸°
- /settings, /config - ì„¤ì • íŽ˜ì´ì§€ ì—´ê¸°
- /model [ëª¨ë¸ëª…] - LLM ëª¨ë¸ ë³€ê²½ (ì˜ˆ: /model NARRNAS, /model list)

## Git ëª…ë ¹ì–´
- /git status - Git ìƒíƒœ í™•ì¸
- /git commit - ë³€ê²½ì‚¬í•­ ìžë™ ì»¤ë°‹ (ë©”ì‹œì§€ ìžë™ ìƒì„±)
- /git push - ì›ê²© ì €ìž¥ì†Œì— í‘¸ì‹œ
- /git pull - ì›ê²© ì €ìž¥ì†Œì—ì„œ í’€
- /git solve - ì¶©ëŒ ìžë™ í•´ê²°
- /git auto - ìžë™ ì»¤ë°‹ ê¸°ëŠ¥ í† ê¸€
- /git consolidate - ìž„ì‹œ ì»¤ë°‹ í†µí•©

## ì½”ë“œ ëª…ë ¹ì–´
- /analyze, /code - ì„ íƒí•œ ì½”ë“œ ë¶„ì„
- /open, /file - ì§€ì •í•œ íŒŒì¼ ì—´ê¸°

# íŠ¹ìˆ˜ ê¸°ëŠ¥
- ì¸ë¼ì¸ ì½”ë“œ ì™„ì„±: ì½”ë“œ ìž‘ì„± ì¤‘ ìžë™ìœ¼ë¡œ ë‹¤ìŒ ì½”ë“œ ì œì•ˆ
- íƒ­ ì™„ì„±: íƒ­ í‚¤ë¥¼ ëˆŒëŸ¬ ì½”ë“œ ì™„ì„± í™œì„±í™”
- ì½”ë“œ ì˜ì—­ ë³„ë„ í‘œì‹œ: ì½”ë“œ ë¸”ë¡ ì•„ëž˜ ë³µì‚¬, ì‚½ìž…, ìƒˆ íŒŒì¼ ìƒì„± ë²„íŠ¼ ì œê³µ
- ì»¨í…ìŠ¤íŠ¸ ì¸ì‹ ëª…ë ¹ì–´: í˜„ìž¬ ìž‘ì—… í™˜ê²½ì— ë§žëŠ” ëª…ë ¹ì–´ ìžë™ ì œì•ˆ

# ê¸°íƒ€ ì •ë³´
- ë²„ì „: v0.3.0
- ê°œë°œìž: APE í”„ë¡œì íŠ¸ íŒ€

ìžì„¸í•œ ì‚¬ìš©ë²•ê³¼ ì˜ˆì œëŠ” ê° ëª…ë ¹ì–´ ì„¤ëª…ì— í¬í•¨ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.
`));
/**
 * ì½”ë“œ ê´€ë ¨ ë„ì›€ë§ í”„ë¡¬í”„íŠ¸
 */
const CODE_HELP_PROMPT = (/* unused pure expression or super */ null && (`
# ì½”ë“œ ì²˜ë¦¬ ëª…ë ¹ì–´ ì‚¬ìš©ë²•

## ì½”ë“œ ë¶„ì„
- /analyze, /code - ì„ íƒí•œ ì½”ë“œë¥¼ ë¶„ì„í•˜ê³  ì„¤ëª…í•©ë‹ˆë‹¤.
  ì˜ˆ: (ì½”ë“œ ì„ íƒ í›„) /analyze

## ì½”ë“œ ìµœì í™”
- /optimize - ì„ íƒí•œ ì½”ë“œë¥¼ ìµœì í™”í•˜ê³  ê°œì„ í•©ë‹ˆë‹¤.
  ì˜ˆ: (ì½”ë“œ ì„ íƒ í›„) /optimize

## ì½”ë“œ ë¦¬íŒ©í† ë§
- /refactor - ì„ íƒí•œ ì½”ë“œë¥¼ ë¦¬íŒ©í† ë§í•˜ì—¬ í’ˆì§ˆì„ ê°œì„ í•©ë‹ˆë‹¤.
  ì˜ˆ: (ì½”ë“œ ì„ íƒ í›„) /refactor

## ì½”ë“œ ì„¤ëª…
- /explain - ì„ íƒí•œ ì½”ë“œì˜ ê¸°ëŠ¥ê³¼ ë™ìž‘ì„ ì„¤ëª…í•©ë‹ˆë‹¤.
  ì˜ˆ: (ì½”ë“œ ì„ íƒ í›„) /explain

# ì½”ë“œ ë¸”ë¡ ê¸°ëŠ¥

## ì½”ë“œ ë¸”ë¡ ìž‘ì—…
- ë³µì‚¬ ë²„íŠ¼: ì½”ë“œ ë¸”ë¡ ë‚´ìš©ì„ í´ë¦½ë³´ë“œì— ë³µì‚¬í•©ë‹ˆë‹¤.
- ì‚½ìž… ë²„íŠ¼: ì½”ë“œ ë¸”ë¡ ë‚´ìš©ì„ í˜„ìž¬ íŽ¸ì§‘ê¸°ì— ì‚½ìž…í•©ë‹ˆë‹¤.
- ìƒˆ íŒŒì¼ ë²„íŠ¼: ì½”ë“œ ë¸”ë¡ ë‚´ìš©ìœ¼ë¡œ ìƒˆ íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤.

## ì½”ë“œ ìž‘ì„± ìš”ì²­
ë‹¤ìŒê³¼ ê°™ì´ ìš”ì²­í•˜ì—¬ íŠ¹ì • ì½”ë“œë¥¼ ìƒì„±í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤:
- "TypeScriptë¡œ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ìž‘ì„±í•´ì¤„"
- "Pythonìœ¼ë¡œ íŒŒì¼ ì½ê¸° ì˜ˆì œ ë³´ì—¬ì¤„"
- "Javaë¡œ HTTP í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„í•´ì¤„"
`));
/**
 * Git ê´€ë ¨ ë„ì›€ë§ í”„ë¡¬í”„íŠ¸
 */
const GIT_HELP_PROMPT = (/* unused pure expression or super */ null && (`
# Git ëª…ë ¹ì–´ ì‚¬ìš©ë²•

## ê¸°ë³¸ Git ëª…ë ¹ì–´
- /git status - í˜„ìž¬ Git ì €ìž¥ì†Œì˜ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤.
- /git commit - ë³€ê²½ëœ íŒŒì¼ì„ ìžë™ìœ¼ë¡œ ì»¤ë°‹í•©ë‹ˆë‹¤. ì»¤ë°‹ ë©”ì‹œì§€ëŠ” ë³€ê²½ ë‚´ìš©ì„ ë¶„ì„í•˜ì—¬ ìžë™ ìƒì„±ë©ë‹ˆë‹¤.
- /git push - í˜„ìž¬ ë¸Œëžœì¹˜ì˜ ë³€ê²½ì‚¬í•­ì„ ì›ê²© ì €ìž¥ì†Œì— í‘¸ì‹œí•©ë‹ˆë‹¤.
- /git pull - ì›ê²© ì €ìž¥ì†Œì˜ ë³€ê²½ì‚¬í•­ì„ í˜„ìž¬ ë¸Œëžœì¹˜ë¡œ ê°€ì ¸ì˜µë‹ˆë‹¤.

## ê³ ê¸‰ Git ëª…ë ¹ì–´
- /git solve - ì¶©ëŒì´ ë°œìƒí•œ íŒŒì¼ì„ ìžë™ìœ¼ë¡œ í•´ê²°í•©ë‹ˆë‹¤.
- /git branch [ì´ë¦„] - ìƒˆ ë¸Œëžœì¹˜ë¥¼ ìƒì„±í•˜ê±°ë‚˜ ë¸Œëžœì¹˜ ëª©ë¡ì„ í‘œì‹œí•©ë‹ˆë‹¤.
- /git auto [on|off] - ìžë™ ì»¤ë°‹ ê¸°ëŠ¥ì„ ì¼œê±°ë‚˜ ë—ë‹ˆë‹¤. í™œì„±í™”ë˜ë©´ íŒŒì¼ ì €ìž¥ ì‹œ ìžë™ìœ¼ë¡œ ì»¤ë°‹ë©ë‹ˆë‹¤.
- /git consolidate - '[APE][Temporary]' ì ‘ë‘ì‚¬ê°€ ë¶™ì€ ì—°ì†ëœ ìž„ì‹œ ì»¤ë°‹ì„ í•˜ë‚˜ì˜ ì •ì‹ ì»¤ë°‹ìœ¼ë¡œ í†µí•©í•©ë‹ˆë‹¤.

## ì˜ˆì œ
- í˜„ìž¬ ìƒíƒœ í™•ì¸: /git status
- ë³€ê²½ì‚¬í•­ ì»¤ë°‹: /git commit
- ìžë™ ì»¤ë°‹ ì¼œê¸°: /git auto on
- ìž„ì‹œ ì»¤ë°‹ í†µí•©: /git consolidate

## ì°¸ê³ ì‚¬í•­
- ìžë™ ì»¤ë°‹ ë©”ì‹œì§€ëŠ” ë³€ê²½ ë‚´ìš©ì„ ë¶„ì„í•˜ì—¬ ìƒì„±ë©ë‹ˆë‹¤.
- ì¶©ëŒ í•´ê²°ì€ AI ê¸°ë°˜ìœ¼ë¡œ ì§„í–‰ë˜ë©°, ë³µìž¡í•œ ì¶©ëŒì€ ìˆ˜ë™ ê°œìž…ì´ í•„ìš”í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
- ë¸Œëžœì¹˜ ìƒì„± ì‹œ í˜„ìž¬ ì²´í¬ì•„ì›ƒëœ ë¸Œëžœì¹˜ì—ì„œ ë¶„ê¸°ë©ë‹ˆë‹¤.
`));
/**
 * ë„ì›€ë§ ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ ìƒì„±
 * @param helpData ë„ì›€ë§ ë°ì´í„° ê°ì²´
 * @param query ì‚¬ìš©ìž ì§ˆë¬¸
 * @returns LLMì— ì „ë‹¬í•  í”„ë¡¬í”„íŠ¸
 */
function generateHelpSystemPrompt(helpData, query) {
    return `
# APE ë„ì›€ë§ ì‹œìŠ¤í…œ - LLM ì‘ë‹µ ê°€ì´ë“œ

ë‹¹ì‹ ì€ APE(Agentic Pipeline Extension)ì˜ ë„ì›€ë§ ì‹œìŠ¤í…œìž…ë‹ˆë‹¤. ì‚¬ìš©ìžì˜ ì§ˆë¬¸ì— ëŒ€í•´ ì œê³µëœ ë„ì›€ë§ ë°ì´í„° ë‚´ì—ì„œë§Œ ì •ë³´ë¥¼ ì°¾ì•„ ì‘ë‹µí•´ì•¼ í•©ë‹ˆë‹¤. ì œê³µëœ ì •ë³´ì— ì—†ëŠ” ë‚´ìš©ì€ ì ˆëŒ€ ì¶”ê°€í•˜ì§€ ë§ˆì„¸ìš”.

## ì‘ë‹µ ì§€ì¹¨

1. ì‚¬ìš©ìž ì§ˆë¬¸ì„ ì •í™•í•˜ê²Œ ì´í•´í•˜ê³  ê´€ë ¨ ì •ë³´ë§Œ ì œê³µí•˜ì„¸ìš”.
2. ì œê³µëœ ë„ì›€ë§ ë°ì´í„°ì— ì—†ëŠ” ë‚´ìš©ì€ "í•´ë‹¹ ì •ë³´ëŠ” ì œê³µëœ ë„ì›€ë§ì— í¬í•¨ë˜ì–´ ìžˆì§€ ì•ŠìŠµë‹ˆë‹¤."ë¼ê³  ì‘ë‹µí•˜ì„¸ìš”.
3. ëª…ë ¹ì–´ ê´€ë ¨ ì§ˆë¬¸ì—ëŠ” ì‚¬ìš©ë²•, ì˜ˆì‹œ, ìƒì„¸ ì„¤ëª…ì„ í¬í•¨í•˜ì„¸ìš”.
4. ì‘ë‹µì€ ê°„ê²°í•˜ê³  ëª…í™•í•˜ê²Œ ìž‘ì„±í•˜ë˜, í•„ìš”í•œ ëª¨ë“  ì •ë³´ëŠ” í¬í•¨í•´ì•¼ í•©ë‹ˆë‹¤.
5. ì ì ˆí•œ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ì„ ì‚¬ìš©í•˜ì—¬ ê°€ë…ì„±ì„ ë†’ì´ì„¸ìš”.
6. ì§ˆë¬¸ì´ ì¼ë°˜ì ì¸ í”„ë¡œê·¸ëž˜ë°ì´ë‚˜ ë„êµ¬ì— ê´€í•œ ê²ƒì´ë¼ë©´, ë°˜ë“œì‹œ APE ì»¨í…ìŠ¤íŠ¸ ë‚´ì—ì„œë§Œ ë‹µë³€í•˜ì„¸ìš”.

## ë„ì›€ë§ ë°ì´í„°

ì´ ë°ì´í„°ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‚¬ìš©ìž ì§ˆë¬¸ì— ì‘ë‹µí•˜ì„¸ìš”:

${JSON.stringify(helpData, null, 2)}

## ì‚¬ìš©ìž ì§ˆë¬¸

ì‚¬ìš©ìž: ${query}

## ì‘ë‹µ í˜•ì‹

ì‘ë‹µ ì‹œ ë‹¤ìŒ í˜•ì‹ì„ ë”°ë¥´ì„¸ìš”:

1. ì§ˆë¬¸ ìš”ì•½ ë˜ëŠ” ì£¼ì œë¥¼ ìµœìƒë‹¨ì— H1 ë˜ëŠ” H2 ì œëª©ìœ¼ë¡œ í‘œì‹œ
2. ê´€ë ¨ ëª…ë ¹ì–´ê°€ ìžˆë‹¤ë©´ ì½”ë“œ ë¸”ë¡ìœ¼ë¡œ í‘œì‹œ (\`/command\`)
3. í•„ìš”í•œ ê²½ìš° ë‹¨ê³„ë³„ ì•ˆë‚´ ì œê³µ
4. ê´€ë ¨ ëª…ë ¹ì–´ë‚˜ ê°€ì´ë“œê°€ ìžˆë‹¤ë©´ "ê´€ë ¨ ëª…ë ¹ì–´" ë˜ëŠ” "ë” ì•Œì•„ë³´ê¸°" ì„¹ì…˜ ì¶”ê°€

ë‹µë³€ì„ ì‹œìž‘í•˜ì„¸ìš”.
`;
}
/**
 * ëª…ë ¹ì–´ì— ëŒ€í•œ ìƒì„¸ í”„ë¡¬í”„íŠ¸ ìƒì„±
 * @param commandData ëª…ë ¹ì–´ ë°ì´í„°
 * @returns LLMì— ì „ë‹¬í•  í”„ë¡¬í”„íŠ¸
 */
function generateCommandDetailPrompt(commandData) {
    return `
# APE ëª…ë ¹ì–´ ìƒì„¸ ì •ë³´ - LLM ì‘ë‹µ ê°€ì´ë“œ

ë‹¹ì‹ ì€ APE(Agentic Pipeline Extension)ì˜ ë„ì›€ë§ ì‹œìŠ¤í…œìž…ë‹ˆë‹¤. ë‹¤ìŒ ëª…ë ¹ì–´ì˜ ìƒì„¸ ì •ë³´ë¥¼ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤.

## ëª…ë ¹ì–´ ë°ì´í„°

${JSON.stringify(commandData, null, 2)}

## ì‘ë‹µ ì§€ì¹¨

ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ëª…ë ¹ì–´ ìƒì„¸ ì •ë³´ë¥¼ ì œê³µí•˜ì„¸ìš”:

1. ëª…ë ¹ì–´ ì´ë¦„ê³¼ ê°„ë‹¨í•œ ì„¤ëª…ì„ H1 ì œëª©ìœ¼ë¡œ í‘œì‹œ
2. ì‚¬ìš©ë²•ì„ ì½”ë“œ ë¸”ë¡ìœ¼ë¡œ í‘œì‹œ
3. ìƒì„¸ ì„¤ëª… ì œê³µ
4. ì˜ˆì‹œ ëª…ë ¹ì–´ ë‚˜ì—´
5. ë³„ì¹­ ëª©ë¡ ì œê³µ
6. ê´€ë ¨ ëª…ë ¹ì–´ ì œì•ˆ

ë‹µë³€ì€ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ìž‘ì„±í•˜ì„¸ìš”. ì œê³µëœ ë°ì´í„°ì— ì—†ëŠ” ë‚´ìš©ì„ ì¶”ê°€í•˜ì§€ ë§ˆì„¸ìš”.

ë‹µë³€ì„ ì‹œìž‘í•˜ì„¸ìš”.
`;
}
/**
 * FAQ ì§ˆë¬¸ì— ëŒ€í•œ í”„ë¡¬í”„íŠ¸ ìƒì„±
 * @param faqData FAQ ë°ì´í„°
 * @param query ì‚¬ìš©ìž ì§ˆë¬¸
 * @returns LLMì— ì „ë‹¬í•  í”„ë¡¬í”„íŠ¸
 */
function generateFaqPrompt(faqData, query) {
    return `
# APE FAQ ì‘ë‹µ ê°€ì´ë“œ

ë‹¹ì‹ ì€ APE(Agentic Pipeline Extension)ì˜ FAQ ì‹œìŠ¤í…œìž…ë‹ˆë‹¤. ì‚¬ìš©ìžì˜ ì§ˆë¬¸ê³¼ ê°€ìž¥ ê´€ë ¨ì„± ë†’ì€ FAQ í•­ëª©ì„ ì°¾ì•„ ì‘ë‹µí•´ì•¼ í•©ë‹ˆë‹¤.

## FAQ ë°ì´í„°

${JSON.stringify(faqData, null, 2)}

## ì‚¬ìš©ìž ì§ˆë¬¸

ì‚¬ìš©ìž: ${query}

## ì‘ë‹µ ì§€ì¹¨

1. ì§ˆë¬¸ê³¼ ê°€ìž¥ ê´€ë ¨ì„± ë†’ì€ FAQ í•­ëª©(ë“¤)ì„ ì°¾ìœ¼ì„¸ìš”.
2. FAQ ë‚´ìš©ì„ ê¸°ë°˜ìœ¼ë¡œ ì‘ë‹µí•˜ë˜, ì§ˆë¬¸ì— ë§žê²Œ ì•½ê°„ ì¡°ì •í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
3. ê´€ë ¨ FAQê°€ ì—†ë‹¤ë©´ "í•´ë‹¹ ì§ˆë¬¸ì— ê´€í•œ FAQ í•­ëª©ì´ ì—†ìŠµë‹ˆë‹¤."ë¼ê³  ì‘ë‹µí•˜ì„¸ìš”.
4. ê´€ë ¨ ëª…ë ¹ì–´ê°€ ìžˆë‹¤ë©´ í•¨ê»˜ ì œì•ˆí•˜ì„¸ìš”.

ë‹µë³€ì„ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ìž‘ì„±í•˜ì„¸ìš”.

ë‹µë³€ì„ ì‹œìž‘í•˜ì„¸ìš”.
`;
}
/**
 * ê°€ì´ë“œ ë¬¸ì„œì— ëŒ€í•œ í”„ë¡¬í”„íŠ¸ ìƒì„±
 * @param guideData ê°€ì´ë“œ ë¬¸ì„œ ë°ì´í„°
 * @param guideId ê°€ì´ë“œ ID
 * @returns LLMì— ì „ë‹¬í•  í”„ë¡¬í”„íŠ¸
 */
function generateGuidePrompt(guideData, guideId) {
    const guide = guideData.find(g => g.id === guideId);
    if (!guide) {
        return `
# APE ê°€ì´ë“œ ë¬¸ì„œ ì—ëŸ¬

ìš”ì²­í•˜ì‹  ê°€ì´ë“œ ë¬¸ì„œ(ID: ${guideId})ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë‹¤ìŒ ê°€ì´ë“œ ë¬¸ì„œê°€ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤:

${guideData.map(g => `- ${g.id}: ${g.title}`).join('\n')}

ì˜¬ë°”ë¥¸ ê°€ì´ë“œ IDë¥¼ ì„ íƒí•˜ì—¬ ë‹¤ì‹œ ìš”ì²­í•´ì£¼ì„¸ìš”.
`;
    }
    return `
# APE ê°€ì´ë“œ ë¬¸ì„œ - ${guide.title}

ë‹¤ìŒ ê°€ì´ë“œ ë¬¸ì„œ ë‚´ìš©ì„ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ì •ë¦¬í•˜ì—¬ ì œê³µí•˜ì„¸ìš”:

${guide.content}

ë‹µë³€ ì‹œ ë‹¤ìŒ ì‚¬í•­ì„ ê³ ë ¤í•˜ì„¸ìš”:
1. ë¬¸ì„œ í˜•ì‹ê³¼ êµ¬ì¡°ë¥¼ ìœ ì§€í•˜ì„¸ìš”.
2. ë‚´ìš©ì„ ë³€ê²½í•˜ê±°ë‚˜ ì¶”ê°€í•˜ì§€ ë§ˆì„¸ìš”.
3. í•„ìš”í•œ ê²½ìš° ë§ˆí¬ë‹¤ìš´ í˜•ì‹ì„ í–¥ìƒì‹œì¼œ ê°€ë…ì„±ì„ ë†’ì´ì„¸ìš”.
4. ì½”ë“œ ì˜ˆì œì™€ ëª…ë ¹ì–´ëŠ” ì ì ˆí•œ ì½”ë“œ ë¸”ë¡ìœ¼ë¡œ í‘œì‹œí•˜ì„¸ìš”.

ë‹µë³€ì„ ì‹œìž‘í•˜ì„¸ìš”.
`;
}
/**
 * ëª¨ë“  ê°€ì´ë“œ ëª©ë¡ í”„ë¡¬í”„íŠ¸ ìƒì„±
 * @param guideData ê°€ì´ë“œ ë¬¸ì„œ ë°ì´í„°
 * @returns LLMì— ì „ë‹¬í•  í”„ë¡¬í”„íŠ¸
 */
function generateGuidesListPrompt(guideData) {
    return `
# APE ê°€ì´ë“œ ë¬¸ì„œ ëª©ë¡

ë‹¤ìŒ APE ê°€ì´ë“œ ë¬¸ì„œ ëª©ë¡ì„ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ì •ë¦¬í•˜ì—¬ ì œê³µí•˜ì„¸ìš”:

${JSON.stringify(guideData, null, 2)}

ê° ê°€ì´ë“œì— ëŒ€í•´ ë‹¤ìŒ ì •ë³´ë¥¼ í¬í•¨í•˜ì„¸ìš”:
1. ê°€ì´ë“œ ì œëª©
2. ì§§ì€ ì„¤ëª… (ê°€ëŠ¥í•œ ê²½ìš°)
3. ê°€ì´ë“œ ID (ì‚¬ìš©ìžê°€ íŠ¹ì • ê°€ì´ë“œë¥¼ ìš”ì²­í•  ë•Œ ì‚¬ìš©)

ë‹µë³€ í˜•ì‹:

## APE ê°€ì´ë“œ ë¬¸ì„œ

ë‹¤ìŒ ê°€ì´ë“œ ë¬¸ì„œë¥¼ ì´ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤:

1. **[ê°€ì´ë“œ ì œëª© 1]**
   - ID: [ê°€ì´ë“œ ID]
   - [ì§§ì€ ì„¤ëª…]

2. **[ê°€ì´ë“œ ì œëª© 2]**
   - ID: [ê°€ì´ë“œ ID]
   - [ì§§ì€ ì„¤ëª…]

íŠ¹ì • ê°€ì´ë“œ ë¬¸ì„œë¥¼ ë³´ë ¤ë©´ "/help guide [ê°€ì´ë“œ ID]" ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.
ì˜ˆì‹œ: /help guide auto-commit

ë‹µë³€ì„ ì‹œìž‘í•˜ì„¸ìš”.
`;
}

;// ./src/core/commands/helpRenderer.ts
/**
 * ë„ì›€ë§ ë Œë”ëŸ¬
 *
 * ë„ì›€ë§ ë°ì´í„°ë¥¼ ì›¹ë·°ì— í‘œì‹œí•˜ê¸° ìœ„í•œ HTMLë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
 */



// vscode í™•ìž¥ ì¸ìŠ¤í„´ìŠ¤ ìºì‹œ
// í˜„ìž¬ ì‚¬ìš©ë˜ì§€ ì•Šì§€ë§Œ í–¥í›„ ì‚¬ìš© ê°€ëŠ¥ì„±ì´ ìžˆì–´ ì£¼ì„ìœ¼ë¡œ ìœ ì§€
// let _extensionContext: vscode.ExtensionContext | undefined;
/**
 * í™•ìž¥ ì»¨í…ìŠ¤íŠ¸ ì„¤ì •
 */
function setExtensionContext() {
    // ì§€ê¸ˆì€ ì‚¬ìš©ë˜ì§€ ì•Šì§€ë§Œ í–¥í›„ í™•ìž¥ì„±ì„ ìœ„í•´ ìœ ì§€
    // ë§¤ê°œë³€ìˆ˜ë„ ì œê±°
}
/**
 * ì¹´í…Œê³ ë¦¬ë³„ ë¯¸ë‹ˆë©€ ì•„ì´ì½˜ ê°€ì ¸ì˜¤ê¸°
 * @param category ì¹´í…Œê³ ë¦¬ ID
 * @returns ë¯¸ë‹ˆë©€ ì•„ì´ì½˜
 */
/* í˜„ìž¬ ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” í•¨ìˆ˜ì´ì§€ë§Œ í–¥í›„ ì‚¬ìš© ê°€ëŠ¥ì„±ì´ ìžˆì–´ ì£¼ì„ìœ¼ë¡œ ìœ ì§€
function getCategorySimpleIcon(category: string): string {
  switch (category) {
    case 'general':
      return 'â—';  // ì¼ë°˜ ëª…ë ¹ì–´ - ì‹¬í”Œí•œ ì›í˜•
    case 'git':
      return 'â—†';  // Git ëª…ë ¹ì–´ - ë‹¤ì´ì•„ëª¬ë“œ
    case 'code':
      return 'â–¢';  // ì½”ë“œ ê´€ë ¨ - ì‚¬ê°í˜•
    case 'utility':
      return 'â—ˆ';  // ìœ í‹¸ë¦¬í‹° - íŠ¹ìˆ˜ ë¬¸ìž
    case 'advanced':
      return 'â—Ž';  // ê³ ê¸‰ ì„¤ì • - ì´ì¤‘ ì›í˜•
    default:
      return 'â—‹';  // ê¸°ë³¸ê°’ - ë¹ˆ ì›í˜•
  }
}
*/
/**
 * Codicon CSS íŒŒì¼ì— ëŒ€í•œ URI ê°€ì ¸ì˜¤ê¸°
 */
function getCodiconCssUri() {
    const extension = external_vscode_.extensions.getExtension('ape-team.ape-extension');
    if (!extension) {
        throw new Error('APE í™•ìž¥ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
    }
    return external_vscode_.Uri.joinPath(extension.extensionUri, 'media', 'codicon', 'codicon.css');
}

// ë„ì›€ë§ ë°ì´í„° ìºì‹œ
let helpDataCache = null;
/**
 * ë„ì›€ë§ ë°ì´í„° ë¡œë“œ
 * @returns ë„ì›€ë§ ë°ì´í„° ê°ì²´
 */
async function loadHelpData() {
    if (helpDataCache) {
        return helpDataCache;
    }
    try {
        const extensionPath = external_vscode_.extensions.getExtension('ape-team.ape-extension')?.extensionPath;
        if (!extensionPath) {
            throw new Error('í™•ìž¥ í”„ë¡œê·¸ëž¨ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        }
        const helpFilePath = external_path_.join(extensionPath, 'src', 'data', 'help.json');
        const helpDataStr = external_fs_.readFileSync(helpFilePath, 'utf8');
        helpDataCache = JSON.parse(helpDataStr);
        return helpDataCache;
    }
    catch (error) {
        console.error('ë„ì›€ë§ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
        throw new Error('ë„ì›€ë§ ë°ì´í„°ë¥¼ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
    }
}
/**
 * íŠ¹ì • ëª…ë ¹ì–´ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
 * @param commandName ëª…ë ¹ì–´ ì´ë¦„
 * @returns ëª…ë ¹ì–´ ë°ì´í„° ê°ì²´
 */
async function getCommandData(commandName) {
    try {
        const helpData = await loadHelpData();
        // ëª¨ë“  ì¹´í…Œê³ ë¦¬ ê²€ìƒ‰
        for (const category of helpData.categories) {
            // ì¹´í…Œê³ ë¦¬ ë‚´ ëª…ë ¹ì–´ ê²€ìƒ‰
            for (const command of category.commands) {
                // ëª…ë ¹ì–´ ì´ë¦„ ë˜ëŠ” ë³„ì¹­ ë§¤ì¹­
                if (command.name === commandName || (command.aliases && command.aliases.includes(commandName))) {
                    return {
                        ...command,
                        category: category.id,
                        categoryName: category.name
                    };
                }
            }
        }
        return null;
    }
    catch (error) {
        console.error('ëª…ë ¹ì–´ ë°ì´í„° ê²€ìƒ‰ ì˜¤ë¥˜:', error);
        return null;
    }
}
/**
 * ì¹´í…Œê³ ë¦¬ë³„ ëª…ë ¹ì–´ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
 * @param categoryId ì¹´í…Œê³ ë¦¬ ID (ì˜µì…˜)
 * @returns ì¹´í…Œê³ ë¦¬ë³„ ëª…ë ¹ì–´ ëª©ë¡
 */
async function getCommandsByCategory(categoryId) {
    try {
        const helpData = await loadHelpData();
        // íŠ¹ì • ì¹´í…Œê³ ë¦¬ ìš”ì²­ ì‹œ
        if (categoryId) {
            const category = helpData.categories.find((c) => c.id === categoryId);
            return category ? [category] : [];
        }
        // ëª¨ë“  ì¹´í…Œê³ ë¦¬ ë°˜í™˜
        return helpData.categories;
    }
    catch (error) {
        console.error('ì¹´í…Œê³ ë¦¬ë³„ ëª…ë ¹ì–´ ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
        return [];
    }
}
/**
 * ë„ì›€ë§ HTML ìƒì„± (ê¸°ë³¸ ì¹´í…Œê³ ë¦¬ ëª©ë¡)
 * @param categoryId ì¹´í…Œê³ ë¦¬ ID (ì˜µì…˜)
 * @returns HTML ë¬¸ìžì—´
 */
async function generateHelpHtml(categoryId) {
    try {
        const categories = await getCommandsByCategory(categoryId);
        let content = `
      <h1>APE ë„ì›€ë§</h1>
      <p>ì‚¬ìš© ê°€ëŠ¥í•œ ëª…ë ¹ì–´ ëª©ë¡ìž…ë‹ˆë‹¤. ê° ëª…ë ¹ì–´ì— ëŒ€í•œ ìžì„¸í•œ ì •ë³´ë¥¼ ë³´ë ¤ë©´ ëª…ë ¹ì–´ë¥¼ í´ë¦­í•˜ì„¸ìš”.</p>
      
      <div class="quick-actions">
        <h2>ìžì£¼ ì‚¬ìš©í•˜ëŠ” ëª…ë ¹ì–´</h2>
        <div class="quick-buttons">
          <button class="quick-button git" onclick="sendCommandToVSCode('git status')">
            <span class="codicon codicon-git-commit"></span>Git ìƒíƒœ
          </button>
          <button class="quick-button code" onclick="sendCommandToVSCode('analyze')">
            <span class="codicon codicon-code"></span>ì½”ë“œ ë¶„ì„
          </button>
          <button class="quick-button utility" onclick="sendCommandToVSCode('clear')">
            <span class="codicon codicon-clear-all"></span>ì±„íŒ… ì§€ìš°ê¸°
          </button>
          <button class="quick-button model" onclick="sendCommandToVSCode('model list')">
            <span class="codicon codicon-settings-gear"></span>ëª¨ë¸ ì„ íƒ
          </button>
        </div>
      </div>
    `;
        // ì¹´í…Œê³ ë¦¬ë³„ ëª…ë ¹ì–´ ëª©ë¡
        for (const category of categories) {
            content += `
        <div class="help-category">
          <h2>${category.name}</h2>
          <p>${category.description || ''}</p>
          <div class="command-grid">
      `;
            // ì¹´í…Œê³ ë¦¬ ë‚´ ëª…ë ¹ì–´
            for (const command of category.commands) {
                // ëª…ë ¹ì–´ ì•„ì´ì½˜ ì„ íƒ
                const iconName = getCategoryIcon(category.id);
                // ëª…ë ¹ì–´ ìš”ì•½ ì¹´ë“œ
                content += `
          <div class="command-card" onclick="sendCommandToVSCode('${command.name}')">
            <div class="command-name">
              <span class="command-icon codicon codicon-${iconName}"></span>
              <span class="command-text">/${command.name}</span>
            </div>
            <div class="command-description">${command.description}</div>
            ${command.examples && command.examples.length > 0 ?
                    `<div class="command-examples">ì˜ˆì‹œ: ${command.examples[0]}</div>` : ''}
            ${command.aliases && command.aliases.length > 0 ?
                    `<div class="command-aliases">ë³„ì¹­: ${command.aliases.map((a) => `/${a}`).join(', ')}</div>` : ''}
          </div>
        `;
            }
            content += `
          </div>
        </div>
      `;
        }
        // ì „ì²´ HTML ëž˜í•‘
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('ë„ì›€ë§ HTML ìƒì„± ì˜¤ë¥˜:', error);
        return getHelpPageHtml(`
      <h1>ë„ì›€ë§ ë¡œë“œ ì˜¤ë¥˜</h1>
      <p>ë„ì›€ë§ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}</p>
    `);
    }
}
/**
 * ëª…ë ¹ì–´ ìƒì„¸ ì •ë³´ HTML ìƒì„±
 * @param commandName ëª…ë ¹ì–´ ì´ë¦„
 * @returns HTML ë¬¸ìžì—´
 */
async function generateCommandDetailHtml(commandName) {
    try {
        const commandData = await getCommandData(commandName);
        if (!commandData) {
            return getHelpPageHtml(`
        <h1>ëª…ë ¹ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ</h1>
        <p>'${commandName}' ëª…ë ¹ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
        <p><a href="#" onclick="sendCommandToVSCode('help')">ëª¨ë“  ëª…ë ¹ì–´ ë³´ê¸°</a></p>
      `);
        }
        let content = `
      <div class="command-detail">
        <h1>/${commandData.name}</h1>
        <div class="command-description">${commandData.description}</div>
        
        <h2>ìƒì„¸ ì •ë³´</h2>
        <p>${commandData.longDescription || commandData.description}</p>
        
        <h2>ì‚¬ìš©ë²•</h2>
        <div class="command-usage">
          <code>${commandData.usage || `/${commandData.name}`}</code>
        </div>
    `;
        // ì˜ˆì‹œ
        if (commandData.examples && commandData.examples.length > 0) {
            content += `
        <h2>ì˜ˆì‹œ</h2>
        <ul class="command-examples-list">
          ${commandData.examples.map((example) => `<li><code>${example}</code></li>`).join('')}
        </ul>
      `;
        }
        // ë³„ì¹­
        if (commandData.aliases && commandData.aliases.length > 0) {
            content += `
        <h2>ë³„ì¹­</h2>
        <div class="command-aliases">
          ${commandData.aliases.map((alias) => `<code>/${alias}</code>`).join(', ')}
        </div>
      `;
        }
        // ê´€ë ¨ ëª…ë ¹ì–´
        if (commandData.related && commandData.related.length > 0) {
            content += `
        <h2>ê´€ë ¨ ëª…ë ¹ì–´</h2>
        <div class="related-commands">
          ${commandData.related.map((cmd) => `<a href="#" class="related-command" onclick="sendCommandToVSCode('${cmd}')">${cmd}</a>`).join(', ')}
        </div>
      `;
        }
        content += `
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">â† ëª¨ë“  ëª…ë ¹ì–´ ë³´ê¸°</a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('ëª…ë ¹ì–´ ìƒì„¸ ì •ë³´ HTML ìƒì„± ì˜¤ë¥˜:', error);
        return getHelpPageHtml(`
      <h1>ëª…ë ¹ì–´ ì •ë³´ ë¡œë“œ ì˜¤ë¥˜</h1>
      <p>ëª…ë ¹ì–´ ì •ë³´ë¥¼ ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}</p>
    `);
    }
}
/**
 * FAQ HTML ìƒì„±
 * @returns HTML ë¬¸ìžì—´
 */
async function generateFaqHtml() {
    try {
        const helpData = await loadHelpData();
        const faqs = helpData.faq || [];
        let content = `
      <h1>APE ìžì£¼ ë¬»ëŠ” ì§ˆë¬¸ (FAQ)</h1>
      <div class="faq-list">
    `;
        for (const faq of faqs) {
            content += `
        <div class="faq-item">
          <div class="faq-question">${faq.question}</div>
          <div class="faq-answer">${faq.answer}</div>
        </div>
      `;
        }
        content += `
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">â† ë„ì›€ë§ë¡œ ëŒì•„ê°€ê¸°</a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('FAQ HTML ìƒì„± ì˜¤ë¥˜:', error);
        return getHelpPageHtml(`
      <h1>FAQ ë¡œë“œ ì˜¤ë¥˜</h1>
      <p>FAQ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}</p>
    `);
    }
}
/**
 * ê°€ì´ë“œ ë¬¸ì„œ HTML ìƒì„±
 * @param guideId ê°€ì´ë“œ ID
 * @returns HTML ë¬¸ìžì—´
 */
async function generateGuideHtml(guideId) {
    try {
        const helpData = await loadHelpData();
        const guides = helpData.guides || [];
        const guide = guides.find((g) => g.id === guideId);
        if (!guide) {
            return getHelpPageHtml(`
        <h1>ê°€ì´ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ</h1>
        <p>'${guideId}' ê°€ì´ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.</p>
        <p><a href="#" onclick="sendCommandToVSCode('help guides')">ëª¨ë“  ê°€ì´ë“œ ë³´ê¸°</a></p>
      `);
        }
        // ë§ˆí¬ë‹¤ìš´ í˜•ì‹ ê·¸ëŒ€ë¡œ í‘œì‹œ
        const content = `
      <div class="guide-content markdown-body">
        ${guide.content}
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help guides')">â† ëª¨ë“  ê°€ì´ë“œ ë³´ê¸°</a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('ê°€ì´ë“œ HTML ìƒì„± ì˜¤ë¥˜:', error);
        return getHelpPageHtml(`
      <h1>ê°€ì´ë“œ ë¡œë“œ ì˜¤ë¥˜</h1>
      <p>ê°€ì´ë“œ ë°ì´í„°ë¥¼ ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}</p>
    `);
    }
}
/**
 * ëª¨ë“  ê°€ì´ë“œ ëª©ë¡ HTML ìƒì„±
 * @returns HTML ë¬¸ìžì—´
 */
async function generateGuidesListHtml() {
    try {
        const helpData = await loadHelpData();
        const guides = helpData.guides || [];
        let content = `
      <h1>APE ê°€ì´ë“œ ë¬¸ì„œ</h1>
      <p>ì‚¬ìš© ê°€ëŠ¥í•œ ê°€ì´ë“œ ë¬¸ì„œ ëª©ë¡ìž…ë‹ˆë‹¤. ê° ê°€ì´ë“œì— ëŒ€í•œ ìžì„¸í•œ ì •ë³´ë¥¼ ë³´ë ¤ë©´ ì œëª©ì„ í´ë¦­í•˜ì„¸ìš”.</p>
      <div class="guides-list">
    `;
        for (const guide of guides) {
            content += `
        <div class="guide-item">
          <h2 class="guide-title">
            <a href="#" onclick="sendCommandToVSCode('help guide ${guide.id}')">${guide.title}</a>
          </h2>
          <div class="guide-description">
            ${guide.content.split('\n')[0].replace(/^#+\s+.*$/, '')}
          </div>
        </div>
      `;
        }
        content += `
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">â† ë„ì›€ë§ë¡œ ëŒì•„ê°€ê¸°</a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('ê°€ì´ë“œ ëª©ë¡ HTML ìƒì„± ì˜¤ë¥˜:', error);
        return getHelpPageHtml(`
      <h1>ê°€ì´ë“œ ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜</h1>
      <p>ê°€ì´ë“œ ëª©ë¡ì„ ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}</p>
    `);
    }
}
/**
 * LLMì„ ì‚¬ìš©í•œ ìŠ¤ë§ˆíŠ¸ ë„ì›€ë§ ìƒì„±
 * @param query ì‚¬ìš©ìž ì§ˆë¬¸
 * @param llmService LLM ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
 * @returns HTML ë¬¸ìžì—´
 */
async function generateSmartHelpHtml(query, llmService) {
    try {
        const helpData = await loadHelpData();
        // LLM í”„ë¡¬í”„íŠ¸ ìƒì„±
        const prompt = generateHelpSystemPrompt(helpData, query);
        // LLMì— ì§ˆë¬¸ ì „ì†¡
        const result = await llmService.getCompletion(prompt);
        if (!result.success || !result.data) {
            throw new Error(result.error?.message || 'LLM ì‘ë‹µì„ ë°›ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
        }
        // ë§ˆí¬ë‹¤ìš´ ì‘ë‹µì„ HTMLë¡œ ë³€í™˜
        const markdownResponse = result.data;
        const content = `
      <div class="smart-help">
        <h1>APE ë„ì›€ë§ - ${escapeHtml(query)}</h1>
        <div class="markdown-body">
          ${markdownToHtml(markdownResponse)}
        </div>
      </div>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">â† ë„ì›€ë§ë¡œ ëŒì•„ê°€ê¸°</a>
      </div>
    `;
        return getHelpPageHtml(content);
    }
    catch (error) {
        console.error('ìŠ¤ë§ˆíŠ¸ ë„ì›€ë§ ìƒì„± ì˜¤ë¥˜:', error);
        return getHelpPageHtml(`
      <h1>ë„ì›€ë§ ì‘ë‹µ ì˜¤ë¥˜</h1>
      <p>ë„ì›€ë§ì„ ìƒì„±í•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}</p>
      <p><a href="#" onclick="sendCommandToVSCode('help')">ë„ì›€ë§ë¡œ ëŒì•„ê°€ê¸°</a></p>
    `);
    }
}
/**
 * ë„ì›€ë§ íŽ˜ì´ì§€ HTML ëž˜í•‘
 * @param content ë‚´ìš© HTML
 * @returns ì™„ì„±ëœ HTML ë¬¸ìžì—´
 */
function getHelpPageHtml(content) {
    return `
    <!DOCTYPE html>
    <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>APE ë„ì›€ë§</title>
      <link rel="stylesheet" href="${getCodiconCssUri().toString()}" />
      <style>
        :root {
          --bg-color: var(--vscode-editor-background, #ffffff);
          --text-color: var(--vscode-editor-foreground, #333333);
          --link-color: var(--vscode-textLink-foreground, #3794ff);
          --heading-color: var(--vscode-editor-foreground, #333333);
          --border-color: var(--vscode-panel-border, #e7e7e7);
          --accent-color: var(--vscode-button-background, #0e639c);
          --accent-hover-color: var(--vscode-button-hoverBackground, #1177bb);
          --card-bg-color: var(--vscode-editor-inactiveSelectionBackground, #f5f5f5);
          --code-bg-color: var(--vscode-textBlockQuote-background, #f1f1f1);
        }
        
        body {
          font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
          line-height: 1.6;
          color: var(--text-color);
          background-color: var(--bg-color);
          margin: 0;
          padding: 20px;
          max-width: 1000px;
          margin: 0 auto;
        }
        
        h1, h2, h3, h4, h5, h6 {
          color: var(--heading-color);
          margin-top: 24px;
          margin-bottom: 16px;
          font-weight: 600;
          line-height: 1.25;
        }
        
        h1 {
          font-size: 2em;
          padding-bottom: 0.3em;
          border-bottom: 1px solid var(--border-color);
        }
        
        h2 {
          font-size: 1.5em;
          padding-bottom: 0.3em;
        }
        
        a {
          color: var(--link-color);
          text-decoration: none;
        }
        
        a:hover {
          text-decoration: underline;
        }
        
        p {
          margin-top: 0;
          margin-bottom: 16px;
        }
        
        code {
          font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, Courier, monospace;
          padding: 0.2em 0.4em;
          margin: 0;
          font-size: 85%;
          background-color: var(--code-bg-color);
          border-radius: 3px;
        }
        
        pre {
          background-color: var(--code-bg-color);
          border-radius: 3px;
          padding: 16px;
          overflow: auto;
        }
        
        pre code {
          background-color: transparent;
          padding: 0;
          margin: 0;
          font-size: 100%;
          word-break: normal;
          white-space: pre;
        }
        
        ul, ol {
          margin-top: 0;
          margin-bottom: 16px;
          padding-left: 2em;
        }
        
        li {
          margin-top: 0.25em;
        }
        
        .help-category {
          margin-bottom: 30px;
        }
        
        .command-grid {
          display: grid;
          grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
          gap: 12px;
          margin-bottom: 20px;
        }
        
        .command-card {
          background-color: var(--card-bg-color);
          border-radius: 8px;
          padding: 16px;
          cursor: pointer;
          transition: all 0.2s ease;
          border: 1px solid var(--border-color);
          box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
          position: relative;
          overflow: hidden;
        }
        
        .command-card:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          border-color: var(--accent-color);
        }
        
        .command-card::before {
          content: '';
          position: absolute;
          top: 0;
          left: 0;
          width: 4px;
          height: 100%;
          background-color: var(--accent-color);
          opacity: 0;
          transition: opacity 0.2s ease;
        }
        
        .command-card:hover::before {
          opacity: 1;
        }
        
        .clickable-command {
          cursor: pointer;
          transition: all 0.2s ease;
        }
        
        .clickable-command:hover {
          color: var(--accent-color);
          text-decoration: underline;
        }
        
        .command-name {
          font-weight: bold;
          margin-bottom: 10px;
          color: var(--accent-color);
          font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, Courier, monospace;
          font-size: 1.1em;
          display: flex;
          align-items: center;
        }
        
        .command-description {
          margin-bottom: 10px;
          color: var(--text-color);
          line-height: 1.4;
        }
        
        .command-examples {
          font-size: 0.85em;
          color: var(--vscode-descriptionForeground, #747474);
          font-style: italic;
          padding: 4px 0;
        }
        
        .command-aliases {
          font-size: 0.85em;
          color: var(--vscode-descriptionForeground, #747474);
          background-color: var(--code-bg-color);
          border-radius: 3px;
          padding: 2px 6px;
          display: inline-block;
          margin-top: 4px;
        }
        
        .command-icon {
          font-size: 1em;
          margin-right: 6px;
          position: relative;
          top: 1px;
        }
        
        .command-text {
          font-weight: bold;
        }
        
        .command-usage {
          margin-bottom: 16px;
        }
        
        .command-aliases, .related-commands {
          margin-bottom: 16px;
        }
        
        .related-command {
          margin-right: 8px;
        }
        
        .back-link {
          margin-top: 24px;
          padding-top: 16px;
          border-top: 1px solid var(--border-color);
        }
        
        .faq-list {
          margin-top: 24px;
        }
        
        .faq-item {
          margin-bottom: 24px;
          border-bottom: 1px solid var(--border-color);
          padding-bottom: 16px;
        }
        
        .faq-question {
          font-weight: 600;
          font-size: 1.2em;
          margin-bottom: 8px;
          color: var(--accent-color);
        }
        
        .guides-list {
          margin-top: 24px;
        }
        
        .guide-item {
          margin-bottom: 24px;
          border-bottom: 1px solid var(--border-color);
          padding-bottom: 16px;
        }
        
        .guide-title {
          margin-bottom: 8px;
        }
        
        .guide-description {
          margin-bottom: 8px;
        }
        
        .markdown-body {
          line-height: 1.6;
        }
        
        .markdown-body img {
          max-width: 100%;
          box-sizing: content-box;
        }
        
        .markdown-body blockquote {
          padding: 0 1em;
          color: var(--vscode-editor-foreground, #6a737d);
          border-left: 0.25em solid var(--vscode-panel-border, #dfe2e5);
          margin: 0 0 16px 0;
        }
        
        .markdown-body table {
          display: block;
          width: 100%;
          overflow: auto;
          border-collapse: collapse;
          margin-bottom: 16px;
        }
        
        .markdown-body table th,
        .markdown-body table td {
          padding: 6px 13px;
          border: 1px solid var(--vscode-panel-border, #dfe2e5);
        }
        
        .markdown-body table tr {
          background-color: var(--bg-color);
          border-top: 1px solid var(--vscode-panel-border, #c6cbd1);
        }
        
        .markdown-body table tr:nth-child(2n) {
          background-color: var(--vscode-editor-inactiveSelectionBackground, #f6f8fa);
        }
        
        /* í€µ ì•¡ì…˜ ìŠ¤íƒ€ì¼ */
        .quick-actions {
          margin: 20px 0 30px;
          background-color: var(--vscode-editor-inactiveSelectionBackground, #f6f8fa);
          border-radius: 8px;
          padding: 16px;
          border: 1px solid var(--border-color);
        }
        
        .quick-actions h2 {
          margin-top: 0;
          font-size: 1.3em;
          color: var(--accent-color);
          padding-left: 4px;
        }
        
        .quick-buttons {
          display: flex;
          flex-wrap: wrap;
          gap: 10px;
        }
        
        .quick-button {
          display: flex;
          align-items: center;
          padding: 8px 16px;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 500;
          border: none;
          min-width: 120px;
          font-size: 0.95em;
          transition: all 0.2s ease;
          color: white;
        }
        
        .quick-button:hover {
          transform: translateY(-2px);
          box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }
        
        .quick-button .codicon {
          margin-right: 8px;
          font-size: 1.2em;
        }
        
        .quick-button.git {
          background-color: #F05033;
        }
        
        .quick-button.code {
          background-color: #007ACC;
        }
        
        .quick-button.utility {
          background-color: #6C757D;
        }
        
        .quick-button.model {
          background-color: #28A745;
        }
      </style>
    </head>
    <body>
      <div class="help-content">
        ${content}
      </div>
      
      <script>
        // VS Code APIì™€ í†µì‹ 
        const vscode = acquireVsCodeApi();
        
        // ëª…ë ¹ì–´ VS Codeë¡œ ì „ì†¡
        function sendCommandToVSCode(command) {
          vscode.postMessage({
            type: 'command',
            command: command
          });
        }
        
        // ì±„íŒ…ì°½ì— ëª…ë ¹ì–´ ìž…ë ¥
        function insertCommandToChatInput(command) {
          vscode.postMessage({
            type: 'insertCommand',
            command: command
          });
        }
        
        // ëª…ë ¹ì–´ ì¹´ë“œ í´ë¦­ ì‹œ ëª…ë ¹ì–´ ìž…ë ¥
        document.addEventListener('click', (event) => {
          const target = event.target;
          
          // ëª…ë ¹ì–´ ì¹´ë“œ í´ë¦­ ì²˜ë¦¬
          const commandCard = target.closest('.command-card');
          if (commandCard) {
            const cmdName = commandCard.querySelector('.command-name')?.textContent;
            if (cmdName) {
              insertCommandToChatInput(cmdName);
            }
          }
          
          // A íƒœê·¸ ì´ë²¤íŠ¸ ì²˜ë¦¬
          if (target.tagName === 'A' && target.getAttribute('href') === '#') {
            event.preventDefault();
            // ì´ë²¤íŠ¸ ì²˜ë¦¬ëŠ” ê° ìš”ì†Œì˜ onclickì—ì„œ ì²˜ë¦¬
          }
        });
        
        // ì½”ë“œ ë¸”ë¡ ë‚´ ëª…ë ¹ì–´ í´ë¦­ ì²˜ë¦¬
        document.querySelectorAll('code').forEach(codeElement => {
          if (codeElement.textContent.startsWith('/')) {
            codeElement.classList.add('clickable-command');
            codeElement.addEventListener('click', () => {
              insertCommandToChatInput(codeElement.textContent);
            });
          }
        });
      </script>
    </body>
    </html>
  `;
}
/**
 * HTML ì´ìŠ¤ì¼€ì´í”„
 * @param unsafe ì´ìŠ¤ì¼€ì´í”„í•  ë¬¸ìžì—´
 * @returns ì´ìŠ¤ì¼€ì´í”„ëœ ë¬¸ìžì—´
 */
function escapeHtml(unsafe) {
    return unsafe
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}
/**
 * ì¹´í…Œê³ ë¦¬ë³„ Codicon ì•„ì´ì½˜ ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
 * @param category ì¹´í…Œê³ ë¦¬ ID
 * @returns Codicon ì•„ì´ì½˜ ì´ë¦„
 */
function getCategoryIcon(category) {
    switch (category) {
        case 'general':
            return 'info';
        case 'git':
            return 'git-commit';
        case 'code':
            return 'code';
        case 'utility':
            return 'tools';
        case 'advanced':
            return 'settings-gear';
        default:
            return 'symbol-event';
    }
}
/**
 * ë„êµ¬ë³„ ë¯¸ë‹ˆë©€ ì•„ì´ì½˜ ê°€ì ¸ì˜¤ê¸°
 * @param toolName ë„êµ¬ ì´ë¦„
 * @returns ë¯¸ë‹ˆë©€ ì•„ì´ì½˜
 */
function getToolEmoji(toolName) {
    switch (toolName) {
        case 'Bash':
            return 'â–¶'; // í„°ë¯¸ë„ ì‹¤í–‰
        case 'Batch':
            return 'â§‰'; // ë³‘ë ¬ ì‹¤í–‰
        case 'Glob':
            return 'â—Ž'; // ê²€ìƒ‰ ì¡°íšŒ
        case 'Grep':
            return 'âŒ•'; // ë‚´ìš© ê²€ìƒ‰
        case 'LS':
            return 'âŠž'; // ë””ë ‰í† ë¦¬ ëª©ë¡
        case 'Read':
            return 'â—¯'; // íŒŒì¼ ì½ê¸°
        case 'Edit':
            return 'âœŽ'; // íŽ¸ì§‘
        case 'MultiEdit':
            return 'â§ '; // ë‹¤ì¤‘ íŽ¸ì§‘
        case 'Write':
            return 'âŠ•'; // ìƒˆ íŒŒì¼ ìƒì„±
        case 'TodoRead':
            return 'â˜°'; // í• ì¼ ëª©ë¡
        case 'TodoWrite':
            return 'âœ“'; // í• ì¼ ì™„ë£Œ
        case 'WebFetch':
            return 'â‡¥'; // ì›¹ ê°€ì ¸ì˜¤ê¸°
        case 'WebSearch':
            return 'âŒ•'; // ì›¹ ê²€ìƒ‰
        case 'Task':
            return 'â—ˆ'; // ìž‘ì—… ì‹¤í–‰
        default:
            return 'â—‡'; // ê¸°ë³¸ ë„êµ¬
    }
}
/**
 * ë§ˆí¬ë‹¤ìš´ì„ HTMLë¡œ ë³€í™˜ (ê°„ë‹¨ êµ¬í˜„)
 */
function markdownToHtml(markdown) {
    return markdown
        // í—¤ë” ë³€í™˜
        .replace(/^# (.+)$/gm, '<h1>$1</h1>')
        .replace(/^## (.+)$/gm, '<h2>$1</h2>')
        .replace(/^### (.+)$/gm, '<h3>$1</h3>')
        .replace(/^#### (.+)$/gm, '<h4>$1</h4>')
        .replace(/^##### (.+)$/gm, '<h5>$1</h5>')
        .replace(/^###### (.+)$/gm, '<h6>$1</h6>')
        // ì½”ë“œ ë¸”ë¡ ë³€í™˜
        .replace(/```([a-z]*)\n([\s\S]*?)\n```/g, '<pre><code class="language-$1">$2</code></pre>')
        // ì¸ë¼ì¸ ì½”ë“œ ë³€í™˜
        .replace(/`([^`]+)`/g, '<code>$1</code>')
        // ë³¼ë“œ í…ìŠ¤íŠ¸ ë³€í™˜
        .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
        .replace(/__([^_]+)__/g, '<strong>$1</strong>')
        // ì´íƒ¤ë¦­ í…ìŠ¤íŠ¸ ë³€í™˜
        .replace(/\*([^*]+)\*/g, '<em>$1</em>')
        .replace(/_([^_]+)_/g, '<em>$1</em>')
        // ëª©ë¡ ë³€í™˜
        .replace(/^- (.+)$/gm, '<li>$1</li>')
        .replace(/^([0-9]+)\. (.+)$/gm, '<li>$2</li>')
        .replace(/(<li>.*<\/li>\n)+/g, '<ul>$&</ul>')
        // ë§í¬ ë³€í™˜
        .replace(/\[([^\]]+)\]\(([^)]+)\)/g, '<a href="$2">$1</a>')
        // ì¤„ë°”ê¿ˆ ë³€í™˜
        .replace(/\n\n/g, '</p><p>')
        .replace(/\n/g, '<br>')
        // ë‹¨ë½ ê°ì‹¸ê¸°
        .replace(/^(.+?)(?=<\/p>|<h[1-6]|<ul>|$)/s, '<p>$1</p>');
}
/**
 * Agent ë„êµ¬ ëª©ë¡ HTML ìƒì„±
 * @returns HTML ë¬¸ìžì—´
 */
async function generateToolsHelpHtml() {
    try {
        // ë„êµ¬ íŽ˜ì´ì§€ ìŠ¤íƒ€ì¼
        const toolsPageStyle = `
      .tools-page {
        max-width: 900px;
        margin: 0 auto;
        padding: 10px 0;
      }
      
      .tools-page h1 {
        text-align: center;
        margin-bottom: 30px;
        color: var(--vscode-editor-foreground);
        font-size: 32px;
      }
      
      .tools-page p {
        text-align: center;
        margin-bottom: 40px;
        line-height: 1.6;
        color: var(--text-color);
        opacity: 0.8;
      }
      
      .tools-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 24px;
        margin-bottom: 40px;
      }
      
      .tool-card {
        background-color: var(--bg-color);
        border-radius: var(--modern-radius);
        padding: 24px;
        box-shadow: var(--modern-card-shadow);
        transition: var(--modern-transition);
        border: 1px solid rgba(0, 0, 0, 0.05);
        cursor: pointer;
        position: relative;
        overflow: hidden;
      }
      
      .tool-card::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 4px;
        background: linear-gradient(90deg, var(--modern-accent), #7C4DFF);
        opacity: 0;
        transition: opacity 0.3s ease;
      }
      
      .tool-card:hover {
        transform: translateY(-5px);
        box-shadow: 0 8px 24px rgba(0, 0, 0, 0.12);
      }
      
      .tool-card:hover::before {
        opacity: 1;
      }
      
      .tool-header {
        display: flex;
        align-items: center;
        margin-bottom: 16px;
      }
      
      .tool-icon {
        margin-right: 12px;
        font-size: 24px;
        color: var(--modern-accent);
        background-color: var(--modern-accent-light);
        width: 40px;
        height: 40px;
        border-radius: 10px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: var(--modern-transition);
      }
      
      .tool-card:hover .tool-icon {
        transform: scale(1.1);
        background-color: var(--modern-accent);
        color: white;
      }
      
      .tool-icon-svg {
        width: 24px;
        height: 24px;
        filter: var(--vscode-editor-foreground-filter, none);
      }
      
      .tool-name {
        font-size: 18px;
        font-weight: 600;
        color: var(--heading-color);
      }
      
      .tool-description {
        font-size: 14px;
        color: var(--text-color);
        opacity: 0.8;
        line-height: 1.6;
        margin-bottom: 16px;
      }
      
      .tool-examples {
        background-color: var(--card-bg-color);
        border-radius: 8px;
        padding: 10px;
      }
      
      .tool-examples-title {
        font-size: 13px;
        font-weight: 600;
        color: var(--heading-color);
        margin-bottom: 8px;
      }
      
      .tool-examples-list {
        font-size: 12px;
        color: var(--text-color);
        opacity: 0.8;
        line-height: 1.5;
      }
      
      .tool-examples-list li {
        margin-bottom: 4px;
      }
      
      /* ë‹¤í¬ ëª¨ë“œ ì¡°ì • */
      .vscode-dark .tool-card {
        background-color: var(--bg-color);
        border-color: rgba(255, 255, 255, 0.1);
      }
      
      .vscode-dark .tool-examples {
        background-color: rgba(30, 30, 30, 0.6);
      }
      
      /* ë°˜ì‘í˜• */
      @media (max-width: 768px) {
        .tools-grid {
          grid-template-columns: 1fr;
        }
      }
    `;
        // ë„êµ¬ ë°ì´í„° ëª©ë¡
        const tools = [
            {
                name: 'Bash',
                description: 'ì‰˜ ëª…ë ¹ì„ ì‹¤í–‰í•˜ì—¬ íŒŒì¼ ì‹œìŠ¤í…œì„ ì¡°ìž‘í•˜ê³  ì‹œìŠ¤í…œ ìž‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.',
                icon: 'terminal',
                examples: ['ë””ë ‰í„°ë¦¬ ë‚´ìš© ë‚˜ì—´', 'íŒŒì¼ ì´ë™ ë° ë³µì‚¬', 'ì‹œìŠ¤í…œ ì •ë³´ ì¡°íšŒ']
            },
            {
                name: 'Batch',
                description: 'ì—¬ëŸ¬ ë„êµ¬ í˜¸ì¶œì„ ë³‘ë ¬ë¡œ ì‹¤í–‰í•˜ì—¬ ìž‘ì—… ì†ë„ë¥¼ í–¥ìƒì‹œí‚µë‹ˆë‹¤.',
                icon: 'layers',
                examples: ['ì—¬ëŸ¬ íŒŒì¼ ë™ì‹œ ì½ê¸°', 'ë³µìˆ˜ Bash ëª…ë ¹ ì‹¤í–‰', 'ë³‘ë ¬ ê²€ìƒ‰ ìˆ˜í–‰']
            },
            {
                name: 'Glob',
                description: 'íŒ¨í„´ ë§¤ì¹­ì„ ì‚¬ìš©í•˜ì—¬ íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ íŒŒì¼ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.',
                icon: 'filter',
                examples: ['.js íŒŒì¼ ì°¾ê¸°', 'íŠ¹ì • ë””ë ‰í„°ë¦¬ ë‚´ íŒŒì¼ ê²€ìƒ‰', 'ì œì™¸ íŒ¨í„´ ì‚¬ìš©']
            },
            {
                name: 'Grep',
                description: 'íŒŒì¼ ë‚´ìš©ì—ì„œ ì •ê·œì‹ íŒ¨í„´ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.',
                icon: 'search',
                examples: ['í•¨ìˆ˜ ì •ì˜ ì°¾ê¸°', 'ì˜¤ë¥˜ ë©”ì‹œì§€ ê²€ìƒ‰', 'ì½”ë“œ íŒ¨í„´ ì‹ë³„']
            },
            {
                name: 'LS',
                description: 'ë””ë ‰í„°ë¦¬ ë‚´ìš©ì„ ë‚˜ì—´í•˜ì—¬ íŒŒì¼ê³¼ í´ë”ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤.',
                icon: 'folder-opened',
                examples: ['ë””ë ‰í„°ë¦¬ êµ¬ì¡° í™•ì¸', 'ìˆ¨ê²¨ì§„ íŒŒì¼ í‘œì‹œ', 'íŒŒì¼ ë©”íƒ€ë°ì´í„° í™•ì¸']
            },
            {
                name: 'Read',
                description: 'íŒŒì¼ ë‚´ìš©ì„ ì½ì–´ í…ìŠ¤íŠ¸ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.',
                icon: 'preview',
                examples: ['ì†ŒìŠ¤ ì½”ë“œ ì½ê¸°', 'êµ¬ì„± íŒŒì¼ ê²€ì‚¬', 'ë¡œê·¸ íŒŒì¼ ë¶„ì„']
            },
            {
                name: 'Edit',
                description: 'íŒŒì¼ ë‚´ìš©ì„ ìˆ˜ì •í•˜ê³  ë³€ê²½ ì‚¬í•­ì„ ì €ìž¥í•©ë‹ˆë‹¤.',
                icon: 'edit',
                examples: ['ì½”ë“œ ë²„ê·¸ ìˆ˜ì •', 'êµ¬ì„± ì„¤ì • ì—…ë°ì´íŠ¸', 'ë¬¸ì„œ ìˆ˜ì •']
            },
            {
                name: 'MultiEdit',
                description: 'ì—¬ëŸ¬ íŽ¸ì§‘ ìž‘ì—…ì„ ë‹¨ì¼ íŒŒì¼ì— ì›ìžì ìœ¼ë¡œ ì ìš©í•©ë‹ˆë‹¤.',
                icon: 'multiple-edit',
                examples: ['ì—¬ëŸ¬ ì½”ë“œ ì„¹ì…˜ ìˆ˜ì •', 'í´ëž˜ìŠ¤/í•¨ìˆ˜ ì´ë¦„ ë³€ê²½', 'ì—¬ëŸ¬ ë²„ê·¸ í•œ ë²ˆì— ìˆ˜ì •']
            },
            {
                name: 'Write',
                description: 'ìƒˆ íŒŒì¼ì„ ìƒì„±í•˜ê±°ë‚˜ ê¸°ì¡´ íŒŒì¼ì„ ë®ì–´ì”ë‹ˆë‹¤.',
                icon: 'new-file',
                examples: ['ìƒˆ ì†ŒìŠ¤ íŒŒì¼ ìƒì„±', 'êµ¬ì„± íŒŒì¼ ìž‘ì„±', 'ë¡œê·¸ íŒŒì¼ ìƒì„±']
            },
            {
                name: 'WebFetch',
                description: 'ì›¹ URLì—ì„œ ì½˜í…ì¸ ë¥¼ ê°€ì ¸ì™€ ë¶„ì„í•©ë‹ˆë‹¤.',
                icon: 'globe',
                examples: ['API ë¬¸ì„œ ì½ê¸°', 'ì›¹ íŽ˜ì´ì§€ ì½˜í…ì¸  ë¶„ì„', 'ì™¸ë¶€ ë°ì´í„° ê°€ì ¸ì˜¤ê¸°']
            },
            {
                name: 'WebSearch',
                description: 'ì¸í„°ë„·ì—ì„œ ìµœì‹  ì •ë³´ë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤.',
                icon: 'web-search',
                examples: ['ê¸°ìˆ  ë¬¸ì„œ ì°¾ê¸°', 'ì˜¤ë¥˜ ì†”ë£¨ì…˜ ê²€ìƒ‰', 'ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‚¬ìš©ë²• ê²€ìƒ‰']
            },
            {
                name: 'TodoRead',
                description: 'ì„¸ì…˜ì˜ í˜„ìž¬ í•  ì¼ ëª©ë¡ì„ ì½ìŠµë‹ˆë‹¤.',
                icon: 'list-selection',
                examples: ['ìž‘ì—… ì§„í–‰ ìƒí™© í™•ì¸', 'ë‚¨ì€ ìž‘ì—… íŒŒì•…', 'ìž‘ì—… ìš°ì„ ìˆœìœ„ í™•ì¸']
            },
            {
                name: 'TodoWrite',
                description: 'í•  ì¼ ëª©ë¡ì„ ì—…ë°ì´íŠ¸í•˜ê³  ìž‘ì—… ìƒíƒœë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.',
                icon: 'checklist',
                examples: ['ìƒˆ ìž‘ì—… ì¶”ê°€', 'ìž‘ì—… ìƒíƒœ ì—…ë°ì´íŠ¸', 'ì™„ë£Œëœ ìž‘ì—… í‘œì‹œ']
            },
            {
                name: 'Task',
                description: 'í•˜ìœ„ ì—ì´ì „íŠ¸ë¥¼ ì‹¤í–‰í•˜ì—¬ ë…ë¦½ì ì¸ ìž‘ì—…ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤.',
                icon: 'agent',
                examples: ['ì½”ë“œë² ì´ìŠ¤ ê²€ìƒ‰', 'ë³µìž¡í•œì˜ ìž‘ì—… ìœ„ìž„', 'ë°°ê²½ ë¶„ì„ ìˆ˜í–‰']
            }
        ];
        // HTML ìƒì„±
        let content = `
      <div class="tools-page">
        <h1>APE ì§€ì› ë„êµ¬</h1>
        <p>APEì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìžˆëŠ” ë‹¤ì–‘í•œ Agent ë„êµ¬ ëª©ë¡ìž…ë‹ˆë‹¤. ì´ëŸ¬í•œ ë„êµ¬ë¥¼ í™œìš©í•˜ì—¬ ì½”ë“œ ìž‘ì„±, ê²€ìƒ‰, ë¶„ì„ ë“± ë‹¤ì–‘í•œ ìž‘ì—…ì„ ìˆ˜í–‰í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.</p>
        
        <div class="tools-grid">
    `;
        // ê° ë„êµ¬ë³„ ì¹´ë“œ ìƒì„±
        for (const tool of tools) {
            // ë¯¸ë‹ˆë©€ ì•„ì´ì½˜ ì‚¬ìš©
            const iconEmoji = getToolEmoji(tool.name);
            const iconHtml = `<div class="tool-icon minimal-icon">${iconEmoji}</div>`;
            content += `
        <div class="tool-card">
          <div class="tool-header">
            ${iconHtml}
            <div class="tool-name">${tool.name}</div>
          </div>
          <div class="tool-description">${tool.description}</div>
          
          <div class="tool-examples">
            <div class="tool-examples-title">ì£¼ìš” ì‚¬ìš© ì‚¬ë¡€</div>
            <ul class="tool-examples-list">
              ${tool.examples.map(ex => `<li>${ex}</li>`).join('')}
            </ul>
          </div>
        </div>
      `;
        }
        content += `
        </div>
        
        <div class="back-link">
          <a href="#" onclick="sendCommandToVSCode('help')">â† ë„ì›€ë§ë¡œ ëŒì•„ê°€ê¸°</a>
        </div>
      </div>
    `;
        // ì „ì²´ HTML ìƒì„±
        return getHelpPageHtml(toolsPageStyle + content);
    }
    catch (error) {
        console.error('Agent ë„êµ¬ HTML ìƒì„± ì˜¤ë¥˜:', error);
        return getHelpPageHtml(`
      <h1>ë„êµ¬ ëª©ë¡ ë¡œë“œ ì˜¤ë¥˜</h1>
      <p>ë„êµ¬ ëª©ë¡ì„ ë¡œë“œí•˜ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}</p>
      <div class="back-link">
        <a href="#" onclick="sendCommandToVSCode('help')">â† ë„ì›€ë§ë¡œ ëŒì•„ê°€ê¸°</a>
      </div>
    `);
    }
}

;// ./src/core/commands/slashCommandManager.ts
/**
 * ìŠ¬ëž˜ì‹œ ì»¤ë§¨ë“œ ë§¤ë‹ˆì €
 *
 * ì±„íŒ… ì¸í„°íŽ˜ì´ìŠ¤ì—ì„œ ìŠ¬ëž˜ì‹œ(/)ë¡œ ì‹œìž‘í•˜ëŠ” ëª…ë ¹ì–´ë¥¼ ì²˜ë¦¬í•˜ëŠ” ì‹œìŠ¤í…œ
 */





/**
 * ìŠ¬ëž˜ì‹œ ì»¤ë§¨ë“œ ë§¤ë‹ˆì € í´ëž˜ìŠ¤
 */
class SlashCommandManager {
    context;
    llmService;
    services;
    // ë“±ë¡ëœ ëª…ë ¹ì–´ ëª©ë¡
    commands = new Map();
    // ëª…ë ¹ì–´ ë³„ì¹­ ë§µ
    aliasMap = new Map();
    // í•œêµ­ì–´ ëª…ë ¹ì–´ ë§µ (í•œêµ­ì–´ ëª…ë ¹ì–´ -> ì˜ì–´ ëª…ë ¹ì–´ ì´ë¦„)
    koreanCommandMap = new Map();
    // ì˜ë„ ê¸°ë°˜ ë§¤í•‘ (í†µí•©ëœ intentMap)
    intentMap = {};
    // ì´ë²¤íŠ¸ ì´ë¯¸í„°
    _onDidSuggestCommands = new external_vscode_.EventEmitter();
    /**
     * ëª…ë ¹ì–´ ì œì•ˆ ì´ë²¤íŠ¸
     */
    onDidSuggestCommands = this._onDidSuggestCommands.event;
    /**
     * ìƒì„±ìž
     */
    constructor(context, llmService, services) {
        this.context = context;
        this.llmService = llmService;
        this.services = services;
        // í™•ìž¥ ì»¨í…ìŠ¤íŠ¸ ì„¤ì • (ë„ì›€ë§ ë Œë”ëŸ¬ì— ì „ë‹¬)
        setExtensionContext();
        // ê¸°ë³¸ ëª…ë ¹ì–´ ë“±ë¡
        this.registerDefaultCommands();
        // ëª…ë ¹ì–´ ë“±ë¡
        this.registerVSCodeCommands();
    }
    /**
     * ê¸°ë³¸ ëª…ë ¹ì–´ ë“±ë¡
     */
    registerDefaultCommands() {
        createDefaultCommands(this.services).forEach(command => {
            this.registerCommand(command);
        });
    }
    /**
     * VS Code ëª…ë ¹ì–´ ë“±ë¡
     */
    registerVSCodeCommands() {
        // ë„ì›€ë§ ëª…ë ¹ì–´ ë“±ë¡
        const showHelpCommand = external_vscode_.commands.registerCommand('ape.showCommandHelp', (category) => {
            this.showCommandHelp(category);
        });
        // 'executeSlashCommand'ëŠ” CommandManagerì—ì„œ ì´ë¯¸ ë“±ë¡ë˜ë¯€ë¡œ ì—¬ê¸°ì„œëŠ” ì œê±°
        // ì¤‘ë³µ ë“±ë¡ìœ¼ë¡œ ì¸í•œ ì¶©ëŒ ë°©ì§€
        // Git ìƒíƒœ í‘œì‹œ ëª…ë ¹ì–´
        const showGitStatus = external_vscode_.commands.registerCommand('ape.git.showStatus', () => {
            this.showGitStatus();
        });
        // ëª…ë ¹ì–´ ë“±ë¡ í•´ì œ
        this.context.subscriptions.push(showHelpCommand, showGitStatus);
    }
    /**
     * ëª…ë ¹ì–´ ë“±ë¡
     */
    registerCommand(command) {
        // ê¸°ë³¸ ëª…ë ¹ì–´ ë“±ë¡
        this.commands.set(command.name, command);
        // ë³„ì¹­ ë“±ë¡
        if (command.aliases) {
            command.aliases.forEach(alias => {
                this.aliasMap.set(alias, command.name);
            });
        }
        // BilingualCommandì¸ ê²½ìš° í•œêµ­ì–´ ì§€ì› ë“±ë¡
        if (this.isBilingualCommand(command)) {
            this.registerBilingualCommand(command);
        }
    }
    /**
     * ì´ì¤‘ ì–¸ì–´ ëª…ë ¹ì–´ ë“±ë¡
     * BilingualCommand ì¸í„°íŽ˜ì´ìŠ¤ë¡œ ì •ì˜ëœ ëª…ë ¹ì–´ì— ëŒ€í•œ í•œêµ­ì–´ ì§€ì›ì„ ë“±ë¡í•©ë‹ˆë‹¤.
     */
    registerBilingualCommand(command) {
        // í•œêµ­ì–´ ê¸°ë³¸ ëª…ë ¹ì–´ ë“±ë¡ (ìžˆëŠ” ê²½ìš°)
        if (command.koreanName) {
            this.koreanCommandMap.set(command.koreanName, command.name);
            // ì˜ë„ ë§µì—ë„ ì¶”ê°€
            this.intentMap[command.koreanName] = command.name;
        }
        // í•œêµ­ì–´ ë³„ì¹­ ë“±ë¡
        if (command.koreanAliases) {
            command.koreanAliases.forEach(alias => {
                this.koreanCommandMap.set(alias, command.name);
                // ì˜ë„ ë§µì—ë„ ì¶”ê°€
                this.intentMap[alias] = command.name;
            });
        }
        // ì˜ë„ ë§¤í•‘ ë“±ë¡ (ìžˆëŠ” ê²½ìš°)
        if (command.intentMap) {
            // ëª…ë ¹ì–´ê°€ ì œê³µí•˜ëŠ” ì˜ë„ ë§µ ë³‘í•©
            Object.entries(command.intentMap).forEach(([intent, cmd]) => {
                this.intentMap[intent] = cmd;
            });
        }
    }
    /**
     * ëª…ë ¹ì–´ê°€ BilingualCommand ì¸í„°íŽ˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•˜ëŠ”ì§€ í™•ì¸
     */
    isBilingualCommand(command) {
        return ('koreanName' in command ||
            'koreanAliases' in command ||
            'koreanDescription' in command ||
            'koreanExamples' in command ||
            'intentMap' in command);
    }
    /**
     * ëª¨ë“  ëª…ë ¹ì–´ ê°€ì ¸ì˜¤ê¸°
     */
    getAllCommands() {
        return Array.from(this.commands.values());
    }
    /**
     * íŠ¹ì • ëª…ë ¹ì–´ ê°€ì ¸ì˜¤ê¸°
     */
    getCommand(name) {
        // ì§ì ‘ ëª…ë ¹ì–´ ì´ë¦„ìœ¼ë¡œ ì°¾ê¸°
        if (this.commands.has(name)) {
            return this.commands.get(name);
        }
        // ë³„ì¹­ìœ¼ë¡œ ì°¾ê¸°
        const originalName = this.aliasMap.get(name);
        if (originalName) {
            return this.commands.get(originalName);
        }
        return undefined;
    }
    /**
     * ìœ ì‚¬ ëª…ë ¹ì–´ ì°¾ê¸°
     *
     * ë ˆë²¤ìŠˆíƒ€ì¸ ê±°ë¦¬ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ìž…ë ¥ëœ ëª…ë ¹ì–´ì™€ ê°€ìž¥ ìœ ì‚¬í•œ ëª…ë ¹ì–´ë¥¼ ì°¾ìŠµë‹ˆë‹¤.
     * @param name ìž…ë ¥ëœ ëª…ë ¹ì–´ ì´ë¦„
     * @param maxDistance ìµœëŒ€ í—ˆìš© ê±°ë¦¬ (ê¸°ë³¸ê°’: 2)
     * @returns ê°€ìž¥ ìœ ì‚¬í•œ ëª…ë ¹ì–´ ëª©ë¡ (ê±°ë¦¬ ì˜¤ë¦„ì°¨ìˆœ)
     */
    findSimilarCommands(name, maxDistance = 2) {
        const result = [];
        // ëª¨ë“  ëª…ë ¹ì–´ ë° ë³„ì¹­ê³¼ ë¹„êµ
        for (const command of this.getAllCommands()) {
            // ë©”ì¸ ëª…ë ¹ì–´ ë¹„êµ
            const distance = this.levenshteinDistance(name, command.name);
            if (distance <= maxDistance) {
                result.push({ command, distance });
            }
            // ë³„ì¹­ ë¹„êµ
            if (command.aliases) {
                for (const alias of command.aliases) {
                    const aliasDistance = this.levenshteinDistance(name, alias);
                    if (aliasDistance <= maxDistance && aliasDistance < distance) {
                        // ë³„ì¹­ì´ ë” ìœ ì‚¬í•˜ë©´ ê¸°ì¡´ í•­ëª© ëŒ€ì²´
                        const existing = result.findIndex(r => r.command === command);
                        if (existing >= 0) {
                            result[existing].distance = aliasDistance;
                        }
                        else {
                            result.push({ command, distance: aliasDistance });
                        }
                    }
                }
            }
        }
        // ê±°ë¦¬ ê¸°ì¤€ ì •ë ¬ (ê°€ìž¥ ìœ ì‚¬í•œ ê²ƒë¶€í„°)
        return result.sort((a, b) => a.distance - b.distance);
    }
    /**
     * ë ˆë²¤ìŠˆíƒ€ì¸ ê±°ë¦¬ ê³„ì‚°
     *
     * ë‘ ë¬¸ìžì—´ ê°„ì˜ íŽ¸ì§‘ ê±°ë¦¬ë¥¼ ê³„ì‚°í•©ë‹ˆë‹¤. ê°’ì´ ìž‘ì„ìˆ˜ë¡ ë¬¸ìžì—´ì´ ìœ ì‚¬í•©ë‹ˆë‹¤.
     * @param a ì²« ë²ˆì§¸ ë¬¸ìžì—´
     * @param b ë‘ ë²ˆì§¸ ë¬¸ìžì—´
     * @returns íŽ¸ì§‘ ê±°ë¦¬
     */
    levenshteinDistance(a, b) {
        // ê³µë°± ì œê±° ë° ì†Œë¬¸ìž ë³€í™˜
        a = a.toLowerCase().trim();
        b = b.toLowerCase().trim();
        if (a === b)
            return 0;
        if (a.length === 0)
            return b.length;
        if (b.length === 0)
            return a.length;
        // ë§¤íŠ¸ë¦­ìŠ¤ ìƒì„±
        const matrix = Array(a.length + 1).fill(null).map(() => Array(b.length + 1).fill(null));
        // ì²« í–‰ê³¼ ì—´ ì´ˆê¸°í™”
        for (let i = 0; i <= a.length; i++) {
            matrix[i][0] = i;
        }
        for (let j = 0; j <= b.length; j++) {
            matrix[0][j] = j;
        }
        // í–‰ë ¬ ì±„ìš°ê¸°
        for (let i = 1; i <= a.length; i++) {
            for (let j = 1; j <= b.length; j++) {
                const cost = a[i - 1] === b[j - 1] ? 0 : 1;
                matrix[i][j] = Math.min(matrix[i - 1][j] + 1, // ì‚­ì œ
                matrix[i][j - 1] + 1, // ì‚½ìž…
                matrix[i - 1][j - 1] + cost // ëŒ€ì²´
                );
            }
        }
        return matrix[a.length][b.length];
    }
    /**
     * í•œê¸€ ì˜ë„ ê¸°ë°˜ ëª…ë ¹ì–´ ë§¤ì¹­ (ê°œì„ ëœ ë²„ì „)
     *
     * í•œê¸€ë¡œ ëœ ìžì—°ì–´ ìž…ë ¥ì„ ì˜ë„ì— ë§žëŠ” ëª…ë ¹ì–´ë¡œ ë§¤í•‘í•©ë‹ˆë‹¤.
     * ìžì—°ì–´ ì´í•´ ê¸°ëŠ¥ìœ¼ë¡œ ì‚¬ìš©ìž ì˜ë„ì— ë§žëŠ” ëª…ë ¹ì–´ë¥¼ ì°¾ì•„ëƒ…ë‹ˆë‹¤.
     * @param input ì‚¬ìš©ìž ìž…ë ¥ (ìŠ¬ëž˜ì‹œ í¬í•¨)
     * @returns ë§¤ì¹­ëœ ëª…ë ¹ì–´ ë˜ëŠ” undefined
     */
    matchCommandByIntent(input) {
        // ì˜ë„ ë¬¸êµ¬ì™€ ëª…ë ¹ì–´ ì´ë¦„ ë§¤í•‘
        const intentMap = {
            // ë„ì›€ë§ ê´€ë ¨
            'ë­í•´ì•¼í•´': 'help', // ë­ í•´ì•¼ í• ì§€ ëª¨ë¥´ê² ìŒ â†’ ë„ì›€ë§
            'ë­ë¶€í„°í•´ì•¼í•´': 'help', // ë¬´ì—‡ë¶€í„° í•´ì•¼í• ì§€ â†’ ë„ì›€ë§ 
            'ë„ì™€ì¤˜': 'help', // ë„ì™€ì¤˜ â†’ ë„ì›€ë§
            'ëª…ë ¹ì–´': 'help', // ëª…ë ¹ì–´ í™•ì¸ â†’ ë„ì›€ë§
            'ì–´ë–»ê²Œ': 'help', // ì–´ë–»ê²Œ ì‚¬ìš©í•˜ì§€ â†’ ë„ì›€ë§
            'ì‚¬ìš©ë²•': 'help', // ì‚¬ìš©ë²• â†’ ë„ì›€ë§
            'ê¸°ëŠ¥': 'help', // ê¸°ëŠ¥ â†’ ë„ì›€ë§
            'ë©”ë‰´': 'help', // ë©”ë‰´ â†’ ë„ì›€ë§
            'ë„ì›€': 'help', // ë„ì›€ â†’ ë„ì›€ë§
            'ì•ˆë‚´': 'help', // ì•ˆë‚´ â†’ ë„ì›€ë§
            'ì‚¬ìš©ë°©ë²•': 'help', // ì‚¬ìš© ë°©ë²• â†’ ë„ì›€ë§
            'ê¸°ëŠ¥ëª©ë¡': 'help', // ê¸°ëŠ¥ ëª©ë¡ â†’ ë„ì›€ë§
            'ì„¤ëª…ì„œ': 'help', // ì„¤ëª…ì„œ â†’ ë„ì›€ë§
            'ê°€ì´ë“œ': 'help', // ê°€ì´ë“œ â†’ ë„ì›€ë§
            'íŠœí† ë¦¬ì–¼': 'help', // íŠœí† ë¦¬ì–¼ â†’ ë„ì›€ë§
            'ë„ì›€ë§': 'help', // ë„ì›€ë§ â†’ ë„ì›€ë§
            'ì–´ë–»ê²Œì‚¬ìš©': 'help', // ì–´ë–»ê²Œ ì‚¬ìš© â†’ ë„ì›€ë§
            'ì‚¬ìš©ë°©ì‹': 'help', // ì‚¬ìš© ë°©ì‹ â†’ ë„ì›€ë§
            'ì‹œìž‘í•˜ê¸°': 'help', // ì‹œìž‘í•˜ê¸° â†’ ë„ì›€ë§
            'ížŒíŠ¸': 'help', // ížŒíŠ¸ â†’ ë„ì›€ë§
            'ë„ì›€ì£¼ì„¸ìš”': 'help', // ë„ì›€ ì£¼ì„¸ìš” â†’ ë„ì›€ë§ (ì‹ ê·œ)
            'ì‚¬ìš©ë²•ì•Œë ¤ì¤˜': 'help', // ì‚¬ìš©ë²• ì•Œë ¤ì¤˜ â†’ ë„ì›€ë§ (ì‹ ê·œ)
            'ì–´ë–»ê²Œì“°ëŠ”ê±°ì•¼': 'help', // ì–´ë–»ê²Œ ì“°ëŠ”ê±°ì•¼ â†’ ë„ì›€ë§ (ì‹ ê·œ)
            'ì–´ë–»ê²Œìž‘ë™í•´': 'help', // ì–´ë–»ê²Œ ìž‘ë™í•´ â†’ ë„ì›€ë§ (ì‹ ê·œ)
            'ì‚¬ìš©ì„¤ëª…': 'help', // ì‚¬ìš© ì„¤ëª… â†’ ë„ì›€ë§ (ì‹ ê·œ)
            // ë©”ëª¨ë¦¬ ê´€ë ¨
            'ê¸°ì–µí•´': 'memory', // ê¸°ì–µí•´ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ì €ìž¥í•´': 'memory', // ì €ìž¥í•´ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ë©”ëª¨': 'memory', // ë©”ëª¨ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ë…¸íŠ¸': 'memory', // ë…¸íŠ¸ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ê¸°ë¡': 'memory', // ê¸°ë¡ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ë©”ëª¨ë¦¬': 'memory', // ë©”ëª¨ë¦¬ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ë‚´ìš©ì €ìž¥': 'memory', // ë‚´ìš© ì €ìž¥ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ê¸°ë¡ì €ìž¥': 'memory', // ê¸°ë¡ ì €ìž¥ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ì ì–´ë‘¬': 'memory', // ì ì–´ë‘¬ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ë©”ëª¨ìž¥': 'memory', // ë©”ëª¨ìž¥ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ì €ìž¥ì†Œ': 'memory', // ì €ìž¥ì†Œ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ë¶ë§ˆí¬': 'memory', // ë¶ë§ˆí¬ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ë©”ëª¨í•´ì¤˜': 'memory', // ë©”ëª¨í•´ì¤˜ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ê¸°ì–µ': 'memory', // ê¸°ì–µ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ì €ìž¥': 'memory', // ì €ìž¥ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            'ë©”ëª¨ì €ìž¥': 'memory', // ë©”ëª¨ ì €ìž¥ â†’ ë©”ëª¨ë¦¬ ì €ìž¥
            // VAULT ê´€ë ¨ (ë³¼íŠ¸ ì‹œìŠ¤í…œ)
            'ë³¼íŠ¸': 'vault', // ë³¼íŠ¸ â†’ vault
            'ê¸ˆê³ ': 'vault', // ê¸ˆê³  â†’ vault
            'ì»¨í…ìŠ¤íŠ¸': 'vault', // ì»¨í…ìŠ¤íŠ¸ â†’ vault
            'ë¬¸ë§¥': 'vault', // ë¬¸ë§¥ â†’ vault
            'ìžë£Œì €ìž¥ì†Œ': 'vault', // ìžë£Œì €ìž¥ì†Œ â†’ vault
            'ìžë£Œë³´ê´€': 'vault', // ìžë£Œë³´ê´€ â†’ vault
            'ë³¼íŠ¸ì €ìž¥': 'vault save', // ë³¼íŠ¸ì €ìž¥ â†’ vault save
            'ë³¼íŠ¸ëª©ë¡': 'vault list', // ë³¼íŠ¸ëª©ë¡ â†’ vault list
            'ë³¼íŠ¸ì¡°íšŒ': 'vault list', // ë³¼íŠ¸ì¡°íšŒ â†’ vault list
            'ë³¼íŠ¸ë‚´ìš©': 'vault show', // ë³¼íŠ¸ë‚´ìš© â†’ vault show
            'ì»¨í…ìŠ¤íŠ¸ì €ìž¥': 'vault save', // ì»¨í…ìŠ¤íŠ¸ì €ìž¥ â†’ vault save
            'ë³¼íŠ¸ê²€ìƒ‰': 'vault search', // ë³¼íŠ¸ê²€ìƒ‰ â†’ vault search
            'ë³¼íŠ¸ì°¾ê¸°': 'vault search', // ë³¼íŠ¸ì°¾ê¸° â†’ vault search
            'ì»¨í…ìŠ¤íŠ¸ì°¾ê¸°': 'vault search', // ì»¨í…ìŠ¤íŠ¸ì°¾ê¸° â†’ vault search
            'ë³¼íŠ¸ìƒì„±': 'vault create', // ë³¼íŠ¸ìƒì„± â†’ vault create
            'ë³¼íŠ¸ë§Œë“¤ê¸°': 'vault create', // ë³¼íŠ¸ë§Œë“¤ê¸° â†’ vault create
            'ì»¨í…ìŠ¤íŠ¸ìƒì„±': 'vault create', // ì»¨í…ìŠ¤íŠ¸ìƒì„± â†’ vault create
            'ë³¼íŠ¸ì‚­ì œ': 'vault delete', // ë³¼íŠ¸ì‚­ì œ â†’ vault delete
            'ë³¼íŠ¸ì§€ìš°ê¸°': 'vault delete', // ë³¼íŠ¸ì§€ìš°ê¸° â†’ vault delete
            'ì»¨í…ìŠ¤íŠ¸ì‚­ì œ': 'vault delete', // ì»¨í…ìŠ¤íŠ¸ì‚­ì œ â†’ vault delete
            'ë³¼íŠ¸ì‚¬ìš©': 'vault use', // ë³¼íŠ¸ì‚¬ìš© â†’ vault use
            'ë³¼íŠ¸ê°€ì ¸ì˜¤ê¸°': 'vault use', // ë³¼íŠ¸ê°€ì ¸ì˜¤ê¸° â†’ vault use
            'ì»¨í…ìŠ¤íŠ¸ì‚¬ìš©': 'vault use', // ì»¨í…ìŠ¤íŠ¸ì‚¬ìš© â†’ vault use
            // Git ê´€ë ¨
            'ê¹ƒìƒíƒœ': 'git status', // ê¹ƒ ìƒíƒœ â†’ git status
            'ê¹ƒ': 'git status', // ê¹ƒ â†’ git status
            'ê¹ƒì»¤ë°‹': 'git commit', // ê¹ƒ ì»¤ë°‹ â†’ git commit
            'ì»¤ë°‹': 'git commit', // ì»¤ë°‹ â†’ git commit
            'í‘¸ì‹œ': 'git push', // í‘¸ì‹œ â†’ git push
            'í’€': 'git pull', // í’€ â†’ git pull
            'ì¶©ëŒ': 'git solve', // ì¶©ëŒ â†’ git solve
            'ìžë™ì»¤ë°‹': 'git auto', // ìžë™ì»¤ë°‹ â†’ git auto
            'ë³€ê²½ì‚¬í•­': 'git status', // ë³€ê²½ì‚¬í•­ â†’ git status
            'ê¹ƒìƒí™©': 'git status', // ê¹ƒ ìƒí™© â†’ git status
            'ê¹ƒì €ìž¥': 'git commit', // ê¹ƒ ì €ìž¥ â†’ git commit
            'ê¹ƒí‘¸ì‹œ': 'git push', // ê¹ƒ í‘¸ì‹œ â†’ git push
            'ê¹ƒí’€': 'git pull', // ê¹ƒ í’€ â†’ git pull
            'ê¹ƒì¶©ëŒ': 'git solve', // ê¹ƒ ì¶©ëŒ â†’ git solve
            'ê¹ƒì›ê²©': 'git push', // ê¹ƒ ì›ê²© â†’ git push
            'ê¹ƒí•©ì¹˜ê¸°': 'git merge', // ê¹ƒ í•©ì¹˜ê¸° â†’ git merge
            'ê¹ƒë¸Œëžœì¹˜': 'git branch', // ê¹ƒ ë¸Œëžœì¹˜ â†’ git branch
            'ê¹ƒì „í™˜': 'git checkout', // ê¹ƒ ì „í™˜ â†’ git checkout
            'ê¹ƒì´ë ¥': 'git log', // ê¹ƒ ì´ë ¥ â†’ git log
            'ê¹ƒë¡œê·¸': 'git log', // ê¹ƒ ë¡œê·¸ â†’ git log
            'ê¹ƒë²„ì „': 'git log', // ê¹ƒ ë²„ì „ â†’ git log
            'ê¹ƒìŠ¤í…Œì´ì§€': 'git add', // ê¹ƒ ìŠ¤í…Œì´ì§€ â†’ git add
            'ê¹ƒì¶”ê°€': 'git add', // ê¹ƒ ì¶”ê°€ â†’ git add
            'ê¹ƒìƒíƒœì•Œë ¤ì¤˜': 'git status', // ê¹ƒ ìƒíƒœ ì•Œë ¤ì¤˜ â†’ git status (ì‹ ê·œ)
            'ê¹ƒìƒíƒœí™•ì¸': 'git status', // ê¹ƒ ìƒíƒœ í™•ì¸ â†’ git status (ì‹ ê·œ)
            'ë³€ê²½í™•ì¸': 'git status', // ë³€ê²½ í™•ì¸ â†’ git status (ì‹ ê·œ)
            'ì½”ë“œì»¤ë°‹': 'git commit', // ì½”ë“œ ì»¤ë°‹ â†’ git commit (ì‹ ê·œ)
            'ë³€ê²½ì €ìž¥': 'git commit', // ë³€ê²½ ì €ìž¥ â†’ git commit (ì‹ ê·œ)
            'ì½”ë“œì €ìž¥': 'git commit', // ì½”ë“œ ì €ìž¥ â†’ git commit (ì‹ ê·œ)
            'ë¸Œëžœì¹˜í™•ì¸': 'git branch', // ë¸Œëžœì¹˜ í™•ì¸ â†’ git branch (ì‹ ê·œ)
            'ë¸Œëžœì¹˜ëª©ë¡': 'git branch', // ë¸Œëžœì¹˜ ëª©ë¡ â†’ git branch (ì‹ ê·œ)
            'ë¨¸ì§€ì¶©ëŒ': 'git solve', // ë¨¸ì§€ ì¶©ëŒ â†’ git solve (ì‹ ê·œ)
            'ì›ê²©ì €ìž¥ì†Œì—…ë°ì´íŠ¸': 'git push', // ì›ê²© ì €ìž¥ì†Œ ì—…ë°ì´íŠ¸ â†’ git push (ì‹ ê·œ)
            // íŒŒì¼ ê´€ë ¨
            'íŒŒì¼ì—´ì–´': 'open', // íŒŒì¼ ì—´ê¸° â†’ open
            'ì—´ê¸°': 'open', // ì—´ê¸° â†’ open
            'íŒŒì¼': 'open', // íŒŒì¼ â†’ open
            'ì½”ë“œì—´ì–´': 'open', // ì½”ë“œ ì—´ê¸° â†’ open
            'íŒŒì¼ì˜¤í”ˆ': 'open', // íŒŒì¼ ì˜¤í”ˆ â†’ open
            'íŒŒì¼ë³´ê¸°': 'open', // íŒŒì¼ ë³´ê¸° â†’ open
            'ì†ŒìŠ¤ì—´ê¸°': 'open', // ì†ŒìŠ¤ ì—´ê¸° â†’ open
            'ë¬¸ì„œì—´ê¸°': 'open', // ë¬¸ì„œ ì—´ê¸° â†’ open
            'ì½”ë“œíŒŒì¼': 'open', // ì½”ë“œ íŒŒì¼ â†’ open
            'ì—´ì–´ì¤˜': 'open', // ì—´ì–´ì¤˜ â†’ open
            'íŒŒì¼ë‚´ìš©': 'open', // íŒŒì¼ ë‚´ìš© â†’ open
            'íŒŒì¼ë‚´ìš©ë³´ê¸°': 'open', // íŒŒì¼ ë‚´ìš© ë³´ê¸° â†’ open
            'ì½”ë“œíŒŒì¼ì—´ê¸°': 'open', // ì½”ë“œ íŒŒì¼ ì—´ê¸° â†’ open
            'íŒŒì¼ê²½ë¡œ': 'open', // íŒŒì¼ ê²½ë¡œ â†’ open
            'ê²½ë¡œì—´ê¸°': 'open', // ê²½ë¡œ ì—´ê¸° â†’ open
            'ì´íŒŒì¼ì—´ì–´ì¤˜': 'open', // ì´ íŒŒì¼ ì—´ì–´ì¤˜ â†’ open (ì‹ ê·œ)
            'ì†ŒìŠ¤ì½”ë“œì—´ê¸°': 'open', // ì†ŒìŠ¤ì½”ë“œ ì—´ê¸° â†’ open (ì‹ ê·œ)
            'ì½”ë“œë‚´ìš©ë³´ê¸°': 'open', // ì½”ë“œ ë‚´ìš© ë³´ê¸° â†’ open (ì‹ ê·œ)
            'íŒŒì¼ì—´ì–´ë³¼ëž˜': 'open', // íŒŒì¼ ì—´ì–´ë³¼ëž˜ â†’ open (ì‹ ê·œ)
            'íŒŒì¼ë³´ì—¬ì¤˜': 'open', // íŒŒì¼ ë³´ì—¬ì¤˜ â†’ open (ì‹ ê·œ)
            'ë¬¸ì„œë³´ì—¬ì¤˜': 'open', // ë¬¸ì„œ ë³´ì—¬ì¤˜ â†’ open (ì‹ ê·œ)
            'ì†ŒìŠ¤ë³´ì—¬ì¤˜': 'open', // ì†ŒìŠ¤ ë³´ì—¬ì¤˜ â†’ open (ì‹ ê·œ)
            // ì‹¤í–‰ ê´€ë ¨
            'ì‹¤í–‰í•´': 'execute', // ì‹¤í–‰í•´ â†’ execute
            'ì‹¤í–‰': 'execute', // ì‹¤í–‰ â†’ execute
            'ëŒë ¤': 'execute', // ëŒë ¤ â†’ execute
            'ì½”ë“œì‹¤í–‰': 'execute', // ì½”ë“œ ì‹¤í–‰ â†’ execute
            'êµ¬ë™': 'execute', // êµ¬ë™ â†’ execute
            'ì‹¤í–‰ì‹œì¼œ': 'execute', // ì‹¤í–‰ì‹œì¼œ â†’ execute
            'ëŒë ¤ë´': 'execute', // ëŒë ¤ë´ â†’ execute
            'ì‹¤í–‰í•´ë´': 'execute', // ì‹¤í–‰í•´ë´ â†’ execute
            'ì‹¤í–‰í•´ì¤˜': 'execute', // ì‹¤í–‰í•´ì¤˜ â†’ execute
            'ì½”ë“œëŒë ¤': 'execute', // ì½”ë“œ ëŒë ¤ â†’ execute
            'ì½”ë“œêµ¬ë™': 'execute', // ì½”ë“œ êµ¬ë™ â†’ execute
            'ìŠ¤í¬ë¦½íŠ¸ì‹¤í–‰': 'execute', // ìŠ¤í¬ë¦½íŠ¸ ì‹¤í–‰ â†’ execute
            'ëª…ë ¹ì‹¤í–‰': 'execute', // ëª…ë ¹ ì‹¤í–‰ â†’ execute
            'ëª…ë ¹ì–´ì‹¤í–‰': 'execute', // ëª…ë ¹ì–´ ì‹¤í–‰ â†’ execute
            // ë¶„ì„ ê´€ë ¨
            'ë¶„ì„í•´': 'analyze', // ë¶„ì„í•´ â†’ analyze
            'ë¶„ì„': 'analyze', // ë¶„ì„ â†’ analyze
            'ì½”ë“œë¶„ì„': 'analyze', // ì½”ë“œë¶„ì„ â†’ analyze
            'ê²€í† ': 'analyze', // ê²€í†  â†’ analyze
            'ë¦¬ë·°': 'analyze', // ë¦¬ë·° â†’ analyze
            'ì½”ë“œë¦¬ë·°': 'analyze', // ì½”ë“œë¦¬ë·° â†’ analyze
            'ì½”ë“œê²€í† ': 'analyze', // ì½”ë“œ ê²€í†  â†’ analyze
            'ë¶„ì„í•˜ê¸°': 'analyze', // ë¶„ì„í•˜ê¸° â†’ analyze
            'ì‚´íŽ´ë´': 'analyze', // ì‚´íŽ´ë´ â†’ analyze
            'íŒŒì•…í•´': 'analyze', // íŒŒì•…í•´ â†’ analyze
            'ì´í•´': 'analyze', // ì´í•´ â†’ analyze
            'ì½”ë“œì´í•´': 'analyze', // ì½”ë“œ ì´í•´ â†’ analyze
            'ì½”ë“œíŒŒì•…': 'analyze', // ì½”ë“œ íŒŒì•… â†’ analyze
            'ë¶„ì„í•´ë´': 'analyze', // ë¶„ì„í•´ë´ â†’ analyze
            'ë¶„ì„í•´ì¤˜': 'analyze', // ë¶„ì„í•´ì¤˜ â†’ analyze
            'ê²€í† í•´ì¤˜': 'analyze', // ê²€í† í•´ì¤˜ â†’ analyze
            'ë¦¬ë·°í•´ì¤˜': 'analyze', // ë¦¬ë·°í•´ì¤˜ â†’ analyze
            'ì½”ë“œì§„ë‹¨': 'analyze', // ì½”ë“œ ì§„ë‹¨ â†’ analyze
            'ì§„ë‹¨': 'analyze', // ì§„ë‹¨ â†’ analyze
            'ì½”ë“œë¦¬ë·°í•´ì¤˜': 'analyze', // ì½”ë“œ ë¦¬ë·°í•´ì¤˜ â†’ analyze (ì‹ ê·œ)
            'ì½”ë“œê°œì„ ': 'analyze', // ì½”ë“œ ê°œì„  â†’ analyze (ì‹ ê·œ)
            'ì½”ë“œí’ˆì§ˆ': 'analyze', // ì½”ë“œ í’ˆì§ˆ â†’ analyze (ì‹ ê·œ)
            'ì½”ë“œí‰ê°€': 'analyze', // ì½”ë“œ í‰ê°€ â†’ analyze (ì‹ ê·œ)
            'ì½”ë“œë¶„ì„í•´ì¤˜': 'analyze', // ì½”ë“œ ë¶„ì„í•´ì¤˜ â†’ analyze (ì‹ ê·œ)
            'ì´ì½”ë“œì–´ë•Œ': 'analyze', // ì´ ì½”ë“œ ì–´ë•Œ â†’ analyze (ì‹ ê·œ)
            'ì½”ë“œë¬¸ì œ': 'analyze', // ì½”ë“œ ë¬¸ì œ â†’ analyze (ì‹ ê·œ)
            'ë²„ê·¸ë¶„ì„': 'analyze', // ë²„ê·¸ ë¶„ì„ â†’ analyze (ì‹ ê·œ)
            'ì½”ë“œìµœì í™”': 'analyze', // ì½”ë“œ ìµœì í™” â†’ analyze (ì‹ ê·œ)
            'ì„±ëŠ¥ë¶„ì„': 'analyze', // ì„±ëŠ¥ ë¶„ì„ â†’ analyze (ì‹ ê·œ)
            // ì„¤ì • ë° ëª¨ë¸ ê´€ë ¨
            'ëª¨ë¸ë°”ê¿”': 'model', // ëª¨ë¸ ë³€ê²½ â†’ model
            'ëª¨ë¸': 'model', // ëª¨ë¸ â†’ model
            'ì„¤ì •í•´': 'settings', // ì„¤ì • ë³€ê²½ â†’ settings
            'ì„¤ì •': 'settings', // ì„¤ì • â†’ settings
            'í™˜ê²½ì„¤ì •': 'settings', // í™˜ê²½ì„¤ì • â†’ settings
            'ì˜µì…˜': 'settings', // ì˜µì…˜ â†’ settings
            'ëª¨ë¸ë³€ê²½': 'model', // ëª¨ë¸ ë³€ê²½ â†’ model
            'ëª¨ë¸ëª©ë¡': 'model list', // ëª¨ë¸ ëª©ë¡ â†’ model list
            'ì„¤ì •ë³€ê²½': 'settings', // ì„¤ì • ë³€ê²½ â†’ settings
            'ëª¨ë¸ì„ íƒ': 'model', // ëª¨ë¸ ì„ íƒ â†’ model
            'ì—ì´ì•„ì´ë³€ê²½': 'model', // AI ë³€ê²½ â†’ model
            'ëª¨ë¸êµì²´': 'model', // ëª¨ë¸ êµì²´ â†’ model
            'ëª¨ë¸ì „í™˜': 'model', // ëª¨ë¸ ì „í™˜ â†’ model
            'ì„¤ì •ë³´ê¸°': 'settings', // ì„¤ì • ë³´ê¸° â†’ settings
            'ì˜µì…˜ë³€ê²½': 'settings', // ì˜µì…˜ ë³€ê²½ â†’ settings
            'ì˜µì…˜ë³´ê¸°': 'settings', // ì˜µì…˜ ë³´ê¸° â†’ settings
            'ì„¤ì •ë©”ë‰´': 'settings', // ì„¤ì • ë©”ë‰´ â†’ settings
            'í™˜ê²½': 'settings', // í™˜ê²½ â†’ settings
            'ëª¨ë¸ì¢…ë¥˜': 'model list', // ëª¨ë¸ ì¢…ë¥˜ â†’ model list
            'ëª¨ë¸íƒ€ìž…': 'model list', // ëª¨ë¸ íƒ€ìž… â†’ model list
            'ëª¨ë¸í™•ì¸': 'model', // ëª¨ë¸ í™•ì¸ â†’ model
            // ê²€ìƒ‰ ê´€ë ¨
            'ê²€ìƒ‰í•´': 'search', // ê²€ìƒ‰í•´ â†’ search
            'ê²€ìƒ‰': 'search', // ê²€ìƒ‰ â†’ search
            'ì°¾ì•„': 'search', // ì°¾ì•„ â†’ search
            'ì°¾ê¸°': 'search', // ì°¾ê¸° â†’ search
            'ì°¾ì•„ì¤˜': 'search', // ì°¾ì•„ì¤˜ â†’ search
            'ì½”ë“œê²€ìƒ‰': 'search', // ì½”ë“œ ê²€ìƒ‰ â†’ search
            'ê²€ìƒ‰í•˜ê¸°': 'search', // ê²€ìƒ‰í•˜ê¸° â†’ search
            'ë‚´ìš©ì°¾ê¸°': 'search', // ë‚´ìš© ì°¾ê¸° â†’ search
            'ê²€ìƒ‰í•´ì¤˜': 'search', // ê²€ìƒ‰í•´ì¤˜ â†’ search
            'ì½”ë“œì°¾ê¸°': 'search', // ì½”ë“œ ì°¾ê¸° â†’ search
            'íŒŒì¼ê²€ìƒ‰': 'search', // íŒŒì¼ ê²€ìƒ‰ â†’ search
            'íŒŒì¼ì°¾ê¸°': 'search', // íŒŒì¼ ì°¾ê¸° â†’ search
            'í‚¤ì›Œë“œê²€ìƒ‰': 'search', // í‚¤ì›Œë“œ ê²€ìƒ‰ â†’ search
            'í…ìŠ¤íŠ¸ê²€ìƒ‰': 'search', // í…ìŠ¤íŠ¸ ê²€ìƒ‰ â†’ search
            'ë¬¸ìžê²€ìƒ‰': 'search', // ë¬¸ìž ê²€ìƒ‰ â†’ search
            'ê²€ìƒ‰ì–´': 'search', // ê²€ìƒ‰ì–´ â†’ search
            'ë¬¸ìžì—´ê²€ìƒ‰': 'search', // ë¬¸ìžì—´ ê²€ìƒ‰ â†’ search
            'ì°¾ì•„ë³´ê¸°': 'search', // ì°¾ì•„ë³´ê¸° â†’ search
            // ìƒíƒœ ë° ê¸°íƒ€
            'ì§€ê¸ˆë­í•´': 'status', // ì§€ê¸ˆ ë­í•´ â†’ status
            'ìƒíƒœ': 'status', // ìƒíƒœ â†’ status
            'ì´ˆê¸°í™”': 'clear', // ì´ˆê¸°í™” â†’ clear
            'ì§€ì›Œ': 'clear', // ì§€ì›Œ â†’ clear
            'ìƒˆë¡œê³ ì¹¨': 'clear', // ìƒˆë¡œê³ ì¹¨ â†’ clear
            'ì‹œìŠ¤í…œìƒíƒœ': 'status', // ì‹œìŠ¤í…œ ìƒíƒœ â†’ status
            'í˜„ìž¬ìƒíƒœ': 'status', // í˜„ìž¬ ìƒíƒœ â†’ status
            'ë­í•˜ê³ ìžˆì–´': 'status', // ë­í•˜ê³  ìžˆì–´ â†’ status
            'ì±„íŒ…ì§€ìš°ê¸°': 'clear', // ì±„íŒ… ì§€ìš°ê¸° â†’ clear
            'ë‚´ìš©ì§€ìš°ê¸°': 'clear', // ë‚´ìš© ì§€ìš°ê¸° â†’ clear
            'ë‹¤ì‹œì‹œìž‘': 'clear', // ë‹¤ì‹œ ì‹œìž‘ â†’ clear
            'ìƒíƒœí™•ì¸': 'status', // ìƒíƒœ í™•ì¸ â†’ status
            'ì‹œìŠ¤í…œí™•ì¸': 'status', // ì‹œìŠ¤í…œ í™•ì¸ â†’ status
            'ìƒíƒœë³´ê¸°': 'status', // ìƒíƒœ ë³´ê¸° â†’ status
            'ìž‘ì—…í˜„í™©': 'status', // ìž‘ì—… í˜„í™© â†’ status
            'ì§„í–‰í˜„í™©': 'status', // ì§„í–‰ í˜„í™© â†’ status
            'ì§€ê¸ˆìƒíƒœ': 'status', // ì§€ê¸ˆ ìƒíƒœ â†’ status
            'ë¹„ìš°ê¸°': 'clear', // ë¹„ìš°ê¸° â†’ clear
            'ì‚­ì œ': 'clear', // ì‚­ì œ â†’ clear
            'ë‚´ìš©ì‚­ì œ': 'clear', // ë‚´ìš© ì‚­ì œ â†’ clear
            'ì „ì²´ì‚­ì œ': 'clear', // ì „ì²´ ì‚­ì œ â†’ clear
            'ìž¬ì‹œìž‘': 'clear', // ìž¬ì‹œìž‘ â†’ clear
            'ì²˜ìŒë¶€í„°': 'clear', // ì²˜ìŒë¶€í„° â†’ clear
            // JIRA ê´€ë ¨
            'ì§€ë¼': 'jira', // ì§€ë¼ â†’ jira
            'ì§€ë¼ì´ìŠˆ': 'jira issue', // ì§€ë¼ ì´ìŠˆ â†’ jira issue
            'ì´ìŠˆ': 'jira issue', // ì´ìŠˆ â†’ jira issue
            'ì§€ë¼ê²€ìƒ‰': 'jira search', // ì§€ë¼ ê²€ìƒ‰ â†’ jira search
            'ì§€ë¼ëª©ë¡': 'jira list', // ì§€ë¼ ëª©ë¡ â†’ jira list
            'ì§€ë¼ìƒíƒœ': 'jira status', // ì§€ë¼ ìƒíƒœ â†’ jira status
            'ì§€ë¼ì—…ë°ì´íŠ¸': 'jira update', // ì§€ë¼ ì—…ë°ì´íŠ¸ â†’ jira update
            'ì§€ë¼ìƒì„±': 'jira create', // ì§€ë¼ ìƒì„± â†’ jira create
            'ì´ìŠˆìƒì„±': 'jira create', // ì´ìŠˆ ìƒì„± â†’ jira create
            'ì§€ë¼ì •ë³´': 'jira info', // ì§€ë¼ ì •ë³´ â†’ jira info
            // Todo ê´€ë ¨
            'í• ì¼': 'todo', // í• ì¼ â†’ todo
            'íˆ¬ë‘': 'todo', // íˆ¬ë‘ â†’ todo
            'íƒœìŠ¤í¬': 'todo', // íƒœìŠ¤í¬ â†’ todo
            'ìž‘ì—…': 'todo', // ìž‘ì—… â†’ todo
            'í• ì¼ì¶”ê°€': 'todo add', // í• ì¼ ì¶”ê°€ â†’ todo add
            'í• ì¼ëª©ë¡': 'todo list', // í• ì¼ ëª©ë¡ â†’ todo list
            'íˆ¬ë‘ëª©ë¡': 'todo list', // íˆ¬ë‘ ëª©ë¡ â†’ todo list
            'íƒœìŠ¤í¬ëª©ë¡': 'todo list', // íƒœìŠ¤í¬ ëª©ë¡ â†’ todo list
            'ìž‘ì—…ëª©ë¡': 'todo list', // ìž‘ì—… ëª©ë¡ â†’ todo list
            'í• ì¼ê´€ë¦¬': 'todo', // í• ì¼ ê´€ë¦¬ â†’ todo
            'íˆ¬ë‘ê´€ë¦¬': 'todo', // íˆ¬ë‘ ê´€ë¦¬ â†’ todo
            'íƒœìŠ¤í¬ê´€ë¦¬': 'todo', // íƒœìŠ¤í¬ ê´€ë¦¬ â†’ todo
            'ìž‘ì—…ê´€ë¦¬': 'todo', // ìž‘ì—… ê´€ë¦¬ â†’ todo
            'í• ì¼ì¶”ê°€í•˜ê¸°': 'todo add', // í• ì¼ ì¶”ê°€í•˜ê¸° â†’ todo add (ì‹ ê·œ)
            'í• ì¼ë“±ë¡': 'todo add', // í• ì¼ ë“±ë¡ â†’ todo add (ì‹ ê·œ)
            'íƒœìŠ¤í¬ë“±ë¡': 'todo add', // íƒœìŠ¤í¬ ë“±ë¡ â†’ todo add (ì‹ ê·œ)
            'ìž‘ì—…ë“±ë¡': 'todo add', // ìž‘ì—… ë“±ë¡ â†’ todo add (ì‹ ê·œ)
            'í• ì¼ì‚­ì œ': 'todo delete', // í• ì¼ ì‚­ì œ â†’ todo delete (ì‹ ê·œ)
            'íƒœìŠ¤í¬ì‚­ì œ': 'todo delete', // íƒœìŠ¤í¬ ì‚­ì œ â†’ todo delete (ì‹ ê·œ)
            'ìž‘ì—…ì‚­ì œ': 'todo delete', // ìž‘ì—… ì‚­ì œ â†’ todo delete (ì‹ ê·œ)
            'ìž‘ì—…ìƒíƒœ': 'todo status', // ìž‘ì—… ìƒíƒœ â†’ todo status (ì‹ ê·œ)
            'í• ì¼ìƒíƒœ': 'todo status', // í• ì¼ ìƒíƒœ â†’ todo status (ì‹ ê·œ)
            'íƒœìŠ¤í¬ìƒíƒœ': 'todo status', // íƒœìŠ¤í¬ ìƒíƒœ â†’ todo status (ì‹ ê·œ)
            'í• ì¼ì™„ë£Œ': 'todo status', // í• ì¼ ì™„ë£Œ â†’ todo status (ì‹ ê·œ)
            'ìž‘ì—…ì™„ë£Œ': 'todo status', // ìž‘ì—… ì™„ë£Œ â†’ todo status (ì‹ ê·œ)
            'íƒœìŠ¤í¬ì™„ë£Œ': 'todo status', // íƒœìŠ¤í¬ ì™„ë£Œ â†’ todo status (ì‹ ê·œ)
            'ìž‘ì—…ìš°ì„ ìˆœìœ„': 'todo priority', // ìž‘ì—… ìš°ì„ ìˆœìœ„ â†’ todo priority (ì‹ ê·œ)
            'í• ì¼ìš°ì„ ìˆœìœ„': 'todo priority', // í• ì¼ ìš°ì„ ìˆœìœ„ â†’ todo priority (ì‹ ê·œ)
            'íƒœìŠ¤í¬ìš°ì„ ìˆœìœ„': 'todo priority', // íƒœìŠ¤í¬ ìš°ì„ ìˆœìœ„ â†’ todo priority (ì‹ ê·œ)
            // ì±„íŒ… ì €ìž¥/ë³´ê¸°
            'ëŒ€í™”ì €ìž¥': 'stack', // ëŒ€í™” ì €ìž¥ â†’ stack
            'ì±„íŒ…ì €ìž¥': 'stack', // ì±„íŒ… ì €ìž¥ â†’ stack
            'ëŒ€í™”ê¸°ë¡': 'stack', // ëŒ€í™” ê¸°ë¡ â†’ stack
            'ì±„íŒ…ê¸°ë¡': 'stack', // ì±„íŒ… ê¸°ë¡ â†’ stack
            'ëŒ€í™”ë‚´ì—­': 'show', // ëŒ€í™” ë‚´ì—­ â†’ show
            'ì±„íŒ…ë‚´ì—­': 'show', // ì±„íŒ… ë‚´ì—­ â†’ show
            'ëŒ€í™”ëª©ë¡': 'show', // ëŒ€í™” ëª©ë¡ â†’ show
            'ì±„íŒ…ëª©ë¡': 'show', // ì±„íŒ… ëª©ë¡ â†’ show
            'ëŒ€í™”ë³´ê¸°': 'show', // ëŒ€í™” ë³´ê¸° â†’ show
            'ì±„íŒ…ë³´ê¸°': 'show', // ì±„íŒ… ë³´ê¸° â†’ show
            'ê¸°ë¡ë³´ê¸°': 'show', // ê¸°ë¡ ë³´ê¸° â†’ show
        };
        // ìž…ë ¥ ì •ê·œí™” (ìŠ¬ëž˜ì‹œ ì œê±° ë° ì†Œë¬¸ìž ë³€í™˜)
        const normalizedInput = input.substring(1).trim().toLowerCase();
        // 1. ì •í™•í•œ ì˜ë„ ë§¤ì¹­ ë¨¼ì € ì‹œë„
        for (const [intent, commandName] of Object.entries(intentMap)) {
            if (normalizedInput === intent) {
                return this.getCommand(commandName.split(' ')[0]);
            }
        }
        // 2. ë¶€ë¶„ ë§¤ì¹­ ì‹œë„ (ìž…ë ¥ì— íŠ¹ì • ì˜ë„ ë‹¨ì–´ê°€ í¬í•¨ëœ ê²½ìš°)
        for (const [intent, commandName] of Object.entries(intentMap)) {
            if (normalizedInput.includes(intent)) {
                return this.getCommand(commandName.split(' ')[0]);
            }
        }
        // 3. ê³µë°±ì„ ì œê±°í•œ ë§¤ì¹­ ì‹œë„ (ì˜ˆ: "ë­ í•´ì•¼ í•´" â†’ "ë­í•´ì•¼í•´")
        const normalizedWithoutSpaces = normalizedInput.replace(/\s+/g, '');
        for (const [intent, commandName] of Object.entries(intentMap)) {
            if (normalizedWithoutSpaces === intent || normalizedWithoutSpaces.includes(intent)) {
                return this.getCommand(commandName.split(' ')[0]);
            }
        }
        // 4. ìœ ì‚¬ ë§¤ì¹­ - ìžìŒ/ëª¨ìŒ ê¸°ë°˜ ìœ ì‚¬ë„ ê³„ì‚° (í•œê¸€ë§Œ ì ìš©)
        if (/[\uAC00-\uD7AF]/.test(normalizedInput)) {
            // í–¥ìƒëœ ìœ ì‚¬ë„ ê³„ì‚° í•¨ìˆ˜
            const calculateSimilarity = (a, b) => {
                // ì™„ì „ ì¼ì¹˜í•˜ëŠ” ê²½ìš°
                if (a === b)
                    return 1.0;
                if (a.length === 0 || b.length === 0)
                    return 0.0;
                // ìŒì ˆ ë‹¨ìœ„ë¡œ ë¶„ë¦¬
                const charsA = Array.from(a);
                const charsB = Array.from(b);
                // í•œê¸€ ì´ˆì„± ë§¤ì¹­ ê°€ì¤‘ì¹˜ ì¶”ê°€
                // ì´ˆì„± ì¶”ì¶œ í•¨ìˆ˜
                const getInitialConsonant = (char) => {
                    if (!/^[ê°€-íž£]$/.test(char))
                        return char;
                    const code = char.charCodeAt(0) - 0xAC00;
                    const consonantIndex = Math.floor(code / 28 / 21);
                    const consonants = [
                        'ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……',
                        'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…Ž'
                    ];
                    return consonants[consonantIndex];
                };
                // ì´ˆì„± ì¶”ì¶œ
                const initialA = charsA.map(getInitialConsonant).join('');
                const initialB = charsB.map(getInitialConsonant).join('');
                // ì´ˆì„± ì¼ì¹˜ ì ìˆ˜ (ê°€ì¤‘ì¹˜: 0.3)
                const initialScore = initialA === initialB ? 0.3 : 0;
                // ê° ë¬¸ìžì—´ì˜ n-gram ìƒì„± (1-gram, 2-gram)
                const generateNgrams = (str, n) => {
                    const ngrams = [];
                    for (let i = 0; i <= str.length - n; i++) {
                        ngrams.push(str.substring(i, i + n));
                    }
                    return ngrams;
                };
                // 1-gram (ìŒì ˆ) ìœ ì‚¬ë„ (ê°€ì¤‘ì¹˜: 0.3)
                const chars1A = new Set(charsA);
                const chars1B = new Set(charsB);
                const charIntersection = new Set([...chars1A].filter(x => chars1B.has(x)));
                const charUnion = new Set([...chars1A, ...chars1B]);
                const charScore = charIntersection.size / charUnion.size * 0.3;
                // 2-gram (ìŒì ˆ ìŒ) ìœ ì‚¬ë„ (ê°€ì¤‘ì¹˜: 0.4)
                const bigrams2A = new Set(generateNgrams(a, 2));
                const bigrams2B = new Set(generateNgrams(b, 2));
                const bigramIntersection = new Set([...bigrams2A].filter(x => bigrams2B.has(x)));
                const bigramUnion = new Set([...bigrams2A, ...bigrams2B]);
                const bigramScore = bigrams2A.size > 0 && bigrams2B.size > 0 ?
                    bigramIntersection.size / bigramUnion.size * 0.4 : 0;
                // ê¸¸ì´ ìœ ì‚¬ë„ - ê¸¸ì´ê°€ ë¹„ìŠ·í• ìˆ˜ë¡ ë†’ì€ ì ìˆ˜ (ê°€ì¤‘ì¹˜: 0.2)
                const lengthScore = 1 - (Math.abs(a.length - b.length) / Math.max(a.length, b.length, 1)) * 0.2;
                // ì ‘ë‘ì‚¬ ê°€ì¤‘ì¹˜ - ì‹œìž‘ ë¶€ë¶„ì´ ê°™ìœ¼ë©´ ê°€ì¤‘ì¹˜ ë¶€ì—¬
                const prefixBonus = a.startsWith(b.charAt(0)) || b.startsWith(a.charAt(0)) ? 0.1 : 0;
                // ì „ì²´ ìœ ì‚¬ë„ ì ìˆ˜
                return Math.min(1.0, initialScore + charScore + bigramScore + lengthScore + prefixBonus);
            };
            const similarityThreshold = 0.45; // ìœ ì‚¬ë„ ìž„ê³„ê°’ (ì•½ê°„ ë‚®ì¶¤)
            let bestMatch = null;
            for (const [intent, commandName] of Object.entries(intentMap)) {
                const similarity = calculateSimilarity(normalizedInput, intent);
                if (similarity >= similarityThreshold && (!bestMatch || similarity > bestMatch.similarity)) {
                    bestMatch = { intent, command: commandName, similarity };
                }
            }
            if (bestMatch) {
                console.log(`í•œê¸€ ìœ ì‚¬ë„ ë§¤ì¹­ (ê°œì„ ): "${normalizedInput}" â†’ "${bestMatch.intent}" (${bestMatch.similarity.toFixed(2)})`);
                return this.getCommand(bestMatch.command.split(' ')[0]);
            }
        }
        return undefined;
    }
    /**
     * ëª…ë ¹ì–´ ì‹¤í–‰
     */
    async executeCommand(input) {
        // ìŠ¬ëž˜ì‹œë¡œ ì‹œìž‘í•˜ëŠ”ì§€ í™•ì¸
        if (!input.startsWith('/') && !input.startsWith('@')) {
            return false;
        }
        // ëª…ë ¹ì–´ì™€ ì¸ìž ë¶„ë¦¬
        const trimmedInput = input.trim();
        const parts = trimmedInput.split(' ');
        // @ ëª…ë ¹ì–´ ì²˜ë¦¬ (íŠ¹ìˆ˜ ì ‘ë‘ì‚¬)
        if (trimmedInput.startsWith('@')) {
            const specialCommand = parts[0].substring(1); // @ ì œê±°
            // ì§€ì›ë˜ì§€ ì•ŠëŠ” @ ëª…ë ¹ì–´
            external_vscode_.window.showInformationMessage(`'@${specialCommand}'ëŠ” í˜„ìž¬ ì§€ì›ë˜ì§€ ì•ŠëŠ” ëª…ë ¹ì–´ìž…ë‹ˆë‹¤.`);
            return false;
        }
        // ì¼ë°˜ ìŠ¬ëž˜ì‹œ ëª…ë ¹ì–´ ì²˜ë¦¬
        const commandName = parts[0].substring(1); // ìŠ¬ëž˜ì‹œ ì œê±°
        const args = parts.slice(1);
        // 1. ì§ì ‘ ëª…ë ¹ì–´ ë§¤ì¹­ ì‹œë„
        let command = this.getCommand(commandName);
        // 2. í•œê¸€ í…ìŠ¤íŠ¸ê°€ ìžˆëŠ” ê²½ìš° ì˜ë„ ê¸°ë°˜ ë§¤ì¹­ ì‹œë„
        if (!command && /[\uAC00-\uD7AF]/.test(commandName)) {
            command = this.matchCommandByIntent(trimmedInput);
        }
        // 3. ëª…ë ¹ì–´ë¥¼ ì°¾ì§€ ëª»í•œ ê²½ìš°
        if (!command) {
            // ìœ ì‚¬ ëª…ë ¹ì–´ ì°¾ê¸°
            const similarCommands = this.findSimilarCommands(commandName);
            if (similarCommands.length > 0 && similarCommands[0].distance <= 1) {
                // ë§¤ìš° ìœ ì‚¬í•œ ëª…ë ¹ì–´ê°€ ìžˆëŠ” ê²½ìš° (ì˜¤íƒ€ë¡œ ê°„ì£¼)
                const closestCommand = similarCommands[0].command;
                const result = await external_vscode_.window.showInformationMessage(`ëª…ë ¹ì–´ '/${commandName}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. '/${closestCommand.name}'ë¥¼ ì‹¤í–‰í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`, 'ì‹¤í–‰', 'ì·¨ì†Œ');
                if (result === 'ì‹¤í–‰') {
                    // ì‚¬ìš©ìžê°€ ìˆ˜ì •ëœ ëª…ë ¹ì–´ ì‹¤í–‰ì— ë™ì˜í•¨
                    try {
                        await closestCommand.execute({
                            extensionContext: this.context,
                            args,
                            originalInput: `/${closestCommand.name} ${args.join(' ')}`.trim()
                        });
                        return true;
                    }
                    catch (error) {
                        console.error(`Error executing command /${closestCommand.name}:`, error);
                        external_vscode_.window.showErrorMessage(`ëª…ë ¹ì–´ ì‹¤í–‰ ì˜¤ë¥˜: /${closestCommand.name}`);
                        return true; // ëª…ë ¹ì–´ëŠ” ì²˜ë¦¬ë¨ (ì˜¤ë¥˜ ë°œìƒ)
                    }
                }
                else {
                    // ì‚¬ìš©ìžê°€ ì·¨ì†Œí•¨ - LLM ì¶”ì²œ ë˜ëŠ” ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì‹œ
                    if (this.llmService) {
                        await this.handleUnknownCommandWithSuggestions(commandName, trimmedInput, similarCommands);
                        return true; // ëª…ë ¹ì–´ëŠ” ì²˜ë¦¬ë¨ (ëŒ€ì²´ ì²˜ë¦¬)
                    }
                    else {
                        this.showSimilarCommandSuggestions(commandName, similarCommands);
                        return false;
                    }
                }
            }
            else {
                // ìœ ì‚¬í•œ ëª…ë ¹ì–´ê°€ ì—†ê±°ë‚˜ ì¶©ë¶„ížˆ ìœ ì‚¬í•˜ì§€ ì•Šì€ ê²½ìš°
                if (this.llmService) {
                    await this.handleUnknownCommandWithSuggestions(commandName, trimmedInput, similarCommands);
                    return true; // ëª…ë ¹ì–´ëŠ” ì²˜ë¦¬ë¨ (ëŒ€ì²´ ì²˜ë¦¬)
                }
                else {
                    if (similarCommands.length > 0) {
                        this.showSimilarCommandSuggestions(commandName, similarCommands);
                    }
                    else {
                        external_vscode_.window.showErrorMessage(`ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: /${commandName}`);
                    }
                    return false;
                }
            }
        }
        // ëª…ë ¹ì–´ ì‹¤í–‰
        try {
            await command.execute({
                extensionContext: this.context,
                args,
                originalInput: trimmedInput
            });
            return true;
        }
        catch (error) {
            console.error(`Error executing command /${commandName}:`, error);
            external_vscode_.window.showErrorMessage(`ëª…ë ¹ì–´ ì‹¤í–‰ ì˜¤ë¥˜: /${commandName}`);
            return true; // ëª…ë ¹ì–´ëŠ” ì²˜ë¦¬ë¨ (ì˜¤ë¥˜ ë°œìƒ)
        }
    }
    /**
     * ìœ ì‚¬ ëª…ë ¹ì–´ ì¶”ì²œ ë©”ì‹œì§€ í‘œì‹œ
     */
    showSimilarCommandSuggestions(commandName, similarCommands) {
        if (similarCommands.length === 0) {
            external_vscode_.window.showErrorMessage(`ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: /${commandName}`);
            return;
        }
        // ìµœëŒ€ 3ê°œê¹Œì§€ë§Œ í‘œì‹œ
        const suggestionsLimit = Math.min(3, similarCommands.length);
        const suggestions = similarCommands.slice(0, suggestionsLimit);
        // ë©”ì‹œì§€ êµ¬ì„±
        const message = `ëª…ë ¹ì–´ '/${commandName}'ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì´ê²ƒì„ ì˜ë¯¸í–ˆë‚˜ìš”?`;
        // ë²„íŠ¼ ìƒì„±
        const buttons = suggestions.map(s => `/${s.command.name}`);
        // ë©”ì‹œì§€ í‘œì‹œ
        external_vscode_.window.showErrorMessage(message, ...buttons)
            .then(selected => {
            if (selected) {
                // ì„ íƒí•œ ëª…ë ¹ì–´ ì‹¤í–‰
                this.executeCommand(selected);
            }
        });
    }
    /**
     * ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ ì²˜ë¦¬ - LLMì„ í†µí•œ í•´ì„ ë° ì¶”ì²œ
     * @param commandName ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ ì´ë¦„
     * @param originalInput ì›ë³¸ ìž…ë ¥
     */
    async handleUnknownCommand(commandName, originalInput) {
        try {
            // 1. ë„ì›€ë§ ë°ì´í„° ë¡œë“œ
            const helpData = await this.loadHelpData();
            // 2. ê°€ì´ë“œ ë°ì´í„° ë¡œë“œ
            const guideData = await this.loadGuideData();
            // 3. LLM í”„ë¡¬í”„íŠ¸ ìƒì„±
            const prompt = this.generateUnknownCommandPrompt(commandName, originalInput, helpData, guideData);
            // 4. LLM ì‘ë‹µ ìš”ì²­
            const result = await this.llmService.getCompletion(prompt);
            if (!result.success || !result.data) {
                throw new Error(result.error?.message || 'LLM ì‘ë‹µì„ ë°›ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
            // 5. LLM ì‘ë‹µ ì²˜ë¦¬ ë° UIì— í‘œì‹œ (WebView íŒ¨ë„ ì‚¬ìš©)
            await this.showLlmResponsePanel('ëª…ë ¹ì–´ ë„ì›€ë§', result.data);
        }
        catch (error) {
            console.error('ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
            external_vscode_.window.showErrorMessage(`'/${commandName}' ëª…ë ¹ì–´ í•´ì„ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ê¸°ë³¸ ë„ì›€ë§ì„ ì°¸ì¡°í•˜ì„¸ìš”.`);
            // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ ë„ì›€ë§ í‘œì‹œ
            await external_vscode_.commands.executeCommand('ape.showCommandHelp');
        }
    }
    /**
     * ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ ì²˜ë¦¬ - ìœ ì‚¬ ëª…ë ¹ì–´ ì •ë³´ë¥¼ í¬í•¨í•œ LLM ì¶”ì²œ
     * @param commandName ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ ì´ë¦„
     * @param originalInput ì›ë³¸ ìž…ë ¥
     * @param similarCommands ìœ ì‚¬ ëª…ë ¹ì–´ ëª©ë¡
     */
    async handleUnknownCommandWithSuggestions(commandName, originalInput, similarCommands) {
        try {
            // 1. ë„ì›€ë§ ë°ì´í„° ë¡œë“œ
            const helpData = await this.loadHelpData();
            // 2. ê°€ì´ë“œ ë°ì´í„° ë¡œë“œ
            const guideData = await this.loadGuideData();
            // 3. LLM í”„ë¡¬í”„íŠ¸ ìƒì„± (ìœ ì‚¬ ëª…ë ¹ì–´ ì •ë³´ í¬í•¨)
            const prompt = this.generateUnknownCommandPromptWithSuggestions(commandName, originalInput, helpData, guideData, similarCommands);
            // 4. LLM ì‘ë‹µ ìš”ì²­
            const result = await this.llmService.getCompletion(prompt);
            if (!result.success || !result.data) {
                throw new Error(result.error?.message || 'LLM ì‘ë‹µì„ ë°›ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
            // 5. LLM ì‘ë‹µ ì²˜ë¦¬ ë° UIì— í‘œì‹œ (WebView íŒ¨ë„ ì‚¬ìš©)
            await this.showLlmResponsePanel('ëª…ë ¹ì–´ ë„ì›€ë§', result.data);
        }
        catch (error) {
            console.error('ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
            // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ ìœ ì‚¬ ëª…ë ¹ì–´ ì¶”ì²œ ì‚¬ìš©
            this.showSimilarCommandSuggestions(commandName, similarCommands);
            // í•„ìš”ì‹œ ê¸°ë³¸ ë„ì›€ë§ë„ í‘œì‹œ ê°€ëŠ¥
            // await vscode.commands.executeCommand('ape.showCommandHelp');
        }
    }
    /**
     * ë„ì›€ë§ ë°ì´í„° ë¡œë“œ
     */
    async loadHelpData() {
        try {
            const extensionPath = this.context.extensionPath;
            const helpFilePath = external_path_.join(extensionPath, 'src', 'data', 'help.json');
            const helpDataStr = external_fs_.readFileSync(helpFilePath, 'utf8');
            return JSON.parse(helpDataStr);
        }
        catch (error) {
            console.error('ë„ì›€ë§ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
            return {};
        }
    }
    /**
     * ê°€ì´ë“œ ë°ì´í„° ë¡œë“œ
     */
    async loadGuideData() {
        try {
            const extensionPath = this.context.extensionPath;
            const guideFilePath = external_path_.join(extensionPath, 'src', 'data', 'guide.json');
            const guideDataStr = external_fs_.readFileSync(guideFilePath, 'utf8');
            return JSON.parse(guideDataStr);
        }
        catch (error) {
            console.error('ê°€ì´ë“œ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
            return {};
        }
    }
    /**
     * ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ ì²˜ë¦¬ë¥¼ ìœ„í•œ LLM í”„ë¡¬í”„íŠ¸ ìƒì„±
     */
    generateUnknownCommandPrompt(commandName, originalInput, helpData, guideData) {
        return `
# APE ëª…ë ¹ì–´ í•´ì„ ë° ì¶”ì²œ ì‹œìŠ¤í…œ

ë‹¹ì‹ ì€ APE(Agentic Pipeline Extension)ì˜ ë„ì›€ë§ ì‹œìŠ¤í…œìž…ë‹ˆë‹¤. ì‚¬ìš©ìžê°€ ìž…ë ¥í•œ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ë¥¼ í•´ì„í•˜ê³  ê´€ë ¨ëœ ìœ íš¨í•œ ëª…ë ¹ì–´ë‚˜ ì§ˆë¬¸ì„ ì¶”ì²œí•´ì•¼ í•©ë‹ˆë‹¤.

## ì‚¬ìš©ìž ìž…ë ¥

ì‚¬ìš©ìžê°€ ìž…ë ¥í•œ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: \`${originalInput}\`

## ë„ì›€ë§ ë°ì´í„°

${JSON.stringify(helpData, null, 2)}

## ê°€ì´ë“œ ë°ì´í„°

${JSON.stringify(guideData, null, 2)}

## ì‘ë‹µ ì§€ì¹¨

1. ì‚¬ìš©ìž ìž…ë ¥ì„ ë¶„ì„í•˜ì—¬ ì˜ë„ë¥¼ íŒŒì•…í•˜ì„¸ìš”. íŠ¹ížˆ í•œê¸€ë¡œ ìž…ë ¥ëœ ìžì—°ì–´ ì§ˆë¬¸ì´ë‚˜ ëª…ë ¹ì— ì£¼ì˜í•˜ì„¸ìš”.
2. ìž…ë ¥ê³¼ ìœ ì‚¬í•˜ê±°ë‚˜ ê´€ë ¨ëœ ìœ íš¨í•œ ëª…ë ¹ì–´ë¥¼ ì¶”ì²œí•˜ì„¸ìš”. 
3. í•œê¸€ ìž…ë ¥ì˜ ê²½ìš° "ë­í•´ì•¼í•´", "ë­ë¶€í„°í•´ì•¼í•´" ê°™ì€ ìžì—°ì–´ ì§ˆë¬¸ìœ¼ë¡œ ì´í•´í•˜ê³  ì ì ˆí•œ ì›Œí¬í”Œë¡œìš°ë¥¼ ì œì•ˆí•˜ì„¸ìš”.
4. í˜„ìž¬ ìƒí™©ì— ì í•©í•œ ì»¨í…ìŠ¤íŠ¸ ì§ˆë¬¸ë„ ì¶”ì²œí•˜ì„¸ìš” (ì˜ˆ: "Git í˜•ìƒì´ ì„¸íŒ…ëë‚˜ìš”?", "Jira ìž‘ì—…ì´ í•„ìš”í•œê°€ìš”?" ë“±).
5. ì‘ë‹µì€ ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ìž‘ì„±í•˜ì„¸ìš”:

---
### ëª…ë ¹ì–´ í•´ì„

[ìž…ë ¥í•œ ëª…ë ¹ì–´ì— ëŒ€í•œ í•´ì„ ë° ì¶”ì¸¡ - í•œê¸€ ìž…ë ¥ì˜ ê²½ìš° ì‚¬ìš©ìž ì˜ë„ë¥¼ ìžì„¸ížˆ ë¶„ì„]

### ì¶”ì²œ ëª…ë ¹ì–´

- **[ëª…ë ¹ì–´1]**: [ì„¤ëª…]
- **[ëª…ë ¹ì–´2]**: [ì„¤ëª…]
- **[ëª…ë ¹ì–´3]**: [ì„¤ëª…]

### ì¶”ì²œ ì§ˆë¬¸

- [ì§ˆë¬¸1]
- [ì§ˆë¬¸2]
- [ì§ˆë¬¸3]

---

ì‘ë‹µì„ ì‹œìž‘í•˜ì„¸ìš”.
`;
    }
    /**
     * ìœ ì‚¬ ëª…ë ¹ì–´ ì •ë³´ë¥¼ í¬í•¨í•œ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ ì²˜ë¦¬ í”„ë¡¬í”„íŠ¸ ìƒì„±
     */
    generateUnknownCommandPromptWithSuggestions(commandName, originalInput, helpData, guideData, similarCommands) {
        // ìœ ì‚¬ ëª…ë ¹ì–´ ì •ë³´ ì¶”ì¶œ
        const similarCommandsInfo = similarCommands.map(sc => ({
            name: sc.command.name,
            description: sc.command.description,
            category: sc.command.category,
            aliases: sc.command.aliases || [],
            examples: sc.command.examples || [],
            distance: sc.distance
        }));
        return `
# APE ëª…ë ¹ì–´ í•´ì„ ë° ì¶”ì²œ ì‹œìŠ¤í…œ (í–¥ìƒëœ ë²„ì „)

ë‹¹ì‹ ì€ APE(Agentic Pipeline Extension)ì˜ ë„ì›€ë§ ì‹œìŠ¤í…œìž…ë‹ˆë‹¤. ì‚¬ìš©ìžê°€ ìž…ë ¥í•œ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´ë¥¼ í•´ì„í•˜ê³  ê´€ë ¨ëœ ìœ íš¨í•œ ëª…ë ¹ì–´ë‚˜ ì§ˆë¬¸ì„ ì¶”ì²œí•´ì•¼ í•©ë‹ˆë‹¤.

## ì‚¬ìš©ìž ìž…ë ¥

ì‚¬ìš©ìžê°€ ìž…ë ¥í•œ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: \`${originalInput}\`

## ë„ì›€ë§ ë°ì´í„°

${JSON.stringify(helpData, null, 2)}

## ê°€ì´ë“œ ë°ì´í„°

${JSON.stringify(guideData, null, 2)}

## ìœ ì‚¬ ëª…ë ¹ì–´ (ë ˆë²¤ìŠˆíƒ€ì¸ ê±°ë¦¬ ê¸°ë°˜)

${JSON.stringify(similarCommandsInfo, null, 2)}

## ì‘ë‹µ ì§€ì¹¨

1. ì‚¬ìš©ìž ìž…ë ¥ì„ ë¶„ì„í•˜ì—¬ ì˜ë„ë¥¼ íŒŒì•…í•˜ì„¸ìš”. íŠ¹ížˆ í•œê¸€ë¡œ ìž…ë ¥ëœ ìžì—°ì–´ ì§ˆë¬¸ì´ë‚˜ ëª…ë ¹ì— ì£¼ì˜í•˜ì„¸ìš”.
2. ì œê³µëœ ìœ ì‚¬ ëª…ë ¹ì–´ë¥¼ ì°¸ê³ í•˜ì—¬ ì‚¬ìš©ìžê°€ ì‹¤ì œë¡œ ì›í–ˆì„ ê°€ëŠ¥ì„±ì´ ë†’ì€ ëª…ë ¹ì–´ë¥¼ ì¶”ì²œí•˜ì„¸ìš”.
3. ì‚¬ìš©ìž ìž…ë ¥ê³¼ ìœ ì‚¬í•œ ëª…ë ¹ì–´ê°€ ìžˆë‹¤ë©´ ì˜¤íƒ€ì¼ ê°€ëŠ¥ì„±ì„ ì–¸ê¸‰í•˜ì„¸ìš”. (ì˜ˆ: "/gti status"ëŠ” "/git status"ì˜ ì˜¤íƒ€ë¡œ ë³´ìž…ë‹ˆë‹¤)
4. í•œê¸€ ìž…ë ¥ì˜ ê²½ìš° "ë­í•´ì•¼í•´", "ë­ë¶€í„°í•´ì•¼í•´" ê°™ì€ ìžì—°ì–´ ì§ˆë¬¸ìœ¼ë¡œ ì´í•´í•˜ê³  ì ì ˆí•œ ì›Œí¬í”Œë¡œìš°ë¥¼ ì œì•ˆí•˜ì„¸ìš”.
5. íŠ¹ížˆ ë ˆë²¤ìŠˆíƒ€ì¸ ê±°ë¦¬ê°€ ê°€ìž¥ ìž‘ì€ ëª…ë ¹ì–´ë¥¼ ìš°ì„ ì ìœ¼ë¡œ ì¶”ì²œí•˜ë˜, ë§¥ë½ìƒ ë§žì§€ ì•ŠëŠ” ê²½ìš°ëŠ” ì œì™¸í•˜ì„¸ìš”.
6. í˜„ìž¬ ìƒí™©ì— ì í•©í•œ ì»¨í…ìŠ¤íŠ¸ ì§ˆë¬¸ë„ ì¶”ì²œí•˜ì„¸ìš”.
7. ì‘ë‹µì€ ì¹œì ˆí•˜ê³  ë„ì›€ì´ ë˜ëŠ” í†¤ìœ¼ë¡œ ìž‘ì„±í•˜ì„¸ìš”.
8. ì‘ë‹µì€ ë‹¤ìŒ í˜•ì‹ìœ¼ë¡œ ìž‘ì„±í•˜ì„¸ìš”:

---
### ëª…ë ¹ì–´ í•´ì„

[ìž…ë ¥í•œ ëª…ë ¹ì–´ì— ëŒ€í•œ í•´ì„ ë° ì¶”ì¸¡ - í•œê¸€ ìž…ë ¥ì˜ ê²½ìš° ì‚¬ìš©ìž ì˜ë„ë¥¼ ìžì„¸ížˆ ë¶„ì„]

### ì¶”ì²œ ëª…ë ¹ì–´

- **[ëª…ë ¹ì–´1]**: [ì„¤ëª…] [ì˜¤íƒ€ ê°€ëŠ¥ì„± ë˜ëŠ” ì¶”ì²œ ì´ìœ  ì–¸ê¸‰]
- **[ëª…ë ¹ì–´2]**: [ì„¤ëª…]
- **[ëª…ë ¹ì–´3]**: [ì„¤ëª…]

### ì¶”ì²œ ì§ˆë¬¸

- [ì§ˆë¬¸1]
- [ì§ˆë¬¸2]
- [ì§ˆë¬¸3]

---

ì‘ë‹µì„ ì‹œìž‘í•˜ì„¸ìš”.
`;
    }
    /**
     * LLM ì‘ë‹µì„ WebView íŒ¨ë„ë¡œ í‘œì‹œ
     */
    async showLlmResponsePanel(title, content) {
        // WebView íŒ¨ë„ ìƒì„±
        const panel = external_vscode_.window.createWebviewPanel('apeLlmResponse', title, external_vscode_.ViewColumn.One, {
            enableScripts: true,
            localResourceRoots: [external_vscode_.Uri.joinPath(this.context.extensionUri, 'media')]
        });
        // LLM ì‘ë‹µì—ì„œ ëª…ë ¹ì–´ ì¶”ì¶œ (í•œê¸€ ëª…ë ¹ì–´ í¬í•¨)
        const commandRegex = /\*\*\/([\p{L}\p{N}-]+)(?:\s+[\p{L}\p{N}-]+)*\*\*/gu;
        const extractedCommands = [];
        let match;
        while ((match = commandRegex.exec(content)) !== null) {
            extractedCommands.push(`/${match[1]}`);
        }
        // ì§ˆë¬¸ ì¶”ì¶œ
        const questionRegex = /- ([^-\n]+)/g;
        const extractedQuestions = [];
        match = null;
        while ((match = questionRegex.exec(content)) !== null) {
            const question = match[1].trim();
            if (question && !question.startsWith('/')) {
                extractedQuestions.push(question);
            }
        }
        // íŒ¨ë„ì— HTML ì„¤ì •
        panel.webview.html = this.getLlmResponseHtml(content, extractedCommands, extractedQuestions);
        // ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ì„¤ì •
        panel.webview.onDidReceiveMessage(async (message) => {
            if (message.type === 'executeCommand') {
                // ëª…ë ¹ì–´ ì‹¤í–‰
                await this.executeCommand(message.command);
            }
            else if (message.type === 'insertToChat') {
                // ì±„íŒ… ìž…ë ¥ì°½ì— í…ìŠ¤íŠ¸ ì‚½ìž… (ì´ë²¤íŠ¸ ë°œìƒ)
                external_vscode_.commands.executeCommand('ape.insertToChatInput', message.text);
            }
        });
    }
    /**
     * LLM ì‘ë‹µ HTML ìƒì„±
     */
    getLlmResponseHtml(content, commands, questions) {
        // ë§ˆí¬ë‹¤ìš´ì„ HTMLë¡œ ë³€í™˜
        const markdownContent = content
            // ì œëª© ë³€í™˜
            .replace(/^### (.*$)/gm, '<h3>$1</h3>')
            .replace(/^## (.*$)/gm, '<h2>$1</h2>')
            .replace(/^# (.*$)/gm, '<h1>$1</h1>')
            // ë³¼ë“œ ë° ì½”ë“œ ë³€í™˜
            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
            .replace(/`(.*?)`/g, '<code>$1</code>')
            // ëª©ë¡ ë³€í™˜
            .replace(/^- (.*$)/gm, '<li>$1</li>')
            .replace(/(<li>.*<\/li>\n)+/g, '<ul>$&</ul>');
        // ëª…ë ¹ì–´ ë° ì§ˆë¬¸ ë²„íŠ¼ HTML ìƒì„±
        let commandsHtml = '';
        if (commands.length > 0) {
            commandsHtml = `
        <div class="command-buttons">
          <h3>ëª…ë ¹ì–´ ë°”ë¡œ ì‹¤í–‰</h3>
          <div class="button-container">
            ${commands.map(cmd => `
              <button class="command-button" onclick="executeCommand('${cmd}')">${cmd}</button>
            `).join('')}
          </div>
        </div>
      `;
        }
        let questionsHtml = '';
        if (questions.length > 0) {
            questionsHtml = `
        <div class="question-buttons">
          <h3>ì§ˆë¬¸ ì¶”ì²œ</h3>
          <div class="button-container">
            ${questions.map(q => `
              <button class="question-button" onclick="insertToChat('${q.replace(/'/g, "\\'")}')">${q}</button>
            `).join('')}
          </div>
        </div>
      `;
        }
        return `
      <!DOCTYPE html>
      <html lang="ko">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>APE ëª…ë ¹ì–´ ë„ì›€ë§</title>
        <style>
          :root {
            --bg-color: var(--vscode-editor-background, #1e1e1e);
            --text-color: var(--vscode-editor-foreground, #d4d4d4);
            --link-color: var(--vscode-textLink-foreground, #3794ff);
            --button-bg: var(--vscode-button-background, #0e639c);
            --button-fg: var(--vscode-button-foreground, white);
            --button-hover-bg: var(--vscode-button-hoverBackground, #1177bb);
            --code-bg: var(--vscode-textBlockQuote-background, #2a2d2e);
          }
          
          body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--bg-color);
            margin: 0;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
          }
          
          h1, h2, h3 {
            margin-top: 20px;
            margin-bottom: 10px;
          }
          
          ul {
            margin-bottom: 20px;
          }
          
          code {
            background-color: var(--code-bg);
            padding: 2px 4px;
            border-radius: 3px;
            font-family: SFMono-Regular, Consolas, 'Liberation Mono', Menlo, monospace;
          }
          
          .content {
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #444;
          }
          
          .button-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 20px;
          }
          
          .command-button, .question-button {
            background-color: var(--button-bg);
            color: var(--button-fg);
            border: none;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
          }
          
          .command-button:hover, .question-button:hover {
            background-color: var(--button-hover-bg);
          }
          
          .question-button {
            background-color: var(--vscode-badge-background, #4d4d4d);
          }
          
          .question-button:hover {
            background-color: var(--vscode-list-hoverBackground, #2a2d2e);
          }
        </style>
      </head>
      <body>
        <div class="content">
          ${markdownContent}
        </div>
        
        ${commandsHtml}
        ${questionsHtml}
        
        <script>
          const vscode = acquireVsCodeApi();
          
          function executeCommand(command) {
            vscode.postMessage({
              type: 'executeCommand',
              command: command
            });
          }
          
          function insertToChat(text) {
            vscode.postMessage({
              type: 'insertToChat',
              text: text
            });
          }
        </script>
      </body>
      </html>
    `;
    }
    /**
     * ëª…ë ¹ì–´ ì œì•ˆ í•­ëª© ê°€ì ¸ì˜¤ê¸°
     */
    getCommandSuggestions(input = '') {
        // ìž…ë ¥í•œ í…ìŠ¤íŠ¸ ì²˜ë¦¬
        const trimmedInput = input.trim();
        const isSlashCommand = trimmedInput.startsWith('/');
        // ìŠ¬ëž˜ì‹œê°€ ì—†ìœ¼ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜
        if (!isSlashCommand && trimmedInput !== '') {
            return [];
        }
        // ìŠ¬ëž˜ì‹œ ì´í›„ í…ìŠ¤íŠ¸ ì¶”ì¶œ
        const searchText = isSlashCommand ? trimmedInput.substring(1).toLowerCase() : '';
        // ëª…ë ¹ì–´ í•„í„°ë§
        return this.filterCommands(searchText);
    }
    /**
     * ëª…ë ¹ì–´ í•„í„°ë§
     */
    filterCommands(searchText) {
        const suggestions = [];
        for (const command of this.getAllCommands()) {
            // ê²€ìƒ‰ì–´ í•„í„°ë§
            if (searchText && !command.name.toLowerCase().includes(searchText)) {
                // ë³„ì¹­ ê²€ìƒ‰
                const hasMatchingAlias = command.aliases?.some(alias => alias.toLowerCase().includes(searchText));
                // ë§¤ì¹­ë˜ëŠ” ë³„ì¹­ì´ ì—†ìœ¼ë©´ ê±´ë„ˆë›°ê¸°
                if (!hasMatchingAlias) {
                    continue;
                }
            }
            // ì œì•ˆ í•­ëª© ìƒì„±
            suggestions.push({
                label: `/${command.name}`,
                description: command.description,
                detail: command.examples ? `ì˜ˆì‹œ: ${command.examples.join(', ')}` : undefined,
                category: command.category,
                insertText: `/${command.name} `,
                iconPath: this.getIconForCategory(command.category)
            });
        }
        // ìš°ì„ ìˆœìœ„ ë° ì´ë¦„ìœ¼ë¡œ ì •ë ¬
        return suggestions.sort((a, b) => {
            // ìš°ì„  ì¹´í…Œê³ ë¦¬ë¡œ ì •ë ¬
            const commandA = this.getCommand(a.label.substring(1));
            const commandB = this.getCommand(b.label.substring(1));
            // ìš°ì„ ìˆœìœ„ ë¹„êµ
            const priorityA = commandA?.priority || 100;
            const priorityB = commandB?.priority || 100;
            if (priorityA !== priorityB) {
                return priorityA - priorityB;
            }
            // ì´ë¦„ìœ¼ë¡œ ì •ë ¬
            return a.label.localeCompare(b.label);
        });
    }
    /**
     * ì¹´í…Œê³ ë¦¬ë³„ ì•„ì´ì½˜ ê°€ì ¸ì˜¤ê¸°
     */
    getIconForCategory(category) {
        // ì´ëª¨ì§€ ì•„ì´ì½˜ ëŒ€ì‹  ThemeIcon ì‚¬ìš©
        switch (category) {
            case 'general':
                return new external_vscode_.ThemeIcon('info');
            case 'git':
                return new external_vscode_.ThemeIcon('git-commit');
            case 'code':
                return new external_vscode_.ThemeIcon('code');
            case 'utility':
                return new external_vscode_.ThemeIcon('tools');
            case 'advanced':
                return new external_vscode_.ThemeIcon('settings-gear');
            default:
                return new external_vscode_.ThemeIcon('symbol-event');
        }
    }
    /**
     * ëª…ë ¹ì–´ ìžë™ì™„ì„± ì œê³µ
     */
    provideCompletions(input) {
        // ìž…ë ¥í•œ í…ìŠ¤íŠ¸ ì²˜ë¦¬
        const trimmedInput = input.trim();
        if (!trimmedInput.startsWith('/')) {
            return [];
        }
        const parts = trimmedInput.split(' ');
        const commandName = parts[0].substring(1); // ìŠ¬ëž˜ì‹œ ì œê±°
        const partialArg = parts.length > 1 ? parts[parts.length - 1] : '';
        // ëª…ë ¹ì–´ ì°¾ê¸°
        const command = this.getCommand(commandName);
        if (!command || !command.provideCompletions) {
            return [];
        }
        // ëª…ë ¹ì–´ë³„ ìžë™ì™„ì„± í˜¸ì¶œ
        return command.provideCompletions(partialArg);
    }
    /**
     * ëª…ë ¹ì–´ ì œì•ˆ ì—…ë°ì´íŠ¸
     *
     * ì±„íŒ… ìž…ë ¥ í•„ë“œ ê°’ì´ ë³€ê²½ë  ë•Œ í˜¸ì¶œë©ë‹ˆë‹¤.
     */
    updateSuggestions(input) {
        const suggestions = this.getCommandSuggestions(input);
        this._onDidSuggestCommands.fire(suggestions);
    }
    /**
     * ëª…ë ¹ì–´ ë„ì›€ë§ í‘œì‹œ
     *
     * ìƒˆë¡œìš´ JSON ê¸°ë°˜ ë„ì›€ë§ ì‹œìŠ¤í…œ ì‚¬ìš©
     */
    async showCommandHelp(arg) {
        // ë„ì›€ë§ íŒ¨ë„ ìƒì„±
        const helpPanel = external_vscode_.window.createWebviewPanel('apeCommandHelp', 'APE ë„ì›€ë§', external_vscode_.ViewColumn.One, {
            enableScripts: true, // ìŠ¤í¬ë¦½íŠ¸ í™œì„±í™” (ë„ì›€ë§ ë‚´ë¹„ê²Œì´ì…˜ ìœ„í•¨)
            localResourceRoots: [external_vscode_.Uri.joinPath(this.context.extensionUri, 'media')]
        });
        // ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ì„¤ì •
        helpPanel.webview.onDidReceiveMessage(async (message) => {
            if (message.type === 'command') {
                // ë„ì›€ë§ ë‚´ì—ì„œ ëª…ë ¹ì–´ ì‹¤í–‰
                if (message.command.startsWith('help ')) {
                    // ë„ì›€ë§ ë‚´ë¶€ ë§í¬ ì²˜ë¦¬
                    const helpArg = message.command.substring(5);
                    await this.processHelpCommand(helpPanel, helpArg);
                }
                else {
                    // ë‹¤ë¥¸ ëª…ë ¹ì–´ëŠ” ìŠ¬ëž˜ì‹œ ëª…ë ¹ì–´ë¡œ ì‹¤í–‰
                    await this.executeCommand(`/${message.command}`);
                }
            }
            else if (message.type === 'expandTreeView') {
                // íŠ¸ë¦¬ ë·° í™•ìž¥ ìš”ì²­
                await external_vscode_.commands.executeCommand('ape.focusTreeView');
            }
        });
        // ì´ˆê¸° ë„ì›€ë§ ë‚´ìš© í‘œì‹œ
        if (!arg) {
            // ì¹´í…Œê³ ë¦¬ ë˜ëŠ” ëª…ë ¹ì–´ ë¯¸ì§€ì • ì‹œ ê¸°ë³¸ ë„ì›€ë§ í‘œì‹œ
            helpPanel.webview.html = await generateHelpHtml();
        }
        else if (arg.startsWith('guide ')) {
            // ê°€ì´ë“œ ë¬¸ì„œ í‘œì‹œ
            const guideId = arg.substring(6);
            helpPanel.webview.html = await generateGuideHtml(guideId);
        }
        else if (arg === 'guides' || arg === 'guide') {
            // ê°€ì´ë“œ ëª©ë¡ í‘œì‹œ
            helpPanel.webview.html = await generateGuidesListHtml();
        }
        else if (arg === 'faq') {
            // FAQ í‘œì‹œ
            helpPanel.webview.html = await generateFaqHtml();
        }
        else if (arg === 'tools') {
            // Agent ë„êµ¬ ëª©ë¡ í‘œì‹œ
            helpPanel.webview.html = await generateToolsHelpHtml();
        }
        else if (this.getCommand(arg)) {
            // ëª…ë ¹ì–´ ìƒì„¸ ì •ë³´ í‘œì‹œ
            helpPanel.webview.html = await generateCommandDetailHtml(arg);
        }
        else if (arg.startsWith('search ')) {
            // ë„ì›€ë§ ê²€ìƒ‰ ê¸°ëŠ¥
            const query = arg.substring(7);
            if (this.llmService) {
                // LLM ì„œë¹„ìŠ¤ê°€ ìžˆëŠ” ê²½ìš° ìŠ¤ë§ˆíŠ¸ ë„ì›€ë§ ì‚¬ìš©
                helpPanel.webview.html = await generateSmartHelpHtml(query, this.llmService);
            }
            else {
                // LLM ì„œë¹„ìŠ¤ê°€ ì—†ëŠ” ê²½ìš° ê¸°ë³¸ ë„ì›€ë§ í‘œì‹œì™€ ë©”ì‹œì§€
                helpPanel.webview.html = await generateHelpHtml();
                external_vscode_.window.showWarningMessage('ìŠ¤ë§ˆíŠ¸ ë„ì›€ë§ ê²€ìƒ‰ì„ ìœ„í•œ LLM ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
        }
        else {
            // ì¹´í…Œê³ ë¦¬ ì§€ì • ì‹œ í•´ë‹¹ ì¹´í…Œê³ ë¦¬ ë„ì›€ë§ í‘œì‹œ
            helpPanel.webview.html = await generateHelpHtml(arg);
        }
    }
    /**
     * ë„ì›€ë§ ëª…ë ¹ì–´ ì²˜ë¦¬
     *
     * ë„ì›€ë§ íŒ¨ë„ ë‚´ì—ì„œ ëª…ë ¹ì–´ ì‹¤í–‰ ì‹œ ì²˜ë¦¬
     */
    async processHelpCommand(helpPanel, arg) {
        // ë„ì›€ë§ ë‚´ë¶€ ë§í¬ í´ë¦­ ì²˜ë¦¬
        if (!arg) {
            // ì¸ìž ì—†ëŠ” ê²½ìš° ê¸°ë³¸ ë„ì›€ë§ í‘œì‹œ
            helpPanel.webview.html = await generateHelpHtml();
        }
        else if (arg.startsWith('guide ')) {
            // ê°€ì´ë“œ ë¬¸ì„œ í‘œì‹œ
            const guideId = arg.substring(6);
            helpPanel.webview.html = await generateGuideHtml(guideId);
        }
        else if (arg === 'guides' || arg === 'guide') {
            // ê°€ì´ë“œ ëª©ë¡ í‘œì‹œ
            helpPanel.webview.html = await generateGuidesListHtml();
        }
        else if (arg === 'faq') {
            // FAQ í‘œì‹œ
            helpPanel.webview.html = await generateFaqHtml();
        }
        else if (arg === 'tools') {
            // Agent ë„êµ¬ ëª©ë¡ í‘œì‹œ
            helpPanel.webview.html = await generateToolsHelpHtml();
        }
        else if (arg.startsWith('search ')) {
            // ë„ì›€ë§ ê²€ìƒ‰ ê¸°ëŠ¥
            const query = arg.substring(7);
            if (this.llmService) {
                // LLM ì„œë¹„ìŠ¤ê°€ ìžˆëŠ” ê²½ìš° ìŠ¤ë§ˆíŠ¸ ë„ì›€ë§ ì‚¬ìš©
                helpPanel.webview.html = await generateSmartHelpHtml(query, this.llmService);
            }
            else {
                // LLM ì„œë¹„ìŠ¤ê°€ ì—†ëŠ” ê²½ìš° ê¸°ë³¸ ë„ì›€ë§ í‘œì‹œì™€ ë©”ì‹œì§€
                helpPanel.webview.html = await generateHelpHtml();
                external_vscode_.window.showWarningMessage('ìŠ¤ë§ˆíŠ¸ ë„ì›€ë§ ê²€ìƒ‰ì„ ìœ„í•œ LLM ì„œë¹„ìŠ¤ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            }
        }
        else {
            // ëª…ë ¹ì–´ ì´ë¦„ìœ¼ë¡œ ì²˜ë¦¬
            const command = this.getCommand(arg);
            if (command) {
                // ëª…ë ¹ì–´ ìƒì„¸ ì •ë³´ í‘œì‹œ
                helpPanel.webview.html = await generateCommandDetailHtml(arg);
            }
            else {
                // ì¹´í…Œê³ ë¦¬ë¡œ ì²˜ë¦¬
                helpPanel.webview.html = await generateHelpHtml(arg);
            }
        }
    }
    /**
     * ì¹´í…Œê³ ë¦¬ ì œëª© ê°€ì ¸ì˜¤ê¸°
     */
    getCategoryTitle(category) {
        switch (category) {
            case 'general':
                return 'ì¼ë°˜ ëª…ë ¹ì–´';
            case 'git':
                return 'Git ê´€ë ¨ ëª…ë ¹ì–´';
            case 'code':
                return 'ì½”ë“œ ê´€ë ¨ ëª…ë ¹ì–´';
            case 'utility':
                return 'ìœ í‹¸ë¦¬í‹° ëª…ë ¹ì–´';
            case 'advanced':
                return 'ê³ ê¸‰ ëª…ë ¹ì–´';
            default:
                return category;
        }
    }
    /**
     * ë„ì›€ë§ íŒ¨ë„ HTML ìƒì„±
     */
    getHelpPanelHtml(content) {
        return `
      <!DOCTYPE html>
      <html lang="ko">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>ìŠ¬ëž˜ì‹œ ëª…ë ¹ì–´ ë„ì›€ë§</title>
        <style>
          body {
            font-family: var(--vscode-font-family, 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif);
            padding: 0 20px;
            color: var(--vscode-foreground);
            font-size: var(--vscode-font-size);
            background-color: var(--vscode-editor-background);
          }
          h1 {
            border-bottom: 1px solid var(--vscode-panel-border);
            padding-bottom: 10px;
            color: var(--vscode-symbolIcon-classForeground);
          }
          h2 {
            margin-top: 20px;
            color: var(--vscode-symbolIcon-constantForeground);
            border-left: 3px solid var(--vscode-activityBarBadge-background);
            padding-left: 10px;
          }
          code {
            font-family: var(--vscode-editor-font-family, monospace);
            background-color: var(--vscode-textBlockQuote-background);
            padding: 2px 4px;
            border-radius: 3px;
          }
          .command-name {
            font-weight: bold;
            color: var(--vscode-symbolIcon-functionForeground);
          }
        </style>
      </head>
      <body>
        ${this.markdownToHtml(content)}
      </body>
      </html>
    `;
    }
    /**
     * ë§ˆí¬ë‹¤ìš´ì„ HTMLë¡œ ë³€í™˜ (ê°„ë‹¨ êµ¬í˜„)
     */
    markdownToHtml(markdown) {
        return markdown
            // í—¤ë” ë³€í™˜
            .replace(/^# (.+)$/gm, '<h1>$1</h1>')
            .replace(/^## (.+)$/gm, '<h2>$1</h2>')
            .replace(/^### (.+)$/gm, '<h3>$1</h3>')
            // ë³¼ë“œ í…ìŠ¤íŠ¸ ë³€í™˜
            .replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>')
            // ëª…ë ¹ì–´ ê°•ì¡° (í•œê¸€, ì˜ë¬¸ ëª¨ë‘ ì§€ì›)
            .replace(/\/([\p{L}\p{N}-]+)/gu, '<code>/$1</code>')
            // ëª©ë¡ ë³€í™˜
            .replace(/^- (.+)$/gm, '<li>$1</li>')
            .replace(/(<li>.*<\/li>\n)+/g, '<ul>$&</ul>')
            // ì¤„ë°”ê¿ˆ ë³€í™˜
            .replace(/\n\n/g, '</p><p>')
            .replace(/\n/g, '<br>')
            // ë‹¨ë½ ê°ì‹¸ê¸°
            .replace(/^(.+?)(?=<\/p>|<h[1-6]|<ul>|$)/s, '<p>$1</p>');
    }
    /**
     * Git ìƒíƒœ í‘œì‹œ
     */
    async showGitStatus() {
        try {
            // Git í™•ìž¥ API ê°€ì ¸ì˜¤ê¸°
            const gitExtension = external_vscode_.extensions.getExtension('vscode.git')?.exports;
            if (!gitExtension) {
                external_vscode_.window.showErrorMessage('Git í™•ìž¥ì´ í™œì„±í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                return;
            }
            const git = gitExtension.getAPI(1);
            if (!git) {
                external_vscode_.window.showErrorMessage('Git APIë¥¼ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            // í˜„ìž¬ ì €ìž¥ì†Œ ê°€ì ¸ì˜¤ê¸°
            const repositories = git.repositories;
            if (repositories.length === 0) {
                external_vscode_.window.showInformationMessage('Git ì €ìž¥ì†Œê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }
            // í˜„ìž¬ ì €ìž¥ì†Œ ìƒíƒœ í‘œì‹œ
            const repo = repositories[0];
            const state = repo.state;
            // ìƒíƒœ ë©”ì‹œì§€ ìƒì„±
            const changes = state.workingTreeChanges.length;
            const staged = state.indexChanges.length;
            const untracked = state.untrackedChanges.length;
            const statusMessage = `# Git ìƒíƒœ ìš”ì•½\n\n` +
                `- ë¸Œëžœì¹˜: **${state.HEAD?.name || 'detached HEAD'}**\n` +
                `- ë³€ê²½: **${changes}**ê°œ íŒŒì¼\n` +
                `- ìŠ¤í…Œì´ì§•: **${staged}**ê°œ íŒŒì¼\n` +
                `- ì¶”ì ë˜ì§€ ì•ŠìŒ: **${untracked}**ê°œ íŒŒì¼\n\n` +
                `## ë³€ê²½ëœ íŒŒì¼\n\n` +
                state.workingTreeChanges.map((c) => `- ${c.uri.fsPath.split('/').pop()} (${this.getChangeTypeLabel(c.status)})`).join('\n');
            // ë„ì›€ë§ íŒ¨ë„ë¡œ í‘œì‹œ
            const statusPanel = external_vscode_.window.createWebviewPanel('apeGitStatus', 'Git ìƒíƒœ', external_vscode_.ViewColumn.One, {
                enableScripts: false,
                localResourceRoots: []
            });
            statusPanel.webview.html = this.getHelpPanelHtml(statusMessage);
        }
        catch (error) {
            external_vscode_.window.showErrorMessage(`Git ìƒíƒœ í™•ì¸ ì˜¤ë¥˜: ${error}`);
        }
    }
    /**
     * ë³€ê²½ ìœ í˜• ë¼ë²¨ ê°€ì ¸ì˜¤ê¸°
     */
    getChangeTypeLabel(status) {
        // Git ë³€ê²½ íƒ€ìž… ë§¤í•‘
        switch (status) {
            case 0: return 'ì¶”ê°€ë¨'; // Added
            case 1: return 'ìˆ˜ì •ë¨'; // Modified
            case 2: return 'ì‚­ì œë¨'; // Deleted
            case 3: return 'ì´ë¦„ ë³€ê²½ë¨'; // Renamed
            case 4: return 'ë³µì‚¬ë¨'; // Copied
            default: return 'ì•Œ ìˆ˜ ì—†ìŒ';
        }
    }
}

;// ./src/core/commands/commandManager.ts


/**
 * Manages all commands for the extension
 */
class CommandManager {
    _context;
    _chatViewProvider;
    _llmService;
    _memoryService;
    _modelManager;
    _rulesService;
    _vaultService;
    _jiraService;
    _slashCommandManager;
    constructor(_context, _chatViewProvider, _llmService, _memoryService, _modelManager, _rulesService, // Rules ì„œë¹„ìŠ¤
    _vaultService, // Vault ì„œë¹„ìŠ¤
    _jiraService // Jira ì„œë¹„ìŠ¤
    ) {
        this._context = _context;
        this._chatViewProvider = _chatViewProvider;
        this._llmService = _llmService;
        this._memoryService = _memoryService;
        this._modelManager = _modelManager;
        this._rulesService = _rulesService;
        this._vaultService = _vaultService;
        this._jiraService = _jiraService;
        // Initialize slash command manager with LLMService for smart help and services
        const services = {
            llmService: this._llmService,
            memoryService: this._memoryService,
            modelManager: this._modelManager,
            rulesService: this._rulesService,
            vaultService: this._vaultService,
            jiraService: this._jiraService
        };
        this._slashCommandManager = new SlashCommandManager(this._context, this._llmService, services);
    }
    /**
     * Gets the slash command manager instance
     */
    get slashCommandManager() {
        return this._slashCommandManager;
    }
    /**
     * Registers all commands for the extension
     */
    registerCommands() {
        // Chat commands
        this._registerCommand('ape.openChat', this._openChat.bind(this));
        this._registerCommand('ape.clearChat', this._clearChat.bind(this));
        this._registerCommand('ape.sendMessage', this._sendMessage.bind(this));
        // Model commands
        this._registerCommand('ape.selectModel', this.selectModel.bind(this));
        this._registerCommand('ape.switchModel', this.switchModel.bind(this));
        // Code commands
        this._registerCommand('ape.analyzeCode', this._analyzeCode.bind(this));
        // Slash commands
        this._registerCommand('ape.executeSlashCommand', this._executeSlashCommand.bind(this));
    }
    /**
     * Registers a single command
     */
    _registerCommand(commandId, handler) {
        const disposable = external_vscode_.commands.registerCommand(commandId, handler);
        this._context.subscriptions.push(disposable);
    }
    /**
     * Opens the chat view
     */
    async _openChat() {
        await external_vscode_.commands.executeCommand('workbench.view.extension.ape-sidebar');
    }
    /**
     * Clears the chat history
     */
    async _clearChat() {
        await this._chatViewProvider.clearChat();
    }
    /**
     * Sends a message to the chat
     */
    async _sendMessage(content) {
        if (!content) {
            // If no content provided, prompt the user
            const message = await external_vscode_.window.showInputBox({
                prompt: 'Enter message to send to APE',
                placeHolder: 'Type your message here...'
            });
            if (message) {
                await this._chatViewProvider.sendMessage(message);
            }
        }
        else {
            await this._chatViewProvider.sendMessage(content);
        }
    }
    /**
     * Opens model selection dialog
     */
    async selectModel() {
        const models = this._modelManager.getAvailableModels();
        const activeModel = this._modelManager.getActiveModel();
        // Create friendly display names for models
        const selectedModel = await external_vscode_.window.showQuickPick(models.map(model => ({
            label: this._modelManager.getModelDisplayName(model),
            description: model === activeModel ? '(active)' : '',
            detail: this._modelManager.getModelDescription(model),
            model: model // Keep original model ID
        })), {
            placeHolder: 'Select a model to use',
            title: 'APE Model Selection'
        });
        if (selectedModel) {
            await this.switchModel(selectedModel.model);
        }
    }
    /**
     * Switches to a specific model
     */
    async switchModel(modelName) {
        try {
            // Use the ModelManager to switch models
            const success = await this._modelManager.setActiveModel(modelName);
            if (success) {
                // Update the UI to reflect the model change
                this._chatViewProvider.updateModelIndicator();
                external_vscode_.window.showInformationMessage(`${this._modelManager.getModelDisplayName(modelName)} ëª¨ë¸ë¡œ ì „í™˜í–ˆìŠµë‹ˆë‹¤`);
            }
            else {
                external_vscode_.window.showErrorMessage(`ëª¨ë¸ ì „í™˜ ì‹¤íŒ¨: ìœ íš¨í•˜ì§€ ì•Šì€ ëª¨ë¸ ë˜ëŠ” ì „í™˜ ì¤‘ ì˜¤ë¥˜ ë°œìƒ`);
            }
        }
        catch (error) {
            external_vscode_.window.showErrorMessage(`ëª¨ë¸ ì „í™˜ ì‹¤íŒ¨: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * Gets user-friendly display name for a model - Deprecated, use ModelManager.getModelDisplayName instead
     * @param modelId The model ID
     * @returns User-friendly display name
     * @deprecated This method is kept for backward compatibility. Use ModelManager.getModelDisplayName instead
     */
    _getModelDisplayName(modelId) {
        return this._modelManager.getModelDisplayName(modelId);
    }
    /**
     * Executes a slash command
     */
    async _executeSlashCommand(commandText) {
        const executed = await this._slashCommandManager.executeCommand(commandText);
        if (!executed) {
            // If not a slash command, treat as regular message
            await this._sendMessage(commandText);
        }
    }
    /**
     * Gets description for a model - Deprecated, use ModelManager.getModelDescription instead
     * @param model The model ID
     * @returns Model description
     * @deprecated This method is kept for backward compatibility. Use ModelManager.getModelDescription instead
     */
    _getModelDescription(model) {
        return this._modelManager.getModelDescription(model);
    }
    /**
     * Analyzes selected code with APE
     */
    async _analyzeCode() {
        const editor = external_vscode_.window.activeTextEditor;
        if (!editor) {
            external_vscode_.window.showErrorMessage('No active editor');
            return;
        }
        const selection = editor.selection;
        if (selection.isEmpty) {
            external_vscode_.window.showInformationMessage('Please select code to analyze');
            return;
        }
        const selectedText = editor.document.getText(selection);
        const filePath = editor.document.fileName;
        const fileExtension = filePath.split('.').pop() || '';
        const fileName = filePath.split('/').pop() || '';
        // Create analysis prompt with improved message for APE analysis
        const prompt = `Please analyze this ${fileExtension} code from ${fileName}:\n\n\`\`\`${fileExtension}\n${selectedText}\n\`\`\`\n\nProvide a detailed APE analysis including:\n1. Code functionality\n2. Potential issues or improvements\n3. Best practices recommendations`;
        // Show notification that analysis is starting
        external_vscode_.window.showInformationMessage('Analyzing selected code with APE...');
        // Open chat and send the prompt
        await this._openChat();
        await this._sendMessage(prompt);
    }
}

;// ./src/core/git/autoCommitService.ts
/**
 * Auto Commit Service
 *
 * ìžë™ ì»¤ë°‹, ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„±, ì¶©ëŒ í•´ê²° ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ì„œë¹„ìŠ¤
 */




const autoCommitService_execAsync = (0,external_util_.promisify)(external_child_process_namespaceObject.exec);
/**
 * ìžë™ ì»¤ë°‹ ì„œë¹„ìŠ¤ í´ëž˜ìŠ¤
 */
class AutoCommitService {
    context;
    llmService;
    bitbucketService;
    workspaceRoot;
    statusBarItem;
    commitInProgress = false;
    disposables = [];
    gitWatcher;
    /**
     * ìƒì„±ìž
     */
    constructor(context, llmService, bitbucketService) {
        this.context = context;
        this.llmService = llmService;
        this.bitbucketService = bitbucketService;
        // ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ ë£¨íŠ¸ ì„¤ì •
        this.workspaceRoot = external_vscode_.workspace.workspaceFolders?.[0]?.uri.fsPath;
        // ìƒíƒœ í‘œì‹œì¤„ ì•„ì´í…œ ìƒì„±
        this.statusBarItem = external_vscode_.window.createStatusBarItem(external_vscode_.StatusBarAlignment.Left, 100);
        this.statusBarItem.text = "$(git-commit) ìžë™ ì»¤ë°‹ ì¤€ë¹„ë¨";
        this.statusBarItem.tooltip = "APE ìžë™ ì»¤ë°‹ ì„œë¹„ìŠ¤";
        this.statusBarItem.command = "ape.git.toggleAutoCommit";
        this.statusBarItem.show();
        // ëª…ë ¹ì–´ ë“±ë¡
        this.registerCommands();
        // Git ë³€ê²½ ê°ì§€ ì„¤ì •
        this.setupGitWatcher();
    }
    /**
     * ëª…ë ¹ì–´ ë“±ë¡
     */
    registerCommands() {
        // ìžë™ ì»¤ë°‹ í† ê¸€
        this.disposables.push(external_vscode_.commands.registerCommand('ape.git.toggleAutoCommit', () => this.toggleAutoCommit()));
        // ìˆ˜ë™ ì»¤ë°‹
        this.disposables.push(external_vscode_.commands.registerCommand('ape.git.commit', () => this.createCommit()));
        // ìž„ì‹œ ì»¤ë°‹ í†µí•©
        this.disposables.push(external_vscode_.commands.registerCommand('ape.git.consolidateTemporaryCommits', () => this.consolidateTemporaryCommits()));
    }
    /**
     * Git ë³€ê²½ ê°ì§€ ì„¤ì •
     */
    setupGitWatcher() {
        if (!this.workspaceRoot) {
            return;
        }
        try {
            // .git/index íŒŒì¼ ë³€ê²½ ê°ì§€
            const gitIndexPath = external_path_.join(this.workspaceRoot, '.git', 'index');
            this.gitWatcher = external_vscode_.workspace.createFileSystemWatcher(gitIndexPath);
            // íŒŒì¼ ë³€ê²½ ì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸
            this.gitWatcher.onDidChange(() => {
                this.updateStatusBar();
            });
            this.disposables.push(this.gitWatcher);
            // ì´ˆê¸° ìƒíƒœ ì—…ë°ì´íŠ¸
            this.updateStatusBar();
            // ì—ë””í„° ì €ìž¥ ì´ë²¤íŠ¸ ê°ì§€
            external_vscode_.workspace.onDidSaveTextDocument(() => {
                // ìžë™ ì»¤ë°‹ì´ í™œì„±í™”ë˜ì—ˆì„ ë•Œ íŒŒì¼ ì €ìž¥ ì‹œ ë³€ê²½ ì‚¬í•­ ê°ì§€
                void this.handleFileSaved();
            }, this, this.disposables);
        }
        catch (error) {
            // Git ì €ìž¥ì†Œê°€ ì•„ë‹Œ ê²½ìš° ë¬´ì‹œ
            console.log('Git ì €ìž¥ì†Œê°€ ì•„ë‹™ë‹ˆë‹¤:', error);
        }
    }
    /**
     * ìƒíƒœ í‘œì‹œì¤„ ì—…ë°ì´íŠ¸
     */
    async updateStatusBar() {
        if (!this.workspaceRoot) {
            this.statusBarItem.hide();
            return;
        }
        try {
            // Git ìƒíƒœ í™•ì¸
            const { stdout } = await autoCommitService_execAsync('git status --porcelain', { cwd: this.workspaceRoot });
            if (stdout.trim() === '') {
                // ë³€ê²½ ì‚¬í•­ ì—†ìŒ
                this.statusBarItem.text = "$(git-commit) ìžë™ ì»¤ë°‹ ì¤€ë¹„ë¨";
                this.statusBarItem.tooltip = "ë³€ê²½ ì‚¬í•­ì´ ì—†ìŠµë‹ˆë‹¤";
            }
            else {
                // ë³€ê²½ëœ íŒŒì¼ ìˆ˜ ê³„ì‚°
                const changedFiles = stdout.split('\n').filter(line => line.trim() !== '').length;
                this.statusBarItem.text = `$(git-commit) ìžë™ ì»¤ë°‹ (${changedFiles})`;
                this.statusBarItem.tooltip = `${changedFiles}ê°œ íŒŒì¼ì´ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤`;
            }
            this.statusBarItem.show();
        }
        catch {
            // Git ì €ìž¥ì†Œê°€ ì•„ë‹Œ ê²½ìš°
            this.statusBarItem.text = "$(git-commit) Git ì €ìž¥ì†Œ ì•„ë‹˜";
            this.statusBarItem.tooltip = "í˜„ìž¬ í´ë”ëŠ” Git ì €ìž¥ì†Œê°€ ì•„ë‹™ë‹ˆë‹¤";
            this.statusBarItem.show();
        }
    }
    /**
     * ìžë™ ì»¤ë°‹ í† ê¸€
     */
    toggleAutoCommit() {
        const config = external_vscode_.workspace.getConfiguration('ape.git');
        const current = config.get('autoCommit', false);
        // ì„¤ì • í† ê¸€
        config.update('autoCommit', !current, external_vscode_.ConfigurationTarget.Workspace).then(() => {
            external_vscode_.window.showInformationMessage(`ìžë™ ì»¤ë°‹ì´ ${!current ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}ë˜ì—ˆìŠµë‹ˆë‹¤`);
            // ìƒíƒœ í‘œì‹œì¤„ ì—…ë°ì´íŠ¸
            if (!current) {
                this.statusBarItem.text = "$(git-commit) ìžë™ ì»¤ë°‹ í™œì„±í™”ë¨";
                this.statusBarItem.backgroundColor = new external_vscode_.ThemeColor('statusBarItem.warningBackground');
            }
            else {
                this.statusBarItem.text = "$(git-commit) ìžë™ ì»¤ë°‹ ì¤€ë¹„ë¨";
                this.statusBarItem.backgroundColor = undefined;
            }
        });
    }
    /**
     * íŒŒì¼ ì €ìž¥ ì²˜ë¦¬
     */
    async handleFileSaved() {
        if (this.commitInProgress) {
            return;
        }
        // ìžë™ ì»¤ë°‹ ì„¤ì • í™•ì¸
        const config = external_vscode_.workspace.getConfiguration('ape.git');
        const autoCommitEnabled = config.get('autoCommit', false);
        if (!autoCommitEnabled) {
            return;
        }
        // ì¼ì • ì‹œê°„ í›„ ì»¤ë°‹ (ì—°ì† ì €ìž¥ ë°©ì§€)
        setTimeout(async () => {
            try {
                // ë³€ê²½ ì‚¬í•­ í™•ì¸
                const { stdout } = await autoCommitService_execAsync('git status --porcelain', { cwd: this.workspaceRoot });
                if (stdout.trim() !== '') {
                    // ë³€ê²½ ì‚¬í•­ì´ ìžˆìœ¼ë©´ ì»¤ë°‹
                    await this.createCommit();
                }
            }
            catch (error) {
                console.error('ìžë™ ì»¤ë°‹ ì˜¤ë¥˜:', error);
            }
        }, 2000); // 2ì´ˆ ì§€ì—°
    }
    /**
     * ì»¤ë°‹ ìƒì„±
     */
    async createCommit() {
        if (!this.workspaceRoot || this.commitInProgress) {
            return;
        }
        this.commitInProgress = true;
        try {
            // Git ìƒíƒœ í™•ì¸
            const { stdout: statusOutput } = await autoCommitService_execAsync('git status --porcelain', { cwd: this.workspaceRoot });
            if (statusOutput.trim() === '') {
                external_vscode_.window.showInformationMessage('ì»¤ë°‹í•  ë³€ê²½ ì‚¬í•­ì´ ì—†ìŠµë‹ˆë‹¤');
                this.commitInProgress = false;
                return;
            }
            // ë³€ê²½ëœ íŒŒì¼ ëª©ë¡
            const changedFiles = statusOutput
                .split('\n')
                .filter(line => line.trim() !== '')
                .map(line => {
                const status = line.substring(0, 2).trim();
                const file = line.substring(3).trim();
                return { status, file };
            });
            // ë³€ê²½ ë‚´ìš© í™•ì¸
            const { stdout: diffOutput } = await autoCommitService_execAsync('git diff --staged', { cwd: this.workspaceRoot });
            const unstaged = await autoCommitService_execAsync('git diff', { cwd: this.workspaceRoot });
            try {
                // ìžë™ ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„±
                let commitMessage = await this.generateCommitMessage(changedFiles, diffOutput + unstaged.stdout);
                // ìžë™ ì»¤ë°‹ì˜ ê²½ìš° í”„ë¦¬í”½ìŠ¤ ì¶”ê°€
                const config = external_vscode_.workspace.getConfiguration('ape.git');
                const autoCommitEnabled = config.get('autoCommit', false);
                if (autoCommitEnabled) {
                    // ìžë™ ì»¤ë°‹ì¸ ê²½ìš° [APE][Temporary] í”„ë¦¬í”½ìŠ¤ ì¶”ê°€
                    commitMessage = `[APE][Temporary] ${commitMessage}`;
                }
                // ë³€ê²½ ì‚¬í•­ ìŠ¤í…Œì´ì§•
                await autoCommitService_execAsync('git add .', { cwd: this.workspaceRoot });
                // ì»¤ë°‹ ìƒì„±
                await autoCommitService_execAsync(`git commit -m "${commitMessage}"`, { cwd: this.workspaceRoot });
                // ì„±ê³µ ë©”ì‹œì§€
                external_vscode_.window.showInformationMessage(`ì»¤ë°‹ ì„±ê³µ: ${commitMessage}`);
                // ìƒíƒœ ì—…ë°ì´íŠ¸
                this.updateStatusBar();
            }
            catch (error) {
                // ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„± ì‹¤íŒ¨ ì²˜ë¦¬
                const errorMessage = error.message || 'ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜';
                // BitBucket ì˜¤ë¥˜ë‚˜ Jira ì˜¤ë¥˜ ë“± ì™¸ë¶€ API ì˜¤ë¥˜ì¼ ê²½ìš° êµ¬ì²´ì ì¸ ë©”ì‹œì§€ ì „ë‹¬
                if (errorMessage.includes('BitBucket') || errorMessage.includes('Jira')) {
                    external_vscode_.window.showErrorMessage(`ì„œë¹„ìŠ¤ ì—°ê²° ì‹¤íŒ¨: ${errorMessage}. ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.`);
                }
                else {
                    external_vscode_.window.showErrorMessage(`ì»¤ë°‹ ì‹¤íŒ¨: ${errorMessage}`);
                }
                // API ì„¤ì • ì•ˆë‚´
                const openSettings = 'ì„¤ì • ì—´ê¸°';
                external_vscode_.window.showInformationMessage('ì•„í‹€ë¼ì‹œì•ˆ API ì„¤ì •ì´ ì˜¬ë°”ë¥´ì§€ ì•Šê±°ë‚˜ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤. ì„¤ì •ì—ì„œ í™•ì¸í•´ë³´ì„¸ìš”.', openSettings).then(selection => {
                    if (selection === openSettings) {
                        external_vscode_.commands.executeCommand('workbench.action.openSettings', 'ape.bitbucket');
                    }
                });
            }
        }
        catch (error) {
            // Git ëª…ë ¹ ì‹¤í–‰ ìžì²´ì˜ ì˜¤ë¥˜ (status ì¡°íšŒ, diff ì‹¤íŒ¨ ë“±)
            external_vscode_.window.showErrorMessage(`Git ëª…ë ¹ ì‹¤íŒ¨: ${error.message}`);
        }
        finally {
            this.commitInProgress = false;
        }
    }
    /**
     * ìžë™ ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„±
     */
    async generateCommitMessage(changedFiles, diff) {
        try {
            // ì„¤ì •ì—ì„œ LLM ì‚¬ìš© ì—¬ë¶€ í™•ì¸
            const config = external_vscode_.workspace.getConfiguration('ape.git');
            const useLLM = config.get('useLLMForCommitMessages', false);
            // LLM ì‚¬ìš© ì‹œ ê³ ê¸‰ ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„±
            if (useLLM && diff.length > 0) {
                try {
                    return await this.generateLLMCommitMessage(changedFiles, diff);
                }
                catch (error) {
                    console.error('LLM ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„± ì‹¤íŒ¨:', error);
                    // LLM ìƒì„± ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ë©”ì‹œì§€ ìƒì„± ë¡œì§ìœ¼ë¡œ í´ë°±
                }
            }
            // ê°„ë‹¨í•œ ì»¤ë°‹ ë©”ì‹œì§€ í—¤ë” ìƒì„± ë¡œì§
            let messagePrefix = '';
            // ë³€ê²½ ìœ í˜•ì— ë”°ë¥¸ ì ‘ë‘ì‚¬ ê²°ì •
            const newFiles = changedFiles.filter(file => file.status.includes('A') || file.status.includes('?'));
            const modifiedFiles = changedFiles.filter(file => file.status.includes('M'));
            const deletedFiles = changedFiles.filter(file => file.status.includes('D'));
            if (newFiles.length > 0 && modifiedFiles.length === 0 && deletedFiles.length === 0) {
                messagePrefix = 'Add';
            }
            else if (modifiedFiles.length > 0 && newFiles.length === 0 && deletedFiles.length === 0) {
                messagePrefix = 'Update';
            }
            else if (deletedFiles.length > 0 && newFiles.length === 0 && modifiedFiles.length === 0) {
                messagePrefix = 'Remove';
            }
            else if (deletedFiles.length > 0 || newFiles.length > 0) {
                messagePrefix = 'Refactor';
            }
            else {
                messagePrefix = 'Fix';
            }
            // ë³€ê²½ëœ íŒŒì¼ ê²½ë¡œì—ì„œ ì£¼ìš” êµ¬ì„± ìš”ì†Œ ì¶”ì¶œ
            const fileComponents = [];
            for (const file of changedFiles) {
                const ext = external_path_.extname(file.file);
                const dir = external_path_.dirname(file.file);
                // í™•ìž¥ìž ë° ë””ë ‰í† ë¦¬ ì •ë³´ ìˆ˜ì§‘
                if (ext && !fileComponents.includes(ext.substring(1))) {
                    fileComponents.push(ext.substring(1));
                }
                // ì£¼ìš” ë””ë ‰í† ë¦¬ ê²½ë¡œ ì¶”ì¶œ
                const mainDir = dir.split('/')[0];
                if (mainDir && mainDir !== '.' && !fileComponents.includes(mainDir)) {
                    fileComponents.push(mainDir);
                }
            }
            // ë³€ê²½ëœ íŒŒì¼ ëª©ë¡ ìš”ì•½
            let fileList = '';
            if (changedFiles.length <= 3) {
                fileList = changedFiles.map(f => external_path_.basename(f.file)).join(', ');
            }
            else {
                fileList = `${changedFiles.length} files`;
            }
            // ê¸°ë³¸ ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„±
            const component = fileComponents.length > 0 ? fileComponents.join(', ') : 'code';
            const baseMessage = `${messagePrefix} ${component}: `;
            return `${baseMessage}${fileList}`;
        }
        catch (error) {
            console.error('ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„± ì˜¤ë¥˜:', error);
            throw new Error(`ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„± ì‹¤íŒ¨: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * LLMì„ ì‚¬ìš©í•œ ê³ ê¸‰ ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„±
     * @throws Error ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„± ì‹¤íŒ¨ ì‹œ ì˜¤ë¥˜ë¥¼ ë˜ì§
     */
    async generateLLMCommitMessage(changedFiles, diff) {
        // ì»¤ë°‹ ë©”ì‹œì§€ ì˜ˆì œ ê°€ì ¸ì˜¤ê¸°
        let commitExamples = '';
        try {
            // BitBucket ì„œë¹„ìŠ¤ê°€ ì£¼ìž…ë˜ì—ˆëŠ”ì§€ í™•ì¸
            if (this.bitbucketService) {
                try {
                    // BitBucket APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ìš©ìž ì´ë¦„ ê°€ì ¸ì˜¤ê¸°
                    const userName = await this.bitbucketService.getGitUsername();
                    if (userName) {
                        // BitBucket APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì‚¬ìš©ìžì˜ ìµœê·¼ ì»¤ë°‹ ì´ë ¥ ê²€ìƒ‰
                        const commits = await this.bitbucketService.getCommitHistory(userName, 20);
                        if (commits && commits.length > 0) {
                            // ì»¤ë°‹ ì´ë ¥ì„ í¬ë§·íŒ…í•˜ì—¬ ì˜ˆì œë¡œ ì‚¬ìš©
                            const formattedHistory = commits.map(commit => `${commit.displayId} - ${commit.message}`).join('\n');
                            // ì‚¬ìš©ìžì˜ ìµœê·¼ ì»¤ë°‹ ë©”ì‹œì§€ë¥¼ ì˜ˆì œë¡œ ì‚¬ìš©
                            commitExamples = `Here are some example commit messages to follow the style:\n${formattedHistory}\n\n`;
                        }
                    }
                }
                catch (error) {
                    console.error('BitBucket ì„œë¹„ìŠ¤ ì˜¤ë¥˜:', error);
                    // BitBucket ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ì‹œ ë¡œì»¬ Git ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ í´ë°±
                    await this.fallbackToLocalGitHistory();
                }
            }
            else {
                // BitBucket ì„œë¹„ìŠ¤ê°€ ì£¼ìž…ë˜ì§€ ì•Šì€ ê²½ìš° ë¡œì»¬ Git ëª…ë ¹ì–´ ì‚¬ìš©
                await this.fallbackToLocalGitHistory();
            }
        }
        catch (error) {
            console.error('ì»¤ë°‹ ì´ë ¥ ê²€ìƒ‰ ì˜¤ë¥˜:', error);
            // ëª¨ë“  ë°©ë²•ì´ ì‹¤íŒ¨í•˜ë©´ ê¸°ë³¸ ì˜ˆì œ ì‚¬ìš©
            const defaultExamples = [
                "feat(ui): add slash command suggestions to chat interface",
                "fix(core): resolve memory leak in service initialization",
                "docs(api): update API documentation with examples",
                "refactor(git): improve auto-commit change detection",
                "style(ui): update chat interface styling",
                "test(llm): add integration tests for LLM service",
                "perf(stream): optimize streaming response handling",
                "chore(deps): update dependencies to latest versions"
            ];
            commitExamples = `Here are some example commit messages to follow the style:\n${defaultExamples.join('\n')}\n\n`;
        }
        // diffê°€ ë„ˆë¬´ ê¸¸ë©´ ìž˜ë¼ë‚´ê¸°
        const maxDiffLength = 5000; // ìµœëŒ€ 5000ìž
        const truncatedDiff = diff.length > maxDiffLength ?
            diff.substring(0, maxDiffLength) + '\n... (truncated)' : diff;
        // íŒŒì¼ ëª©ë¡ ìƒì„±
        const fileChangeList = changedFiles.map(file => {
            return `${file.status} ${file.file}`;
        }).join('\n');
        // Conventional Commits í˜•ì‹ ì•ˆë‚´
        const prompt = `Please generate a concise and meaningful Git commit message for the following changes. 
Use the Conventional Commits format: <type>(<scope>): <description>

Types: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert

${commitExamples}
Changed files:
${fileChangeList}

Diff:
${truncatedDiff}

Generate ONLY the commit message without any explanation. Keep it under 72 characters if possible.`;
        try {
            // LLMì— ìš”ì²­ ë³´ë‚´ê¸°
            const result = await this.llmService.getCompletion(prompt);
            if (result.success && result.data) {
                // ê³µë°± ì œê±° ë° ì •ë¦¬
                const message = result.data.trim();
                // ê²°ê³¼ê°€ ì§§ê³  ì˜ë¯¸ìžˆì„ ê²½ìš° ì‚¬ìš©
                if (message.length > 0 && message.length < 200) {
                    return message;
                }
            }
            // LLM ê²°ê³¼ê°€ ì ì ˆí•˜ì§€ ì•Šì„ ê²½ìš° ì˜¤ë¥˜ ë°œìƒ
            throw new Error('LLM ìƒì„± ê²°ê³¼ê°€ ì ì ˆí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤');
        }
        catch (error) {
            // LLM ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ë¡œê¹…
            console.error('LLM ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„± ì˜¤ë¥˜:', error);
            // ì˜¤ë¥˜ ì „íŒŒ - í˜¸ì¶œìžì—ì„œ ê¸°ë³¸ ë©”ì‹œì§€ ìƒì„± ë¡œì§ìœ¼ë¡œ í´ë°±
            throw new Error(`LLM ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„± ì‹¤íŒ¨: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * ë¡œì»¬ Git ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì»¤ë°‹ ì´ë ¥ ê°€ì ¸ì˜¤ê¸° (BitBucket í´ë°±)
     * @private
     */
    async fallbackToLocalGitHistory() {
        try {
            const { stdout: userName } = await autoCommitService_execAsync('git config --get user.name', { cwd: this.workspaceRoot });
            if (userName.trim()) {
                // ì‚¬ìš©ìž ì´ë¦„ìœ¼ë¡œ ì»¤ë°‹ ì´ë ¥ ê²€ìƒ‰
                const { stdout: commitHistory } = await autoCommitService_execAsync(`git log --author="${userName.trim()}" -n 20 --pretty=format:"%h - %s"`, { cwd: this.workspaceRoot });
                if (commitHistory.trim()) {
                    // ì‚¬ìš©ìžì˜ ìµœê·¼ ì»¤ë°‹ ë©”ì‹œì§€ë¥¼ ì˜ˆì œë¡œ ì‚¬ìš©
                    return `Here are some example commit messages to follow the style:\n${commitHistory.trim()}\n\n`;
                }
            }
            // ë¡œì»¬ Git ëª…ë ¹ì–´ë„ ì‹¤íŒ¨í•˜ë©´ ë¹ˆ ë¬¸ìžì—´ ë°˜í™˜
            return '';
        }
        catch (error) {
            console.error('ë¡œì»¬ Git ì´ë ¥ ê²€ìƒ‰ ì˜¤ë¥˜:', error);
            return '';
        }
    }
    /**
     * ìž„ì‹œ ì»¤ë°‹ í†µí•©
     *
     * [APE][Temporary] í”„ë¦¬í”½ìŠ¤ê°€ ë¶™ì€ ëª¨ë“  ìž„ì‹œ ì»¤ë°‹ì„ ì°¾ì•„ì„œ
     * ì´ë“¤ì„ í†µí•©í•˜ì—¬ í•˜ë‚˜ì˜ ì •ìƒì ì¸ ì»¤ë°‹ìœ¼ë¡œ ë§Œë“­ë‹ˆë‹¤.
     */
    async consolidateTemporaryCommits() {
        if (!this.workspaceRoot) {
            external_vscode_.window.showErrorMessage('Git ì €ìž¥ì†Œê°€ ì—†ìŠµë‹ˆë‹¤.');
            return;
        }
        try {
            // ì§„í–‰ ì¤‘ ì•ˆë‚´
            external_vscode_.window.withProgress({
                location: external_vscode_.ProgressLocation.Notification,
                title: "ìž„ì‹œ ì»¤ë°‹ í†µí•© ì¤‘...",
                cancellable: false
            }, async (progress) => {
                progress.report({ message: "ìž„ì‹œ ì»¤ë°‹ ì°¾ëŠ” ì¤‘..." });
                // [APE][Temporary] í”„ë¦¬í”½ìŠ¤ê°€ ë¶™ì€ ì»¤ë°‹ ì°¾ê¸°
                const { stdout: logOutput } = await autoCommitService_execAsync('git log --pretty=format:"%H %s" -n 30', { cwd: this.workspaceRoot });
                // ìž„ì‹œ ì»¤ë°‹ ëª©ë¡ ì¶”ì¶œ
                const allCommits = logOutput.split('\n')
                    .map(line => {
                    const space = line.indexOf(' ');
                    return {
                        hash: line.substring(0, space),
                        message: line.substring(space + 1),
                        isTemporary: line.substring(space + 1).includes('[APE][Temporary]')
                    };
                });
                // ì—°ì†ëœ ìž„ì‹œ ì»¤ë°‹ ê·¸ë£¹ ì°¾ê¸°
                const temporaryGroups = [];
                let currentGroup = [];
                // ê°€ìž¥ ìµœê·¼ ì»¤ë°‹ë¶€í„° ê²€ì‚¬í•˜ì—¬ ì—°ì†ëœ ìž„ì‹œ ì»¤ë°‹ ê·¸ë£¹ ì°¾ê¸°
                for (const commit of allCommits) {
                    if (commit.isTemporary) {
                        currentGroup.push(commit);
                    }
                    else {
                        // ì¼ë°˜ ì»¤ë°‹ì„ ë§Œë‚˜ë©´ ì§€ê¸ˆê¹Œì§€ì˜ ê·¸ë£¹ì„ ì €ìž¥í•˜ê³  ìƒˆ ê·¸ë£¹ ì‹œìž‘
                        if (currentGroup.length > 0) {
                            temporaryGroups.push([...currentGroup]);
                            currentGroup = [];
                        }
                    }
                }
                // ë§ˆì§€ë§‰ ê·¸ë£¹ì´ ë‚¨ì•„ìžˆìœ¼ë©´ ì¶”ê°€
                if (currentGroup.length > 0) {
                    temporaryGroups.push(currentGroup);
                }
                // ìž„ì‹œ ì»¤ë°‹ì´ ì—†ëŠ” ê²½ìš°
                if (temporaryGroups.length === 0 || temporaryGroups[0].length === 0) {
                    external_vscode_.window.showInformationMessage('í†µí•©í•  ìž„ì‹œ ì»¤ë°‹ì´ ì—†ìŠµë‹ˆë‹¤.');
                    return;
                }
                // ê°€ìž¥ ìµœê·¼ì˜ ì—°ì†ëœ ìž„ì‹œ ì»¤ë°‹ ê·¸ë£¹ ì„ íƒ (ì²« ë²ˆì§¸ ê·¸ë£¹)
                const commits = temporaryGroups[0];
                // ìž„ì‹œ ì»¤ë°‹ ì´ì „ í•´ì‹œ ì°¾ê¸°
                const oldestTempCommitHash = commits[commits.length - 1].hash;
                // ìž„ì‹œ ì»¤ë°‹ ì´ì „ ì»¤ë°‹ ì°¾ê¸°
                const { stdout: parentHash } = await autoCommitService_execAsync(`git rev-parse ${oldestTempCommitHash}^`, { cwd: this.workspaceRoot });
                // í†µí•©í•  ì»¤ë°‹ ìˆ˜ í™•ì¸
                const commitCount = commits.length;
                // ë©”ì‹œì§€ ìƒì„±
                progress.report({ message: "ë³€ê²½ ë‚´ìš© ì·¨í•© ì¤‘..." });
                // ë³€ê²½ ì‚¬í•­ ì·¨í•©ì„ ìœ„í•œ ì„¤ëª… ìž‘ì„±
                let commitDescription = '';
                try {
                    // ë³€ê²½ ë‚´ìš© diff ê°€ì ¸ì˜¤ê¸°
                    const { stdout: diffOutput } = await autoCommitService_execAsync(`git diff ${parentHash.trim()} HEAD`, { cwd: this.workspaceRoot });
                    // ìž„ì‹œ ì»¤ë°‹ ë©”ì‹œì§€ ëª¨ìŒ
                    const messages = commits.map(c => c.message.replace('[APE][Temporary] ', '')).join('\n');
                    // ì„¤ëª… ìƒì„± (LLM ì‚¬ìš©)
                    progress.report({ message: "ì»¤ë°‹ ì„¤ëª… ìƒì„± ì¤‘..." });
                    // LLM ì‚¬ìš© ì„¤ì • í™•ì¸
                    const config = external_vscode_.workspace.getConfiguration('ape.git');
                    const useLLM = config.get('useLLMForCommitMessages', false);
                    if (useLLM) {
                        // LLMìœ¼ë¡œ í†µí•© ì»¤ë°‹ ë©”ì‹œì§€ ìƒì„±
                        const prompt = `ë‹¤ìŒì€ ì—¬ëŸ¬ ìž„ì‹œ ì»¤ë°‹ì„ í†µí•©í•˜ê¸° ìœ„í•œ ì •ë³´ìž…ë‹ˆë‹¤.

ìž„ì‹œ ì»¤ë°‹ ë©”ì‹œì§€ë“¤:
${messages}

ë³€ê²½ ë‚´ìš© ìš”ì•½ (diff):
${diffOutput.length > 5000 ? diffOutput.substring(0, 5000) + '\n... (ìž˜ë¦¼)' : diffOutput}

ìœ„ ìž„ì‹œ ì»¤ë°‹ë“¤ì„ í†µí•©í•˜ëŠ” í•˜ë‚˜ì˜ ì •ì‹ ì»¤ë°‹ ë©”ì‹œì§€ë¥¼ ìž‘ì„±í•´ì£¼ì„¸ìš”.
Conventional Commits í˜•ì‹ì„ ì‚¬ìš©í•˜ì„¸ìš”: <type>(<scope>): <description>
íƒ€ìž…: feat, fix, docs, style, refactor, perf, test, build, ci, chore, revert
ì„¤ëª…ë§Œ ì œê³µí•˜ê³  ë‹¤ë¥¸ ì„¤ëª…ì€ í•˜ì§€ ë§ˆì„¸ìš”. ê°€ëŠ¥í•˜ë©´ 72ìž ë¯¸ë§Œìœ¼ë¡œ ìž‘ì„±í•˜ì„¸ìš”.`;
                        const result = await this.llmService.getCompletion(prompt);
                        if (result.success && result.data) {
                            commitDescription = result.data.trim();
                        }
                    }
                    // LLM ì‹¤íŒ¨ ë˜ëŠ” ë¹„í™œì„±í™”ëœ ê²½ìš° ê¸°ë³¸ ë©”ì‹œì§€ ìƒì„±
                    if (!commitDescription) {
                        commitDescription = `chore(git): consolidate ${commitCount} temporary commits`;
                    }
                }
                catch (error) {
                    console.error('ì»¤ë°‹ ì„¤ëª… ìƒì„± ì˜¤ë¥˜:', error);
                    commitDescription = `chore(git): consolidate ${commitCount} temporary commits`;
                }
                // ì‚¬ìš©ìžì—ê²Œ ìµœì¢… í™•ì¸ ìš”ì²­
                progress.report({ message: "í†µí•© ì¤€ë¹„ ì™„ë£Œ..." });
                const result = await external_vscode_.window.showInformationMessage(`${commitCount}ê°œì˜ ìž„ì‹œ ì»¤ë°‹ì„ í†µí•©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?`, { modal: true }, 'í†µí•©í•˜ê¸°', 'ì·¨ì†Œ');
                if (result !== 'í†µí•©í•˜ê¸°') {
                    return;
                }
                // git reset --softë¡œ ë³€ê²½ ì‚¬í•­ ìœ ì§€í•˜ë©° ì»¤ë°‹ ì·¨ì†Œ
                progress.report({ message: "ìž„ì‹œ ì»¤ë°‹ ë¦¬ì…‹ ì¤‘..." });
                await autoCommitService_execAsync(`git reset --soft ${parentHash.trim()}`, { cwd: this.workspaceRoot });
                // í†µí•© ì»¤ë°‹ ìƒì„±
                progress.report({ message: "í†µí•© ì»¤ë°‹ ìƒì„± ì¤‘..." });
                await autoCommitService_execAsync(`git commit -m "${commitDescription.replace(/"/g, '\\"')}"`, { cwd: this.workspaceRoot });
                // ì„±ê³µ ë©”ì‹œì§€
                external_vscode_.window.showInformationMessage(`${commitCount}ê°œì˜ ìž„ì‹œ ì»¤ë°‹ì´ ì„±ê³µì ìœ¼ë¡œ í†µí•©ë˜ì—ˆìŠµë‹ˆë‹¤.`);
                // ìƒíƒœ ì—…ë°ì´íŠ¸
                this.updateStatusBar();
            });
        }
        catch (error) {
            external_vscode_.window.showErrorMessage(`ìž„ì‹œ ì»¤ë°‹ í†µí•© ì˜¤ë¥˜: ${error.message}`);
        }
    }
    /**
     * ë¦¬ì†ŒìŠ¤ í•´ì œ
     */
    dispose() {
        this.statusBarItem.dispose();
        for (const disposable of this.disposables) {
            disposable.dispose();
        }
        this.disposables = [];
    }
}

;// ./src/core/git/bitbucketService.ts
/**
 * BitBucket ì„œë¹„ìŠ¤
 *
 * BitBucket APIë¥¼ ì‚¬ìš©í•˜ì—¬ Git ì €ìž¥ì†Œ ì •ë³´ë¥¼ ì¡°íšŒí•˜ê³  ê´€ë¦¬í•˜ëŠ” ì„œë¹„ìŠ¤ìž…ë‹ˆë‹¤.
 * ë‚´ë¶€ë§ BitBucket ì„œë²„ì™€ í†µì‹ í•˜ë©°, ì‹¤ì œ ì„œë²„ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ëŠ” ê²½ìš° Mock ë°ì´í„°ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
 */



/**
 * BitBucket ì„œë¹„ìŠ¤ ì˜¤ë¥˜ ìœ í˜•
 */
var BitbucketErrorType;
(function (BitbucketErrorType) {
    BitbucketErrorType["ConnectionFailed"] = "connection_failed";
    BitbucketErrorType["AuthenticationFailed"] = "authentication_failed";
    BitbucketErrorType["PermissionDenied"] = "permission_denied";
    BitbucketErrorType["ResourceNotFound"] = "resource_not_found";
    BitbucketErrorType["ServerError"] = "server_error";
    BitbucketErrorType["Unknown"] = "unknown";
})(BitbucketErrorType || (BitbucketErrorType = {}));
/**
 * BitBucket ì„œë¹„ìŠ¤ í´ëž˜ìŠ¤
 */
class BitbucketService {
    context;
    serviceConfigManager;
    baseUrl = '';
    projectKey = '';
    repoSlug = '';
    username = '';
    password = '';
    token = '';
    authType = AuthType.Basic;
    useMock = true;
    disposables = [];
    _lastError = null;
    /**
     * BitBucket ì„œë¹„ìŠ¤ ìƒì„±ìž
     * @param context VSCode í™•ìž¥ ì»¨í…ìŠ¤íŠ¸
     * @param serviceConfigManager ì„œë¹„ìŠ¤ ì„¤ì • ê´€ë¦¬ìž (ì„ íƒì )
     */
    constructor(context, serviceConfigManager) {
        this.context = context;
        this.serviceConfigManager = serviceConfigManager;
        // ì„¤ì • ë¡œë“œ
        this.loadConfiguration();
        // ì„¤ì • ë³€ê²½ ê°ì§€
        this.disposables.push(external_vscode_.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.bitbucket')) {
                this.loadConfiguration();
            }
        }));
    }
    /**
     * ì„¤ì • ë‹¤ì‹œ ë¡œë“œ
     */
    loadConfiguration() {
        if (this.serviceConfigManager) {
            // ì„œë¹„ìŠ¤ ì„¤ì • ê´€ë¦¬ìžë¥¼ ì‚¬ìš©í•˜ì—¬ ì„¤ì • ë¡œë“œ
            const config = this.serviceConfigManager.getServiceConfig(ServiceType.Bitbucket);
            this.baseUrl = config.url;
            this.authType = config.authType;
            this.username = config.username || '';
            this.password = config.password || '';
            this.token = config.token || '';
            this.useMock = config.useMock;
            // ì¶”ê°€ íŒŒë¼ë¯¸í„°ì—ì„œ í”„ë¡œì íŠ¸ í‚¤ì™€ ì €ìž¥ì†Œ ìŠ¬ëŸ¬ê·¸ ê°€ì ¸ì˜¤ê¸°
            const additionalParams = config.additionalParams || {};
            this.projectKey = additionalParams.projectKey || '';
            this.repoSlug = additionalParams.repositorySlug || '';
        }
        else {
            // ì§ì ‘ VSCode ì„¤ì •ì—ì„œ ë¡œë“œ
            const config = external_vscode_.workspace.getConfiguration('ape.bitbucket');
            this.baseUrl = config.get('url', '');
            this.projectKey = config.get('projectKey', '');
            this.repoSlug = config.get('repositorySlug', '');
            this.username = config.get('username', '');
            this.password = config.get('password', '');
            this.token = config.get('token', '');
            this.authType = config.get('authType', AuthType.Basic);
            this.useMock = config.get('useMock', false);
        }
        // í•„ìˆ˜ ì„¤ì •ì´ ì—†ìœ¼ë©´ ëª¨ì˜ ëª¨ë“œ ê°•ì œ í™œì„±í™”
        if (!this.baseUrl || (this.authType === AuthType.Basic && (!this.username || !this.password)) ||
            (this.authType === AuthType.Token && !this.token)) {
            this.useMock = true;
        }
    }
    /**
     * ë§ˆì§€ë§‰ ì˜¤ë¥˜ ê°€ì ¸ì˜¤ê¸°
     */
    get lastError() {
        return this._lastError;
    }
    /**
     * íŠ¹ì • ì‚¬ìš©ìžì˜ ìµœê·¼ ì»¤ë°‹ ì´ë ¥ ê°€ì ¸ì˜¤ê¸°
     * @param authorName ìž‘ì„±ìž ì´ë¦„ (ë¹„ì–´ ìžˆìœ¼ë©´ ëª¨ë“  ì»¤ë°‹ ê°€ì ¸ì˜´)
     * @param limit ê°€ì ¸ì˜¬ ì»¤ë°‹ ìˆ˜ (ê¸°ë³¸ê°’: 20)
     * @returns ì»¤ë°‹ ëª©ë¡
     * @throws Error ì—°ê²° ì‹¤íŒ¨ ë˜ëŠ” ì„œë²„ ì˜¤ë¥˜ ì‹œ ì˜¤ë¥˜ë¥¼ ë˜ì§
     */
    async getCommitHistory(authorName, limit = 20) {
        try {
            // ë§ˆì§€ë§‰ ì˜¤ë¥˜ ì´ˆê¸°í™”
            this._lastError = null;
            // ëª¨ì˜ ëª¨ë“œì¸ ê²½ìš° ëª¨ì˜ ë°ì´í„° ë°˜í™˜
            if (this.useMock) {
                return this.getMockCommitHistory(authorName, limit);
            }
            // í•„ìˆ˜ ì„¤ì • í™•ì¸
            if (!this.baseUrl) {
                throw new Error('BitBucket ì„œë²„ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('BitBucket ì¸ì¦ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì‚¬ìš©ìž ì´ë¦„ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Token && !this.token) {
                throw new Error('BitBucket ì¸ì¦ í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í† í° ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (!this.projectKey || !this.repoSlug) {
                throw new Error('BitBucket í”„ë¡œì íŠ¸ í‚¤ ë˜ëŠ” ì €ìž¥ì†Œ ìŠ¬ëŸ¬ê·¸ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            // BitBucket REST API ì—”ë“œí¬ì¸íŠ¸
            const url = `${this.baseUrl}/rest/api/1.0/projects/${this.projectKey}/repos/${this.repoSlug}/commits`;
            // ì¿¼ë¦¬ íŒŒë¼ë¯¸í„°
            const params = {
                limit: limit
            };
            // ìž‘ì„±ìž í•„í„°ë§
            if (authorName) {
                // BitBucket Server APIëŠ” 'until' íŒŒë¼ë¯¸í„°ë¥¼ ì‚¬ìš©í•˜ì—¬ ì»¤ë°‹ ë²”ìœ„ë¥¼ ì§€ì •í•  ìˆ˜ ìžˆìŒ
                params.until = 'HEAD';
                // 'since'ëŠ” ì„ íƒì ìœ¼ë¡œ ì‚¬ìš© (í•„ìš”í•˜ë©´ ì¶”ê°€)
            }
            // API ìš”ì²­ ì„¤ì •
            const config = {};
            // ì¸ì¦ ìœ í˜•ì— ë”°ë¥¸ ì„¤ì •
            if (this.authType === AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // ì¿¼ë¦¬ íŒŒë¼ë¯¸í„° ì„¤ì •
            config.params = params;
            // API ìš”ì²­ ì‹¤í–‰
            const response = await lib_axios.get(url, config);
            // ì‘ë‹µ ë°ì´í„° íŒŒì‹±
            const commits = response.data.values.filter((commit) => {
                // ìž‘ì„±ìž í•„í„°ë§ (ì„œë²„ì—ì„œ ì§€ì›í•˜ì§€ ì•ŠëŠ” ê²½ìš° í´ë¼ì´ì–¸íŠ¸ì¸¡ì—ì„œ í•„í„°ë§)
                return !authorName || commit.author.name === authorName;
            }).map((commit) => ({
                id: commit.id,
                displayId: commit.displayId,
                message: commit.message,
                author: {
                    name: commit.author.name,
                    emailAddress: commit.author.emailAddress
                },
                authorTimestamp: commit.authorTimestamp
            }));
            return commits;
        }
        catch (error) {
            // ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¶„ë¥˜
            this.handleError(error);
            // ì˜¤ë¥˜ ë¡œê·¸
            console.error('BitBucket ì»¤ë°‹ ì´ë ¥ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
            // ë§ˆì§€ë§‰ ì˜¤ë¥˜ ê°ì²´ë¥¼ í†µí•´ ì˜ˆì™¸ ìƒì„±
            if (this._lastError) {
                throw new Error(`BitBucket ì˜¤ë¥˜ (${this._lastError.type}): ${this._lastError.message}`);
            }
            else {
                throw error; // ì›ë³¸ ì˜¤ë¥˜ ì „íŒŒ
            }
        }
    }
    /**
     * ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¶„ë¥˜
     * @param error ë°œìƒí•œ ì˜¤ë¥˜
     * @private
     */
    handleError(error) {
        if (lib_axios.isAxiosError(error)) {
            const axiosError = error;
            if (!axiosError.response) {
                // ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜
                this.setError(BitbucketErrorType.ConnectionFailed, `BitBucket ì„œë²„ ì—°ê²° ì‹¤íŒ¨: ${error.message}. ì„œë²„ URLì„ í™•ì¸í•˜ì„¸ìš”: ${this.baseUrl}`);
            }
            else {
                // HTTP ìƒíƒœ ì½”ë“œì— ë”°ë¥¸ ì˜¤ë¥˜ ë¶„ë¥˜
                const status = axiosError.response.status;
                if (status === 401 || status === 403) {
                    this.setError(BitbucketErrorType.AuthenticationFailed, `BitBucket ì¸ì¦ ì‹¤íŒ¨: ${error.message}. ì‚¬ìš©ìž ì´ë¦„ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.`);
                }
                else if (status === 404) {
                    this.setError(BitbucketErrorType.ResourceNotFound, `BitBucket ë¦¬ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: ${error.message}. í”„ë¡œì íŠ¸ í‚¤ì™€ ì €ìž¥ì†Œ ìŠ¬ëŸ¬ê·¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.`);
                }
                else if (status >= 500) {
                    this.setError(BitbucketErrorType.ServerError, `BitBucket ì„œë²„ ì˜¤ë¥˜: ${error.message}. ì„œë²„ ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”.`);
                }
                else {
                    this.setError(BitbucketErrorType.Unknown, `BitBucket ì˜¤ë¥˜: ${error.message}`);
                }
            }
        }
        else {
            // ì¼ë°˜ ì˜¤ë¥˜
            this.setError(BitbucketErrorType.Unknown, `BitBucket ì˜¤ë¥˜: ${error.message}`);
        }
    }
    /**
     * ì˜¤ë¥˜ ì„¤ì •
     * @param type ì˜¤ë¥˜ ìœ í˜•
     * @param message ì˜¤ë¥˜ ë©”ì‹œì§€
     * @param details ì¶”ê°€ ì„¸ë¶€ ì •ë³´
     * @private
     */
    setError(type, message, details) {
        this._lastError = {
            type,
            message,
            details
        };
        // ì½˜ì†”ì— ì˜¤ë¥˜ ê¸°ë¡
        console.error(`BitBucket ì˜¤ë¥˜ (${type}):`, message, details || '');
    }
    /**
     * ì‚¬ìš©ìžì˜ Git ì‚¬ìš©ìž ì´ë¦„ ê°€ì ¸ì˜¤ê¸° (BitBucket ê³„ì • ì´ë¦„ê³¼ ë‹¤ë¥¼ ìˆ˜ ìžˆìŒ)
     * @returns Git ì‚¬ìš©ìž ì´ë¦„
     * @throws Error ì—°ê²° ì‹¤íŒ¨ ë˜ëŠ” ì„œë²„ ì˜¤ë¥˜ ì‹œ ì˜¤ë¥˜ë¥¼ ë˜ì§
     */
    async getGitUsername() {
        try {
            // ë§ˆì§€ë§‰ ì˜¤ë¥˜ ì´ˆê¸°í™”
            this._lastError = null;
            // ëª¨ì˜ ëª¨ë“œì¸ ê²½ìš° ëª¨ì˜ ë°ì´í„° ë°˜í™˜
            if (this.useMock) {
                return 'TestUser';
            }
            // í•„ìˆ˜ ì„¤ì • í™•ì¸
            if (!this.baseUrl) {
                throw new Error('BitBucket ì„œë²„ URLì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Basic && (!this.username || !this.password)) {
                throw new Error('BitBucket ì¸ì¦ ì •ë³´ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì‚¬ìš©ìž ì´ë¦„ê³¼ ë¹„ë°€ë²ˆí˜¸ë¥¼ í™•ì¸í•˜ì„¸ìš”.');
            }
            if (this.authType === AuthType.Token && !this.token) {
                throw new Error('BitBucket ì¸ì¦ í† í°ì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í† í° ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.');
            }
            // BitBucket REST APIë¥¼ í†µí•´ í˜„ìž¬ ì‚¬ìš©ìž ì •ë³´ ê°€ì ¸ì˜¤ê¸°
            const url = `${this.baseUrl}/rest/api/1.0/users/~`;
            // API ìš”ì²­ ì„¤ì •
            const config = {};
            // ì¸ì¦ ìœ í˜•ì— ë”°ë¥¸ ì„¤ì •
            if (this.authType === AuthType.Basic) {
                config.auth = {
                    username: this.username,
                    password: this.password
                };
            }
            else if (this.authType === AuthType.Token) {
                config.headers = {
                    ...config.headers,
                    'Authorization': `Bearer ${this.token}`
                };
            }
            // API ìš”ì²­ ì‹¤í–‰
            const response = await lib_axios.get(url, config);
            return response.data.displayName || response.data.name || this.username;
        }
        catch (error) {
            // ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¶„ë¥˜
            this.handleError(error);
            // ì˜¤ë¥˜ ë¡œê·¸
            console.error('BitBucket ì‚¬ìš©ìž ì •ë³´ ê°€ì ¸ì˜¤ê¸° ì‹¤íŒ¨:', error);
            // ë§ˆì§€ë§‰ ì˜¤ë¥˜ ê°ì²´ë¥¼ í†µí•´ ì˜ˆì™¸ ìƒì„±
            if (this._lastError) {
                throw new Error(`BitBucket ì˜¤ë¥˜ (${this._lastError.type}): ${this._lastError.message}`);
            }
            else {
                throw error; // ì›ë³¸ ì˜¤ë¥˜ ì „íŒŒ
            }
        }
    }
    /**
     * ëª¨ì˜ ì»¤ë°‹ ì´ë ¥ ìƒì„±
     * @param authorName ìž‘ì„±ìž ì´ë¦„
     * @param limit ê°€ì ¸ì˜¬ ì»¤ë°‹ ìˆ˜
     * @returns ëª¨ì˜ ì»¤ë°‹ ëª©ë¡
     */
    getMockCommitHistory(authorName, limit = 20) {
        // ëª¨ì˜ ì»¤ë°‹ ë°ì´í„°
        const mockCommits = [
            {
                id: 'abcdef1234567890abcdef1234567890abcdef12',
                displayId: 'abcdef1',
                message: 'feat(ui): add slash command suggestions to chat interface',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 1
            },
            {
                id: 'bcdef1234567890abcdef1234567890abcdef123',
                displayId: 'bcdef12',
                message: 'fix(core): resolve memory leak in service initialization',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 2
            },
            {
                id: 'cdef1234567890abcdef1234567890abcdef1234',
                displayId: 'cdef123',
                message: 'docs(api): update API documentation with examples',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 3
            },
            {
                id: 'def1234567890abcdef1234567890abcdef12345',
                displayId: 'def1234',
                message: 'refactor(git): improve auto-commit change detection',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 4
            },
            {
                id: 'ef1234567890abcdef1234567890abcdef123456',
                displayId: 'ef12345',
                message: 'style(ui): update chat interface styling',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 5
            },
            {
                id: 'f1234567890abcdef1234567890abcdef1234567',
                displayId: 'f123456',
                message: 'test(llm): add integration tests for LLM service',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 6
            },
            {
                id: '1234567890abcdef1234567890abcdef12345678',
                displayId: '1234567',
                message: 'perf(stream): optimize streaming response handling',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 7
            },
            {
                id: '234567890abcdef1234567890abcdef123456789',
                displayId: '2345678',
                message: 'chore(deps): update dependencies to latest versions',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 8
            },
            {
                id: '34567890abcdef1234567890abcdef1234567890',
                displayId: '3456789',
                message: 'feat(commands): add support for keyboard shortcuts',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 9
            },
            {
                id: '4567890abcdef1234567890abcdef12345678901',
                displayId: '4567890',
                message: 'fix(ui): correct positioning of dropdown menu',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 10
            },
            {
                id: '567890abcdef1234567890abcdef123456789012',
                displayId: '567890a',
                message: 'docs(readme): update installation instructions',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 11
            },
            {
                id: '67890abcdef1234567890abcdef1234567890123',
                displayId: '67890ab',
                message: 'refactor(core): simplify service initialization logic',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 12
            },
            {
                id: '7890abcdef1234567890abcdef12345678901234',
                displayId: '7890abc',
                message: 'style(icons): update icon set for better visibility',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 13
            },
            {
                id: '890abcdef1234567890abcdef123456789012345',
                displayId: '890abcd',
                message: 'test(core): improve test coverage for core services',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 14
            },
            {
                id: '90abcdef1234567890abcdef1234567890123456',
                displayId: '90abcde',
                message: 'perf(memory): optimize memory usage in large operations',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 15
            },
            {
                id: '0abcdef1234567890abcdef12345678901234567',
                displayId: '0abcdef',
                message: 'chore(build): update build configuration',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 16
            },
            {
                id: 'abcdef1234567890abcdef123456789012345678',
                displayId: 'abcdef1',
                message: 'feat(git): enhance commit message generation',
                author: { name: 'OtherUser', emailAddress: 'otheruser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 17
            },
            {
                id: 'bcdef1234567890abcdef1234567890123456789',
                displayId: 'bcdef12',
                message: 'fix(auth): resolve authentication token refresh issue',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 18
            },
            {
                id: 'cdef1234567890abcdef12345678901234567890',
                displayId: 'cdef123',
                message: 'docs(api): add examples for new API endpoints',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 19
            },
            {
                id: 'def1234567890abcdef123456789012345678901',
                displayId: 'def1234',
                message: 'refactor(ui): reorganize component hierarchy',
                author: { name: 'TestUser', emailAddress: 'testuser@example.com' },
                authorTimestamp: Date.now() - 86400000 * 20
            }
        ];
        // ìž‘ì„±ìžë¡œ í•„í„°ë§
        const filteredCommits = authorName
            ? mockCommits.filter(commit => commit.author.name === authorName)
            : mockCommits;
        // ìµœëŒ€ ê°œìˆ˜ ì œí•œ
        return filteredCommits.slice(0, limit);
    }
    /**
     * ë¦¬ì†ŒìŠ¤ í•´ì œ
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}

;// ./src/core/completion/tabCompletionProvider.ts
/**
 * Tab Completion Provider
 *
 * íƒ­ ìžë™ ì™„ì„± ê¸°ëŠ¥ì„ ì œê³µí•˜ëŠ” ëª¨ë“ˆ
 */


/**
 * íƒ­ ìžë™ ì™„ì„± ì œê³µìž
 */
class TabCompletionProvider {
    llmService;
    cachedCompletions = new Map();
    cacheTimeout = 30 * 60 * 1000; // 30ë¶„
    suggestionCache = new Map();
    contextAwareCommands = new Map();
    /**
     * ìƒì„±ìž
     */
    constructor(llmService) {
        this.llmService = llmService;
        // ì»¨í…ìŠ¤íŠ¸ ì¸ì‹ ëª…ë ¹ì–´ ì´ˆê¸°í™”
        this.initializeContextAwareCommands();
    }
    /**
     * ì»¨í…ìŠ¤íŠ¸ ì¸ì‹ ëª…ë ¹ì–´ ì´ˆê¸°í™”
     */
    initializeContextAwareCommands() {
        // Git ê´€ë ¨ ì»¨í…ìŠ¤íŠ¸
        this.contextAwareCommands.set('git', [
            'commit',
            'push',
            'pull',
            'status',
            'solve',
            'branch',
            'auto',
            'consolidate'
        ]);
        // Jira ê´€ë ¨ ì»¨í…ìŠ¤íŠ¸
        this.contextAwareCommands.set('jira', [
            'create',
            'list',
            'update',
            'comment',
            'assign'
        ]);
        // ì½”ë“œ ê´€ë ¨ ì»¨í…ìŠ¤íŠ¸
        this.contextAwareCommands.set('code', [
            'analyze',
            'review',
            'optimize',
            'refactor',
            'format'
        ]);
        // SWDP ê´€ë ¨ ì»¨í…ìŠ¤íŠ¸
        this.contextAwareCommands.set('swdp', [
            'build',
            'deploy',
            'status',
            'verify',
            'list'
        ]);
    }
    /**
     * ìžë™ ì™„ì„± ì œì•ˆ
     */
    async provideCompletionItems(document, position, token, context) {
        // íŠ¸ë¦¬ê±° ë¬¸ìžê°€ TABì¸ ê²½ìš°ì—ë§Œ ì²˜ë¦¬
        if (context.triggerKind !== external_vscode_.CompletionTriggerKind.TriggerCharacter &&
            context.triggerKind !== external_vscode_.CompletionTriggerKind.Invoke) {
            return [];
        }
        // í˜„ìž¬ ì¤„ ê°€ì ¸ì˜¤ê¸°
        const lineText = document.lineAt(position.line).text;
        const linePrefix = lineText.substring(0, position.character);
        // ëª…ë ¹ì–´ ë˜ëŠ” ì½”ë“œ ì™„ì„±ì´ í•„ìš”í•œì§€ í™•ì¸
        if (this.isCommandCompletion(linePrefix)) {
            return this.provideCommandCompletions(linePrefix);
        }
        else {
            // ì½”ë“œ ìžë™ ì™„ì„±
            return this.provideCodeCompletions(document, position, linePrefix);
        }
    }
    /**
     * ëª…ë ¹ì–´ ìžë™ ì™„ì„±ì¸ì§€ í™•ì¸
     */
    isCommandCompletion(linePrefix) {
        // í–‰ì´ '/'ë¡œ ì‹œìž‘í•˜ëŠ”ì§€ í™•ì¸
        return linePrefix.trim().startsWith('/');
    }
    /**
     * ëª…ë ¹ì–´ ìžë™ ì™„ì„± ì œê³µ
     */
    provideCommandCompletions(linePrefix) {
        const commands = [
            { name: 'git', description: 'Git ê´€ë ¨ ëª…ë ¹ì–´' },
            { name: 'commit', description: 'ë³€ê²½ ì‚¬í•­ ì»¤ë°‹' },
            { name: 'push', description: 'ì›ê²© ì €ìž¥ì†Œì— í‘¸ì‹œ' },
            { name: 'pull', description: 'ì›ê²© ì €ìž¥ì†Œì—ì„œ í’€' },
            { name: 'status', description: 'Git ìƒíƒœ í™•ì¸' },
            { name: 'jira', description: 'JIRA ê´€ë ¨ ëª…ë ¹ì–´' },
            { name: 'issue', description: 'JIRA ì´ìŠˆ ì¡°íšŒ/ìƒì„±' },
            { name: 'ticket', description: 'JIRA í‹°ì¼“ ê´€ë¦¬' },
            { name: 'help', description: 'ë„ì›€ë§ í‘œì‹œ' },
            { name: 'todo', description: 'í•  ì¼ ì§€ì •' },
            { name: 'code', description: 'ì½”ë“œ ë¶„ì„ ë° ìž‘ì—…' },
            { name: 'analyze', description: 'ì½”ë“œ ë¶„ì„' },
            { name: 'settings', description: 'ì„¤ì • ì—´ê¸°' },
            { name: 'theme', description: 'í…Œë§ˆ ë³€ê²½' },
            { name: 'model', description: 'LLM ëª¨ë¸ ì„¤ì •' },
            { name: 'clear', description: 'ì±„íŒ… ë‚´ì—­ ì§€ìš°ê¸°' },
            { name: 'swdp', description: 'SWDP ê´€ë ¨ ëª…ë ¹ì–´' }
        ];
        // í˜„ìž¬ ìž…ë ¥ëœ ëª…ë ¹ì–´ íŒŒì‹±
        const commandParts = linePrefix.trim().substring(1).split(/\s+/);
        const currentCommand = commandParts[0];
        // í˜„ìž¬ ìž‘ì—… ì»¨í…ìŠ¤íŠ¸ íŒŒì•…
        const activeContext = this.getActiveContext();
        // í•˜ìœ„ ëª…ë ¹ì–´ í•„í„°ë§
        if (commandParts.length > 1 && !commandParts[1].startsWith('-')) {
            // ìƒìœ„ ëª…ë ¹ì–´ì— ë”°ë¥¸ í•˜ìœ„ ëª…ë ¹ì–´ ì œê³µ
            if (this.contextAwareCommands.has(currentCommand)) {
                const subCommands = this.contextAwareCommands.get(currentCommand) || [];
                return subCommands.map(subCmd => this.createCompletionItem(subCmd, `${currentCommand} ${subCmd} ëª…ë ¹ì–´`, `/${currentCommand} ${subCmd}`));
            }
            // ê¸°ë³¸ ì„œë¸Œì»¤ë§¨ë“œ ì œê³µ
            switch (currentCommand) {
                case 'git':
                    return [
                        this.createCompletionItem('commit', 'ë³€ê²½ ì‚¬í•­ ì»¤ë°‹', '/git commit'),
                        this.createCompletionItem('push', 'ì›ê²© ì €ìž¥ì†Œì— í‘¸ì‹œ', '/git push'),
                        this.createCompletionItem('pull', 'ì›ê²© ì €ìž¥ì†Œì—ì„œ í’€', '/git pull'),
                        this.createCompletionItem('status', 'í˜„ìž¬ Git ìƒíƒœ í™•ì¸', '/git status'),
                        this.createCompletionItem('solve', 'ì¶©ëŒ ìžë™ í•´ê²°', '/git solve'),
                        this.createCompletionItem('branch', 'ë¸Œëžœì¹˜ ìƒì„±/ëª©ë¡/ì „í™˜', '/git branch'),
                        this.createCompletionItem('auto', 'ìžë™ ì»¤ë°‹ í† ê¸€', '/git auto'),
                        this.createCompletionItem('consolidate', 'ìž„ì‹œ ì»¤ë°‹ í†µí•©', '/git consolidate')
                    ];
                case 'jira':
                    return [
                        this.createCompletionItem('create', 'ìƒˆ ì´ìŠˆ ìƒì„±', '/jira create'),
                        this.createCompletionItem('list', 'ì´ìŠˆ ëª©ë¡ ì¡°íšŒ', '/jira list'),
                        this.createCompletionItem('assign', 'ì´ìŠˆ í• ë‹¹', '/jira assign'),
                        this.createCompletionItem('update', 'ì´ìŠˆ ì—…ë°ì´íŠ¸', '/jira update'),
                        this.createCompletionItem('comment', 'ì´ìŠˆì— ì½”ë©˜íŠ¸ ì¶”ê°€', '/jira comment')
                    ];
                case 'code':
                    return [
                        this.createCompletionItem('analyze', 'ì½”ë“œ ë¶„ì„', '/code analyze'),
                        this.createCompletionItem('review', 'ì½”ë“œ ë¦¬ë·°', '/code review'),
                        this.createCompletionItem('optimize', 'ì½”ë“œ ìµœì í™”', '/code optimize'),
                        this.createCompletionItem('refactor', 'ì½”ë“œ ë¦¬íŒ©í† ë§', '/code refactor'),
                        this.createCompletionItem('format', 'ì½”ë“œ ì„œì‹ ì •ë¦¬', '/code format')
                    ];
                case 'swdp':
                    return [
                        this.createCompletionItem('build', 'ë¹Œë“œ ì‹¤í–‰', '/swdp build'),
                        this.createCompletionItem('deploy', 'ë°°í¬ ì‹¤í–‰', '/swdp deploy'),
                        this.createCompletionItem('status', 'ìƒíƒœ í™•ì¸', '/swdp status'),
                        this.createCompletionItem('verify', 'ê²€ì¦ ì‹¤í–‰', '/swdp verify'),
                        this.createCompletionItem('list', 'ëª©ë¡ í‘œì‹œ', '/swdp list')
                    ];
                case 'todo':
                    return [
                        this.createCompletionItem('add', 'í•  ì¼ ì¶”ê°€', '/todo add'),
                        this.createCompletionItem('list', 'í•  ì¼ ëª©ë¡', '/todo list'),
                        this.createCompletionItem('done', 'í•  ì¼ ì™„ë£Œ', '/todo done'),
                        this.createCompletionItem('delete', 'í•  ì¼ ì‚­ì œ', '/todo delete'),
                        this.createCompletionItem('prioritize', 'ìš°ì„ ìˆœìœ„ ë³€ê²½', '/todo prioritize')
                    ];
            }
        }
        // í˜„ìž¬ ì»¨í…ìŠ¤íŠ¸ì— ë”°ë¼ ì¶”ì²œë˜ëŠ” ëª…ë ¹ì–´ í•„í„°ë§
        let filteredCommands = [...commands];
        if (activeContext) {
            // ì—ë””í„°ì—ì„œ í…ìŠ¤íŠ¸ ì„ íƒëœ ê²½ìš°: code ê´€ë ¨ ëª…ë ¹ì–´ ìš°ì„ 
            const codeRelatedCommands = ['code', 'analyze', 'review', 'optimize', 'refactor'];
            if (activeContext.hasTextSelection) {
                filteredCommands = [
                    ...filteredCommands.filter(cmd => codeRelatedCommands.includes(cmd.name)),
                    ...filteredCommands.filter(cmd => !codeRelatedCommands.includes(cmd.name))
                ];
            }
            // Git ê´€ë ¨ ì»¨í…ìŠ¤íŠ¸: git ê´€ë ¨ ëª…ë ¹ì–´ ìš°ì„ 
            const gitRelatedCommands = ['git', 'commit', 'push', 'pull', 'status'];
            if (activeContext.isGitRepo) {
                filteredCommands = [
                    ...filteredCommands.filter(cmd => gitRelatedCommands.includes(cmd.name)),
                    ...filteredCommands.filter(cmd => !gitRelatedCommands.includes(cmd.name))
                ];
            }
        }
        // ê¸°ë³¸ ìµœìƒìœ„ ëª…ë ¹ì–´ ì œê³µ
        return filteredCommands.map(cmd => this.createCompletionItem(cmd.name, cmd.description, '/' + cmd.name));
    }
    /**
     * í˜„ìž¬ ì»¨í…ìŠ¤íŠ¸ íŒŒì•…
     */
    getActiveContext() {
        try {
            const editor = external_vscode_.window.activeTextEditor;
            return {
                hasTextSelection: !!(editor && !editor.selection.isEmpty),
                isGitRepo: this.isGitRepository()
            };
        }
        catch (error) {
            console.error('ì»¨í…ìŠ¤íŠ¸ íŒŒì•… ì˜¤ë¥˜:', error);
            return null;
        }
    }
    /**
     * Git ì €ìž¥ì†Œì¸ì§€ í™•ì¸
     */
    isGitRepository() {
        try {
            // í˜„ìž¬ ìž‘ì—… ë””ë ‰í† ë¦¬
            const workspaceFolders = external_vscode_.workspace.workspaceFolders;
            if (!workspaceFolders || workspaceFolders.length === 0) {
                return false;
            }
            // ê°„ë‹¨ížˆ true ë°˜í™˜ (ëª¨ì˜ êµ¬í˜„)
            // ì‹¤ì œë¡œëŠ” .git í´ë” ì¡´ìž¬ ì—¬ë¶€ë¥¼ í™•ì¸í•´ì•¼ í•˜ì§€ë§Œ, ì—¬ê¸°ì„œëŠ” ëª¨ì˜ êµ¬í˜„ë§Œ ì œê³µ
            return true;
        }
        catch (error) {
            console.error('Git ì €ìž¥ì†Œ í™•ì¸ ì˜¤ë¥˜:', error);
            return false;
        }
    }
    /**
     * ì½”ë“œ ìžë™ ì™„ì„± ì œê³µ
     */
    async provideCodeCompletions(document, position, linePrefix) {
        // ìºì‹œ í‚¤ ìƒì„± (íŒŒì¼ ê²½ë¡œ + í˜„ìž¬ ìœ„ì¹˜)
        const cacheKey = `${document.fileName}:${position.line}:${position.character}`;
        // ìºì‹œëœ ê²°ê³¼ê°€ ìžˆëŠ” ê²½ìš° ìž¬ì‚¬ìš©
        const cachedResult = this.suggestionCache.get(cacheKey);
        if (cachedResult && Date.now() - cachedResult.timestamp < this.cacheTimeout) {
            return cachedResult.suggestions;
        }
        try {
            // ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘
            // ì „ì²´ íŒŒì¼ ë‚´ìš©ê³¼ ì»¤ì„œ ìœ„ì¹˜ ê³„ì‚°(ë¯¸ì‚¬ìš©)
            // // const fileContent = document.getText();
            // // const cursorOffset = document.offsetAt(position);
            // ì´ì „ ì¤„ê³¼ í˜„ìž¬ ì¤„ ì¶”ì¶œ
            const precedingLines = document.getText(new external_vscode_.Range(new external_vscode_.Position(Math.max(0, position.line - 10), 0), position));
            // íŒŒì¼ ìœ í˜• í™•ì¸
            const fileType = document.fileName.split('.').pop() || '';
            // LLMì— ì½”ë“œ ì™„ì„± ìš”ì²­
            const suggestions = await this.requestCodeCompletions(precedingLines, linePrefix, fileType);
            // ê²°ê³¼ ìºì‹±
            this.suggestionCache.set(cacheKey, {
                suggestions,
                timestamp: Date.now()
            });
            return suggestions;
        }
        catch (error) {
            console.error('ì½”ë“œ ì™„ì„± ì˜¤ë¥˜:', error);
            return [];
        }
    }
    /**
     * LLMì„ í†µí•œ ì½”ë“œ ì™„ì„± ìš”ì²­
     */
    async requestCodeCompletions(context, currentLine, fileType) {
        try {
            // í”„ë¡¬í”„íŠ¸ ìƒì„±
            const prompt = `
ë‹¤ìŒ ì½”ë“œì˜ ë‹¤ìŒ ì¤„ì„ ì™„ì„±í•´ì£¼ì„¸ìš”. íŒŒì¼ íƒ€ìž…ì€ ${fileType}ìž…ë‹ˆë‹¤.
íƒ­ ìžë™ ì™„ì„±ì„ ìœ„í•œ ì—¬ëŸ¬ ê°€ì§€ ê°€ëŠ¥í•œ ì½”ë“œ ì™„ì„±ì„ ì œì•ˆí•´ì£¼ì„¸ìš”.
ê° ì œì•ˆì€ ìƒˆë¡œìš´ ì¤„ì— ì‹œìž‘í•˜ë©°, ì™„ì „í•œ ì½”ë“œ ì¡°ê°ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
ìµœëŒ€ 5ê°œì˜ ë‹¤ë¥¸ ì™„ì„±ì„ ì œì•ˆí•´ì£¼ì„¸ìš”.

ì½”ë“œ ì»¨í…ìŠ¤íŠ¸:
\`\`\`${fileType}
${context}
\`\`\`

í˜„ìž¬ ì¤„ (ì»¤ì„œ ìœ„ì¹˜ëŠ” | ë¡œ í‘œì‹œ):
\`\`\`
${currentLine}|
\`\`\`

ê°€ëŠ¥í•œ ì™„ì„±:`;
            // LLM ìš”ì²­
            const messages = [
                {
                    id: `msg_completion_${Date.now()}`,
                    role: MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            const result = await this.llmService.sendRequest(messages);
            if (result.success && result.data) {
                // ì‘ë‹µ íŒŒì‹±í•˜ì—¬ CompletionItem ë°°ì—´ë¡œ ë³€í™˜
                return this.parseCompletionResponse(result.data.content || '', currentLine);
            }
            else {
                throw new Error('LLM ìš”ì²­ ì‹¤íŒ¨');
            }
        }
        catch (error) {
            console.error('LLM ì½”ë“œ ì™„ì„± ìš”ì²­ ì˜¤ë¥˜:', error);
            return [];
        }
    }
    /**
     * LLM ì‘ë‹µì„ CompletionItemìœ¼ë¡œ íŒŒì‹±
     */
    parseCompletionResponse(responseContent, currentLine) {
        const completions = [];
        try {
            // ì½”ë“œ ë¸”ë¡ì—ì„œ ì œì•ˆ ì¶”ì¶œ
            const codeBlockMatch = responseContent.match(/```(?:.*?)?\n([\s\S]*?)```/);
            const suggestions = codeBlockMatch
                ? codeBlockMatch[1].split('\n').filter(line => line.trim() !== '')
                : responseContent.split('\n').filter(line => line.trim() !== '');
            // ê° ì œì•ˆì— ëŒ€í•´ CompletionItem ìƒì„±
            suggestions.forEach((suggestion, index) => {
                // ë²ˆí˜¸ ë˜ëŠ” ë¶ˆë¦¿ í¬ì¸íŠ¸ ì œê±°
                suggestion = suggestion.replace(/^\d+\.\s+|^-\s+/, '').trim();
                if (suggestion) {
                    // í˜„ìž¬ ì¤„ê³¼ ê²¹ì¹˜ëŠ” ë¶€ë¶„ ì œê±°
                    const overlap = this.findOverlap(currentLine, suggestion);
                    const insertText = overlap > 0 ? suggestion.substring(overlap) : suggestion;
                    if (insertText.trim()) {
                        const item = new external_vscode_.CompletionItem(suggestion, external_vscode_.CompletionItemKind.Snippet);
                        item.insertText = insertText;
                        item.sortText = String(index).padStart(5, '0');
                        item.detail = 'íƒ­ ìžë™ ì™„ì„±';
                        completions.push(item);
                    }
                }
            });
        }
        catch (error) {
            console.error('ì‘ë‹µ íŒŒì‹± ì˜¤ë¥˜:', error);
        }
        return completions;
    }
    /**
     * í˜„ìž¬ ì¤„ê³¼ ì œì•ˆ ì‚¬ì´ì˜ ê²¹ì¹˜ëŠ” ë¶€ë¶„ ì°¾ê¸°
     */
    findOverlap(currentLine, suggestion) {
        let overlap = 0;
        // í˜„ìž¬ ì¤„ì˜ ëì—ì„œë¶€í„° ì œì•ˆì˜ ì‹œìž‘ê³¼ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
        for (let i = 1; i <= currentLine.length; i++) {
            const suffix = currentLine.substring(currentLine.length - i);
            if (suggestion.startsWith(suffix)) {
                overlap = suffix.length;
            }
        }
        return overlap;
    }
    /**
     * CompletionItem ìƒì„± í—¬í¼ í•¨ìˆ˜
     */
    createCompletionItem(label, detail, insertText) {
        const item = new external_vscode_.CompletionItem(label, external_vscode_.CompletionItemKind.Keyword);
        item.detail = detail;
        item.insertText = insertText;
        item.command = {
            command: 'editor.action.triggerSuggest',
            title: 'Re-trigger completions...'
        };
        return item;
    }
}

;// ./src/core/completion/inlineCompletionProvider.ts
/**
 * ì¸ë¼ì¸ ì™„ì„± ì œê³µìž
 *
 * VS Code ìž…ë ¥ ì¤‘ì— ì¸ë¼ì¸ ì œì•ˆ ë° ê³ ìŠ¤íŠ¸ í…ìŠ¤íŠ¸ë¥¼ ì œê³µí•˜ëŠ” ì»´í¬ë„ŒíŠ¸
 */


/**
 * ì¸ë¼ì¸ ì™„ì„± ì œê³µìž í´ëž˜ìŠ¤
 */
class InlineCompletionProvider {
    llmService;
    context;
    completionCache = new Map();
    cacheTimeout = 5 * 60 * 1000; // 5ë¶„
    requestQueue = new Map();
    completionConfig = {
        enabled: true,
        triggerLength: 3,
        debounceDelay: 300,
        maxLineContext: 10
    };
    // ë””ë°”ìš´ìŠ¤ íƒ€ì´ë¨¸
    debounceTimer = null;
    /**
     * ìƒì„±ìž
     */
    constructor(llmService, context) {
        this.llmService = llmService;
        this.context = context;
        // ì„¤ì • ë¡œë“œ
        this.loadConfiguration();
        // ì„¤ì • ë³€ê²½ ê°ì§€
        external_vscode_.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.completion')) {
                this.loadConfiguration();
            }
        });
    }
    /**
     * ì„¤ì • ë¡œë“œ
     */
    loadConfiguration() {
        const config = external_vscode_.workspace.getConfiguration('ape.completion');
        this.completionConfig = {
            enabled: config.get('inlineEnabled', true),
            triggerLength: config.get('triggerLength', 3),
            debounceDelay: config.get('debounceDelay', 300),
            maxLineContext: config.get('maxLineContext', 10)
        };
    }
    /**
     * ì¸ë¼ì¸ ì™„ì„± ì œê³µ
     */
    async provideInlineCompletionItems(document, position, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _context, 
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    _token) {
        // ë¹„í™œì„±í™”ëœ ê²½ìš°
        if (!this.completionConfig.enabled) {
            return null;
        }
        // í˜„ìž¬ ì¤„ ê°€ì ¸ì˜¤ê¸°
        const lineText = document.lineAt(position.line).text;
        const linePrefix = lineText.substring(0, position.character);
        // íŠ¸ë¦¬ê±° í™•ì¸ (ë¬¸ìž ìˆ˜ ê²€ì‚¬)
        if (linePrefix.trim().length < this.completionConfig.triggerLength) {
            return null;
        }
        // íŠ¹ì • íŒŒì¼ í˜•ì‹ í•„í„°ë§ (ì£¼ì„ ë˜ëŠ” ë¬¸ì„œ)
        if (this.shouldSkipCompletion(document, position)) {
            return null;
        }
        // ìºì‹œ í‚¤ ìƒì„±
        const cacheKey = `${document.fileName}:${position.line}:${position.character}:${lineText}`;
        // ìºì‹œëœ ê²°ê³¼ê°€ ìžˆëŠ” ê²½ìš° ìž¬ì‚¬ìš©
        const cachedResult = this.completionCache.get(cacheKey);
        if (cachedResult && Date.now() - cachedResult.timestamp < this.cacheTimeout) {
            return cachedResult.completions;
        }
        // ì´ë¯¸ ìš”ì²­ ì¤‘ì¸ ê²½ìš° í•´ë‹¹ ìš”ì²­ì˜ ê²°ê³¼ ëŒ€ê¸°
        if (this.requestQueue.has(cacheKey)) {
            try {
                return await this.requestQueue.get(cacheKey);
            }
            catch (error) {
                console.error('ëŒ€ê¸° ì¤‘ì¸ ì¸ë¼ì¸ ì™„ì„± ìš”ì²­ ì˜¤ë¥˜:', error);
                return null;
            }
        }
        // ë””ë°”ìš´ìŠ¤ ì ìš©
        if (this.debounceTimer) {
            clearTimeout(this.debounceTimer);
        }
        const completionPromise = new Promise((resolve) => {
            this.debounceTimer = setTimeout(async () => {
                try {
                    // ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘
                    const context = await this.getCompletionContext(document, position);
                    // LLMì„ í†µí•œ ì¸ë¼ì¸ ì™„ì„± ìš”ì²­
                    const completions = await this.requestInlineCompletions(context.precedingText, context.followingText, document.languageId);
                    // ê²°ê³¼ ìºì‹±
                    this.completionCache.set(cacheKey, {
                        completions,
                        timestamp: Date.now()
                    });
                    // ìš”ì²­ íì—ì„œ ì œê±°
                    this.requestQueue.delete(cacheKey);
                    resolve(completions);
                }
                catch (error) {
                    console.error('ì¸ë¼ì¸ ì™„ì„± ìš”ì²­ ì˜¤ë¥˜:', error);
                    this.requestQueue.delete(cacheKey);
                    resolve([]);
                }
            }, this.completionConfig.debounceDelay);
        });
        // ìš”ì²­ íì— ì¶”ê°€
        this.requestQueue.set(cacheKey, completionPromise);
        return completionPromise;
    }
    /**
     * ì™„ì„±ì„ ê±´ë„ˆë›¸ì§€ ê²°ì •
     */
    shouldSkipCompletion(document, position) {
        // ì½”ë“œ ë¸”ë¡ì´ë‚˜ ë‹¤ë¥¸ íŠ¹ìˆ˜ ì»¨í…ìŠ¤íŠ¸ ê°ì§€
        const lineText = document.lineAt(position.line).text;
        // ë§ˆí¬ë‹¤ìš´ ì½”ë“œ ë¸”ë¡ ë˜ëŠ” ì£¼ì„ ë‚´ì—ì„œëŠ” ê±´ë„ˆë›°ê¸°
        const isMdCodeBlock = document.languageId === 'markdown' &&
            (lineText.trim().startsWith('```') ||
                document.getText(new external_vscode_.Range(new external_vscode_.Position(Math.max(0, position.line - 3), 0), position)).includes('```'));
        // ì£¼ì„ ê°ì§€
        const isInComment = this.isPositionInComment(document, position);
        return isMdCodeBlock || isInComment;
    }
    /**
     * í˜„ìž¬ ìœ„ì¹˜ê°€ ì£¼ì„ ë‚´ì— ìžˆëŠ”ì§€ í™•ì¸
     */
    isPositionInComment(document, position) {
        const lineText = document.lineAt(position.line).text;
        // ì–¸ì–´ë³„ ì£¼ì„ êµ¬ë¬¸ ê²€ì‚¬
        switch (document.languageId) {
            case 'typescript':
            case 'javascript':
            case 'typescriptreact':
            case 'javascriptreact':
            case 'csharp':
            case 'java':
            case 'cpp':
            case 'c': {
                // í•œ ì¤„ ì£¼ì„ í™•ì¸
                if (lineText.substring(0, position.character).includes('//')) {
                    return true;
                }
                // ì—¬ëŸ¬ ì¤„ ì£¼ì„ í™•ì¸ (ê°„ë‹¨í•œ êµ¬í˜„)
                const prevText = document.getText(new external_vscode_.Range(new external_vscode_.Position(0, 0), position));
                const commentStarts = (prevText.match(/\/\*/g) || []).length;
                const commentEnds = (prevText.match(/\*\//g) || []).length;
                return commentStarts > commentEnds;
            }
            case 'python':
                // Python ì£¼ì„
                return lineText.substring(0, position.character).includes('#');
            case 'html':
            case 'xml': {
                // HTML/XML ì£¼ì„
                const htmlPrev = document.getText(new external_vscode_.Range(new external_vscode_.Position(0, 0), position));
                const htmlCommentStarts = (htmlPrev.match(/<!--/g) || []).length;
                const htmlCommentEnds = (htmlPrev.match(/-->/g) || []).length;
                return htmlCommentStarts > htmlCommentEnds;
            }
        }
        return false;
    }
    /**
     * ì™„ì„± ì»¨í…ìŠ¤íŠ¸ ìˆ˜ì§‘
     */
    async getCompletionContext(document, position) {
        // ì´ì „ í…ìŠ¤íŠ¸ (í˜„ìž¬ ë¼ì¸ í¬í•¨)
        const startLine = Math.max(0, position.line - this.completionConfig.maxLineContext);
        const precedingText = document.getText(new external_vscode_.Range(new external_vscode_.Position(startLine, 0), position));
        // ì´í›„ í…ìŠ¤íŠ¸ (í˜„ìž¬ ë¼ì¸ì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ + ë‹¤ìŒ ëª‡ ì¤„)
        const endLine = Math.min(document.lineCount - 1, position.line + 5);
        const followingText = document.getText(new external_vscode_.Range(position, new external_vscode_.Position(endLine, document.lineAt(endLine).text.length)));
        return { precedingText, followingText };
    }
    /**
     * LLMì„ í†µí•œ ì¸ë¼ì¸ ì™„ì„± ìš”ì²­
     */
    async requestInlineCompletions(precedingText, followingText, languageId) {
        try {
            // í”„ë¡¬í”„íŠ¸ ìƒì„±
            const prompt = `
í˜„ìž¬ ì‚¬ìš©ìžê°€ ì½”ë“œë¥¼ ìž‘ì„±í•˜ê³  ìžˆìŠµë‹ˆë‹¤. ì–¸ì–´ëŠ” ${languageId}ìž…ë‹ˆë‹¤.
ì‚¬ìš©ìžì˜ ìž…ë ¥ì„ ê¸°ë°˜ìœ¼ë¡œ ë‹¤ìŒì— ì˜¬ ì½”ë“œë¥¼ ì •í™•í•˜ê²Œ ì˜ˆì¸¡í•´ì„œ ì œì•ˆí•´ì£¼ì„¸ìš”.
ë¬¸ë§¥ì„ ê³ ë ¤í•˜ì—¬ ê°€ìž¥ ì ì ˆí•œ ìžì—°ìŠ¤ëŸ¬ìš´ ë‹¤ìŒ ì½”ë“œ ì¤„ì´ë‚˜ êµ¬ë¬¸ì„ ìž‘ì„±í•´ì£¼ì„¸ìš”.
ì¸ë¼ì¸ ì œì•ˆì´ë¯€ë¡œ ê°„ê²°í•˜ê³  ì •í™•í•´ì•¼ í•©ë‹ˆë‹¤.

í˜„ìž¬ê¹Œì§€ ìž‘ì„±ëœ ì½”ë“œ:
\`\`\`${languageId}
${precedingText}
\`\`\`

í˜„ìž¬ ìœ„ì¹˜ ì´í›„ì˜ ì½”ë“œ (ì»¨í…ìŠ¤íŠ¸):
\`\`\`${languageId}
${followingText}
\`\`\`

ë‹¤ìŒì— ì˜¬ ì½”ë“œ ì˜ˆì¸¡ (ìµœëŒ€ 3ê°œ):
`;
            // LLM ìš”ì²­
            const messages = [
                {
                    id: `msg_inline_${Date.now()}`,
                    role: MessageRole.User,
                    content: prompt,
                    timestamp: new Date()
                }
            ];
            const result = await this.llmService.sendRequest(messages);
            if (result.success && result.data) {
                // ì‘ë‹µ íŒŒì‹±í•˜ì—¬ InlineCompletionItem ë°°ì—´ë¡œ ë³€í™˜
                return this.parseInlineCompletionResponse(result.data.content || '');
            }
            else {
                throw new Error('LLM ìš”ì²­ ì‹¤íŒ¨');
            }
        }
        catch (error) {
            console.error('LLM ì¸ë¼ì¸ ì™„ì„± ìš”ì²­ ì˜¤ë¥˜:', error);
            return [];
        }
    }
    /**
     * LLM ì‘ë‹µì„ InlineCompletionItemìœ¼ë¡œ íŒŒì‹±
     */
    parseInlineCompletionResponse(responseContent) {
        const completions = [];
        try {
            // ì½”ë“œ ë¸”ë¡ ì¶”ì¶œ
            const codeBlockRegex = /```(?:\w+)?\n([\s\S]*?)```/g;
            const codeBlocks = [];
            let match;
            while ((match = codeBlockRegex.exec(responseContent)) !== null) {
                codeBlocks.push(match[1]);
            }
            if (codeBlocks.length > 0) {
                // ì½”ë“œ ë¸”ë¡ì—ì„œ ì¶”ì¶œ
                for (const block of codeBlocks) {
                    const lines = block.split('\n').filter(line => line.trim() !== '');
                    lines.forEach(line => {
                        if (line.trim()) {
                            completions.push({
                                insertText: line.trim(),
                                range: undefined
                            });
                        }
                    });
                }
            }
            else {
                // ì½”ë“œ ë¸”ë¡ì´ ì—†ëŠ” ê²½ìš° ì¼ë°˜ í…ìŠ¤íŠ¸ë¡œ ì²˜ë¦¬
                const lines = responseContent.split('\n')
                    .filter(line => line.trim() !== '')
                    .filter(line => !line.startsWith('#') && !line.startsWith('-') && !line.startsWith('*'));
                lines.forEach(line => {
                    const cleanedLine = line.replace(/^\d+\.\s+/, '').trim();
                    if (cleanedLine) {
                        completions.push({
                            insertText: cleanedLine,
                            range: undefined
                        });
                    }
                });
            }
        }
        catch (error) {
            console.error('ì¸ë¼ì¸ ì™„ì„± ì‘ë‹µ íŒŒì‹± ì˜¤ë¥˜:', error);
        }
        // ì¤‘ë³µ ì œê±°
        const uniqueCompletions = this.removeDuplicates(completions);
        return uniqueCompletions.slice(0, 3); // ìµœëŒ€ 3ê°œ ë°˜í™˜
    }
    /**
     * ì¤‘ë³µ ì œê±°
     */
    removeDuplicates(completions) {
        const seen = new Set();
        return completions.filter(item => {
            if (item.insertText && !seen.has(item.insertText.toString())) {
                seen.add(item.insertText.toString());
                return true;
            }
            return false;
        });
    }
}

;// ./src/ui/tree/treeNodeTypes.ts
/**
 * íŠ¸ë¦¬ ë…¸ë“œ íƒ€ìž… ì •ì˜
 *
 * APE Navigator íŠ¸ë¦¬ë·°ì˜ ë…¸ë“œ íƒ€ìž…ê³¼ ì¸í„°íŽ˜ì´ìŠ¤ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
 */
/**
 * íŠ¸ë¦¬ ë…¸ë“œ íƒ€ìž… ì—´ê±°í˜•
 */
var TreeNodeType;
(function (TreeNodeType) {
    // ì¹´í…Œê³ ë¦¬ ë…¸ë“œ
    TreeNodeType["CATEGORY"] = "category";
    // ëª…ë ¹ì–´ ê´€ë ¨ ë…¸ë“œ
    TreeNodeType["COMMAND_ROOT"] = "command-root";
    TreeNodeType["COMMAND_CATEGORY"] = "command-category";
    TreeNodeType["COMMAND"] = "command";
    // Git ê´€ë ¨ ë…¸ë“œ
    TreeNodeType["GIT_ROOT"] = "git-root";
    TreeNodeType["GIT_CATEGORY"] = "git-category";
    TreeNodeType["GIT_COMMAND"] = "git-command";
    // ì„¤ì • ê´€ë ¨ ë…¸ë“œ
    TreeNodeType["SETTINGS_ROOT"] = "settings-root";
    TreeNodeType["SETTINGS_CATEGORY"] = "settings-category";
    TreeNodeType["SETTINGS_ITEM"] = "settings-item";
    // í”ŒëŸ¬ê·¸ì¸ ê´€ë ¨ ë…¸ë“œ
    TreeNodeType["PLUGIN_ROOT"] = "plugin-root";
    TreeNodeType["PLUGIN_ACTIVE"] = "plugin-active";
    TreeNodeType["PLUGIN_INACTIVE"] = "plugin-inactive";
    TreeNodeType["PLUGIN"] = "plugin";
    // ì§€ë¼ ê´€ë ¨ ë…¸ë“œ
    TreeNodeType["JIRA_ROOT"] = "jira-root";
    TreeNodeType["JIRA_PROJECT"] = "jira-project";
    TreeNodeType["JIRA_ISSUE"] = "jira-issue";
    TreeNodeType["JIRA_CATEGORY"] = "jira-category";
    TreeNodeType["JIRA_COMMAND"] = "jira-command";
    // í¬ì¼“ ê´€ë ¨ ë…¸ë“œ
    TreeNodeType["POCKET_ROOT"] = "pocket-root";
    TreeNodeType["POCKET_CATEGORY"] = "pocket-category";
    TreeNodeType["POCKET_ITEM"] = "pocket-item";
    // SWDP ê´€ë ¨ ë…¸ë“œ
    TreeNodeType["SWDP_ROOT"] = "swdp-root";
    TreeNodeType["SWDP_RELEASE"] = "swdp-release";
    TreeNodeType["SWDP_BUILD_TYPE"] = "swdp-build-type";
    TreeNodeType["SWDP_ARTIFACT"] = "swdp-artifact";
    // VAULT ê´€ë ¨ ë…¸ë“œ
    TreeNodeType["VAULT_ROOT"] = "vault-root";
    TreeNodeType["VAULT_CATEGORY"] = "vault-category";
    TreeNodeType["VAULT_CONTEXT"] = "vault-context";
    TreeNodeType["VAULT_ITEM"] = "vault-item";
    // Rules ê´€ë ¨ ë…¸ë“œ
    TreeNodeType["RULES_ROOT"] = "rules-root";
    TreeNodeType["RULES_ACTIVE"] = "rules-active";
    TreeNodeType["RULES_INACTIVE"] = "rules-inactive";
    TreeNodeType["RULE_ITEM"] = "rule-item";
    // ì±„íŒ… ë‚´ì—­ ê´€ë ¨ ë…¸ë“œ
    TreeNodeType["CHAT_HISTORY_ROOT"] = "chat-history-root";
    TreeNodeType["CHAT_HISTORY_ITEM"] = "chat-history-item";
})(TreeNodeType || (TreeNodeType = {}));

;// ./src/ui/tree/apeTreeDataProvider.ts
/**
 * APE Navigator íŠ¸ë¦¬ ë°ì´í„° ì œê³µìž
 *
 * VS Code TreeView APIë¥¼ ì‚¬ìš©í•˜ì—¬ APE í™•ìž¥ì˜ ì£¼ìš” ê¸°ëŠ¥ì„ ê³„ì¸µì ìœ¼ë¡œ í‘œì‹œí•©ë‹ˆë‹¤.
 * ì£¼ìš” ëª…ë ¹ì–´, ì„¤ì •, í”ŒëŸ¬ê·¸ì¸ ì •ë³´ë¥¼ íŠ¸ë¦¬ í˜•íƒœë¡œ ë³´ì—¬ì¤ë‹ˆë‹¤.
 */





/**
 * APE Navigator íŠ¸ë¦¬ ë°ì´í„° ì œê³µìž í´ëž˜ìŠ¤
 */
class ApeTreeDataProvider {
    context;
    llmService;
    memoryService;
    todoService;
    vaultService;
    rulesService;
    jiraService;
    // íŠ¸ë¦¬ ë°ì´í„° ë³€ê²½ ì´ë²¤íŠ¸
    _onDidChangeTreeData = new external_vscode_.EventEmitter();
    onDidChangeTreeData = this._onDidChangeTreeData.event;
    // íŠ¸ë¦¬ ë°ì´í„°
    treeData = [];
    /**
     * ìƒì„±ìž
     * @param context í™•ìž¥ í”„ë¡œê·¸ëž¨ ì»¨í…ìŠ¤íŠ¸
     * @param llmService LLM ì„œë¹„ìŠ¤
     * @param memoryService ë©”ëª¨ë¦¬ ì„œë¹„ìŠ¤
     */
    constructor(context, llmService, memoryService, todoService, vaultService, rulesService, jiraService) {
        this.context = context;
        this.llmService = llmService;
        this.memoryService = memoryService;
        this.todoService = todoService;
        this.vaultService = vaultService;
        this.rulesService = rulesService;
        this.jiraService = jiraService;
        // íŠ¸ë¦¬ ë°ì´í„° ì´ˆê¸°í™”
        this.initializeTreeData();
        // ì„¤ì • ë³€ê²½ ì´ë²¤íŠ¸ êµ¬ë…
        external_vscode_.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape')) {
                this.refresh();
            }
        });
        // VAULT ì„œë¹„ìŠ¤ ë³€ê²½ ì´ë²¤íŠ¸ êµ¬ë…
        if (this.vaultService) {
            this.vaultService.onDidChangeVault(() => {
                this.refresh();
            });
        }
        // Rules ì„œë¹„ìŠ¤ ë³€ê²½ ì´ë²¤íŠ¸ êµ¬ë…
        if (this.rulesService) {
            this.rulesService.onDidChangeRules(() => {
                this.refresh();
            });
        }
    }
    /**
     * íŠ¸ë¦¬ ë°ì´í„° ì´ˆê¸°í™”
     */
    initializeTreeData() {
        this.treeData = [
            // Git ì„¹ì…˜ (ìµœìƒìœ„ë¡œ ì´ë™)
            {
                id: 'git-root',
                label: 'Git',
                type: TreeNodeType.GIT_ROOT,
                iconPath: this.getIconPath('git-version-control', 'git-commit'),
                contextValue: 'gitRoot',
                children: this.getGitItems()
            },
            // ì±„íŒ… ë‚´ì—­ ì„¹ì…˜
            {
                id: 'chat-history-root',
                label: 'ì±„íŒ… ë‚´ì—­',
                type: TreeNodeType.CHAT_HISTORY_ROOT,
                iconPath: this.getIconPath('chat', 'history'),
                contextValue: 'chatHistoryRoot',
                children: this.getChatHistoryItems()
            },
            // ëª…ë ¹ì–´ ì„¹ì…˜
            {
                id: 'commands',
                label: 'ëª…ë ¹ì–´',
                type: TreeNodeType.COMMAND_ROOT,
                iconPath: this.getIconPath('command-line', 'symbol-method'),
                contextValue: 'commandRoot',
                children: this.getCommandItems()
            },
            // ì„¤ì • ì„¹ì…˜
            {
                id: 'settings',
                label: 'ì„¤ì •',
                type: TreeNodeType.SETTINGS_ROOT,
                iconPath: this.getIconPath('config', 'gear'),
                contextValue: 'settingsRoot',
                children: this.getSettingsItems()
            },
            // Rules ì„¹ì…˜
            {
                id: 'rules-root',
                label: 'Rules',
                type: TreeNodeType.RULES_ROOT,
                iconPath: this.getIconPath('notebook', 'book'),
                contextValue: 'rulesRoot',
                children: this.getRulesItems()
            },
            // VAULT ì„¹ì…˜
            {
                id: 'vault',
                label: 'VAULT ì»¨í…ìŠ¤íŠ¸',
                type: TreeNodeType.VAULT_ROOT,
                iconPath: this.getIconPath('brain-ai', 'library'),
                contextValue: 'vaultRoot',
                children: this.getVaultItems()
            },
            // ì§€ë¼ ì„¹ì…˜ (Mock)
            {
                id: 'jira',
                label: 'Jira ì´ìŠˆ',
                type: TreeNodeType.JIRA_ROOT,
                iconPath: this.getIconPath('jira', 'issues'),
                contextValue: 'jiraRoot',
                children: this.getJiraItems()
            },
            // í¬ì¼“ ì„¹ì…˜ (Mock)
            {
                id: 'pocket',
                label: 'Pocket ì €ìž¥ì†Œ',
                type: TreeNodeType.POCKET_ROOT,
                iconPath: this.getIconPath('folder', 'library'),
                contextValue: 'pocketRoot',
                children: this.getPocketItems()
            },
            // SWDP ì„¹ì…˜ (Mock)
            {
                id: 'swdp',
                label: 'SWDP',
                type: TreeNodeType.SWDP_ROOT,
                iconPath: this.getIconPath('cicd', 'package'),
                contextValue: 'swdpRoot',
                children: this.getSWDPItems()
            },
            // í”ŒëŸ¬ê·¸ì¸ ì„¹ì…˜
            {
                id: 'plugins',
                label: 'í”ŒëŸ¬ê·¸ì¸',
                type: TreeNodeType.PLUGIN_ROOT,
                iconPath: this.getIconPath('plugin', 'extensions'),
                contextValue: 'pluginRoot',
                children: this.getPluginItems()
            }
        ];
    }
    /**
     * Git ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸°
     */
    getGitItems() {
        return [
            {
                id: 'git-commands',
                label: 'Git ëª…ë ¹ì–´',
                type: TreeNodeType.GIT_CATEGORY,
                iconPath: this.getIconPath('git-version-control', 'git-commit'),
                tooltip: 'Git ê´€ë ¨ ìž‘ì—…ì„ ìˆ˜í–‰í•˜ëŠ” ëª…ë ¹ì–´ìž…ë‹ˆë‹¤. ì»¤ë°‹, ìƒíƒœ í™•ì¸, ìžë™ ì»¤ë°‹ ê¸°ëŠ¥ ë“±ì„ ì œê³µí•©ë‹ˆë‹¤.',
                contextValue: 'gitCategory',
                children: [
                    {
                        id: 'git-command-status',
                        label: '/git status',
                        type: TreeNodeType.GIT_COMMAND,
                        description: 'Git ìƒíƒœ í™•ì¸',
                        tooltip: 'í˜„ìž¬ Git ì €ìž¥ì†Œì˜ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤. ë³€ê²½ëœ íŒŒì¼, ìŠ¤í…Œì´ì§•ëœ íŒŒì¼, ë¸Œëžœì¹˜ ì •ë³´ ë“±ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('git-version-control', 'git-pull-request'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['status'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-commit',
                        label: '/git commit',
                        type: TreeNodeType.GIT_COMMAND,
                        description: 'ë³€ê²½ì‚¬í•­ ì»¤ë°‹',
                        tooltip: 'ë³€ê²½ëœ íŒŒì¼ì„ Gitì— ì»¤ë°‹í•©ë‹ˆë‹¤. ìžë™ìœ¼ë¡œ ì ì ˆí•œ ì»¤ë°‹ ë©”ì‹œì§€ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('git-version-control', 'git-commit'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['commit'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-auto',
                        label: '/git auto',
                        type: TreeNodeType.GIT_COMMAND,
                        description: 'ìžë™ ì»¤ë°‹ í† ê¸€',
                        tooltip: 'ìžë™ ì»¤ë°‹ ê¸°ëŠ¥ì„ ì¼œê±°ë‚˜ ë•ë‹ˆë‹¤. ì¼œì§„ ìƒíƒœì—ì„œëŠ” íŒŒì¼ ì €ìž¥ ì‹œ ìžë™ìœ¼ë¡œ ë³€ê²½ì‚¬í•­ì´ ì»¤ë°‹ë©ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('config', 'settings-gear'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['auto'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-consolidate',
                        label: '/git consolidate',
                        type: TreeNodeType.GIT_COMMAND,
                        description: 'ìž„ì‹œ ì»¤ë°‹ í†µí•©',
                        tooltip: '[APE][Temporary] ì ‘ë‘ì‚¬ê°€ ë¶™ì€ ì—°ì†ëœ ìž„ì‹œ ì»¤ë°‹ë“¤ì„ í•˜ë‚˜ì˜ ì •ì‹ ì»¤ë°‹ìœ¼ë¡œ í†µí•©í•©ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('github', 'git-merge'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['consolidate'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-pr-list',
                        label: '/git pr-list [Mock]',
                        type: TreeNodeType.GIT_COMMAND,
                        description: 'PR ëª©ë¡ ì¡°íšŒ',
                        tooltip: 'Git ì €ìž¥ì†Œì˜ PR(Pull Request) ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('github', 'git-pull-request'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['pr-list'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-pr-create',
                        label: '/git pr-create [Mock]',
                        type: TreeNodeType.GIT_COMMAND,
                        description: 'ìƒˆ PR ìƒì„±',
                        tooltip: 'Git ì €ìž¥ì†Œì— ìƒˆë¡œìš´ PR(Pull Request)ì„ ìƒì„±í•©ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('github', 'diff-added'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['pr-create'],
                            category: 'git'
                        }
                    },
                    {
                        id: 'git-command-branch-list',
                        label: '/git branch-list [Mock]',
                        type: TreeNodeType.GIT_COMMAND,
                        description: 'ë¸Œëžœì¹˜ ëª©ë¡ ì¡°íšŒ',
                        tooltip: 'Git ì €ìž¥ì†Œì˜ ë¸Œëžœì¹˜ ëª©ë¡ì„ ì¡°íšŒí•©ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('git-version-control', 'git-branch'),
                        contextValue: 'gitCommand',
                        metadata: {
                            name: 'git',
                            args: ['branch-list'],
                            category: 'git'
                        }
                    }
                ]
            }
        ];
    }
    /**
     * ëª…ë ¹ì–´ ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸°
     */
    getCommandItems() {
        const categories = [
            {
                id: 'commands-general',
                label: 'ì¼ë°˜ ëª…ë ¹ì–´',
                type: TreeNodeType.COMMAND_CATEGORY,
                iconPath: this.getIconPath('command-line', 'info'),
                tooltip: 'ê¸°ë³¸ì ì¸ ì±„íŒ… ë° ë„ì›€ë§ ê´€ë ¨ ëª…ë ¹ì–´ìž…ë‹ˆë‹¤.',
                contextValue: 'commandCategory',
                children: [
                    {
                        id: 'command-help',
                        label: '/help',
                        type: TreeNodeType.COMMAND,
                        description: 'ë„ì›€ë§ í‘œì‹œ',
                        tooltip: 'ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  ëª…ë ¹ì–´ ëª©ë¡ê³¼ ì„¤ëª…ì„ ë³´ì—¬ì¤ë‹ˆë‹¤. "/?" ë˜ëŠ” "/ë„ì›€ë§"ë¡œë„ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('message', 'question'),
                        contextValue: 'command',
                        metadata: {
                            name: 'help',
                            category: 'general'
                        }
                    },
                    {
                        id: 'command-clear',
                        label: '/clear',
                        type: TreeNodeType.COMMAND,
                        description: 'ì±„íŒ… ë‚´ì—­ ì§€ìš°ê¸°',
                        tooltip: 'í˜„ìž¬ ì±„íŒ… ë‚´ì—­ì„ ëª¨ë‘ ì‚­ì œí•©ë‹ˆë‹¤. "/cls" ë˜ëŠ” "/ì§€ìš°ê¸°"ë¡œë„ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('chat', 'clear-all'),
                        contextValue: 'command',
                        metadata: {
                            name: 'clear',
                            category: 'general'
                        }
                    },
                    {
                        id: 'command-model',
                        label: '/model',
                        type: TreeNodeType.COMMAND,
                        description: 'LLM ëª¨ë¸ ë³€ê²½',
                        tooltip: 'ì‚¬ìš©í•  LLM ëª¨ë¸ì„ ì„ íƒí•˜ê±°ë‚˜ ë³€ê²½í•©ë‹ˆë‹¤. "/model list"ë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸ ëª©ë¡ì„ í™•ì¸í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.',
                        iconPath: this.getIconPath('llm', 'server-process'),
                        contextValue: 'command',
                        metadata: {
                            name: 'model',
                            category: 'general'
                        }
                    }
                ]
            },
            {
                id: 'commands-code',
                label: 'ì½”ë“œ ë° ìœ í‹¸ë¦¬í‹° ëª…ë ¹ì–´',
                type: TreeNodeType.COMMAND_CATEGORY,
                iconPath: this.getIconPath('coding', 'symbol-class'),
                tooltip: 'ì½”ë“œ ë¶„ì„ ë° VS Code ê¸°ëŠ¥ ì ‘ê·¼ì„ ìœ„í•œ ìœ í‹¸ë¦¬í‹° ëª…ë ¹ì–´ìž…ë‹ˆë‹¤.',
                contextValue: 'commandCategory',
                children: [
                    {
                        id: 'command-analyze',
                        label: '/analyze',
                        type: TreeNodeType.COMMAND,
                        description: 'ì½”ë“œ ë¶„ì„',
                        tooltip: 'ì„ íƒí•œ ì½”ë“œë¥¼ ìƒì„¸ížˆ ë¶„ì„í•©ë‹ˆë‹¤. ì½”ë“œ ê¸°ëŠ¥, ê°œì„ ì , ëª¨ë²” ì‚¬ë¡€ ë“±ì„ ì œì•ˆí•©ë‹ˆë‹¤. "/code" ë˜ëŠ” "/ë¶„ì„"ìœ¼ë¡œë„ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('code-editor', 'inspect'),
                        contextValue: 'command',
                        metadata: {
                            name: 'analyze',
                            category: 'code'
                        }
                    },
                    {
                        id: 'command-settings',
                        label: '/settings',
                        type: TreeNodeType.COMMAND,
                        description: 'APE ì„¤ì • ì—´ê¸°',
                        tooltip: 'VS Code ì„¤ì •ì—ì„œ APE ê´€ë ¨ ì„¤ì •ì„ ì—´ì–´ í™•ì¸í•˜ê³  ìˆ˜ì •í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. "/config" ë˜ëŠ” "/ì„¤ì •"ìœ¼ë¡œë„ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('config', 'gear'),
                        contextValue: 'command',
                        metadata: {
                            name: 'settings',
                            category: 'utility'
                        }
                    },
                    {
                        id: 'command-open',
                        label: '/open',
                        type: TreeNodeType.COMMAND,
                        description: 'íŒŒì¼ ì—´ê¸°',
                        tooltip: 'ì§€ì •í•œ íŒŒì¼ì„ VS Codeì—ì„œ ì—½ë‹ˆë‹¤. "/file" ë˜ëŠ” "/íŒŒì¼ì—´ê¸°"ë¡œë„ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.',
                        iconPath: this.getIconPath('code-file', 'go-to-file'),
                        contextValue: 'command',
                        metadata: {
                            name: 'open',
                            category: 'utility'
                        }
                    }
                ]
            }
        ];
        return categories;
    }
    /**
     * ì„¤ì • ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸°
     */
    getSettingsItems() {
        return [
            {
                id: 'settings-llm',
                label: 'LLM ì„¤ì •',
                type: TreeNodeType.SETTINGS_CATEGORY,
                iconPath: this.getIconPath('llm', 'server'),
                contextValue: 'settingsCategory',
                children: [
                    {
                        id: 'settings-llm-model',
                        label: 'ê¸°ë³¸ ëª¨ë¸',
                        type: TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('ai-neural-network', 'symbol-enum'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.llm.defaultModel') || 'openai/gpt-4.1-mini',
                        metadata: {
                            settingKey: 'ape.llm.defaultModel'
                        }
                    },
                    {
                        id: 'settings-llm-endpoint',
                        label: 'API ì—”ë“œí¬ì¸íŠ¸',
                        type: TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('api', 'link'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.llm.endpoint') || 'http://localhost:8000/api/chat',
                        metadata: {
                            settingKey: 'ape.llm.endpoint'
                        }
                    }
                ]
            },
            {
                id: 'settings-memory',
                label: 'ë©”ëª¨ë¦¬ ì„¤ì •',
                type: TreeNodeType.SETTINGS_CATEGORY,
                iconPath: this.getIconPath('database', 'database'),
                contextValue: 'settingsCategory',
                children: [
                    {
                        id: 'settings-memory-duration',
                        label: 'ì„¸ì…˜ ìœ ì§€ ê¸°ê°„',
                        type: TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('event', 'history'),
                        contextValue: 'settingsItem',
                        description: `${this.getConfigValue('ape.memory.sessionDuration') || '240'}ë¶„`,
                        metadata: {
                            settingKey: 'ape.memory.sessionDuration'
                        }
                    },
                    {
                        id: 'settings-memory-messages',
                        label: 'ìµœëŒ€ ë©”ì‹œì§€ ìˆ˜',
                        type: TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('message', 'symbol-number'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.memory.maxMessages') || '30',
                        metadata: {
                            settingKey: 'ape.memory.maxMessages'
                        }
                    }
                ]
            },
            {
                id: 'settings-ui',
                label: 'UI ì„¤ì •',
                type: TreeNodeType.SETTINGS_CATEGORY,
                iconPath: this.getIconPath('code-editor', 'browser'),
                contextValue: 'settingsCategory',
                children: [
                    {
                        id: 'settings-ui-theme',
                        label: 'UI í…Œë§ˆ',
                        type: TreeNodeType.SETTINGS_ITEM,
                        iconPath: this.getIconPath('vscode', 'symbol-color'),
                        contextValue: 'settingsItem',
                        description: this.getConfigValue('ape.ui.theme') || 'auto',
                        metadata: {
                            settingKey: 'ape.ui.theme'
                        }
                    }
                ]
            }
        ];
    }
    /**
     * VAULT ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸°
     */
    getVaultItems() {
        // VAULT ì„œë¹„ìŠ¤ê°€ ì—†ìœ¼ë©´ ìŠ¤í… ë°˜í™˜
        if (!this.vaultService) {
            return [{
                    id: 'vault-not-initialized',
                    label: 'VAULT ì„œë¹„ìŠ¤ ì´ˆê¸°í™” í•„ìš”',
                    type: TreeNodeType.VAULT_ROOT,
                    iconPath: this.getIconPath('brain-ai', 'error'),
                    contextValue: 'vaultError',
                    description: 'ì„œë¹„ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ',
                    tooltip: 'VAULT ì„œë¹„ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í™•ìž¥ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.'
                }];
        }
        // ì»¨í…ìŠ¤íŠ¸ íƒ€ìž…ë³„ ì•„ì´í…œ êµ¬ì„±
        const contextTypeItems = [];
        // ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸
        const systemContexts = this.vaultService.getContextsByType(VaultContextType.System);
        if (systemContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-system',
                label: 'ì‹œìŠ¤í…œ ì»¨í…ìŠ¤íŠ¸',
                type: TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('brain-ai', 'server'),
                contextValue: 'vaultCategory',
                tooltip: 'ì‹œìŠ¤í…œ ê¸°ë³¸ ì»¨í…ìŠ¤íŠ¸ìž…ë‹ˆë‹¤.',
                children: systemContexts.flatMap(context => this.createContextNode(context))
            });
        }
        // í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸
        const projectContexts = this.vaultService.getContextsByType(VaultContextType.Project);
        if (projectContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-project',
                label: 'í”„ë¡œì íŠ¸ ì»¨í…ìŠ¤íŠ¸',
                type: TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('coding', 'git-merge'),
                contextValue: 'vaultCategory',
                tooltip: 'í”„ë¡œì íŠ¸ë³„ ì»¨í…ìŠ¤íŠ¸ìž…ë‹ˆë‹¤.',
                children: projectContexts.flatMap(context => this.createContextNode(context))
            });
        }
        // ê°œì¸ ì»¨í…ìŠ¤íŠ¸
        const personalContexts = this.vaultService.getContextsByType(VaultContextType.Personal);
        if (personalContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-personal',
                label: 'ê°œì¸ ì»¨í…ìŠ¤íŠ¸',
                type: TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('message', 'account'),
                contextValue: 'vaultCategory',
                tooltip: 'ê°œì¸ ì‚¬ìš©ìž ì»¨í…ìŠ¤íŠ¸ìž…ë‹ˆë‹¤.',
                children: personalContexts.flatMap(context => this.createContextNode(context))
            });
        }
        // ê³µìœ  ì»¨í…ìŠ¤íŠ¸
        const sharedContexts = this.vaultService.getContextsByType(VaultContextType.Shared);
        if (sharedContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-shared',
                label: 'ê³µìœ  ì»¨í…ìŠ¤íŠ¸',
                type: TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('github', 'repo-forked'),
                contextValue: 'vaultCategory',
                tooltip: 'íŒ€ì› ê°„ ê³µìœ ë˜ëŠ” ì»¨í…ìŠ¤íŠ¸ìž…ë‹ˆë‹¤.',
                children: sharedContexts.flatMap(context => this.createContextNode(context))
            });
        }
        // í…œí”Œë¦¿ ì»¨í…ìŠ¤íŠ¸
        const templateContexts = this.vaultService.getContextsByType(VaultContextType.Template);
        if (templateContexts.length > 0) {
            contextTypeItems.push({
                id: 'vault-template',
                label: 'í…œí”Œë¦¿ ì»¨í…ìŠ¤íŠ¸',
                type: TreeNodeType.VAULT_CATEGORY,
                iconPath: this.getIconPath('code-file', 'file-code'),
                contextValue: 'vaultCategory',
                tooltip: 'ìž¬ì‚¬ìš© ê°€ëŠ¥í•œ í…œí”Œë¦¿ ì»¨í…ìŠ¤íŠ¸ìž…ë‹ˆë‹¤.',
                children: templateContexts.flatMap(context => this.createContextNode(context))
            });
        }
        return contextTypeItems;
    }
    /**
     * VAULT ì»¨í…ìŠ¤íŠ¸ ë…¸ë“œ ìƒì„±
     * @param context ì»¨í…ìŠ¤íŠ¸
     */
    createContextNode(context) {
        if (!context || !context.items) {
            return [];
        }
        const contextNode = {
            id: `vault-context-${context.id}`,
            label: context.name,
            type: TreeNodeType.VAULT_CONTEXT,
            description: `${context.items.length}ê°œ í•­ëª©`,
            tooltip: context.description || context.name,
            iconPath: this.getIconPath('brain-ai', 'library'),
            contextValue: 'vaultContext',
            metadata: {
                contextId: context.id,
                contextType: context.type
            },
            children: context.items.map((item) => this.createItemNode(item, context))
        };
        return [contextNode];
    }
    /**
     * VAULT ì•„ì´í…œ ë…¸ë“œ ìƒì„±
     * @param item ì•„ì´í…œ
     * @param context ì»¨í…ìŠ¤íŠ¸
     */
    createItemNode(item, context) {
        let iconName = 'file-text';
        let fallbackIcon = 'symbol-string';
        // íƒœê·¸ì— ë”°ë¥¸ ì•„ì´ì½˜ ì„¤ì •
        if (item.tags) {
            if (item.tags.includes('prompt')) {
                iconName = 'brain-ai';
                fallbackIcon = 'symbol-text';
            }
            else if (item.tags.includes('code')) {
                iconName = 'code-file';
                fallbackIcon = 'file-code';
            }
            else if (item.tags.includes('architecture')) {
                iconName = 'orchestration';
                fallbackIcon = 'type-hierarchy';
            }
            else if (item.tags.includes('meeting')) {
                iconName = 'event';
                fallbackIcon = 'group';
            }
            else if (item.tags.includes('documentation')) {
                iconName = 'markdown';
                fallbackIcon = 'markdown';
            }
        }
        // ì—…ë°ì´íŠ¸ ë‚ ì§œ í¬ë§·
        const updatedAtStr = item.updatedAt instanceof Date
            ? item.updatedAt.toLocaleDateString()
            : new Date(item.updatedAt).toLocaleDateString();
        return {
            id: `vault-item-${item.id}`,
            label: item.name,
            type: TreeNodeType.VAULT_ITEM,
            description: updatedAtStr,
            tooltip: item.description || item.name,
            iconPath: this.getIconPath(iconName, fallbackIcon),
            contextValue: 'vaultItem',
            metadata: {
                itemId: item.id,
                contextId: context.id,
                content: item.content,
                tags: item.tags
            }
        };
    }
    /**
     * ì§€ë¼ ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸°
     */
    getJiraItems() {
        // Jira ì„œë¹„ìŠ¤ê°€ ì—†ìœ¼ë©´ Mock ë°ì´í„° ë°˜í™˜
        if (!this.jiraService) {
            return [
                {
                    id: 'jira-not-initialized',
                    label: 'Jira ì„œë¹„ìŠ¤ ì´ˆê¸°í™” í•„ìš”',
                    type: TreeNodeType.JIRA_ROOT,
                    iconPath: this.getIconPath('jira', 'error'),
                    contextValue: 'jiraError',
                    description: 'ì„œë¹„ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ',
                    tooltip: 'Jira ì„œë¹„ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í™•ìž¥ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.'
                }
            ];
        }
        try {
            // ì‹¤ì œ Jira ë°ì´í„°ë¥¼ ê°€ì ¸ì˜¤ë ¤ë©´ ì£¼ì„ í•´ì œí•˜ê³  Mock ë°ì´í„° ë¶€ë¶„ ì£¼ì„ ì²˜ë¦¬
            // í˜„ìž¬ëŠ” ê°œë°œ í™˜ê²½ì—ì„œ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ Mock ë°ì´í„° ì‚¬ìš©
            /*
            // ê³„ì • ì •ë³´ í™•ì¸
            const configResult = this.jiraService.getConfig();
            if (!configResult.success || !configResult.data || !configResult.data.isConfigured) {
              return [
                {
                  id: 'jira-not-configured',
                  label: 'Jira ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤',
                  type: TreeNodeType.JIRA_ROOT,
                  iconPath: this.getIconPath('jira', 'warning'),
                  contextValue: 'jiraNotConfigured',
                  description: 'ì¸ì¦ ì •ë³´ ì—†ìŒ',
                  tooltip: 'Jira ì—°ê²°ì„ ìœ„í•œ ì„¤ì •ì´ í•„ìš”í•©ë‹ˆë‹¤. í™•ìž¥ ì„¤ì •ì—ì„œ Jira ì¸ì¦ ì •ë³´ë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”.'
                }
              ];
            }
            
            // ì§€ë¼ í”„ë¡œì íŠ¸ ê°€ì ¸ì˜¤ê¸°
            const projectsResult = await this.jiraService.getProjects();
            if (!projectsResult.success || !projectsResult.data) {
              throw new Error(projectsResult.error?.message || 'Jira í”„ë¡œì íŠ¸ë¥¼ ê°€ì ¸ì˜¤ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
            }
            
            const projects = projectsResult.data;
            
            // ê° í”„ë¡œì íŠ¸ë³„ ì´ìŠˆ ê°€ì ¸ì˜¤ê¸°
            return projects.map(project => {
              return {
                id: `jira-project-${project.key}`,
                label: `${project.name} (${project.key})`,
                type: TreeNodeType.JIRA_PROJECT,
                iconPath: this.getIconPath('jira', 'project'),
                contextValue: 'jiraProject',
                description: `${project.issueCount || 0}ê°œ ì´ìŠˆ`,
                tooltip: project.description || project.name,
                children: this.getJiraIssuesForProject(project.key)
              };
            });
            */
            // Mock ë°ì´í„° (ê°œë°œ í™˜ê²½ìš©)
            return [
                {
                    id: 'jira-project-ape',
                    label: 'APE í”„ë¡œì íŠ¸',
                    type: TreeNodeType.JIRA_PROJECT,
                    iconPath: this.getIconPath('jira', 'project'),
                    contextValue: 'jiraProject',
                    description: 'APE-001 ì™¸ 10ê°œ ì´ìŠˆ',
                    tooltip: 'Agentic Pipeline Engine í”„ë¡œì íŠ¸',
                    children: [
                        {
                            id: 'jira-issue-ape-001',
                            label: 'APE-001: ì´ˆê¸° ì„¤ì • êµ¬í˜„',
                            type: TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-closed'),
                            contextValue: 'jiraIssue',
                            description: 'ì™„ë£Œë¨',
                            tooltip: 'í”„ë¡œì íŠ¸ ì´ˆê¸° ì„¤ì • ë° ê¸°ë³¸ êµ¬ì¡° êµ¬í˜„',
                            metadata: {
                                id: 'APE-001',
                                status: 'Done',
                                assignee: 'ì‚¬ìš©ìž',
                                priority: 'High',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'APE-001']
                                }
                            }
                        },
                        {
                            id: 'jira-issue-ape-002',
                            label: 'APE-002: ì±„íŒ… UI ê°œì„ ',
                            type: TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-open'),
                            contextValue: 'jiraIssue',
                            description: 'ì§„í–‰ ì¤‘',
                            tooltip: 'ì±„íŒ… UI ê°œì„  ë° ì‘ë‹µì„± í–¥ìƒ',
                            metadata: {
                                id: 'APE-002',
                                status: 'In Progress',
                                assignee: 'ì‚¬ìš©ìž',
                                priority: 'Medium',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'APE-002']
                                }
                            }
                        },
                        {
                            id: 'jira-issue-ape-003',
                            label: 'APE-003: íŠ¸ë¦¬ë·° êµ¬í˜„',
                            type: TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issues'),
                            contextValue: 'jiraIssue',
                            description: 'ì§„í–‰ ì¤‘',
                            tooltip: 'íŠ¸ë¦¬ë·° êµ¬í˜„ ë° ì„œë¹„ìŠ¤ ì—°ë™',
                            metadata: {
                                id: 'APE-003',
                                status: 'In Progress',
                                assignee: 'ì‚¬ìš©ìž',
                                priority: 'High',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'APE-003']
                                }
                            }
                        }
                    ]
                },
                {
                    id: 'jira-project-int',
                    label: 'í†µí•© í”„ë¡œì íŠ¸',
                    type: TreeNodeType.JIRA_PROJECT,
                    iconPath: this.getIconPath('jira', 'project'),
                    contextValue: 'jiraProject',
                    description: 'INT-001 ì™¸ 5ê°œ ì´ìŠˆ',
                    tooltip: 'ì‹œìŠ¤í…œ í†µí•© í”„ë¡œì íŠ¸',
                    children: [
                        {
                            id: 'jira-issue-int-001',
                            label: 'INT-001: Git í†µí•©',
                            type: TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-open'),
                            contextValue: 'jiraIssue',
                            description: 'ì§„í–‰ ì¤‘',
                            tooltip: 'Git ì„œë¹„ìŠ¤ í†µí•© ë° ìžë™ ì»¤ë°‹ ê¸°ëŠ¥ êµ¬í˜„',
                            metadata: {
                                id: 'INT-001',
                                status: 'In Progress',
                                assignee: 'ì‚¬ìš©ìž',
                                priority: 'High',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'INT-001']
                                }
                            }
                        },
                        {
                            id: 'jira-issue-int-002',
                            label: 'INT-002: Jira í†µí•©',
                            type: TreeNodeType.JIRA_ISSUE,
                            iconPath: this.getIconPath('jira', 'issue-draft'),
                            contextValue: 'jiraIssue',
                            description: 'ê³„íšë¨',
                            tooltip: 'Jira ì„œë¹„ìŠ¤ í†µí•© ë° ì´ìŠˆ ê´€ë¦¬ ê¸°ëŠ¥ êµ¬í˜„',
                            metadata: {
                                id: 'INT-002',
                                status: 'Planned',
                                assignee: 'ë¯¸í• ë‹¹',
                                priority: 'Medium',
                                command: {
                                    name: 'jira',
                                    args: ['show', 'INT-002']
                                }
                            }
                        }
                    ]
                },
                {
                    id: 'jira-commands',
                    label: 'Jira ëª…ë ¹ì–´',
                    type: TreeNodeType.JIRA_CATEGORY,
                    iconPath: this.getIconPath('command-line', 'terminal'),
                    contextValue: 'jiraCommands',
                    tooltip: 'Jira ê´€ë ¨ ëª…ë ¹ì–´',
                    children: [
                        {
                            id: 'jira-command-create',
                            label: '/jira create',
                            type: TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'add'),
                            contextValue: 'jiraCommand',
                            description: 'ìƒˆ ì´ìŠˆ ìƒì„±',
                            tooltip: 'ìƒˆ Jira ì´ìŠˆë¥¼ ìƒì„±í•©ë‹ˆë‹¤',
                            metadata: {
                                name: 'jira',
                                args: ['create'],
                                category: 'utility'
                            }
                        },
                        {
                            id: 'jira-command-search',
                            label: '/jira search',
                            type: TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'search'),
                            contextValue: 'jiraCommand',
                            description: 'ì´ìŠˆ ê²€ìƒ‰',
                            tooltip: 'Jira ì´ìŠˆë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤',
                            metadata: {
                                name: 'jira',
                                args: ['search'],
                                category: 'utility'
                            }
                        },
                        {
                            id: 'jira-command-summary',
                            label: '/jira summary',
                            type: TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'graph'),
                            contextValue: 'jiraCommand',
                            description: 'í”„ë¡œì íŠ¸ ìš”ì•½',
                            tooltip: 'Jira í”„ë¡œì íŠ¸ ìš”ì•½ ì •ë³´ë¥¼ í‘œì‹œí•©ë‹ˆë‹¤',
                            metadata: {
                                name: 'jira',
                                args: ['summary'],
                                category: 'utility'
                            }
                        },
                        {
                            id: 'jira-command-status',
                            label: '/jira status',
                            type: TreeNodeType.JIRA_COMMAND,
                            iconPath: this.getIconPath('jira', 'sync'),
                            contextValue: 'jiraCommand',
                            description: 'ì´ìŠˆ ìƒíƒœ ë³€ê²½',
                            tooltip: 'Jira ì´ìŠˆì˜ ìƒíƒœë¥¼ ë³€ê²½í•©ë‹ˆë‹¤',
                            metadata: {
                                name: 'jira',
                                args: ['status'],
                                category: 'utility'
                            }
                        }
                    ]
                }
            ];
        }
        catch (error) {
            console.error('Jira ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
            return [{
                    id: 'jira-error',
                    label: 'Jira ë¡œë”© ì˜¤ë¥˜',
                    type: TreeNodeType.JIRA_ROOT,
                    iconPath: this.getIconPath('jira', 'error'),
                    contextValue: 'jiraError',
                    description: `ì˜¤ë¥˜: ${error instanceof Error ? error.message : String(error)}`,
                    tooltip: 'ì˜¤ë¥˜ ë‚´ìš©: ' + (error instanceof Error ? error.message : String(error))
                }];
        }
    }
    /**
     * íŠ¹ì • í”„ë¡œì íŠ¸ì˜ Jira ì´ìŠˆ ê°€ì ¸ì˜¤ê¸°
     * @param projectKey í”„ë¡œì íŠ¸ í‚¤
     */
    getJiraIssuesForProject(projectKey) {
        if (!this.jiraService) {
            return [];
        }
        try {
            /*
            // ì‹¤ì œ êµ¬í˜„ (ì£¼ì„ ì²˜ë¦¬)
            const searchCriteria = {
              projectKey: projectKey,
              maxResults: 10
            };
            
            const searchResult = await this.jiraService.searchIssues(searchCriteria);
            if (!searchResult.success || !searchResult.data) {
              throw new Error(searchResult.error?.message || 'ì´ìŠˆ ê²€ìƒ‰ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤');
            }
            
            const issues = searchResult.data.issues;
            
            return issues.map(issue => {
              let iconName = 'jira';
              let fallbackIcon = 'issues';
              
              // ìƒíƒœì— ë”°ë¥¸ ì•„ì´ì½˜ ì„¤ì •
              if (issue.status === JiraIssueStatus.Done ||
                  issue.status === JiraIssueStatus.Closed ||
                  issue.status === JiraIssueStatus.Resolved) {
                fallbackIcon = 'issue-closed';
              } else if (issue.status === JiraIssueStatus.InProgress) {
                fallbackIcon = 'issue-open';
              } else {
                fallbackIcon = 'issue-draft';
              }
              
              return {
                id: `jira-issue-${issue.key}`,
                label: `${issue.key}: ${issue.summary}`,
                type: TreeNodeType.JIRA_ISSUE,
                iconPath: this.getIconPath(iconName, fallbackIcon),
                contextValue: 'jiraIssue',
                description: issue.status,
                tooltip: issue.description || issue.summary,
                metadata: {
                  id: issue.key,
                  status: issue.status,
                  assignee: issue.assignee || 'ë¯¸í• ë‹¹',
                  priority: issue.priority || 'Medium',
                  command: {
                    name: 'jira',
                    args: ['show', issue.key]
                  }
                }
              };
            });
            */
            // Mock ë°ì´í„° (ì‹¤ì œ êµ¬í˜„ ì „ê¹Œì§€ ì‚¬ìš©)
            return [];
        }
        catch (error) {
            console.error(`Jira ì´ìŠˆ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜ (${projectKey}):`, error);
            return [];
        }
    }
    /**
     * í¬ì¼“ ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸° (Mock)
     */
    getPocketItems() {
        return [
            {
                id: 'pocket-category-code',
                label: 'ì½”ë“œ ìƒ˜í”Œ [Mock]',
                type: TreeNodeType.POCKET_CATEGORY,
                iconPath: this.getIconPath('code-file', 'code'),
                contextValue: 'pocketCategory',
                description: '3ê°œ í•­ëª©',
                tooltip: 'ìœ ìš©í•œ ì½”ë“œ ìƒ˜í”Œ ëª¨ìŒ',
                children: [
                    {
                        id: 'pocket-item-code-1',
                        label: 'íƒ€ìž…ìŠ¤í¬ë¦½íŠ¸ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ [Mock]',
                        type: TreeNodeType.POCKET_ITEM,
                        iconPath: this.getIconPath('typescript', 'symbol-method'),
                        contextValue: 'pocketItem',
                        description: '2023-05-01 ì €ìž¥ë¨',
                        tooltip: 'ìžì£¼ ì‚¬ìš©í•˜ëŠ” íƒ€ìž…ìŠ¤í¬ë¦½íŠ¸ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ëª¨ìŒ',
                        metadata: {
                            id: 'code-1',
                            createdAt: '2023-05-01',
                            tags: ['typescript', 'utility']
                        }
                    },
                    {
                        id: 'pocket-item-code-2',
                        label: 'VS Code API ìƒ˜í”Œ [Mock]',
                        type: TreeNodeType.POCKET_ITEM,
                        iconPath: this.getIconPath('vscode', 'symbol-method'),
                        contextValue: 'pocketItem',
                        description: '2023-05-05 ì €ìž¥ë¨',
                        tooltip: 'VS Code API í™œìš© ì˜ˆì œ ì½”ë“œ',
                        metadata: {
                            id: 'code-2',
                            createdAt: '2023-05-05',
                            tags: ['vscode', 'api', 'extension']
                        }
                    }
                ]
            },
            {
                id: 'pocket-category-notes',
                label: 'í”„ë¡œì íŠ¸ ë…¸íŠ¸ [Mock]',
                type: TreeNodeType.POCKET_CATEGORY,
                iconPath: this.getIconPath('markdown', 'notebook'),
                contextValue: 'pocketCategory',
                description: '2ê°œ í•­ëª©',
                tooltip: 'í”„ë¡œì íŠ¸ ê´€ë ¨ ë©”ëª¨ ë° ë…¸íŠ¸',
                children: [
                    {
                        id: 'pocket-item-notes-1',
                        label: 'ì•„í‚¤í…ì²˜ ì„¤ê³„ ë©”ëª¨ [Mock]',
                        type: TreeNodeType.POCKET_ITEM,
                        iconPath: this.getIconPath('markdown', 'file-text'),
                        contextValue: 'pocketItem',
                        description: '2023-04-28 ì €ìž¥ë¨',
                        tooltip: 'í”„ë¡œì íŠ¸ ì•„í‚¤í…ì²˜ ì„¤ê³„ ê´€ë ¨ ë©”ëª¨',
                        metadata: {
                            id: 'notes-1',
                            createdAt: '2023-04-28',
                            tags: ['architecture', 'design', 'memo']
                        }
                    }
                ]
            }
        ];
    }
    /**
     * SWDP ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸° (Mock)
     */
    getSWDPItems() {
        return [
            {
                id: 'swdp-release',
                label: 'Release Build',
                type: TreeNodeType.SWDP_BUILD_TYPE,
                iconPath: this.getIconPath('cicd', 'package'),
                contextValue: 'swdpBuildType',
                tooltip: 'SWDP Release Build ìœ í˜•',
                children: [
                    {
                        id: 'swdp-release-info',
                        label: 'BUILD, COVERITY, SAM, ONBOARD TESTE, DOBEE, BLACKDUCK, ë“±ë“± ì—¬ê¸°ì— í‘œê¸° ì˜ˆì •ìž…ë‹ˆë‹¤.',
                        type: TreeNodeType.SWDP_ARTIFACT,
                        iconPath: this.getIconPath('jenkins-ci-cd', 'info'),
                        contextValue: 'swdpArtifact',
                        tooltip: 'SWDP Release Build ì •ë³´'
                    }
                ]
            },
            {
                id: 'swdp-layer',
                label: 'Layer Build',
                type: TreeNodeType.SWDP_BUILD_TYPE,
                iconPath: this.getIconPath('orchestration', 'layers'),
                contextValue: 'swdpBuildType',
                tooltip: 'SWDP Layer Build ìœ í˜•',
                children: [
                    {
                        id: 'swdp-layer-info',
                        label: 'BUILD, COVERITY, SAM, ONBOARD TESTE, DOBEE, BLACKDUCK, ë“±ë“± ì—¬ê¸°ì— í‘œê¸° ì˜ˆì •ìž…ë‹ˆë‹¤.',
                        type: TreeNodeType.SWDP_ARTIFACT,
                        iconPath: this.getIconPath('jenkins-ci-cd', 'info'),
                        contextValue: 'swdpArtifact',
                        tooltip: 'SWDP Layer Build ì •ë³´'
                    }
                ]
            },
            {
                id: 'swdp-local',
                label: 'Local Build',
                type: TreeNodeType.SWDP_BUILD_TYPE,
                iconPath: this.getIconPath('docker', 'desktop-download'),
                contextValue: 'swdpBuildType',
                tooltip: 'SWDP Local Build ìœ í˜•',
                children: [
                    {
                        id: 'swdp-local-info',
                        label: 'BUILD, COVERITY, SAM, ONBOARD TESTE, DOBEE, BLACKDUCK, ë“±ë“± ì—¬ê¸°ì— í‘œê¸° ì˜ˆì •ìž…ë‹ˆë‹¤.',
                        type: TreeNodeType.SWDP_ARTIFACT,
                        iconPath: this.getIconPath('docker-container', 'info'),
                        contextValue: 'swdpArtifact',
                        tooltip: 'SWDP Local Build ì •ë³´'
                    }
                ]
            }
        ];
    }
    /**
     * Rules ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸°
     */
    getRulesItems() {
        // Rules ì„œë¹„ìŠ¤ê°€ ì—†ìœ¼ë©´ ìŠ¤í… ë°˜í™˜
        if (!this.rulesService) {
            return [{
                    id: 'rules-not-initialized',
                    label: 'Rules ì„œë¹„ìŠ¤ ì´ˆê¸°í™” í•„ìš”',
                    type: TreeNodeType.RULES_ROOT,
                    iconPath: this.getIconPath('notebook', 'error'),
                    contextValue: 'rulesError',
                    description: 'ì„œë¹„ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ',
                    tooltip: 'Rules ì„œë¹„ìŠ¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í™•ìž¥ ì„¤ì •ì„ í™•ì¸í•˜ì„¸ìš”.'
                }];
        }
        try {
            const activeRules = this.rulesService.getActiveRules();
            const inactiveRules = this.rulesService.getAllRules().filter(rule => !activeRules.some(activeRule => activeRule.id === rule.id));
            const ruleItems = [];
            // í™œì„±í™”ëœ Rules ì¹´í…Œê³ ë¦¬
            if (activeRules.length > 0) {
                ruleItems.push({
                    id: 'rules-active',
                    label: 'í™œì„±í™”ëœ Rules',
                    type: TreeNodeType.RULES_ACTIVE,
                    iconPath: this.getIconPath('notebook', 'check'),
                    contextValue: 'rulesActive',
                    tooltip: 'í˜„ìž¬ LLM ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— ì ìš©ëœ Rules',
                    description: `${activeRules.length}ê°œ í•­ëª©`,
                    children: activeRules.map(rule => this.createRuleNode(rule, true))
                });
            }
            // ë¹„í™œì„±í™”ëœ Rules ì¹´í…Œê³ ë¦¬
            if (inactiveRules.length > 0) {
                ruleItems.push({
                    id: 'rules-inactive',
                    label: 'ë¹„í™œì„±í™”ëœ Rules',
                    type: TreeNodeType.RULES_INACTIVE,
                    iconPath: this.getIconPath('notebook', 'circle-outline'),
                    contextValue: 'rulesInactive',
                    tooltip: 'í˜„ìž¬ ë¹„í™œì„±í™”ë˜ì–´ ìžˆëŠ” Rules',
                    description: `${inactiveRules.length}ê°œ í•­ëª©`,
                    children: inactiveRules.map(rule => this.createRuleNode(rule, false))
                });
            }
            // Rulesê°€ ì—†ëŠ” ê²½ìš°
            if (ruleItems.length === 0) {
                ruleItems.push({
                    id: 'rules-empty',
                    label: 'Rules ì—†ìŒ',
                    type: TreeNodeType.RULES_ROOT,
                    iconPath: this.getIconPath('notebook', 'info'),
                    contextValue: 'rulesEmpty',
                    description: 'ìƒì„±ëœ Rules ì—†ìŒ',
                    tooltip: 'ìš°í´ë¦­ ë©”ë‰´ë¥¼ í†µí•´ ìƒˆ Ruleì„ ìƒì„±í•˜ì„¸ìš”.'
                });
            }
            return ruleItems;
        }
        catch (error) {
            console.error('Rules ëª©ë¡ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
            return [{
                    id: 'rules-error',
                    label: 'Rules ë¡œë”© ì˜¤ë¥˜',
                    type: TreeNodeType.RULES_ROOT,
                    iconPath: this.getIconPath('notebook', 'error'),
                    contextValue: 'rulesError',
                    description: `ì˜¤ë¥˜: ${error instanceof Error ? error.message : String(error)}`,
                    tooltip: 'ì˜¤ë¥˜ ë‚´ìš©: ' + (error instanceof Error ? error.message : String(error))
                }];
        }
    }
    /**
     * Rule ë…¸ë“œ ìƒì„±
     * @param rule Rule ê°ì²´
     * @param isActive í™œì„±í™” ì—¬ë¶€
     */
    createRuleNode(rule, isActive) {
        const iconName = isActive ? 'notebook' : 'notebook';
        const fallbackIcon = isActive ? 'notebook-opened' : 'notebook';
        // íŒŒì¼ ì´ë¦„ë§Œ ì¶”ì¶œ
        const fileName = rule.filePath.split('/').pop();
        return {
            id: `rule-item-${rule.id}`,
            label: rule.name,
            type: TreeNodeType.RULE_ITEM,
            description: fileName, // íŒŒì¼ ì´ë¦„ì„ ì„¤ëª…ìœ¼ë¡œ í‘œì‹œ
            tooltip: `${rule.name} (${fileName})\n\n${rule.content.substring(0, 100)}${rule.content.length > 100 ? '...' : ''}`,
            iconPath: this.getIconPath(iconName, fallbackIcon),
            contextValue: isActive ? 'ruleActive' : 'ruleInactive',
            metadata: {
                id: rule.id,
                filePath: rule.filePath,
                isActive: isActive
            }
        };
    }
    /**
     * ì±„íŒ… ë‚´ì—­ ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸°
     */
    getChatHistoryItems() {
        try {
            // ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ ë£¨íŠ¸ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
            const workspaceFolder = external_vscode_.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                return [this.createChatHistoryErrorNode('ì›Œí¬ìŠ¤íŽ˜ì´ìŠ¤ í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤')];
            }
            // ì±„íŒ… ë‚´ì—­ í´ë” ê²½ë¡œ
            const chatHistoryDir = external_path_.join(workspaceFolder.uri.fsPath, '.ape', 'vault', 'chat-history');
            // í´ë” ì¡´ìž¬ í™•ì¸
            if (!(0,external_fs_.existsSync)(chatHistoryDir)) {
                return [this.createChatHistoryInfoNode('ì €ìž¥ëœ ì±„íŒ… ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤', 'ì±„íŒ… ë‚´ì—­ì„ ì €ìž¥í•˜ë ¤ë©´ ì±„íŒ… ì°½ì—ì„œ `/save` ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.')];
            }
            // íŒŒì¼ ì‹œìŠ¤í…œì—ì„œ ë©”íƒ€ë°ì´í„° íŒŒì¼ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            const fs = __webpack_require__(9896);
            const metaFiles = fs.readdirSync(chatHistoryDir)
                .filter((name) => name.endsWith('.meta.json'));
            if (metaFiles.length === 0) {
                return [this.createChatHistoryInfoNode('ì €ìž¥ëœ ì±„íŒ… ë‚´ì—­ì´ ì—†ìŠµë‹ˆë‹¤', 'ì±„íŒ… ë‚´ì—­ì„ ì €ìž¥í•˜ë ¤ë©´ ì±„íŒ… ì°½ì—ì„œ `/save` ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.')];
            }
            // ì±„íŒ… ë‚´ì—­ ì•„ì´í…œ ëª©ë¡
            const chatItems = [];
            // ë©”íƒ€ë°ì´í„° íŒŒì¼ ì²˜ë¦¬
            for (const fileName of metaFiles) {
                const filePath = external_path_.join(chatHistoryDir, fileName);
                const chatId = fileName.replace('.meta.json', '');
                try {
                    // ë©”íƒ€ë°ì´í„° ì½ê¸°
                    const metadata = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                    // ë‚ ì§œ í¬ë§·íŒ…
                    const createdDate = new Date(metadata.createdAt);
                    const dateStr = createdDate.toLocaleDateString();
                    const timeStr = createdDate.toLocaleTimeString();
                    // ì±„íŒ… ë‚´ì—­ ì•„ì´í…œ ì¶”ê°€
                    chatItems.push({
                        id: `chat-history-${chatId}`,
                        label: metadata.title,
                        type: TreeNodeType.CHAT_HISTORY_ITEM,
                        description: `${dateStr} ${timeStr}`,
                        tooltip: `${metadata.title} (${dateStr} ${timeStr})\n${metadata.messageCount}ê°œ ë©”ì‹œì§€`,
                        iconPath: this.getIconPath('chat', 'comment-discussion'),
                        contextValue: 'chatHistoryItem',
                        metadata: {
                            id: chatId,
                            title: metadata.title,
                            createdAt: metadata.createdAt,
                            updatedAt: metadata.updatedAt,
                            messageCount: metadata.messageCount,
                            command: {
                                name: 'show',
                                args: [chatId]
                            }
                        }
                    });
                }
                catch (error) {
                    console.error(`ì±„íŒ… ë‚´ì—­ ë©”íƒ€ë°ì´í„° ì½ê¸° ì˜¤ë¥˜ (${fileName}):`, error);
                }
            }
            // ìµœì‹ ìˆœ ì •ë ¬
            chatItems.sort((a, b) => {
                const dateA = new Date(a.metadata.createdAt);
                const dateB = new Date(b.metadata.createdAt);
                return dateB.getTime() - dateA.getTime();
            });
            return chatItems;
        }
        catch (error) {
            console.error('ì±„íŒ… ë‚´ì—­ ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
            return [this.createChatHistoryErrorNode(`ì˜¤ë¥˜: ${error instanceof Error ? error.message : String(error)}`)];
        }
    }
    /**
     * ì±„íŒ… ë‚´ì—­ ì˜¤ë¥˜ ë…¸ë“œ ìƒì„±
     */
    createChatHistoryErrorNode(message) {
        return {
            id: 'chat-history-error',
            label: 'ì±„íŒ… ë‚´ì—­ ë¡œë”© ì˜¤ë¥˜',
            type: TreeNodeType.CHAT_HISTORY_ROOT,
            iconPath: this.getIconPath('chat', 'error'),
            contextValue: 'chatHistoryError',
            description: message,
            tooltip: message
        };
    }
    /**
     * ì±„íŒ… ë‚´ì—­ ì •ë³´ ë…¸ë“œ ìƒì„±
     */
    createChatHistoryInfoNode(label, tooltip) {
        return {
            id: 'chat-history-info',
            label,
            type: TreeNodeType.CHAT_HISTORY_ROOT,
            iconPath: this.getIconPath('chat', 'info'),
            contextValue: 'chatHistoryInfo',
            tooltip
        };
    }
    /**
     * í”ŒëŸ¬ê·¸ì¸ ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸° - Stub ì²˜ë¦¬
     */
    getPluginItems() {
        return [
            {
                id: 'plugin-not-implemented',
                label: 'í”ŒëŸ¬ê·¸ì¸ ëª©ë¡ ë¡œë“œ ì¤‘...',
                type: TreeNodeType.PLUGIN_ROOT,
                iconPath: this.getIconPath('plugin', 'error'),
                contextValue: 'pluginStub',
                description: 'êµ¬í˜„ë˜ì§€ ì•Šì€ ê¸°ëŠ¥ìž…ë‹ˆë‹¤',
                tooltip: 'ì´ ê¸°ëŠ¥ì€ ì•„ì§ êµ¬í˜„ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. TASK-W3-001ì˜ ë‹¤ìŒ ë‹¨ê³„ì—ì„œ êµ¬í˜„ë  ì˜ˆì •ìž…ë‹ˆë‹¤.'
            }
        ];
    }
    /**
     * ì„¤ì • ê°’ ê°€ì ¸ì˜¤ê¸°
     */
    getConfigValue(key) {
        const config = external_vscode_.workspace.getConfiguration();
        const value = config.get(key);
        return value !== undefined ? String(value) : '';
    }
    /**
     * ì•„ì´ì½˜ ê²½ë¡œ ê°€ì ¸ì˜¤ê¸°
     * @param iconName ì•„ì´ì½˜ ì´ë¦„
     * @param fallbackIcon ëŒ€ì²´ í…Œë§ˆ ì•„ì´ì½˜
     * @returns í…Œë§ˆ ì•„ì´ì½˜
     */
    getIconPath(iconName, fallbackIcon = 'symbol-event') {
        // ThemeIcon ì‚¬ìš©
        return new external_vscode_.ThemeIcon(fallbackIcon);
    }
    /**
     * TreeView ìƒˆë¡œê³ ì¹¨
     */
    refresh() {
        this.initializeTreeData();
        this._onDidChangeTreeData.fire(undefined);
    }
    /**
     * íŠ¸ë¦¬ ì•„ì´í…œ ê°€ì ¸ì˜¤ê¸°
     */
    getTreeItem(element) {
        const treeItem = new external_vscode_.TreeItem(element.label, element.children && element.children.length > 0
            ? external_vscode_.TreeItemCollapsibleState.Collapsed
            : external_vscode_.TreeItemCollapsibleState.None);
        // ì•„ì´í…œ ì†ì„± ì„¤ì •
        treeItem.description = element.description || '';
        treeItem.tooltip = element.tooltip || element.description || element.label;
        treeItem.contextValue = element.contextValue || '';
        // ì•„ì´ì½˜ ì„¤ì •
        if (element.iconPath) {
            treeItem.iconPath = element.iconPath;
        }
        // ëª…ë ¹ì–´ ì„¤ì •
        if (element.type === TreeNodeType.COMMAND ||
            element.type === TreeNodeType.GIT_COMMAND) {
            // ëª…ë ¹ì–´ í´ë¦­ ì‹œ ì‹¤í–‰
            treeItem.command = {
                command: 'ape.executeCommand',
                title: 'ëª…ë ¹ì–´ ì‹¤í–‰',
                arguments: [element.metadata]
            };
        }
        else if (element.type === TreeNodeType.SETTINGS_ITEM) {
            // ì„¤ì • í´ë¦­ ì‹œ ì„¤ì • íŽ˜ì´ì§€ ì—´ê¸°
            treeItem.command = {
                command: 'ape.openSettings',
                title: 'ì„¤ì • ì—´ê¸°',
                arguments: [element.metadata?.settingKey]
            };
        }
        else if (element.type === TreeNodeType.VAULT_ITEM) {
            // VAULT ì•„ì´í…œ í´ë¦­ ì‹œ ë‚´ìš© ë³´ê¸°
            treeItem.command = {
                command: 'ape.vaultShowItem',
                title: 'VAULT ì•„ì´í…œ ë³´ê¸°',
                arguments: [element.metadata]
            };
        }
        else if (element.type === TreeNodeType.CHAT_HISTORY_ITEM) {
            // ì±„íŒ… ë‚´ì—­ ì•„ì´í…œ í´ë¦­ ì‹œ ë‚´ìš© ë³´ê¸°
            treeItem.command = {
                command: 'ape.executeCommand',
                title: 'ì±„íŒ… ë‚´ì—­ ë³´ê¸°',
                arguments: [{
                        name: 'show',
                        args: [element.metadata.id]
                    }]
            };
        }
        return treeItem;
    }
    /**
     * ìžì‹ ë…¸ë“œ ê°€ì ¸ì˜¤ê¸°
     */
    getChildren(element) {
        if (!element) {
            return this.treeData;
        }
        return element.children || [];
    }
    /**
     * ë¶€ëª¨ ë…¸ë“œ ê°€ì ¸ì˜¤ê¸°
     */
    getParent() {
        // í˜„ìž¬ ë²„ì „ì—ì„œëŠ” ë¶€ëª¨ ë…¸ë“œ ì¶”ì ì´ í•„ìš”í•˜ì§€ ì•ŠìŒ
        return null;
    }
}

;// ./src/core/services/versionManager.ts




/**
 * ì‹œë§¨í‹± ë²„ì „ ê·œì¹™ì— ë”°ë¥¸ ë²„ì „ ì¢…ë¥˜
 */
var VersionType;
(function (VersionType) {
    /**
     * íŒ¨ì¹˜ ë²„ì „: ë²„ê·¸ ìˆ˜ì • ë° ë§ˆì´ë„ˆ ë³€ê²½ (0.0.1)
     */
    VersionType["PATCH"] = "patch";
    /**
     * ë§ˆì´ë„ˆ ë²„ì „: í•˜ìœ„ í˜¸í™˜ì„± ìžˆëŠ” ìƒˆ ê¸°ëŠ¥ ì¶”ê°€ (0.1.0)
     */
    VersionType["MINOR"] = "minor";
    /**
     * ë©”ì´ì € ë²„ì „: ì£¼ìš” ê¸°ëŠ¥ ë˜ëŠ” í•˜ìœ„ í˜¸í™˜ì„±ì´ ì—†ëŠ” ë³€ê²½ (1.0.0)
     */
    VersionType["MAJOR"] = "major";
})(VersionType || (VersionType = {}));
/**
 * ë²„ì „ ê´€ë¦¬ ì„œë¹„ìŠ¤
 * - í”„ë¡œì íŠ¸ ë²„ì „ ê´€ë¦¬
 * - ë²„ì „ ì—…ë°ì´íŠ¸ (patch, minor, major)
 * - Git íƒœê·¸ ìƒì„±
 */
class VersionManager {
    _extensionContext;
    constructor(context) {
        this._extensionContext = context;
    }
    /**
     * í˜„ìž¬ í”„ë¡œì íŠ¸ ë²„ì „ ì •ë³´ ì¡°íšŒ
     * @returns ë²„ì „ ì •ë³´
     */
    async getCurrentVersion() {
        try {
            const packageJsonPath = this.getPackageJsonPath();
            const packageJson = await this.readPackageJson(packageJsonPath);
            const version = packageJson.version || '0.0.0';
            const versionParts = this.parseVersion(version);
            return {
                version,
                packageJsonPath,
                versionParts
            };
        }
        catch (error) {
            throw new ServiceError('ë²„ì „ ì •ë³´ë¥¼ ì½ì–´ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', error);
        }
    }
    /**
     * ë²„ì „ ì—…ë°ì´íŠ¸
     * @param type ë²„ì „ ì—…ë°ì´íŠ¸ ìœ í˜• (patch, minor, major)
     * @param message ë²„ì „ ì—…ë°ì´íŠ¸ ì´ìœ /ë©”ì‹œì§€
     * @param createGitTag Git íƒœê·¸ ìƒì„± ì—¬ë¶€
     * @returns ì—…ë°ì´íŠ¸ëœ ë²„ì „ ì •ë³´
     */
    async updateVersion(type, message, createGitTag = false) {
        try {
            // í˜„ìž¬ ë²„ì „ ì •ë³´ ì¡°íšŒ
            const currentVersionInfo = await this.getCurrentVersion();
            const { versionParts, packageJsonPath } = currentVersionInfo;
            // ìƒˆ ë²„ì „ ê³„ì‚°
            const newVersionParts = [...versionParts];
            switch (type) {
                case VersionType.PATCH:
                    newVersionParts[2] += 1;
                    break;
                case VersionType.MINOR:
                    newVersionParts[1] += 1;
                    newVersionParts[2] = 0;
                    break;
                case VersionType.MAJOR:
                    newVersionParts[0] += 1;
                    newVersionParts[1] = 0;
                    newVersionParts[2] = 0;
                    break;
            }
            const newVersion = newVersionParts.join('.');
            // package.json ì—…ë°ì´íŠ¸
            await this.updatePackageJsonVersion(packageJsonPath, newVersion);
            // Git íƒœê·¸ ìƒì„± (ì˜µì…˜)
            if (createGitTag) {
                await this.createGitTag(newVersion, message);
            }
            // ìƒíƒœë°” ì—…ë°ì´íŠ¸
            this.updateStatusBar(newVersion);
            // ê²°ê³¼ ë°˜í™˜
            return {
                version: newVersion,
                packageJsonPath,
                versionParts: newVersionParts
            };
        }
        catch (error) {
            throw new ServiceError('ë²„ì „ ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', error);
        }
    }
    /**
     * Git íƒœê·¸ ìƒì„±
     * @param version ë²„ì „ ë¬¸ìžì—´
     * @param message íƒœê·¸ ë©”ì‹œì§€
     */
    async createGitTag(version, message) {
        try {
            const tagName = `v${version}`;
            const tagMessage = message || `Version ${version}`;
            // Git íƒœê·¸ ëª…ë ¹ ì‹¤í–‰
            const terminal = external_vscode_.window.createTerminal('APE Version Manager');
            terminal.sendText(`git tag -a "${tagName}" -m "${tagMessage}"`);
            terminal.sendText('git push --tags');
            terminal.show();
            external_vscode_.window.showInformationMessage(`Created Git tag: ${tagName}`);
        }
        catch (error) {
            throw new ServiceError('Git íƒœê·¸ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', error);
        }
    }
    /**
     * ë²„ì „ ê´€ë¦¬ ëª…ë ¹ì–´ ë“±ë¡
     */
    registerCommands() {
        // ë‚´ë¶€ ê°œë°œìš© ëª…ë ¹ì–´ë§Œ ë“±ë¡
        this._extensionContext.subscriptions.push(external_vscode_.commands.registerCommand('ape.internal.version.bump.patch', async () => {
            await this.bumpVersion(VersionType.PATCH);
        }), external_vscode_.commands.registerCommand('ape.internal.version.bump.minor', async () => {
            await this.bumpVersion(VersionType.MINOR);
        }), external_vscode_.commands.registerCommand('ape.internal.version.bump.major', async () => {
            await this.bumpVersion(VersionType.MAJOR);
        }));
    }
    /**
     * VS Code ìƒíƒœ í‘œì‹œì¤„ì— ë²„ì „ í‘œì‹œ
     * @param version ë²„ì „ ë¬¸ìžì—´
     */
    updateStatusBar(version) {
        // ìƒíƒœ í‘œì‹œì¤„ ì•„ì´í…œì´ ì´ë¯¸ ìžˆëŠ”ì§€ í™•ì¸
        const statusBarItem = external_vscode_.window.createStatusBarItem(external_vscode_.StatusBarAlignment.Right, 100);
        statusBarItem.text = `$(tag) APE v${version}`;
        statusBarItem.tooltip = 'APE Extension Version';
        statusBarItem.show();
        // Extension Contextì— ìƒíƒœ í‘œì‹œì¤„ ì•„ì´í…œ ë“±ë¡
        this._extensionContext.subscriptions.push(statusBarItem);
    }
    /**
     * ë²„ì „ ì¦ê°€ ìž‘ì—… ìˆ˜í–‰
     * @param type ë²„ì „ ì¦ê°€ ìœ í˜•
     */
    async bumpVersion(type) {
        try {
            // ë©”ì‹œì§€ ìž…ë ¥ ë°›ê¸°
            const message = await external_vscode_.window.showInputBox({
                prompt: 'ë²„ì „ ì—…ë°ì´íŠ¸ ë©”ì‹œì§€ë¥¼ ìž…ë ¥í•˜ì„¸ìš”',
                placeHolder: 'ì˜ˆ: ìŠ¤íŠ¸ë¦¬ë° ì±„íŒ… UI ê°œì„ '
            });
            if (message === undefined) {
                return; // ì·¨ì†Œë¨
            }
            // Git íƒœê·¸ ìƒì„± ì—¬ë¶€ í™•ì¸
            const createTag = await external_vscode_.window.showQuickPick(['Yes', 'No'], {
                placeHolder: 'Git íƒœê·¸ë¥¼ ìƒì„±í•˜ì‹œê² ìŠµë‹ˆê¹Œ?'
            });
            if (createTag === undefined) {
                return; // ì·¨ì†Œë¨
            }
            // ë²„ì „ ì—…ë°ì´íŠ¸
            const newVersionInfo = await this.updateVersion(type, message, createTag === 'Yes');
            external_vscode_.window.showInformationMessage(`ë²„ì „ì´ ${newVersionInfo.version}(ìœ¼)ë¡œ ì—…ë°ì´íŠ¸ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }
        catch (error) {
            external_vscode_.window.showErrorMessage(`ë²„ì „ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * package.json ê²½ë¡œ ì¡°íšŒ
     */
    getPackageJsonPath() {
        return external_path_.join(this._extensionContext.extensionPath, 'package.json');
    }
    /**
     * package.json íŒŒì¼ ì½ê¸°
     * @param filePath package.json íŒŒì¼ ê²½ë¡œ
     */
    async readPackageJson(filePath) {
        return new Promise((resolve, reject) => {
            external_fs_.readFile(filePath, 'utf8', (err, data) => {
                if (err) {
                    reject(err);
                    return;
                }
                try {
                    const packageJson = JSON.parse(data);
                    resolve(packageJson);
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
    /**
     * package.json ë²„ì „ ì—…ë°ì´íŠ¸
     * @param filePath package.json íŒŒì¼ ê²½ë¡œ
     * @param newVersion ìƒˆ ë²„ì „ ë¬¸ìžì—´
     */
    async updatePackageJsonVersion(filePath, newVersion) {
        return new Promise((resolve, reject) => {
            external_fs_.readFile(filePath, 'utf8', (err, data) => {
                if (err) {
                    reject(err);
                    return;
                }
                try {
                    const packageJson = JSON.parse(data);
                    packageJson.version = newVersion;
                    const updatedContent = JSON.stringify(packageJson, null, 2);
                    external_fs_.writeFile(filePath, updatedContent, 'utf8', (writeErr) => {
                        if (writeErr) {
                            reject(writeErr);
                            return;
                        }
                        resolve();
                    });
                }
                catch (error) {
                    reject(error);
                }
            });
        });
    }
    /**
     * ë²„ì „ ë¬¸ìžì—´ íŒŒì‹±
     * @param version ë²„ì „ ë¬¸ìžì—´ (x.y.z í˜•ì‹)
     * @returns [major, minor, patch] ìˆ«ìž ë°°ì—´
     */
    parseVersion(version) {
        const parts = version.split('.').map(part => parseInt(part, 10));
        // ë°°ì—´ì´ 3ê°œ ìš”ì†Œë¥¼ ê°–ë„ë¡ ë³´ìž¥
        while (parts.length < 3) {
            parts.push(0);
        }
        return parts;
    }
}

;// ./src/core/llm/modelManager.ts


/**
 * ëª¨ë¸ ê´€ë¦¬ ì„œë¹„ìŠ¤
 * LLM ëª¨ë¸ ì„¤ì •, ê²€ìƒ‰ ë° ì´ë²¤íŠ¸ ê´€ë¦¬ë¥¼ ë‹´ë‹¹í•©ë‹ˆë‹¤.
 */
class ModelManager {
    _context;
    // í˜„ìž¬ í™œì„± ëª¨ë¸
    _activeModel = LLMModel.GPT_4_1_MINI;
    // ì„¤ì • ì—…ë°ì´íŠ¸ ì¤‘ì¸ì§€ ì—¬ë¶€ë¥¼ ì¶”ì í•˜ëŠ” í”Œëž˜ê·¸
    _isUpdatingConfig = false;
    // ëª¨ë¸ ë³€ê²½ ì´ë²¤íŠ¸
    _onDidChangeModel = new external_vscode_.EventEmitter();
    onDidChangeModel = this._onDidChangeModel.event;
    // ì„¤ì • ë³€ê²½ ê°ì§€ë¥¼ ìœ„í•œ êµ¬ë…
    _configListener;
    /**
     * ìƒì„±ìž
     * @param _context VSCode í™•ìž¥ ì»¨í…ìŠ¤íŠ¸
     */
    constructor(_context) {
        this._context = _context;
        // ì´ˆê¸° ì„¤ì • ë¡œë“œ
        this._loadConfiguration();
        // ì„¤ì • ë³€ê²½ ì´ë²¤íŠ¸ ì²˜ë¦¬
        this._configListener = external_vscode_.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration('ape.llm.defaultModel') && !this._isUpdatingConfig) {
                this._loadConfiguration();
            }
        });
    }
    /**
     * ì„¤ì •ì—ì„œ ëª¨ë¸ ì •ë³´ ë¡œë“œ
     */
    _loadConfiguration() {
        try {
            const config = external_vscode_.workspace.getConfiguration('ape.llm');
            const configModel = config.get('defaultModel', LLMModel.GPT_4_1_MINI);
            // ìœ íš¨í•œ ëª¨ë¸ì¸ì§€ í™•ì¸
            if (this._isValidModel(configModel)) {
                // ëª¨ë¸ì´ ë³€ê²½ëœ ê²½ìš°ì—ë§Œ ì´ë²¤íŠ¸ ë°œìƒ
                if (this._activeModel !== configModel) {
                    const oldModel = this._activeModel;
                    this._activeModel = configModel;
                    // ëª¨ë¸ ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
                    this._onDidChangeModel.fire({
                        oldModel,
                        newModel: this._activeModel
                    });
                }
            }
            else {
                console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ ëª¨ë¸: ${configModel}, ê¸°ë³¸ ëª¨ë¸ ì‚¬ìš©: ${LLMModel.GPT_4_1_MINI}`);
                // í™œì„± ëª¨ë¸ì´ ì´ë¯¸ ê¸°ë³¸ ëª¨ë¸ì´ ì•„ë‹Œ ê²½ìš°ì—ë§Œ ì—…ë°ì´íŠ¸
                if (this._activeModel !== LLMModel.GPT_4_1_MINI) {
                    const oldModel = this._activeModel;
                    this._activeModel = LLMModel.GPT_4_1_MINI;
                    // ì„¤ì • ì—…ë°ì´íŠ¸ í”Œëž˜ê·¸ ì„¤ì •
                    this._isUpdatingConfig = true;
                    // ì„¤ì • ì—…ë°ì´íŠ¸
                    Promise.resolve(config.update('defaultModel', LLMModel.GPT_4_1_MINI, external_vscode_.ConfigurationTarget.Global))
                        .then(() => {
                        // ëª¨ë¸ ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
                        this._onDidChangeModel.fire({
                            oldModel,
                            newModel: LLMModel.GPT_4_1_MINI
                        });
                        console.log(`ê¸°ë³¸ ëª¨ë¸ë¡œ ì„¤ì • ì—…ë°ì´íŠ¸ë¨: ${LLMModel.GPT_4_1_MINI}`);
                    })
                        .then(undefined, (err) => {
                        console.error('ëª¨ë¸ ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', err);
                    })
                        .finally(() => {
                        // ì„¤ì • ì—…ë°ì´íŠ¸ í”Œëž˜ê·¸ í•´ì œ (ì§€ì—° ì„¤ì •)
                        setTimeout(() => {
                            this._isUpdatingConfig = false;
                        }, 100);
                    });
                }
            }
        }
        catch (error) {
            console.error('ëª¨ë¸ ì„¤ì • ë¡œë“œ ì¤‘ ì˜¤ë¥˜:', error);
        }
    }
    /**
     * ëª¨ë¸ IDê°€ ìœ íš¨í•œì§€ í™•ì¸
     * @param modelId í™•ì¸í•  ëª¨ë¸ ID
     * @returns ìœ íš¨í•œ ëª¨ë¸ì¸ì§€ ì—¬ë¶€
     */
    _isValidModel(modelId) {
        // í‘œì¤€ ëª¨ë¸ í™•ì¸
        const isStandardModel = Object.values(LLMModel).includes(modelId);
        // í…ŒìŠ¤íŠ¸ ëª¨ë¸ í™•ì¸
        const testModels = ['NARRNAS', 'LLAMA4-MAVERICK', 'LLAMA4-SCOUT'];
        const isTestModel = testModels.includes(modelId);
        return isStandardModel || isTestModel;
    }
    /**
     * í˜„ìž¬ í™œì„± ëª¨ë¸ ê°€ì ¸ì˜¤ê¸°
     * @returns í˜„ìž¬ í™œì„± ëª¨ë¸
     */
    getActiveModel() {
        return this._activeModel;
    }
    /**
     * í™œì„± ëª¨ë¸ ë³€ê²½
     * @param model ì‚¬ìš©í•  ìƒˆ ëª¨ë¸
     * @returns ì„±ê³µ ì—¬ë¶€ë¥¼ ë‚˜íƒ€ë‚´ëŠ” Promise
     */
    async setActiveModel(model) {
        // í˜„ìž¬ ëª¨ë¸ê³¼ ë™ì¼í•˜ê±°ë‚˜ ì´ë¯¸ ì„¤ì • ì—…ë°ì´íŠ¸ ì¤‘ì´ë©´ ë¬´ì‹œ
        if (this._activeModel === model || this._isUpdatingConfig) {
            return false;
        }
        // ìœ íš¨í•œ ëª¨ë¸ì¸ì§€ í™•ì¸
        if (!this._isValidModel(model)) {
            console.warn(`ìœ íš¨í•˜ì§€ ì•Šì€ ëª¨ë¸: ${model}, í˜„ìž¬ ëª¨ë¸ ìœ ì§€: ${this._activeModel}`);
            return false;
        }
        try {
            // ì„¤ì • ì—…ë°ì´íŠ¸ í”Œëž˜ê·¸ ì„¤ì •
            this._isUpdatingConfig = true;
            // ì´ì „ ëª¨ë¸ ì €ìž¥
            const oldModel = this._activeModel;
            // í™œì„± ëª¨ë¸ ì—…ë°ì´íŠ¸
            this._activeModel = model;
            // ì„¤ì •ì— ë³€ê²½ ì‚¬í•­ ì €ìž¥
            const config = external_vscode_.workspace.getConfiguration('ape.llm');
            await config.update('defaultModel', model, external_vscode_.ConfigurationTarget.Global);
            // ëª¨ë¸ ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeModel.fire({
                oldModel,
                newModel: model
            });
            console.log(`ëª¨ë¸ì´ ë³€ê²½ë¨: ${oldModel} -> ${model}`);
            return true;
        }
        catch (error) {
            console.error('ëª¨ë¸ ì„¤ì • ì—…ë°ì´íŠ¸ ì‹¤íŒ¨:', error);
            return false;
        }
        finally {
            // ì„¤ì • ì—…ë°ì´íŠ¸ í”Œëž˜ê·¸ í•´ì œ (ì§€ì—° ì„¤ì •)
            setTimeout(() => {
                this._isUpdatingConfig = false;
            }, 100);
        }
    }
    /**
     * ëª¨ë“  ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸ ê°€ì ¸ì˜¤ê¸°
     * @returns ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸ ë°°ì—´
     */
    getAvailableModels() {
        try {
            // ì„¤ì •ì— ì •ì˜ëœ ëª¨ë¸ ëª©ë¡ í™•ì¸
            const config = external_vscode_.workspace.getConfiguration('ape.llm');
            // inspect ê²°ê³¼ê°€ ë‹¤ì–‘í•œ í˜•íƒœì¼ ìˆ˜ ìžˆìœ¼ë¯€ë¡œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬
            const inspection = config.inspect('defaultModel');
            const configModels = inspection && typeof inspection === 'object' ?
                inspection.properties?.enum : undefined;
            // ì„¤ì •ì— ì •ì˜ëœ ëª¨ë¸ ë°°ì—´ì´ ìžˆìœ¼ë©´ ì‚¬ìš©
            if (configModels && Array.isArray(configModels)) {
                return configModels;
            }
            // ì„¤ì •ì—ì„œ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìœ¼ë©´ ê¸°ë³¸ ì •ì˜ ì‚¬ìš©
            const standardModels = Object.values(LLMModel);
            // ë‚´ë¶€ í…ŒìŠ¤íŠ¸ ëª¨ë¸ ì¶”ê°€ (package.jsonì— ì •ì˜ë˜ì–´ ìžˆì–´ì•¼ í•¨)
            const testModels = ['NARRNAS', 'LLAMA4-MAVERICK', 'LLAMA4-SCOUT'];
            return [...standardModels, ...testModels];
        }
        catch (error) {
            // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ ëª¨ë¸ ëª©ë¡ë§Œ ë°˜í™˜
            console.error('ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸ ê°€ì ¸ì˜¤ê¸° ì˜¤ë¥˜:', error);
            return Object.values(LLMModel);
        }
    }
    /**
     * ëª¨ë¸ ì„ íƒ ëª…ë ¹ì–´ ë“±ë¡ - ëª…ë ¹ì–´ëŠ” CommandManagerë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤
     * @deprecated ì´ ë©”ì„œë“œëŠ” ë” ì´ìƒ ì‚¬ìš©ë˜ì§€ ì•Šìœ¼ë©°, ëª…ë ¹ì–´ ë“±ë¡ì€ CommandManagerì—ì„œ ë‹´ë‹¹í•©ë‹ˆë‹¤.
     *
     * ì°¸ê³ : ì´ ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ë©´ ì•„ë¬´ ë™ìž‘ë„ í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
     * extension.tsì—ì„œëŠ” commandManager.registerCommands()ë§Œ í˜¸ì¶œí•©ë‹ˆë‹¤.
     */
    registerCommands() {
        console.log('ê²½ê³ : ModelManager.registerCommands()ëŠ” ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. CommandManagerë¥¼ ì‚¬ìš©í•˜ì„¸ìš”.');
        // ì•„ë¬´ ë™ìž‘ë„ í•˜ì§€ ì•ŠìŒ
        /* ì›ëž˜ ì½”ë“œ (ì°¸ì¡°ìš©)
        // ì´ ë©”ì„œë“œì˜ ì›ëž˜ êµ¬í˜„ì€ CommandManagerë¡œ ì´ë™ë˜ì—ˆìŠµë‹ˆë‹¤.
        /*
        // selectModel ëª…ë ¹ ë“±ë¡
        const selectModelDisposable = vscode.commands.registerCommand('ape.selectModel', async () => {
          try {
            // í˜„ìž¬ í™œì„± ëª¨ë¸
            const activeModel = this.getActiveModel();
            
            // ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë¸ ëª©ë¡
            const availableModels = this.getAvailableModels();
            
            // ëª¨ë¸ ì„ íƒ í•­ëª© ìƒì„±
            const modelItems = availableModels.map(model => ({
              label: this.getModelDisplayName(model),
              description: model === activeModel ? '(í™œì„±)' : '',
              detail: this.getModelDescription(model),
              model: model
            }));
            
            // ì‚¬ìš©ìžì—ê²Œ ëª¨ë¸ ì„ íƒ í‘œì‹œ
            const selectedModel = await vscode.window.showQuickPick(modelItems, {
              placeHolder: 'ì‚¬ìš©í•  ëª¨ë¸ ì„ íƒ',
              title: 'APE ëª¨ë¸ ì„ íƒ'
            });
            
            // ëª¨ë¸ ì„ íƒë¨
            if (selectedModel) {
              // ì„ íƒí•œ ëª¨ë¸ë¡œ ì „í™˜
              const success = await this.setActiveModel(selectedModel.model);
              
              // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
              if (success) {
                vscode.window.showInformationMessage(`${selectedModel.label} ëª¨ë¸ë¡œ ì „í™˜í–ˆìŠµë‹ˆë‹¤`);
              }
            }
          } catch (error) {
            console.error('ëª¨ë¸ ì„ íƒ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜:', error);
            vscode.window.showErrorMessage(`ëª¨ë¸ ì„ íƒ ì˜¤ë¥˜: ${error instanceof Error ? error.message : String(error)}`);
          }
        });
        
        // switchModel ëª…ë ¹ ë“±ë¡
        const switchModelDisposable = vscode.commands.registerCommand('ape.switchModel', async (modelName: string) => {
          try {
            // ëª¨ë¸ ì „í™˜
            const success = await this.setActiveModel(modelName as LLMModel);
            
            // ì„±ê³µ ë©”ì‹œì§€ í‘œì‹œ
            if (success) {
              vscode.window.showInformationMessage(`${this.getModelDisplayName(modelName)} ëª¨ë¸ë¡œ ì „í™˜í–ˆìŠµë‹ˆë‹¤`);
            }
          } catch (error) {
            console.error('ëª¨ë¸ ì „í™˜ ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜:', error);
            vscode.window.showErrorMessage(`ëª¨ë¸ ì „í™˜ ì˜¤ë¥˜: ${error instanceof Error ? error.message : String(error)}`);
          }
        });
        
        // ì»¨í…ìŠ¤íŠ¸ êµ¬ë…ì— ëª…ë ¹ ì¶”ê°€
        this._context.subscriptions.push(selectModelDisposable, switchModelDisposable);
        */
    }
    /**
     * ëª¨ë¸ IDë¥¼ í‘œì‹œ ì´ë¦„ìœ¼ë¡œ ë³€í™˜
     * @param modelId ëª¨ë¸ ID
     * @returns ì‚¬ìš©ìž ì¹œí™”ì ì¸ ëª¨ë¸ í‘œì‹œ ì´ë¦„
     */
    getModelDisplayName(modelId) {
        // ëª¨ë¸ IDë¥¼ í‘œì‹œ ì´ë¦„ìœ¼ë¡œ ë³€í™˜
        switch (modelId) {
            case 'openai/gpt-4.1-mini':
                return 'GPT-4.1 Mini';
            case 'anthropic/claude-3-haiku-20240307':
                return 'Claude 3 Haiku';
            case 'anthropic/claude-3-sonnet-20240229':
                return 'Claude 3 Sonnet';
            case 'perplexity/sonar-small-online':
                return 'Perplexity Sonar';
            case 'mistralai/mistral-large-latest':
                return 'Mistral Large';
            case 'google/gemma-7b-it':
                return 'Gemma 7B';
            case 'NARRNAS':
                return 'NARRNAS';
            case 'LLAMA4-MAVERICK':
                return 'Llama 4 Maverick';
            case 'LLAMA4-SCOUT':
                return 'Llama 4 Scout';
            default: {
                // 'provider/model-name' í˜•ì‹ì—ì„œ ì´ë¦„ ì¶”ì¶œ
                const parts = modelId.split('/');
                if (parts.length > 1) {
                    // ë” ì½ê¸° ì‰¬ìš´ í˜•ì‹ìœ¼ë¡œ ëª¨ë¸ ì´ë¦„ ë³€í™˜
                    const modelName = parts[1].replace(/-/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
                    return modelName;
                }
                return modelId;
            }
        }
    }
    /**
     * ëª¨ë¸ì— ëŒ€í•œ ì„¤ëª… ê°€ì ¸ì˜¤ê¸°
     * @param model ëª¨ë¸ ì´ë¦„
     * @returns ëª¨ë¸ ì„¤ëª…
     */
    getModelDescription(model) {
        switch (model) {
            case 'openai/gpt-4.1-mini':
                return 'ê· í˜• ìž¡ížŒ ì„±ëŠ¥ê³¼ ì†ë„ (ê¸°ë³¸ ëª¨ë¸)';
            case 'anthropic/claude-3-haiku-20240307':
                return 'ë¹ ë¥¸ ì‘ë‹µì´ í•„ìš”í•œ ìž‘ì—…ì— ìµœì í™”';
            case 'anthropic/claude-3-sonnet-20240229':
                return 'ë†’ì€ í’ˆì§ˆê³¼ íš¨ìœ¨ì ì¸ ì„±ëŠ¥ì˜ ê· í˜•';
            case 'anthropic/claude-3-opus-20240229':
                return 'ìµœê³  ìˆ˜ì¤€ì˜ ì¶”ë¡  ë° ë³µìž¡í•œ ìž‘ì—… ì²˜ë¦¬';
            case 'google/gemini-pro':
                return 'Googleì˜ ê³ ê¸‰ ë©€í‹°ëª¨ë‹¬ ëª¨ë¸';
            case 'google/gemma-7b-it':
                return 'ê²½ëŸ‰ ì˜¤í”ˆì†ŒìŠ¤ ëª¨ë¸, ë‚®ì€ ì§€ì—° ì‹œê°„';
            case 'NARRNAS':
                return 'ë²”ìš© ëª¨ë¸ (ë‚´ë¶€ í…ŒìŠ¤íŠ¸ìš©)';
            case 'LLAMA4-MAVERICK':
                return 'ì½”ë“œ ìƒì„± ë° ë””ë²„ê¹… íŠ¹í™” (ë‚´ë¶€ í…ŒìŠ¤íŠ¸ìš©)';
            case 'LLAMA4-SCOUT':
                return 'ì½”ë“œ ë¶„ì„ ë° ì´í•´ ìµœì í™” (ë‚´ë¶€ í…ŒìŠ¤íŠ¸ìš©)';
            default:
                return '';
        }
    }
    /**
     * ë¦¬ì†ŒìŠ¤ í•´ì œ
     */
    dispose() {
        // ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ í•´ì œ
        this._onDidChangeModel.dispose();
        // ì„¤ì • ë³€ê²½ ë¦¬ìŠ¤ë„ˆ í•´ì œ
        this._configListener.dispose();
    }
}

;// ./src/ui/chat/codeService.ts
/**
 * ì½”ë“œ ì„œë¹„ìŠ¤
 *
 * ì½”ë“œ ë¸”ë¡ UI ë° ìƒí˜¸ ìž‘ìš© ê¸°ëŠ¥, ì½”ë“œ ì‚½ìž… ê¸°ëŠ¥ì„ í†µí•© ì œê³µ
 */



/**
 * í†µí•©ëœ ì½”ë“œ ì„œë¹„ìŠ¤ í´ëž˜ìŠ¤
 */
class CodeService {
    static codeBlockCounter = 0;
    /**
     * ì›¹ë·°ì—ì„œ ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ë“±ë¡
     * @param context í™•ìž¥ ì»¨í…ìŠ¤íŠ¸
     * @param webview ì›¹ë·°
     */
    static async registerHandlers(context, webview) {
        console.log('CodeService.registerHandlers called');
        // ì½”ë“œ ë¸”ë¡ ê´€ë ¨ ëª…ë ¹ ë“±ë¡ (ë¹„ë™ê¸° í•¨ìˆ˜ë¡œ ë³€ê²½ë¨)
        await this.registerCommands(context);
        // ì›¹ë·° ë©”ì‹œì§€ í•¸ë“¤ëŸ¬ ë“±ë¡
        webview.onDidReceiveMessage(async (message) => {
            switch (message.type) {
                case 'copyCode': {
                    await this.handleCopyCode(message.code);
                    break;
                }
                case 'insertCodeToEditor': {
                    await this.handleInsertCode(message);
                    break;
                }
                case 'createFileWithCode': {
                    await this.handleCreateFile(message);
                    break;
                }
                case 'attachFile': {
                    await this.handleAttachFile(webview);
                    break;
                }
            }
        }, undefined, context.subscriptions);
    }
    /**
     * ì½”ë“œ ë³µì‚¬ ì²˜ë¦¬
     * @param code ë³µì‚¬í•  ì½”ë“œ
     */
    static async handleCopyCode(code) {
        try {
            await external_vscode_.env.clipboard.writeText(code);
            external_vscode_.window.showInformationMessage('ì½”ë“œê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤.');
        }
        catch (error) {
            console.error('ì½”ë“œ ë³µì‚¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            external_vscode_.window.showErrorMessage('ì½”ë“œ ë³µì‚¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    }
    /**
     * ì½”ë“œ ì‚½ìž… ì²˜ë¦¬
     * @param message ë©”ì‹œì§€ ê°ì²´
     */
    static async handleInsertCode(message) {
        try {
            const options = {
                code: message.code,
                language: message.language || 'plaintext',
                insertAtCursor: message.insertAtCursor,
                replaceSelection: message.replaceSelection,
                createNewFile: message.createNewFile,
                filename: message.filename
            };
            const result = await external_vscode_.commands.executeCommand('ape.insertCodeToEditor', options);
            if (!result) {
                external_vscode_.window.showErrorMessage('ì½”ë“œë¥¼ ì—ë””í„°ì— ì‚½ìž…í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
            }
        }
        catch (error) {
            console.error('ì½”ë“œ ì‚½ìž… ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            external_vscode_.window.showErrorMessage('ì½”ë“œ ì‚½ìž… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    }
    /**
     * ìƒˆ íŒŒì¼ ìƒì„± ì²˜ë¦¬
     * @param message ë©”ì‹œì§€ ê°ì²´
     */
    static async handleCreateFile(message) {
        try {
            const options = {
                code: message.code,
                language: message.language || 'plaintext',
                createNewFile: true,
                filename: message.filename
            };
            const result = await external_vscode_.commands.executeCommand('ape.createNewFileWithCode', options);
            if (!result) {
                external_vscode_.window.showErrorMessage('ìƒˆ íŒŒì¼ì„ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.');
            }
        }
        catch (error) {
            console.error('íŒŒì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            external_vscode_.window.showErrorMessage('íŒŒì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    }
    /**
     * íŒŒì¼ ì²¨ë¶€ ì²˜ë¦¬
     * @param webview ì›¹ë·°
     */
    static async handleAttachFile(webview) {
        try {
            // VSCodeì˜ íŒŒì¼ ì„ íƒ ëŒ€í™”ìƒìž í‘œì‹œ
            const fileUris = await external_vscode_.window.showOpenDialog({
                canSelectFiles: true,
                canSelectFolders: false,
                canSelectMany: false,
                openLabel: 'ì²¨ë¶€',
                filters: {
                    'All Files': ['*']
                }
            });
            if (!fileUris || fileUris.length === 0) {
                return; // ì‚¬ìš©ìžê°€ ì·¨ì†Œí•¨
            }
            const fileUri = fileUris[0];
            const fileName = external_path_.basename(fileUri.fsPath);
            const fileExtension = external_path_.extname(fileUri.fsPath).toLowerCase();
            let fileContent = '';
            // íŒŒì¼ í¬ê¸° í™•ì¸ (í° íŒŒì¼ì€ ë‚´ìš© ë¡œë“œí•˜ì§€ ì•ŠìŒ)
            const stat = await external_vscode_.workspace.fs.stat(fileUri);
            const fileSize = stat.size;
            const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB
            // ìž‘ì€ íŒŒì¼ì¸ ê²½ìš° ë‚´ìš© ë¡œë“œ
            if (fileSize <= MAX_FILE_SIZE) {
                try {
                    const buffer = await external_vscode_.workspace.fs.readFile(fileUri);
                    fileContent = new TextDecoder().decode(buffer);
                }
                catch (error) {
                    console.log('í…ìŠ¤íŠ¸ íŒŒì¼ì´ ì•„ë‹Œ ê²ƒìœ¼ë¡œ ì¶”ì •ë©ë‹ˆë‹¤:', error);
                    // í…ìŠ¤íŠ¸ê°€ ì•„ë‹Œ íŒŒì¼ì€ ë‚´ìš© ë¡œë“œí•˜ì§€ ì•ŠìŒ
                }
            }
            // ìƒëŒ€ ê²½ë¡œ êµ¬í•˜ê¸°
            let relativePath = fileUri.fsPath;
            if (external_vscode_.workspace.workspaceFolders?.length) {
                const workspaceFolder = external_vscode_.workspace.workspaceFolders[0];
                const workspacePath = workspaceFolder.uri.fsPath;
                if (fileUri.fsPath.startsWith(workspacePath)) {
                    relativePath = fileUri.fsPath.substring(workspacePath.length + 1);
                }
            }
            // íŒŒì¼ ì •ë³´ ì›¹ë·°ë¡œ ì „ì†¡
            webview.postMessage({
                type: 'fileAttached',
                file: {
                    path: fileUri.fsPath,
                    relativePath: relativePath,
                    name: fileName,
                    type: fileExtension,
                    size: fileSize,
                    content: fileContent,
                    hasContent: fileContent.length > 0
                }
            });
            external_vscode_.window.showInformationMessage(`${fileName} íŒŒì¼ì´ ì²¨ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }
        catch (error) {
            console.error('íŒŒì¼ ì²¨ë¶€ ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            external_vscode_.window.showErrorMessage(`íŒŒì¼ ì²¨ë¶€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * ì½”ë“œ ë¸”ë¡ CSS ìŠ¤íƒ€ì¼ ë¡œë“œ
     * @param webview ì›¹ë·°
     * @param context í™•ìž¥ ì»¨í…ìŠ¤íŠ¸
     * @returns CSS URI
     */
    static getCodeBlockStyleUri(webview, context) {
        return webview.asWebviewUri(external_vscode_.Uri.joinPath(context.extensionUri, 'media', 'code-block.css'));
    }
    /**
     * ì½”ë“œ ë¸”ë¡ ìŠ¤í¬ë¦½íŠ¸ ìƒì„±
     * @returns JavaScript ì½”ë“œ
     */
    static getCodeBlockScript() {
        return `
    // ì½”ë“œ ë¸”ë¡ ê´€ë ¨ ê¸°ëŠ¥
    (function() {
      document.addEventListener('click', function(event) {
        const target = event.target;
        
        // ë³µì‚¬ ë²„íŠ¼ í´ë¦­ (ë²„íŠ¼ ë˜ëŠ” ë²„íŠ¼ ë‚´ë¶€ ì•„ì´ì½˜)
        const copyButton = target.closest('.code-action-button.copy-button');
        if (copyButton) {
          const codeId = copyButton.getAttribute('data-code-id');
          const codeElement = document.getElementById('code-' + codeId);
          
          if (codeElement) {
            const code = codeElement.textContent;
            
            // VS Codeì— ë³µì‚¬ ìš”ì²­ ì „ì†¡
            vscode.postMessage({
              type: 'copyCode',
              code: code,
              language: codeElement.className.replace('language-', '')
            });
            
            // ë³µì‚¬ ì„±ê³µ ì‹œê°ì  í”¼ë“œë°±
            const codeBlock = copyButton.closest('.code-block-container');
            codeBlock.classList.add('success-animation');
            setTimeout(() => {
              codeBlock.classList.remove('success-animation');
            }, 1000);
          }
          
          event.preventDefault();
          return;
        }
        
        // ì—ë””í„°ì— ì‚½ìž… ë²„íŠ¼ í´ë¦­
        const insertButton = target.closest('.code-action-button.insert-code-button');
        if (insertButton) {
          const codeId = insertButton.getAttribute('data-code-id');
          const codeElement = document.getElementById('code-' + codeId);
          
          if (codeElement) {
            const code = codeElement.textContent;
            const language = codeElement.className.replace('language-', '');
            
            // VS Codeì— ì‚½ìž… ìš”ì²­ ì „ì†¡
            vscode.postMessage({
              type: 'insertCodeToEditor',
              code: code,
              language: language,
              insertAtCursor: true
            });
          }
          
          event.preventDefault();
          return;
        }
        
        // ìƒˆ íŒŒì¼ ìƒì„± ë²„íŠ¼ í´ë¦­
        const newFileButton = target.closest('.code-action-button.new-file-button');
        if (newFileButton) {
          const codeId = newFileButton.getAttribute('data-code-id');
          const codeElement = document.getElementById('code-' + codeId);
          
          if (codeElement) {
            const code = codeElement.textContent;
            const language = codeElement.className.replace('language-', '');
            
            // VS Codeì— ìƒˆ íŒŒì¼ ìƒì„± ìš”ì²­ ì „ì†¡
            vscode.postMessage({
              type: 'createFileWithCode',
              code: code,
              language: language
            });
          }
          
          event.preventDefault();
          return;
        }
      });
      
      // ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì¸ ì½”ë“œ ë¸”ë¡ í‘œì‹œ
      function markStreamingCodeBlock(id, isStreaming) {
        const codeBlock = document.getElementById('code-' + id)?.closest('.code-block-container');
        if (codeBlock) {
          if (isStreaming) {
            codeBlock.classList.add('streaming-code-block');
          } else {
            codeBlock.classList.remove('streaming-code-block');
          }
        }
      }
      
      // ìŠ¤íŠ¸ë¦¬ë° ì‹œìž‘/ì¢…ë£Œ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë‹
      window.addEventListener('message', (event) => {
        const message = event.data;
        if (message.type === 'streamingCodeStart') {
          markStreamingCodeBlock(message.codeId, true);
        } 
        else if (message.type === 'streamingCodeEnd') {
          markStreamingCodeBlock(message.codeId, false);
        }
      });
    })();
    `;
    }
    /**
     * ì½”ë“œ ë¸”ë¡ í…œí”Œë¦¿ ê°€ì ¸ì˜¤ê¸°
     */
    static async getCodeBlockTemplate() {
        const extensionPath = external_vscode_.extensions.getExtension('ape.ape-extension')?.extensionPath;
        if (!extensionPath) {
            console.error('í™•ìž¥ í”„ë¡œê·¸ëž¨ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
            return this.getDefaultCodeBlockTemplate();
        }
        const templatePath = external_path_.join(extensionPath, 'src', 'data', 'codeBlockTemplate.html');
        try {
            return await external_fs_.promises.readFile(templatePath, 'utf-8');
        }
        catch (error) {
            console.error('ì½”ë“œ ë¸”ë¡ í…œí”Œë¦¿ì„ ë¡œë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤:', error);
            return this.getDefaultCodeBlockTemplate();
        }
    }
    /**
     * ê¸°ë³¸ ì½”ë“œ ë¸”ë¡ í…œí”Œë¦¿ ë°˜í™˜
     */
    static getDefaultCodeBlockTemplate() {
        return '<div class="code-block-container code-block-popup">\n' +
            '  <div class="code-block-header">\n' +
            '    <span class="code-block-language language-${language}">${language}</span>\n' +
            '    <div class="code-block-actions">\n' +
            '      <button class="code-action-button copy-button" data-code-id="${codeId}" title="ë³µì‚¬">\n' +
            '        <i class="codicon codicon-copy"></i>\n' +
            '        <span class="tooltip">í´ë¦½ë³´ë“œì— ë³µì‚¬</span>\n' +
            '      </button>\n' +
            '      <button class="code-action-button insert-code-button" data-code-id="${codeId}" title="ì—ë””í„°ì— ì‚½ìž…">\n' +
            '        <i class="codicon codicon-arrow-small-right"></i>\n' +
            '        <span class="tooltip">í˜„ìž¬ íŒŒì¼ì— ë³µì‚¬</span>\n' +
            '      </button>\n' +
            '      <button class="code-action-button new-file-button" data-code-id="${codeId}" title="ìƒˆ íŒŒì¼ë¡œ ìƒì„±">\n' +
            '        <i class="codicon codicon-new-file"></i>\n' +
            '        <span class="tooltip">ìƒˆ íŒŒì¼ë¡œ ìƒì„±</span>\n' +
            '      </button>\n' +
            '    </div>\n' +
            '  </div>\n' +
            '  <div class="code-content ${showLineNumbers ? \'with-line-numbers\' : \'\'}">\n' +
            '    ${showLineNumbers ? \'<div class="line-numbers">${lineNumbers}</div>\' : \'\'}\n' +
            '    <div class="code-area">\n' +
            '      <code class="language-${language}" id="code-${codeId}">${codeContent}</code>\n' +
            '    </div>\n' +
            '  </div>\n' +
            '</div>';
    }
    /**
     * ì½”ë“œë¥¼ í˜„ìž¬ ì—´ë ¤ìžˆëŠ” íŒŒì¼ì— ì‚½ìž…
     * @param options ì½”ë“œ ì‚½ìž… ì˜µì…˜
     * @returns ì„±ê³µ ì—¬ë¶€
     */
    static async insertCodeToEditor(options) {
        try {
            const { code, replaceSelection, insertAtCursor, createNewFile, filename } = options;
            // ìƒˆ íŒŒì¼ ìƒì„± ì˜µì…˜ì´ ìžˆëŠ” ê²½ìš°
            if (createNewFile) {
                return await this.createNewFileWithCode(code, options.language, filename);
            }
            // í˜„ìž¬ í™œì„±í™”ëœ ì—ë””í„° ê°€ì ¸ì˜¤ê¸°
            const editor = external_vscode_.window.activeTextEditor;
            if (!editor) {
                // í™œì„±í™”ëœ ì—ë””í„°ê°€ ì—†ëŠ” ê²½ìš°, ìƒˆ íŒŒì¼ ìƒì„± ì œì•ˆ
                const createNewFile = await external_vscode_.window.showInformationMessage('ì—´ë¦° íŽ¸ì§‘ê¸°ê°€ ì—†ìŠµë‹ˆë‹¤. ìƒˆ íŒŒì¼ì„ ìƒì„±í• ê¹Œìš”?', 'ìƒˆ íŒŒì¼ ìƒì„±', 'ì·¨ì†Œ');
                if (createNewFile === 'ìƒˆ íŒŒì¼ ìƒì„±') {
                    return await this.createNewFileWithCode(code, options.language);
                }
                return false;
            }
            // í˜„ìž¬ ì„ íƒ ì˜ì—­ ê°€ì ¸ì˜¤ê¸°
            const selection = editor.selection;
            // ì—ë””í„°ì— ì½”ë“œ ì‚½ìž…
            await editor.edit(editBuilder => {
                if (replaceSelection && !selection.isEmpty) {
                    // ì„ íƒ ì˜ì—­ ëŒ€ì²´
                    editBuilder.replace(selection, code);
                }
                else if (insertAtCursor) {
                    // ì»¤ì„œ ìœ„ì¹˜ì— ì‚½ìž…
                    editBuilder.insert(selection.active, code);
                }
                else {
                    // ì„ íƒ ì˜ì—­ì´ ì—†ëŠ” ê²½ìš° ì»¤ì„œ ìœ„ì¹˜ì— ì‚½ìž…
                    editBuilder.insert(selection.active, code);
                }
            });
            // ì‚½ìž…ëœ ì½”ë“œ í¬ë§·íŒ… (ì–¸ì–´ì— ë”°ë¼ ë‹¤ë¥¼ ìˆ˜ ìžˆìŒ)
            try {
                await external_vscode_.commands.executeCommand('editor.action.formatDocument');
            }
            catch (error) {
                console.log('ì½”ë“œ í¬ë§·íŒ… ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
                // í¬ë§·íŒ… ì‹¤íŒ¨ëŠ” ë¬´ì‹œ (ëª¨ë“  ì–¸ì–´ê°€ í¬ë§·í„°ë¥¼ ì§€ì›í•˜ì§€ëŠ” ì•ŠìŒ)
            }
            return true;
        }
        catch (error) {
            console.error('ì½”ë“œ ì‚½ìž… ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            external_vscode_.window.showErrorMessage(`ì½”ë“œ ì‚½ìž… ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
            return false;
        }
    }
    /**
     * ì½”ë“œë¡œ ìƒˆ íŒŒì¼ ìƒì„±
     * @param code ì½”ë“œ ë‚´ìš©
     * @param language ì–¸ì–´
     * @param suggestedFilename ì œì•ˆ íŒŒì¼ëª…
     * @returns ì„±ê³µ ì—¬ë¶€
     */
    static async createNewFileWithCode(code, language, suggestedFilename) {
        try {
            // íŒŒì¼ í™•ìž¥ìž ì¶”ë¡ 
            const extension = this.getFileExtensionForLanguage(language);
            const filename = suggestedFilename || `new_file${extension}`;
            // ìƒˆ íŒŒì¼ ìƒì„±
            const document = await external_vscode_.workspace.openTextDocument({
                language: language,
                content: code
            });
            await external_vscode_.window.showTextDocument(document);
            // íŒŒì¼ì„ ì‹¤ì œë¡œ ì €ìž¥í• ì§€ ë¬¼ì–´ë³´ê¸°
            const saveFile = await external_vscode_.window.showInformationMessage('ìƒˆ íŒŒì¼ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤. ì €ìž¥í•˜ì‹œê² ìŠµë‹ˆê¹Œ?', 'ì €ìž¥', 'ë‚˜ì¤‘ì—');
            if (saveFile === 'ì €ìž¥') {
                if (document.isDirty) {
                    const uri = await external_vscode_.window.showSaveDialog({
                        defaultUri: external_vscode_.Uri.file(filename),
                        filters: {
                            'ëª¨ë“  íŒŒì¼': ['*']
                        }
                    });
                    if (uri) {
                        await external_vscode_.workspace.fs.writeFile(uri, Buffer.from(code));
                        external_vscode_.window.showInformationMessage(`íŒŒì¼ì´ ì €ìž¥ë˜ì—ˆìŠµë‹ˆë‹¤: ${uri.fsPath}`);
                    }
                }
            }
            return true;
        }
        catch (error) {
            console.error('ìƒˆ íŒŒì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ:', error);
            external_vscode_.window.showErrorMessage(`ìƒˆ íŒŒì¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
            return false;
        }
    }
    /**
     * ì–¸ì–´ IDë¡œ íŒŒì¼ í™•ìž¥ìž ì¶”ë¡ 
     * @param language ì–¸ì–´ ID
     * @returns íŒŒì¼ í™•ìž¥ìž
     */
    static getFileExtensionForLanguage(language) {
        const languageToExtension = {
            'typescript': '.ts',
            'javascript': '.js',
            'python': '.py',
            'java': '.java',
            'csharp': '.cs',
            'c': '.c',
            'cpp': '.cpp',
            'go': '.go',
            'rust': '.rs',
            'php': '.php',
            'ruby': '.rb',
            'html': '.html',
            'css': '.css',
            'json': '.json',
            'markdown': '.md',
            'plaintext': '.txt',
            'xml': '.xml',
            'yaml': '.yml',
            'shell': '.sh',
            'bash': '.sh',
            'powershell': '.ps1',
            'sql': '.sql'
        };
        return languageToExtension[language] || '.txt';
    }
    /**
     * ì½”ë“œ ì‚½ìž… ì „ ìœ„ì¹˜ ì„ íƒ ëŒ€í™”ìƒìž í‘œì‹œ
     * @returns ì‚½ìž… ì˜µì…˜
     */
    static async promptForInsertionMode() {
        const options = await external_vscode_.window.showQuickPick([
            {
                label: '$(cursor) ì»¤ì„œ ìœ„ì¹˜ì— ì‚½ìž…',
                description: 'í˜„ìž¬ ì»¤ì„œ ìœ„ì¹˜ì— ì½”ë“œë¥¼ ì‚½ìž…í•©ë‹ˆë‹¤.',
                detail: 'ê¸°ì¡´ í…ìŠ¤íŠ¸ëŠ” ê·¸ëŒ€ë¡œ ìœ ì§€ë©ë‹ˆë‹¤.',
                value: 'insert'
            },
            {
                label: '$(edit) ì„ íƒ ì˜ì—­ ëŒ€ì²´',
                description: 'í˜„ìž¬ ì„ íƒ ì˜ì—­ì„ ì½”ë“œë¡œ ëŒ€ì²´í•©ë‹ˆë‹¤.',
                detail: 'ì„ íƒ ì˜ì—­ì´ ì—†ìœ¼ë©´ ì»¤ì„œ ìœ„ì¹˜ì— ì‚½ìž…í•©ë‹ˆë‹¤.',
                value: 'replace'
            },
            {
                label: '$(new-file) ìƒˆ íŒŒì¼ ìƒì„±',
                description: 'ì½”ë“œë¡œ ìƒˆ íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤.',
                detail: 'ì—ë””í„°ì—ì„œ ìƒˆ íŒŒì¼ì„ ì—´ê³  ì½”ë“œë¥¼ ì‚½ìž…í•©ë‹ˆë‹¤.',
                value: 'new'
            }
        ], {
            placeHolder: 'ì½”ë“œ ì‚½ìž… ë°©ì‹ì„ ì„ íƒí•˜ì„¸ìš”',
            matchOnDescription: true,
            matchOnDetail: true
        });
        if (!options) {
            return undefined; // ì‚¬ìš©ìžê°€ ì·¨ì†Œí•¨
        }
        switch (options.value) {
            case 'insert': {
                return { insertAtCursor: true };
            }
            case 'replace': {
                return { replaceSelection: true };
            }
            case 'new': {
                return { createNewFile: true };
            }
        }
        return undefined;
    }
    /**
     * ì½”ë“œ ì‚½ìž… ëª…ë ¹ ë“±ë¡
     * @param context í™•ìž¥ ì»¨í…ìŠ¤íŠ¸
     */
    static async registerCommands(context) {
        // ëª…ë ¹ì–´ ë“±ë¡ ì „ì— ì´ë¯¸ ë“±ë¡ë˜ì–´ ìžˆëŠ”ì§€ í™•ì¸
        const existingCommands = await external_vscode_.commands.getCommands();
        // ì½”ë“œ ì‚½ìž… ëª…ë ¹ ë“±ë¡ (ì¤‘ë³µ ë°©ì§€)
        if (!existingCommands.includes('ape.insertCodeToEditor')) {
            context.subscriptions.push(external_vscode_.commands.registerCommand('ape.insertCodeToEditor', async (options) => {
                const insertionOptions = await this.promptForInsertionMode();
                if (!insertionOptions) {
                    return false;
                }
                return await this.insertCodeToEditor({
                    ...options,
                    ...insertionOptions
                });
            }));
        }
        // ëª…ë ¹ ë°”ë¡œ ì‹¤í–‰ (ì˜µì…˜ ì„ íƒ ì—†ì´)
        if (!existingCommands.includes('ape.insertCodeAtCursor')) {
            context.subscriptions.push(external_vscode_.commands.registerCommand('ape.insertCodeAtCursor', async (options) => {
                return await this.insertCodeToEditor({
                    ...options,
                    insertAtCursor: true
                });
            }));
        }
        // ì„ íƒ ì˜ì—­ ëŒ€ì²´ ëª…ë ¹
        if (!existingCommands.includes('ape.replaceSelectionWithCode')) {
            context.subscriptions.push(external_vscode_.commands.registerCommand('ape.replaceSelectionWithCode', async (options) => {
                return await this.insertCodeToEditor({
                    ...options,
                    replaceSelection: true
                });
            }));
        }
        // ìƒˆ íŒŒì¼ ìƒì„± ëª…ë ¹
        if (!existingCommands.includes('ape.createNewFileWithCode')) {
            context.subscriptions.push(external_vscode_.commands.registerCommand('ape.createNewFileWithCode', async (options) => {
                return await this.insertCodeToEditor({
                    ...options,
                    createNewFile: true
                });
            }));
        }
        // íŒŒì¼ ì²¨ë¶€ ëª…ë ¹
        if (!existingCommands.includes('ape.attachFile')) {
            context.subscriptions.push(external_vscode_.commands.registerCommand('ape.attachFile', async () => {
                try {
                    // í˜„ìž¬ ì›¹ë·° ì°¾ê¸°
                    const activeViewColumn = external_vscode_.window.activeTextEditor?.viewColumn || external_vscode_.ViewColumn.One;
                    const panel = external_vscode_.window.visibleTextEditors
                        .find(editor => editor.viewColumn === activeViewColumn);
                    if (panel) {
                        // íŒŒì¼ ì„ íƒ ëŒ€í™”ìƒìž í‘œì‹œ
                        const fileUris = await external_vscode_.window.showOpenDialog({
                            canSelectFiles: true,
                            canSelectFolders: false,
                            canSelectMany: false,
                            openLabel: 'ì²¨ë¶€',
                            filters: {
                                'All Files': ['*']
                            }
                        });
                        if (fileUris && fileUris.length > 0) {
                            return fileUris[0].fsPath;
                        }
                    }
                    return null;
                }
                catch (error) {
                    console.error('íŒŒì¼ ì²¨ë¶€ ì¤‘ ì˜¤ë¥˜:', error);
                    external_vscode_.window.showErrorMessage(`íŒŒì¼ ì²¨ë¶€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error instanceof Error ? error.message : String(error)}`);
                    return null;
                }
            }));
        }
    }
    /**
     * ì½”ë“œ ë¸”ë¡ UI ìƒì„±
     * @param codeContent ì½”ë“œ ë‚´ìš©
     * @param language ì–¸ì–´
     * @param showLineNumbers ë¼ì¸ ë²ˆí˜¸ í‘œì‹œ ì—¬ë¶€
     * @returns í¬ë§·íŒ…ëœ HTML
     */
    static formatCodeBlock(codeContent, language = 'plaintext', showLineNumbers = true) {
        const codeId = `code_${++this.codeBlockCounter}`;
        const escapedCode = this.escapeHtml(codeContent);
        // ë¼ì¸ ë²ˆí˜¸ ìƒì„±
        const lineNumbers = showLineNumbers ?
            codeContent.split('\n').map((_, i) => `${i + 1}`).join('\n') : '';
        // ì½”ë“œ ë¸”ë¡ í…œí”Œë¦¿ ì‚¬ìš©
        const template = `<div class="code-block-container code-block-popup">
  <div class="code-block-header">
    <span class="code-block-language language-${language}">${language}</span>
    <div class="code-block-actions">
      <button class="code-action-button copy-button" data-code-id="${codeId}" title="ë³µì‚¬">
        <i class="codicon codicon-copy"></i>
        <span class="tooltip">í´ë¦½ë³´ë“œì— ë³µì‚¬</span>
      </button>
      <button class="code-action-button insert-code-button" data-code-id="${codeId}" title="ì—ë””í„°ì— ì‚½ìž…">
        <i class="codicon codicon-arrow-small-right"></i>
        <span class="tooltip">í˜„ìž¬ íŒŒì¼ì— ë³µì‚¬</span>
      </button>
      <button class="code-action-button new-file-button" data-code-id="${codeId}" title="ìƒˆ íŒŒì¼ë¡œ ìƒì„±">
        <i class="codicon codicon-new-file"></i>
        <span class="tooltip">ìƒˆ íŒŒì¼ë¡œ ìƒì„±</span>
      </button>
    </div>
  </div>
  <div class="code-content ${showLineNumbers ? 'with-line-numbers' : ''}">
    ${showLineNumbers ? `<div class="line-numbers">${lineNumbers}</div>` : ''}
    <div class="code-area">
      <code class="language-${language}" id="code-${codeId}">${escapedCode}</code>
    </div>
  </div>
</div>`;
        return template;
    }
    /**
     * HTML ì´ìŠ¤ì¼€ì´í”„ ì²˜ë¦¬
     * @param unsafe ì´ìŠ¤ì¼€ì´í”„í•  ë¬¸ìžì—´
     * @returns ì´ìŠ¤ì¼€ì´í”„ëœ ë¬¸ìžì—´
     */
    static escapeHtml(unsafe) {
        return unsafe
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }
}

;// ./src/core/services/smartPromptingService.ts

/**
 * ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ëª¨ë“œ ì—´ê±°í˜•
 */
var SmartPromptingMode;
(function (SmartPromptingMode) {
    SmartPromptingMode["Basic"] = "basic";
    SmartPromptingMode["Advanced"] = "advanced";
    SmartPromptingMode["Expert"] = "expert"; // ì „ë¬¸ê°€ ëª¨ë“œ
})(SmartPromptingMode || (SmartPromptingMode = {}));
/**
 * ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ì„œë¹„ìŠ¤
 *
 * ë©”ì‹œì§€ ì²˜ë¦¬ ì „ì— í”„ë¡¬í”„íŠ¸ë¥¼ ì¦ê°•í•˜ì—¬ LLM ì‘ë‹µ í’ˆì§ˆì„ í–¥ìƒì‹œí‚µë‹ˆë‹¤.
 * Chain of Thought(CoT) ë° ë™ì  í”„ë¡¬í”„íŠ¸ ì–´ì…ˆë¸”ë§ì„ ì§€ì›í•©ë‹ˆë‹¤.
 */
class SmartPromptingService {
    context;
    llmService;
    state = {
        enabled: false,
        mode: SmartPromptingMode.Basic
    };
    stateChangeEmitter = new external_vscode_.EventEmitter();
    onStateChanged = this.stateChangeEmitter.event;
    /**
     * ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ì„œë¹„ìŠ¤ ìƒì„±ìž
     * @param context VSCode í™•ìž¥ ì»¨í…ìŠ¤íŠ¸
     * @param llmService LLM ì„œë¹„ìŠ¤
     */
    constructor(context, llmService) {
        this.context = context;
        this.llmService = llmService;
        // ì €ìž¥ëœ ìƒíƒœ ë³µì›
        this.restoreState();
        // ì»¨í…ìŠ¤íŠ¸ ì„œë¸ŒìŠ¤í¬ë¦½ì…˜ì— ì´ë²¤íŠ¸ ì—ë¯¸í„° ë“±ë¡
        this.context.subscriptions.push(this.stateChangeEmitter);
    }
    /**
     * ì €ìž¥ëœ ìƒíƒœ ë³µì›
     */
    restoreState() {
        const savedState = this.context.globalState.get('ape.smartPrompting.state');
        if (savedState) {
            this.state = savedState;
        }
    }
    /**
     * ìƒíƒœ ì €ìž¥
     */
    saveState() {
        this.context.globalState.update('ape.smartPrompting.state', this.state);
    }
    /**
     * ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… í™œì„±í™” ì—¬ë¶€ ë°˜í™˜
     */
    isEnabled() {
        return this.state.enabled;
    }
    /**
     * í˜„ìž¬ ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ëª¨ë“œ ë°˜í™˜
     */
    getMode() {
        return this.state.mode;
    }
    /**
     * í˜„ìž¬ ìƒíƒœ ë°˜í™˜
     */
    getState() {
        return { ...this.state };
    }
    /**
     * ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… í™œì„±í™”/ë¹„í™œì„±í™”
     * @param enabled í™œì„±í™” ì—¬ë¶€
     */
    setEnabled(enabled) {
        if (this.state.enabled !== enabled) {
            this.state.enabled = enabled;
            this.saveState();
            this.stateChangeEmitter.fire(this.getState());
        }
    }
    /**
     * ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ëª¨ë“œ ì„¤ì •
     * @param mode ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ëª¨ë“œ
     */
    setMode(mode) {
        if (this.state.mode !== mode) {
            this.state.mode = mode;
            this.saveState();
            this.stateChangeEmitter.fire(this.getState());
        }
    }
    /**
     * ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… í† ê¸€
     */
    toggle() {
        this.setEnabled(!this.state.enabled);
    }
    /**
     * ì‚¬ìš©ìž ë©”ì‹œì§€ë¥¼ ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ…ìœ¼ë¡œ ì²˜ë¦¬
     * @param message ì›ë³¸ ì‚¬ìš©ìž ë©”ì‹œì§€
     * @returns ì¦ê°•ëœ ë©”ì‹œì§€
     */
    processMessage(message) {
        if (!this.state.enabled) {
            return message;
        }
        // í˜„ìž¬ ëª¨ë“œì— ë”°ë¼ ë‹¤ë¥¸ í”„ë¡¬í”„íŒ… ì „ëžµ ì ìš©
        switch (this.state.mode) {
            case SmartPromptingMode.Basic:
                return this.applyBasicPrompting(message);
            case SmartPromptingMode.Advanced:
                return this.applyAdvancedPrompting(message);
            case SmartPromptingMode.Expert:
                return this.applyExpertPrompting(message);
            default:
                return message;
        }
    }
    /**
     * ê¸°ë³¸ ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ì ìš©
     * @param message ì›ë³¸ ë©”ì‹œì§€
     * @returns ì¦ê°•ëœ ë©”ì‹œì§€
     */
    applyBasicPrompting(message) {
        // ê¸°ë³¸ í”„ë¡¬í”„íŒ…: ëª…í™•í•œ ì§€ì‹œì™€ êµ¬ì¡°í™”ëœ ì‘ë‹µ ìš”ì²­ ì¶”ê°€
        return `${message}\n\në‹¹ì‹ ì˜ ì‘ë‹µì€ ëª…í™•í•˜ê³  êµ¬ì¡°í™”ëœ ë°©ì‹ìœ¼ë¡œ ì œê³µí•´ ì£¼ì„¸ìš”. í•„ìš”í•œ ê²½ìš° ë‹¨ê³„ë³„ ì ‘ê·¼ ë°©ì‹ì„ ì‚¬ìš©í•˜ê³ , ì½”ë“œ ì˜ˆì œì—ëŠ” ì£¼ì„ê³¼ ì„¤ëª…ì„ í¬í•¨í•´ ì£¼ì„¸ìš”.`;
    }
    /**
     * ê³ ê¸‰ ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ì ìš©
     * @param message ì›ë³¸ ë©”ì‹œì§€
     * @returns ì¦ê°•ëœ ë©”ì‹œì§€
     */
    applyAdvancedPrompting(message) {
        // ê³ ê¸‰ í”„ë¡¬í”„íŒ…: Chain of Thought ìœ ë„ ë° ë‹¤ê°ì  ë¶„ì„ ì¶”ê°€
        return `${message}\n\nì´ ë¬¸ì œì— ëŒ€í•´ ë‹¨ê³„ë³„ë¡œ ìƒê°í•´ ì£¼ì„¸ìš”. ë¨¼ì € ë¬¸ì œë¥¼ ë¶„ì„í•˜ê³ , ê°€ëŠ¥í•œ ì ‘ê·¼ ë°©ì‹ë“¤ì„ ê³ ë ¤í•œ í›„, ìµœì ì˜ ì†”ë£¨ì…˜ì„ ì„ íƒí•˜ì—¬ êµ¬í˜„í•´ ì£¼ì„¸ìš”. ì½”ë“œ ì˜ˆì œëŠ” íš¨ìœ¨ì„±, ê°€ë…ì„±, ìœ ì§€ë³´ìˆ˜ì„±ì„ ëª¨ë‘ ê³ ë ¤í•˜ì—¬ ìž‘ì„±í•´ ì£¼ì„¸ìš”. ëŒ€ì•ˆì  ì ‘ê·¼ ë°©ì‹ì´ ìžˆë‹¤ë©´ ìž¥ë‹¨ì ê³¼ í•¨ê»˜ ê°„ëžµížˆ ì–¸ê¸‰í•´ ì£¼ì„¸ìš”.`;
    }
    /**
     * ì „ë¬¸ê°€ ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ì ìš©
     * @param message ì›ë³¸ ë©”ì‹œì§€
     * @returns ì¦ê°•ëœ ë©”ì‹œì§€
     */
    applyExpertPrompting(message) {
        // ì „ë¬¸ê°€ í”„ë¡¬í”„íŒ…: ì‹¬ì¸µì  ë¶„ì„ê³¼ ì¢…í•©ì  ì ‘ê·¼ ìœ ë„
        return `${message}\n\nì´ ë¬¸ì œì— ëŒ€í•´ ì „ë¬¸ê°€ ìˆ˜ì¤€ì˜ ë¶„ì„ì„ ì œê³µí•´ ì£¼ì„¸ìš”. ë‹¤ìŒì˜ ì ‘ê·¼ ë°©ì‹ìœ¼ë¡œ ì§„í–‰í•´ ì£¼ì„¸ìš”:
    
1. ë¬¸ì œ ì •ì˜ ë° ìš”êµ¬ì‚¬í•­ ë¶„ì„
2. ê°€ëŠ¥í•œ í•´ê²°ì±…ê³¼ ì ‘ê·¼ ë°©ì‹ íƒìƒ‰ (ê°ê°ì˜ ìž¥ë‹¨ì  í¬í•¨)
3. ìµœì ì˜ ì ‘ê·¼ ë°©ì‹ ì„ íƒ ë° ê·¸ ì´ìœ  ì„¤ëª…
4. êµ¬í˜„ ì„¸ë¶€ì‚¬í•­ ë° ì½”ë“œ ì˜ˆì œ ì œì‹œ
5. ìž ìž¬ì  ë¦¬íŒ©í† ë§ ê¸°íšŒ ë° ìµœì í™” ë°©ì•ˆ ê³ ë ¤
6. ê²€ì¦ ë° í…ŒìŠ¤íŠ¸ ì „ëžµ ì œì•ˆ

ì½”ë“œ ì˜ˆì œëŠ” ìµœì‹  ëª¨ë²” ì‚¬ë¡€, íŒ¨í„´, íš¨ìœ¨ì ì¸ ì•Œê³ ë¦¬ì¦˜ì„ í™œìš©í•˜ê³ , ì˜ˆì™¸ ì²˜ë¦¬ ë° ì—£ì§€ ì¼€ì´ìŠ¤ë¥¼ ê³ ë ¤í•´ ì£¼ì„¸ìš”. í•„ìš”í•œ ê²½ìš° ì„±ëŠ¥, í™•ìž¥ì„± ë˜ëŠ” ìœ ì§€ë³´ìˆ˜ì„± ì¸¡ë©´ì˜ ì ˆì¶©ì ì„ ëª…ì‹œì ìœ¼ë¡œ ì–¸ê¸‰í•´ ì£¼ì„¸ìš”.`;
    }
    /**
     * ì„œë¹„ìŠ¤ ì •ë¦¬
     */
    dispose() {
        this.stateChangeEmitter.dispose();
    }
}

;// ./src/ui/welcomeView.ts

/**
 * WelcomeViewProvider for luxury minimal welcome screen
 * Creates an elegant, clean welcome interface with premium aesthetics
 */
class WelcomeViewProvider {
    /**
     * Generate welcome message HTML with luxury minimal design
     * This is used for the first-run experience and when clearing chat
     */
    static getWelcomeMessageHTML() {
        // The welcome view HTML with luxury minimal styling
        return `
      <div class="welcome-container">
        <div class="welcome-header">
          <div class="welcome-monologue">
  <h1 class="welcome-title">A.P.E</h1>
  <div class="title-separator"></div>
  <p class="welcome-tagline">AGENTIC PIPELINE ENGINE</p>
  <p class="welcome-subtitle">Agentic Vision. Development Illuminated. <br>
Seamless â€¢ Plugin-driven â€¢ Lightweight For S/W Engineers.</p>
</div>
        </div>
        
        <div class="welcome-actions">
          <div class="action-group">
            <div class="action-button">
              <div class="action-icon">âœ§</div>
              <div class="action-content">
                <div class="action-title">New Conversation</div>
                <div class="action-description">Begin a dialogue with your AI assistant</div>
              </div>
            </div>
          </div>

          <div class="action-group">
            <div class="action-button">
              <div class="action-icon">âœ¦</div>
              <div class="action-content">
                <div class="action-title">Code Assistant</div>
                <div class="action-description">Analyze, optimize, and improve your code</div>
              </div>
            </div>

            <div class="action-button">
              <div class="action-icon">âŸ</div>
              <div class="action-content">
                <div class="action-title">Development Tools</div>
                <div class="action-description">Test, debug, and implement new features</div>
              </div>
            </div>
          </div>
        </div>
        
        <div class="welcome-quick-actions">
          <button class="quick-action" onclick="vscode.postMessage({type: 'insertCommand', command: '/help'})">Help</button>
          <button class="quick-action" onclick="vscode.postMessage({type: 'insertCommand', command: '/model'})">Change Model</button>
          <button class="quick-action" onclick="vscode.postMessage({type: 'insertCommand', command: '/settings'})">Settings</button>
          <button class="quick-action" onclick="vscode.postMessage({type: 'insertCommand', command: '/clear'})">Reset Conversation</button>
        </div>
      </div>
    `;
    }
    /**
     * Create standalone webview panel with welcome content
     */
    static createOrShow(context) {
        const panel = external_vscode_.window.createWebviewPanel('apeWelcome', 'Welcome to APE', external_vscode_.ViewColumn.Active, // í˜„ìž¬ í™œì„±í™”ëœ ì—ë””í„° ì˜ì—­ì— í‘œì‹œ
        {
            enableScripts: true,
            localResourceRoots: [
                external_vscode_.Uri.joinPath(context.extensionUri, 'media')
            ],
            retainContextWhenHidden: true // ìˆ¨ê²¨ì§„ ìƒíƒœì—ì„œë„ ì»¨í…ìŠ¤íŠ¸ ìœ ì§€
        });
        // Get WebView stylesheets
        const styleUri = panel.webview.asWebviewUri(external_vscode_.Uri.joinPath(context.extensionUri, 'media', 'chat-ape.css'));
        // Set webview HTML with maximized welcome view
        panel.webview.html = `<!DOCTYPE html>
      <html lang="en">
      <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${panel.webview.cspSource} 'unsafe-inline'; font-src ${panel.webview.cspSource}; img-src ${panel.webview.cspSource} https:; script-src 'unsafe-inline';">
        <link href="${styleUri}" rel="stylesheet">
        <title>Welcome to APE</title>
        <style>
          body, html {
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
          }
          
          .welcome-standalone {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 0;
            width: 100%;
          }
          
          /* ë” í° í™”ë©´ì— ë§žì¶° ì›°ì»´ í™”ë©´ í¬ê¸° ìµœì í™” */
          .welcome-container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
          }
          
          /* ë” ë„“ì€ í™”ë©´ ê³µê°„ìœ¼ë¡œ ì•¡ì…˜ ë²„íŠ¼ ê·¸ë¦¬ë“œ ê°œì„  */
          .action-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 1.5rem;
          }
          
          .example-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 1.2rem;
          }
          
          /* ë” í° í™˜ì˜ í…ìŠ¤íŠ¸ */
          .welcome-title {
            font-size: 6rem;
          }
        </style>
      </head>
      <body>
        <div class="welcome-standalone">
          ${WelcomeViewProvider.getWelcomeMessageHTML()}
        </div>
        
        <script>
          const vscode = acquireVsCodeApi();
          
          document.querySelectorAll('.example-card').forEach(card => {
            card.addEventListener('click', event => {
              const command = card.querySelector('.example-text').textContent;
              vscode.postMessage({ type: 'command', command });
            });
          });
          
          // Quick actions are now handled via onclick attributes directly in HTML
          // This is more reliable than event delegation in this environment
          
          // Add subtle hover animations
          document.querySelectorAll('.example-card').forEach(element => {
            element.addEventListener('mouseover', () => {
              element.style.transform = 'translateY(-2px)';
              element.style.boxShadow = 'var(--ape-shadow-md)';
            });

            element.addEventListener('mouseout', () => {
              element.style.transform = '';
              element.style.boxShadow = '';
            });
          });

          document.querySelectorAll('.action-button').forEach(element => {
            element.addEventListener('mouseover', () => {
              element.style.transform = 'translateY(-2px)';
              element.style.boxShadow = 'var(--ape-shadow-md)';
            });

            element.addEventListener('mouseout', () => {
              element.style.transform = '';
              element.style.boxShadow = '';
            });
          });
          
          // ì›°ì»´ ë·°ê°€ ë¡œë“œëœ í›„ 1ì´ˆ í›„ì— ê°•ì¡° íš¨ê³¼
          setTimeout(() => {
            document.querySelector('.welcome-title').style.animation = 'pulse 2s infinite';
          }, 1000);
        </script>
      </body>
      </html>`;
        return panel;
    }
}

;// ./src/ui/mainChatViewProvider.ts





/**
 * MainChatViewProvider manages the primary chat interface WebView
 * with a clean, modern, and user-friendly design
 */
class MainChatViewProvider {
    _context;
    _llmService;
    _memoryService;
    _commandManager;
    _modelManager;
    static viewType = 'apeChat';
    _view;
    _messages = [];
    _isStreaming = false;
    _currentStreamMessageId = null;
    _streamUpdateTimeout = null;
    _modelChangeListener;
    _smartPromptingService;
    _smartPromptingStateListener;
    // Command suggestion event
    _onDidSuggestCommands = new external_vscode_.EventEmitter();
    onDidSuggestCommands = this._onDidSuggestCommands.event;
    constructor(_context, _llmService, _memoryService, _commandManager, _modelManager) {
        this._context = _context;
        this._llmService = _llmService;
        this._memoryService = _memoryService;
        this._commandManager = _commandManager;
        this._modelManager = _modelManager;
        // Initialize SmartPromptingService
        this._smartPromptingService = new SmartPromptingService(_context, _llmService);
        // Register state change listener
        this._smartPromptingStateListener = this._smartPromptingService.onStateChanged(state => {
            this._updateSmartPromptingUI(state);
        });
        // Add listener to context subscriptions for proper disposal
        this._context.subscriptions.push(this._smartPromptingStateListener);
    }
    /**
     * Converts a URI to a webview-compatible URI
     */
    getWebviewResource(uri) {
        if (!this._view) {
            return null;
        }
        return this._view.webview.asWebviewUri(uri);
    }
    /**
     * Called when the view is first created or becomes visible again
     */
    async resolveWebviewView(webviewView, _context, _token) {
        this._view = webviewView;
        // Set options for the webview
        webviewView.webview.options = {
            enableScripts: true,
            localResourceRoots: [
                external_vscode_.Uri.joinPath(this._context.extensionUri, 'media'),
                external_vscode_.Uri.joinPath(this._context.extensionUri, 'out'),
                external_vscode_.Uri.joinPath(this._context.extensionUri, 'src')
            ]
        };
        // Load previous messages from memory service
        await this.loadMessages();
        // Set initial HTML content
        webviewView.webview.html = this._getHtmlForWebview(webviewView.webview);
        // Handle messages from the webview
        webviewView.webview.onDidReceiveMessage(this._handleMessage.bind(this));
        // Register code service handlers
        try {
            await CodeService.registerHandlers(this._context, webviewView.webview);
        }
        catch (error) {
            console.log('Code service handlers may already be registered:', error);
        }
        // Listen for model changes if ModelManager is available
        if (this._modelManager) {
            // Dispose any existing listener
            if (this._modelChangeListener) {
                this._modelChangeListener.dispose();
            }
            // Register new listener
            this._modelChangeListener = this._modelManager.onDidChangeModel(() => {
                // Update the UI when model changes
                this.updateModelIndicator();
            });
            // Add listener to context for disposal
            this._context.subscriptions.push(this._modelChangeListener);
        }
    }
    /**
     * Updates the model indicator UI with the current model
     */
    updateModelIndicator() {
        if (!this._view) {
            console.log('Model indicator update failed: no webview');
            return;
        }
        try {
            // Use ModelManager if available, otherwise fall back to LLMService
            let currentModel, displayName;
            if (this._modelManager) {
                currentModel = this._modelManager.getActiveModel();
                displayName = this._modelManager.getModelDisplayName(currentModel);
                console.log('Using ModelManager to get current model info:', currentModel);
            }
            else {
                currentModel = this._llmService.getActiveModel();
                displayName = this.getModelDisplayName(currentModel);
                console.log('Using LLMService to get current model info:', currentModel);
            }
            // Send message to webview to update model name display
            this._view.webview.postMessage({
                type: 'updateModelIndicator',
                modelName: displayName
            });
            console.log('Model indicator update message sent to webview');
        }
        catch (error) {
            console.error('Error updating model indicator:', error);
        }
    }
    /**
     * Converts model ID to a user-friendly display name
     * @deprecated Use the ModelManager.getModelDisplayName method instead
     */
    getModelDisplayName(modelId) {
        return this._llmService.getModelDisplayName(modelId);
    }
    /**
     * ëžœë¤ ì¸ì‚¬ë§ ìƒì„± - ìœ ì € ì»¨í…ìŠ¤íŠ¸ì— ë§žëŠ” ì¸ì‚¬ë§ê³¼ íŒ ì œê³µ
     */
    getRandomGreeting() {
        try {
            // greetings.json íŒŒì¼ì—ì„œ ì¸ì‚¬ë§ ë°ì´í„° ë¶ˆëŸ¬ì˜¤ê¸°
            const greetingsUri = external_vscode_.Uri.joinPath(this._context.extensionUri, 'src', 'data', 'greetings.json');
            const greetingsPath = greetingsUri.fsPath;
            const greetingsFile = __webpack_require__(4286)(greetingsPath);
            // ë³€ê²½ëœ í¬ë§·ì˜ greetings.json íŒŒì¼ ì²˜ë¦¬
            if (greetingsFile.messages && Array.isArray(greetingsFile.messages) && greetingsFile.messages.length > 0) {
                // ë‹¨ìˆœ messages ë°°ì—´ì—ì„œ ëžœë¤ ë©”ì‹œì§€ ì„ íƒ
                return greetingsFile.messages[Math.floor(Math.random() * greetingsFile.messages.length)];
            }
            // ì´ì „ í¬ë§·ì˜ íŒŒì¼ë„ ì§€ì› (í•˜ìœ„ í˜¸í™˜ì„±)
            if (greetingsFile.greetings && Array.isArray(greetingsFile.greetings)) {
                // ëª¨ë“  ê°œë³„ ì¸ì‚¬ë§ ë©”ì‹œì§€ ìˆ˜ì§‘
                const allMessages = [];
                // ì¼ë°˜ ì¹´í…Œê³ ë¦¬ ë©”ì‹œì§€ ìˆ˜ì§‘
                for (const category of greetingsFile.greetings) {
                    if (category.messages && Array.isArray(category.messages)) {
                        allMessages.push(...category.messages);
                    }
                }
                // ì¡°í•© ì¹´í…Œê³ ë¦¬ë„ í¬í•¨
                if (greetingsFile.combinations && Array.isArray(greetingsFile.combinations)) {
                    for (const combo of greetingsFile.combinations) {
                        if (combo.messages && Array.isArray(combo.messages)) {
                            allMessages.push(...combo.messages);
                        }
                    }
                }
                // ìœ íš¨í•œ ë©”ì‹œì§€ê°€ ìžˆëŠ”ì§€ í™•ì¸
                if (allMessages.length > 0) {
                    return allMessages[Math.floor(Math.random() * allMessages.length)];
                }
            }
            throw new Error('No valid greeting messages found');
        }
        catch (error) {
            console.error('Error loading greetings:', error);
            // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ ì¸ì‚¬ë§ ë°˜í™˜
            const fallbackGreetings = [
                "ì•ˆë…•í•˜ì„¸ìš”! ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”? ë„ì›€ì´ í•„ìš”í•˜ì‹œë©´ '/'ë¥¼ ìž…ë ¥í•´ë³´ì„¸ìš”.",
                "ì–´ë–¤ ê°œë°œ ìž‘ì—…ì„ ë„ì™€ë“œë¦´ê¹Œìš”? ìŠ¬ëž˜ì‹œ(/) ëª…ë ¹ì–´ë¡œ ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ì‹¤ ìˆ˜ ìžˆì–´ìš”.",
                "ì˜¤ëŠ˜ì€ ì–´ë–¤ ì½”ë“œë¥¼ ìž‘ì„±í•˜ê³  ê³„ì‹ ê°€ìš”? ë„ì›€ì´ í•„ìš”í•˜ì‹œë©´ ì•Œë ¤ì£¼ì„¸ìš”."
            ];
            return fallbackGreetings[Math.floor(Math.random() * fallbackGreetings.length)];
        }
    }
    /**
     * Sends a user message to the LLM and processes the response
     */
    async sendMessage(content) {
        if (!this._view) {
            external_vscode_.window.showErrorMessage('APE Chat view is not available');
            return;
        }
        if (this._isStreaming) {
            external_vscode_.window.showInformationMessage('Please wait for the current response to complete');
            return;
        }
        // Handle slash commands
        if (content.trim().startsWith('/')) {
            // Execute slash command directly via commandManager
            await this._commandManager.slashCommandManager.executeCommand(content);
            return;
        }
        // Apply smart prompting (if enabled)
        let processedContent = content;
        if (this._smartPromptingService && this._smartPromptingService.isEnabled()) {
            processedContent = this._smartPromptingService.processMessage(content);
        }
        // Create and add user message
        const userMessage = {
            id: `msg_${Date.now()}`,
            role: MessageRole.User,
            content: processedContent,
            timestamp: new Date()
        };
        this._messages.push(userMessage);
        this.updateChatView();
        try {
            // Create assistant message placeholder for streaming
            const assistantMessageId = `msg_${Date.now() + 1}`;
            const assistantMessage = {
                id: assistantMessageId,
                role: MessageRole.Assistant,
                content: '',
                timestamp: new Date()
            };
            this._messages.push(assistantMessage);
            this._currentStreamMessageId = assistantMessageId;
            this._isStreaming = true;
            this.updateChatView();
            // Start streaming response from LLM
            await this._llmService.streamResponse(this._messages, (chunk, done) => {
                // Update the assistant message with the new chunk
                const assistantMessage = this._messages.find(m => m.id === this._currentStreamMessageId);
                if (assistantMessage) {
                    assistantMessage.content += chunk;
                    // Debounce updates for efficiency
                    if (!this._streamUpdateTimeout) {
                        this._streamUpdateTimeout = setTimeout(() => {
                            this.updateChatView();
                            this._streamUpdateTimeout = null;
                        }, 30); // 30ms debouncing
                    }
                    if (done) {
                        // Stream completed
                        this._isStreaming = false;
                        this._currentStreamMessageId = null;
                        // Cancel any pending timeout
                        if (this._streamUpdateTimeout) {
                            clearTimeout(this._streamUpdateTimeout);
                            this._streamUpdateTimeout = null;
                        }
                        // ë©”ì‹œì§€ê°€ ì˜¤ë¥˜ ë©”ì‹œì§€ì¸ì§€ í™•ì¸
                        const assistantMessage = this._messages.find(m => m.id === this._currentStreamMessageId);
                        if (assistantMessage && assistantMessage.content.includes('[ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤]')) {
                            // ì˜¤ë¥˜ ë©”ì‹œì§€ë¥¼ ì‹œìŠ¤í…œ ë©”ì‹œì§€ë¡œ ë³€ê²½
                            assistantMessage.role = MessageRole.System;
                            assistantMessage.content = 'ì—°ê²° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.';
                        }
                        // Save messages to memory
                        this.saveMessages();
                        this.updateChatView();
                    }
                }
            });
        }
        catch (error) {
            this._isStreaming = false;
            this._currentStreamMessageId = null;
            // Cancel any pending timeout
            if (this._streamUpdateTimeout) {
                clearTimeout(this._streamUpdateTimeout);
                this._streamUpdateTimeout = null;
            }
            // Add error message
            const errorMessage = {
                id: `msg_error_${Date.now()}`,
                role: MessageRole.System,
                content: `Error: ${error instanceof Error ? error.message : String(error)}`,
                timestamp: new Date()
            };
            this._messages.push(errorMessage);
            this.updateChatView();
        }
    }
    /**
     * Clears all messages from the chat and shows welcome screen
     */
    clearChat() {
        console.log('Clearing chat - creating new welcome message');
        // Clear messages from memory service
        this._memoryService.clearMessages();
        try {
            // Get HTML content for welcome message
            const welcomeHTML = WelcomeViewProvider.getWelcomeMessageHTML();
            console.log('WelcomeViewProvider used - welcome HTML generated, length:', welcomeHTML.length);
            // Create welcome messages
            const welcomeId = `welcome_${Date.now()}`;
            const assistantId = `assistant_welcome_${Date.now()}`;
            this._messages = [
                {
                    id: welcomeId,
                    role: MessageRole.System,
                    content: welcomeHTML,
                    timestamp: new Date()
                },
                {
                    id: assistantId,
                    role: MessageRole.Assistant,
                    content: this.getRandomGreeting(),
                    timestamp: new Date()
                }
            ];
            console.log('Welcome messages added - IDs:', welcomeId, assistantId);
            // Update UI immediately
            this.updateChatView();
        }
        catch (error) {
            console.error('Error creating welcome message:', error);
            this._messages = [{
                    id: `error_${Date.now()}`,
                    role: MessageRole.System,
                    content: 'ì›°ì»´ í™”ë©´ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                    timestamp: new Date()
                }];
            // Update UI with error message
            this.updateChatView();
        }
    }
    /**
     * Loads messages from memory service
     */
    async loadMessages() {
        console.log('Loading messages - checking for existing messages');
        const result = await this._memoryService.getMessages();
        if (result.success && result.data && result.data.length > 0) {
            console.log(`Loaded ${result.data.length} saved messages`);
            this._messages = result.data;
        }
        else {
            console.log('No saved messages found, adding welcome message');
            try {
                // Get HTML content for welcome message
                const welcomeHTML = WelcomeViewProvider.getWelcomeMessageHTML();
                console.log('WelcomeViewProvider used - welcome HTML generated, length:', welcomeHTML.length);
                // Create welcome messages
                const welcomeId = `welcome_${Date.now()}`;
                const assistantId = `assistant_welcome_${Date.now()}`;
                this._messages = [
                    {
                        id: welcomeId,
                        role: MessageRole.System,
                        content: welcomeHTML,
                        timestamp: new Date()
                    },
                    {
                        id: assistantId,
                        role: MessageRole.Assistant,
                        content: this.getRandomGreeting(),
                        timestamp: new Date()
                    }
                ];
                console.log('Welcome messages added - IDs:', welcomeId, assistantId);
            }
            catch (error) {
                console.error('Error creating welcome message:', error);
                this._messages = [{
                        id: `error_${Date.now()}`,
                        role: MessageRole.System,
                        content: 'ì›°ì»´ í™”ë©´ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.',
                        timestamp: new Date()
                    }];
            }
        }
    }
    /**
     * Saves messages to memory service
     */
    async saveMessages() {
        for (const message of this._messages) {
            await this._memoryService.addMessage(message);
        }
    }
    /**
     * Updates the chat view with the current messages
     */
    updateChatView() {
        if (this._view) {
            this._view.webview.postMessage({
                type: 'updateMessages',
                messages: this._messages,
                isStreaming: this._isStreaming
            });
        }
    }
    /**
     * Handles messages sent from the webview
     */
    _handleMessage(message) {
        switch (message.type) {
            case 'sendMessage':
                this.sendMessage(message.content);
                break;
            case 'cancelStream':
                this._llmService.cancelStream();
                this._isStreaming = false;
                this._currentStreamMessageId = null;
                // Cancel any pending timeout
                if (this._streamUpdateTimeout) {
                    clearTimeout(this._streamUpdateTimeout);
                    this._streamUpdateTimeout = null;
                }
                this.updateChatView();
                break;
            case 'clearChat':
                this.clearChat();
                break;
            case 'command':
                // Execute command from help panel
                this.sendMessage(message.command);
                break;
            case 'insertCommand':
                // Insert command text into chat input
                this.insertCommandToChat(message.command);
                break;
            case 'getEditorContent':
                this.getEditorContent().then(content => {
                    if (this._view) {
                        this._view.webview.postMessage({
                            type: 'editorContent',
                            content
                        });
                    }
                });
                break;
            case 'inputChanged':
                // Update command suggestions when input changes
                this.updateCommandSuggestions(message.content);
                break;
            case 'showModelSelector':
                console.log('Model selector request received');
                try {
                    // Call CommandManager's selectModel directly
                    if (this._commandManager) {
                        Promise.resolve(this._commandManager.selectModel()).catch((error) => {
                            console.error('Error executing model selection command:', error);
                            external_vscode_.window.showErrorMessage('Unable to execute model selection');
                        });
                    }
                    else {
                        // Fallback: Use VSCode command system
                        Promise.resolve(external_vscode_.commands.executeCommand('ape.selectModel')).catch((error) => {
                            console.error('Error executing VSCode command:', error);
                            external_vscode_.window.showErrorMessage('Unable to execute model selection');
                        });
                    }
                }
                catch (error) {
                    console.error('Unexpected error:', error);
                    external_vscode_.window.showErrorMessage('Unexpected error during model selection');
                }
                break;
            case 'toggleSmartPrompting':
                // Toggle Smart Prompting service
                if (this._smartPromptingService) {
                    this._smartPromptingService.toggle();
                }
                break;
            case 'setSmartPromptingMode':
                // Set Smart Prompting mode
                if (this._smartPromptingService && message.mode) {
                    this._smartPromptingService.setMode(message.mode);
                }
                break;
            case 'copyCode':
            case 'insertCodeToEditor':
            case 'createFileWithCode':
                // Code block actions handled by CodeService
                break;
        }
    }
    /**
     * Updates command suggestions
     */
    updateCommandSuggestions(input) {
        if (input.startsWith('/')) {
            // Get slash command suggestions
            const suggestions = this._commandManager.slashCommandManager.getCommandSuggestions(input);
            // Send suggestions to webview
            if (this._view) {
                this._view.webview.postMessage({
                    type: 'commandSuggestions',
                    suggestions
                });
            }
            // Fire event for VSCode integration
            this._onDidSuggestCommands.fire(suggestions);
        }
        else if (this._view) {
            // Clear suggestions
            this._view.webview.postMessage({
                type: 'commandSuggestions',
                suggestions: []
            });
        }
    }
    /**
     * Inserts a command into the chat input
     */
    insertCommandToChat(command) {
        if (!this._view) {
            return;
        }
        // Send insert command request to webview
        this._view.webview.postMessage({
            type: 'insertCommandToInput',
            command: command
        });
    }
    /**
     * Inserts text into the chat input from external sources
     */
    handleChatInput(text) {
        if (!this._view) {
            return;
        }
        // Send insert text request to webview
        this._view.webview.postMessage({
            type: 'insertCommandToInput',
            command: text
        });
    }
    /**
     * Adds a direct LLM response to the chat from external sources
     * Used for automated test results or system messages
     */
    async sendLlmResponse(message) {
        if (!this._view) {
            external_vscode_.window.showErrorMessage('APE Chat view is not available');
            return;
        }
        // Create message object
        const newMessage = {
            id: `msg_${Date.now()}`,
            role: message.role,
            content: message.content,
            timestamp: new Date()
        };
        // Add message to list
        this._messages.push(newMessage);
        // Save to memory
        await this._memoryService.addMessage(newMessage);
        // Update UI
        this.updateChatView();
    }
    /**
     * Gets content from the active editor
     */
    async getEditorContent() {
        const editor = external_vscode_.window.activeTextEditor;
        if (editor) {
            const document = editor.document;
            const selection = editor.selection;
            // Return selected text if there's a selection, otherwise entire document
            if (!selection.isEmpty) {
                return document.getText(selection);
            }
            else {
                return document.getText();
            }
        }
        return null;
    }
    /**
     * Generates the HTML for the main chat interface webview
     */
    _getHtmlForWebview(webview) {
        console.log('Generating main chat interface HTML for webview');
        // Get paths to local resources
        const mainStylesUri = webview.asWebviewUri(external_vscode_.Uri.joinPath(this._context.extensionUri, 'media', 'chat-ape.css'));
        console.log('chat-main.css URI:', mainStylesUri.toString());
        const codiconsUri = webview.asWebviewUri(external_vscode_.Uri.joinPath(this._context.extensionUri, 'media', 'codicon', 'codicon.css'));
        console.log('codicon.css URI:', codiconsUri.toString());
        const codeBlockStylesUri = CodeService.getCodeBlockStyleUri(webview, this._context);
        console.log('code-block.css URI:', codeBlockStylesUri.toString());
        const nonce = this._getNonce();
        return `<!DOCTYPE html>
    <html lang="ko">
    <head>
      <meta charset="UTF-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${webview.cspSource} 'unsafe-inline'; font-src ${webview.cspSource} data:; img-src ${webview.cspSource} https: data:; script-src 'nonce-${nonce}' 'unsafe-inline';">
      <link href="${mainStylesUri}" rel="stylesheet" onload="console.log('chat-main.css loaded')" onerror="console.error('Failed to load chat-main.css')">
      <link href="${codiconsUri}" rel="stylesheet" onload="console.log('codicon.css loaded')" onerror="console.error('Failed to load codicon.css')">
      <link href="${codeBlockStylesUri}" rel="stylesheet" onload="console.log('code-block.css loaded')" onerror="console.error('Failed to load code-block.css')">
      <title>APE Chat</title>
    </head>
    <body>
      <div id="chat-container">
        <div class="chat-header">
        </div>
        <div id="chat-messages"></div>
        <div id="chat-input-container">
          <div id="input-actions">
            <button id="smart-prompting-toggle" title="ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ì „í™˜" class="input-top-button">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                <path d="M12 3L14.057 8.17159L19.5 8.88418L15.75 12.8789L16.7135 19L12 16L7.2865 19L8.25 12.8789L4.5 8.88418L9.943 8.17159L12 3Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>
              <span id="smart-prompting-label">ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ…</span>
            </button>
          </div>
          <div class="input-wrapper">
            <textarea id="chat-input" placeholder="ë©”ì‹œì§€ë¥¼ ìž…ë ¥í•˜ì„¸ìš”..." rows="1"></textarea>
            <div id="input-buttons">
              <button id="clear-button" title="ëŒ€í™” ì§€ìš°ê¸°" class="action-button">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M19 6L5 20M5 6L19 20" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
              </button>
              <button id="send-button" title="ë©”ì‹œì§€ ì „ì†¡" class="action-button">
                <svg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              </button>
            </div>
          </div>
        </div>
        <div id="model-indicator">
          <span id="model-name">LLM Model</span>
          <button id="model-selector" title="ëª¨ë¸ ë³€ê²½">
            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M12 4L19 8V16L12 20L5 16V8L12 4Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M12 12L19 8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M12 12V20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
              <path d="M12 12L5 8" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
            ëª¨ë¸ ë³€ê²½
          </button>
        </div>
        <div id="command-suggestions"></div>
      </div>
      
      <script nonce="${nonce}">
        // Main script
        (function() {
          // Initial data
          const vscode = acquireVsCodeApi();
          const initialMessages = ${JSON.stringify(this._messages)};
          const isStreaming = ${this._isStreaming};
          let codeBlockCounter = 0;
          
          // Store messages in state
          vscode.setState({ messages: initialMessages });
          
          // Setup message handler
          window.addEventListener('message', event => {
            const message = event.data;
            
            switch (message.type) {
              case 'updateMessages': {
                updateMessages(message.messages, message.isStreaming);
                break;
              }
                
              case 'editorContent': {
                handleEditorContent(message.content);
                break;
              }
                
              case 'commandSuggestions': {
                updateCommandSuggestions(message.suggestions);
                break;
              }
                
              case 'insertCommandToInput': {
                insertCommandFromHelp(message.command);
                break;
              }
                
              case 'updateModelIndicator': {
                // Update model name display
                if (modelIndicator) {
                  modelIndicator.textContent = message.modelName;
                }
                break;
              }

              case 'updateSmartPrompting': {
                // Update Smart Prompting UI state
                if (smartPromptingToggle && smartPromptingLabel) {
                  if (message.enabled) {
                    smartPromptingToggle.classList.add('active');
                    smartPromptingLabel.textContent = 'ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ… ì¼œì§';
                  } else {
                    smartPromptingToggle.classList.remove('active');
                    smartPromptingLabel.textContent = 'ìŠ¤ë§ˆíŠ¸ í”„ë¡¬í”„íŒ…';
                  }
                }
                break;
              }
            }
          });
          
          // DOM Elements - initialize as variables first, we'll get them in init()
          let chatMessages;
          let chatInput;
          let sendButton;
          let clearButton;
          let modelIndicator;
          let modelSelector;
          let smartPromptingToggle;
          let smartPromptingLabel;

          // Command suggestions container
          let commandSuggestionsContainer;
          
          // Active suggestion index
          let activeSuggestionIndex = -1;
          let suggestions = [];
          
          // Smart scroll state management
          let isUserScrolled = false;
          let isScrollNearBottom = true;
          const SCROLL_THRESHOLD = 100; // Distance from bottom to consider "near bottom"
        
          // Detect user scroll function
          function detectUserScroll() {
            if (!chatMessages) return;
            
            // Calculate scroll position
            const scrollPosition = chatMessages.scrollTop + chatMessages.clientHeight;
            const scrollThreshold = chatMessages.scrollHeight - SCROLL_THRESHOLD;
            
            // Check if scroll is near bottom
            isScrollNearBottom = scrollPosition >= scrollThreshold;
            
            // Detect user scrolling up
            if (!isScrollNearBottom) {
              isUserScrolled = true;
            }
          }
          
          // Smart scroll function
          function performSmartScroll(forceScroll = false) {
            if (!chatMessages) return;
            
            // Only scroll if user hasn't scrolled up, or a force scroll is needed
            if (forceScroll || !isUserScrolled || isScrollNearBottom) {
              chatMessages.scrollTop = chatMessages.scrollHeight;
              isUserScrolled = false;
            }
          }

          // Helper function to format date for iOS-style timestamp display
          function formatMessageDate(date) {
            if (!date) return '';
            
            // Create a date object
            const messageDate = new Date(date);
            
            // Get current date
            const now = new Date();
            
            // Check if message is from today
            const isToday = messageDate.toDateString() === now.toDateString();
            
            // Format the time (HH:MM)
            const hours = messageDate.getHours().toString().padStart(2, '0');
            const minutes = messageDate.getMinutes().toString().padStart(2, '0');
            const timeStr = \`\${hours}:\${minutes}\`;
            
            // Return appropriate format based on age
            if (isToday) {
              return timeStr;
            } else {
              // For older messages, include date
              const month = messageDate.getMonth() + 1;
              const day = messageDate.getDate();
              return \`\${month}ì›” \${day}ì¼ \${timeStr}\`;
            }
          }
          
          // Get the timestamp group for a message
          function getTimestampGroup(date) {
            if (!date) return 'unknown';
            
            const messageDate = new Date(date);
            return messageDate.toDateString();
          }
          
          // Add timestamp dividers between message groups
          function addTimestampDividers(messages) {
            const result = [];
            let currentGroup = null;
            
            messages.forEach((message, index) => {
              // Determine the timestamp group for this message
              const group = getTimestampGroup(message.timestamp);
              
              // If group changed, add timestamp divider
              if (group !== currentGroup) {
                currentGroup = group;
                
                // Skip adding timestamp for welcome message
                if (index > 0) {
                  const divider = {
                    id: \`timestamp_\${Date.now()}_\${index}\`,
                    type: 'timestamp',
                    content: formatMessageDate(message.timestamp),
                    timestamp: message.timestamp
                  };
                  result.push(divider);
                }
              }
              
              // Add the actual message
              result.push(message);
            });
            
            return result;
          }
          
          // Message DOM ID converter
          function getMessageDomId(messageId) {
            return 'msg-' + messageId.replace(/\\s+/g, '-');
          }
          
          // Update messages in the UI
          function updateMessages(messages, isStreaming) {
            console.log("updateMessages called with", messages.length, "messages, isStreaming:", isStreaming);
            
            // Store in state
            vscode.setState({ messages });
            
            // Check if chatMessages exists
            if (!chatMessages) {
              console.error("Error: chatMessages element not found. Retrying initialization...");
              setTimeout(init, 100);
              return;
            }
            
            // Get current messages in the DOM
            const currentMessageIds = Array.from(chatMessages.children)
              .filter(el => el.classList.contains('message'))
              .map(el => el.getAttribute('data-message-id'))
              .filter(id => id);
            
            // Check scroll position
            detectUserScroll();
            
            // Add timestamp dividers
            const messagesWithTimestamps = addTimestampDividers(messages);
            
            // Get DOM elements that should be in the view
            const shouldContainIds = messagesWithTimestamps.map(m => m.id);

            // Add typing indicator if streaming
            if (isStreaming) {
              if (!document.querySelector('.typing-indicator')) {
                const typingIndicator = document.createElement('div');
                typingIndicator.className = 'typing-indicator';
                typingIndicator.innerHTML = \`
                  <span class="typing-dot"></span>
                  <span class="typing-dot"></span>
                  <span class="typing-dot"></span>
                \`;
                
                // Add after last message
                chatMessages.appendChild(typingIndicator);
              }
            } else {
              // Remove typing indicator if present
              const typingIndicator = document.querySelector('.typing-indicator');
              if (typingIndicator) {
                typingIndicator.remove();
              }
            }
            
            // Remove elements that should no longer be in the view
            Array.from(chatMessages.children).forEach(el => {
              const id = el.getAttribute('data-message-id');
              // Keep timestamp dividers
              if (!id || !shouldContainIds.includes(id)) {
                // Don't remove typing indicator
                if (!el.classList.contains('typing-indicator')) {
                  el.remove();
                }
              }
            });
            
            // Clear existing timestamp dividers (we'll recreate them)
            Array.from(chatMessages.querySelectorAll('.timestamp-divider')).forEach(el => {
              el.remove();
            });
            
            // Create mapping for quick element lookup
            const elementMap = {};
            Array.from(chatMessages.children).forEach(el => {
              const id = el.getAttribute('data-message-id');
              if (id) {
                elementMap[id] = el;
              }
            });
            
            // Process messages and add to DOM
            let previousElement = null;
            messagesWithTimestamps.forEach((item, index) => {
              // Handle timestamp dividers
              if (item.type === 'timestamp') {
                const dividerElement = document.createElement('div');
                dividerElement.className = 'timestamp-divider';
                dividerElement.setAttribute('data-message-id', item.id);
                
                dividerElement.innerHTML = \`
                  <span class="timestamp-text">\${item.content}</span>
                \`;
                
                // Insert divider at correct position
                if (previousElement) {
                  previousElement.after(dividerElement);
                } else {
                  chatMessages.appendChild(dividerElement);
                }
                
                previousElement = dividerElement;
                return;
              }
              
              // Handle regular messages
              const message = item;
              const messageId = message.id;
              let messageElement = elementMap[messageId];
              const isLastMessage = message.id === messages[messages.length - 1].id;
              
              // Create new message element if needed
              if (!messageElement) {
                messageElement = document.createElement('div');
                messageElement.className = 'message ' + message.role;
                messageElement.setAttribute('data-message-id', messageId);
                
                const contentElement = document.createElement('div');
                contentElement.className = 'message-content';
                messageElement.appendChild(contentElement);
                
                // Add read/delivered indicator for user messages
                if (message.role === 'user') {
                  const statusElement = document.createElement('div');
                  statusElement.className = 'message-status';
                  messageElement.appendChild(statusElement);
                }
                
                // Insert at correct position
                if (previousElement) {
                  previousElement.after(messageElement);
                } else {
                  chatMessages.appendChild(messageElement);
                }
              }
              
              // Update content if changed
              const contentElement = messageElement.querySelector('.message-content');
              const formattedContent = formatMessageContent(message.content);
              
              if (contentElement.innerHTML !== formattedContent) {
                contentElement.innerHTML = formattedContent;
              }
              
              previousElement = messageElement;
            });
            
            // Smart scroll (force scroll for new messages or when streaming ends)
            performSmartScroll(messages.length !== currentMessageIds.length || !isStreaming);
            
            // Update UI based on streaming state
            if (isStreaming) {
              sendButton.innerHTML = \`<span class="emoji-icon">â– </span>\`;
              sendButton.title = 'ìƒì„± ì¤‘ë‹¨';
              chatInput.disabled = true;
            } else {
              sendButton.innerHTML = \`
                <svg class="send-icon" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                  <path d="M22 2L11 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                  <path d="M22 2L15 22L11 13L2 9L22 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
              \`;
              sendButton.title = 'ë©”ì‹œì§€ ì „ì†¡';
              chatInput.disabled = false;
            }
          }
          
          // Format message content with code blocks and other formatting
          function formatMessageContent(content) {
            if (!content) return '';
            
            // If content is already HTML, return as is
            const trimmedContent = content.trim();
            if (trimmedContent.startsWith('<') && (
              trimmedContent.includes('</div>') || 
              trimmedContent.includes('</p>') || 
              trimmedContent.includes('</h') || 
              trimmedContent.includes('</span>') ||
              trimmedContent.includes('</ul>') ||
              trimmedContent.includes('</li>') ||
              trimmedContent.includes('</table>') ||
              trimmedContent.match(/<[a-zA-Z0-9_]+[^>]*>/)
            )) {
              return content;
            }
            
            // Format content
            let formatted = content;
            
            // Replace code blocks with modern UI
            formatted = formatted.replace(/\`\`\`(\\w*)\\n([\\s\\S]*?)\\n\`\`\`/g, function(match, language, code) {
              const codeId = 'code_' + (++codeBlockCounter);
              const escapedCode = escapeHtml(code);
              const lang = language || 'plaintext';
              
              // Generate line numbers
              const lines = code.split('\\n');
              const lineNumbers = lines.map((_, i) => (i + 1)).join('\\n');
              const showLineNumbers = lines.length > 1;
              
              // Create code block HTML
              return '<div class="code-block-container code-block-popup">' +
                '<div class="code-block-header">' +
                  '<span class="code-block-language language-' + lang + '">' + lang + '</span>' +
                  '<div class="code-block-actions">' +
                    '<button class="code-action-button copy-button" data-code-id="' + codeId + '" title="ë³µì‚¬">' +
                      '<i class="codicon codicon-copy"></i>' +
                      '<span class="tooltip">í´ë¦½ë³´ë“œì— ë³µì‚¬</span>' +
                    '</button>' +
                    '<button class="code-action-button insert-code-button" data-code-id="' + codeId + '" title="ì—ë””í„°ì— ì‚½ìž…">' +
                      '<i class="codicon codicon-arrow-small-right"></i>' +
                      '<span class="tooltip">í˜„ìž¬ íŒŒì¼ì— ë³µì‚¬</span>' +
                    '</button>' +
                    '<button class="code-action-button new-file-button" data-code-id="' + codeId + '" title="ìƒˆ íŒŒì¼ë¡œ ìƒì„±">' +
                      '<i class="codicon codicon-new-file"></i>' +
                      '<span class="tooltip">ìƒˆ íŒŒì¼ë¡œ ìƒì„±</span>' +
                    '</button>' +
                  '</div>' +
                '</div>' +
                '<div class="code-content ' + (showLineNumbers ? 'with-line-numbers' : '') + '">' +
                  (showLineNumbers ? '<div class="line-numbers">' + lineNumbers + '</div>' : '') +
                  '<div class="code-area">' +
                    '<code class="language-' + lang + '" id="code-' + codeId + '">' + escapedCode + '</code>' +
                  '</div>' +
                '</div>' +
              '</div>';
            });
            
            // Replace inline code
            formatted = formatted.replace(/\`([^\`]+)\`/g, function(match, code) {
              return '<code class="inline-code">' + escapeHtml(code) + '</code>';
            });
            
            // Replace newlines with <br>
            formatted = formatted.replace(/\\n/g, '<br>');
            
            return formatted;
          }
          
          // HTML escape function
          function escapeHtml(unsafe) {
            return unsafe
              .replace(/&/g, "&amp;")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;")
              .replace(/"/g, "&quot;")
              .replace(/'/g, "&#039;");
          }
          
          // Handle editor content insertion
          function handleEditorContent(content) {
            if (content) {
              chatInput.value += '\`\`\`\\n' + content + '\\n\`\`\`\\n';
              resizeInput();
            }
          }
          
          // Auto-resize input based on content
          function resizeInput() {
            chatInput.style.height = 'auto';
            chatInput.style.height = (chatInput.scrollHeight) + 'px';
          }
          
          // Update command suggestions in popover
          function updateCommandSuggestions(newSuggestions) {
            suggestions = newSuggestions || [];
            activeSuggestionIndex = -1;
            
            // Clear the container
            commandSuggestionsContainer.innerHTML = '';
            
            if (suggestions.length === 0) {
              // Hide the container if no suggestions
              commandSuggestionsContainer.style.display = 'none';
              return;
            }
            
            // Position the suggestions container
            positionCommandSuggestions();
            
            // Show the container
            commandSuggestionsContainer.style.display = 'block';
            
            // Group suggestions by category
            const categorizedSuggestions = {};
            suggestions.forEach(suggestion => {
              // Add category data attribute
              suggestion.categoryAttr = suggestion.category;
              
              if (!categorizedSuggestions[suggestion.category]) {
                categorizedSuggestions[suggestion.category] = [];
              }
              categorizedSuggestions[suggestion.category].push(suggestion);
            });
            
            // Add each category and its suggestions
            Object.keys(categorizedSuggestions).forEach(category => {
              // Create category header
              const categoryHeader = document.createElement('div');
              categoryHeader.className = 'suggestion-category';
              categoryHeader.textContent = getCategoryTitle(category);
              commandSuggestionsContainer.appendChild(categoryHeader);
              
              // Add suggestions for this category
              categorizedSuggestions[category].forEach((suggestion, index) => {
                const suggestionElement = document.createElement('div');
                suggestionElement.className = 'command-suggestion';
                suggestionElement.dataset.category = suggestion.categoryAttr;
                const suggestionIndex = suggestions.findIndex(s => s.label === suggestion.label);
                suggestionElement.dataset.index = String(suggestionIndex);
                
                // Add icon
                const iconElement = document.createElement('span');
                iconElement.className = 'suggestion-icon';
                iconElement.textContent = getSvgIconForCategory(suggestion.category);
                suggestionElement.appendChild(iconElement);
                
                // Add label
                const labelElement = document.createElement('span');
                labelElement.className = 'suggestion-label';
                labelElement.textContent = suggestion.label;
                suggestionElement.appendChild(labelElement);
                
                // Add description
                const descriptionElement = document.createElement('span');
                descriptionElement.className = 'suggestion-description';
                descriptionElement.textContent = suggestion.description;
                suggestionElement.appendChild(descriptionElement);
                
                // Add click handler
                suggestionElement.addEventListener('click', () => {
                  insertSuggestion(suggestion);
                });
                
                // Add mouseover handler
                suggestionElement.addEventListener('mouseover', () => {
                  activeSuggestionIndex = Number(suggestionElement.dataset.index);
                  highlightActiveSuggestion();
                });
                
                commandSuggestionsContainer.appendChild(suggestionElement);
              });
            });
            
            // Scroll to top
            commandSuggestionsContainer.scrollTop = 0;
          }
          
          // Position command suggestions popover
          function positionCommandSuggestions() {
            if (!chatInput || !commandSuggestionsContainer) return;
            
            // Get the input container's position
            const inputContainer = document.getElementById('chat-input-container');
            if (!inputContainer) return;
            
            const inputRect = inputContainer.getBoundingClientRect();
            
            // Set the position relative to the input container
            commandSuggestionsContainer.style.position = 'absolute';
            commandSuggestionsContainer.style.bottom = (inputRect.height + 8) + 'px';
            commandSuggestionsContainer.style.left = '12px';
            commandSuggestionsContainer.style.right = '12px';
            
            // Make sure it's visible
            commandSuggestionsContainer.style.zIndex = '1000';
          }
          
          // Get category title
          function getCategoryTitle(category) {
            switch (category) {
              case 'general': return 'ì¼ë°˜ ëª…ë ¹ì–´';
              case 'git': return 'Git ê´€ë ¨ ëª…ë ¹ì–´';
              case 'code': return 'ì½”ë“œ ê´€ë ¨ ëª…ë ¹ì–´';
              case 'utility': return 'ìœ í‹¸ë¦¬í‹° ëª…ë ¹ì–´';
              case 'advanced': return 'ê³ ê¸‰ ëª…ë ¹ì–´';
              default: return category;
            }
          }
          
          // Get icon for category
          function getSvgIconForCategory(category) {
            switch (category) {
              case 'general': return 'âœ“';
              case 'git': return 'âŽ‡';
              case 'code': return 'â®â¯';
              case 'utility': return 'âš™';
              case 'advanced': return 'â˜…';
              default: return 'â—‹';
            }
          }
          
          // Highlight active suggestion
          function highlightActiveSuggestion() {
            // Remove highlight from all suggestions
            document.querySelectorAll('.command-suggestion').forEach(el => {
              el.classList.remove('active');
            });
            
            // Highlight the active suggestion
            if (activeSuggestionIndex >= 0 && activeSuggestionIndex < suggestions.length) {
              const activeElement = document.querySelector(
                '.command-suggestion[data-index="' + activeSuggestionIndex + '"]'
              );
              
              if (activeElement) {
                activeElement.classList.add('active');
                
                // Scroll into view if needed
                const container = commandSuggestionsContainer;
                const elementTop = activeElement.offsetTop;
                const elementBottom = elementTop + activeElement.offsetHeight;
                const containerTop = container.scrollTop;
                const containerBottom = containerTop + container.offsetHeight;
                
                if (elementTop < containerTop) {
                  container.scrollTop = elementTop;
                } else if (elementBottom > containerBottom) {
                  container.scrollTop = elementBottom - container.offsetHeight;
                }
              }
            }
          }
          
          // Insert suggestion into input
          function insertSuggestion(suggestion) {
            if (!suggestion) return;
            
            chatInput.value = suggestion.insertText;
            chatInput.focus();
            
            // Position cursor at the end
            chatInput.selectionStart = chatInput.selectionEnd = chatInput.value.length;
            
            // Resize input
            resizeInput();
            
            // Clear suggestions
            updateCommandSuggestions([]);
            
            // Notify about input change
            notifyInputChanged();
          }
          
          // List of standalone commands (ones that can be auto-executed)
          const standAloneCommands = ['help', 'clear', 'settings', 'model'];
          
          // Check if a command can be executed standalone
          function isStandAloneCommand(commandText) {
            if (!commandText.startsWith('/')) return false;
            
            const commandParts = commandText.substring(1).split(/ +/);
            const baseCommand = commandParts[0];
            
            return standAloneCommands.includes(baseCommand) && commandParts.length === 1;
          }
          
          // Send message function
          function sendMessage() {
            const content = chatInput.value.trim();
            if (content) {
              vscode.postMessage({ type: 'sendMessage', content });
              chatInput.value = '';
              resizeInput();
              
              // Clear suggestions
              updateCommandSuggestions([]);
            }
          }
          
          // Navigate through suggestions
          function navigateSuggestions(direction) {
            if (suggestions.length === 0) return false;
            
            // Set active index to 0 if not set
            if (activeSuggestionIndex === -1) {
              activeSuggestionIndex = 0;
              highlightActiveSuggestion();
              return true;
            }
            
            // Navigate based on direction
            if (direction === 'up') {
              activeSuggestionIndex = activeSuggestionIndex <= 0 ? 
                suggestions.length - 1 : activeSuggestionIndex - 1;
            } else if (direction === 'down') {
              activeSuggestionIndex = activeSuggestionIndex >= suggestions.length - 1 ? 
                0 : activeSuggestionIndex + 1;
            }
            
            highlightActiveSuggestion();
            return true;
          }
          
          // Notify about input change
          function notifyInputChanged() {
            const inputValue = chatInput.value;
            
            vscode.postMessage({ 
              type: 'inputChanged', 
              content: inputValue 
            });
          }
          
          // Insert command from help panel
          function insertCommandFromHelp(command) {
            // Add slash if not present
            if (!command.startsWith('/')) {
              command = '/' + command;
            }
            
            // Set input value
            chatInput.value = command;
            chatInput.focus();
            
            // Position cursor at end
            chatInput.selectionStart = chatInput.selectionEnd = chatInput.value.length;
            
            // Resize input and notify
            resizeInput();
            notifyInputChanged();
          }
          
          // Set up event listeners for code actions
          function setupCodeBlockListeners() {
            chatMessages.addEventListener('click', event => {
              const target = event.target;
              
              // Check for copy button
              if (target.closest('.copy-button')) {
                const button = target.closest('.copy-button');
                const codeId = button.getAttribute('data-code-id');
                const codeElement = document.getElementById('code-' + codeId);
                
                if (codeElement) {
                  vscode.postMessage({ 
                    type: 'copyCode', 
                    code: codeElement.textContent 
                  });
                  
                  // Show copied feedback
                  button.classList.add('copied');
                  setTimeout(() => {
                    button.classList.remove('copied');
                  }, 2000);
                }
              }
              
              // Check for insert code button
              if (target.closest('.insert-code-button')) {
                const button = target.closest('.insert-code-button');
                const codeId = button.getAttribute('data-code-id');
                const codeElement = document.getElementById('code-' + codeId);
                
                if (codeElement) {
                  vscode.postMessage({ 
                    type: 'insertCodeToEditor', 
                    code: codeElement.textContent 
                  });
                }
              }
              
              // Check for new file button
              if (target.closest('.new-file-button')) {
                const button = target.closest('.new-file-button');
                const codeId = button.getAttribute('data-code-id');
                const codeElement = document.getElementById('code-' + codeId);
                const languageElement = button.closest('.code-block-container').querySelector('.code-block-language');
                
                if (codeElement) {
                  const language = languageElement ? 
                    languageElement.textContent.trim() || 'plaintext' : 
                    'plaintext';
                    
                  vscode.postMessage({ 
                    type: 'createFileWithCode', 
                    code: codeElement.textContent,
                    language: language
                  });
                }
              }
            });
          }
          
          // Initialize UI
          function init() {
            console.log("Initializing iOS-style chat UI");
            
            // Get DOM elements
            chatMessages = document.getElementById('chat-messages');
            chatInput = document.getElementById('chat-input');
            sendButton = document.getElementById('send-button');
            clearButton = document.getElementById('clear-button');
            modelIndicator = document.getElementById('model-name');
            modelSelector = document.getElementById('model-selector');
            commandSuggestionsContainer = document.getElementById('command-suggestions');
            
            // Get Smart Prompting elements
            smartPromptingToggle = document.getElementById('smart-prompting-toggle');
            smartPromptingLabel = document.getElementById('smart-prompting-label');

            // Check if elements are found
            if (!chatMessages || !chatInput || !sendButton || !clearButton ||
                !commandSuggestionsContainer || !smartPromptingToggle || !smartPromptingLabel) {
              console.error("Critical UI elements missing");
              setTimeout(init, 500);
              return;
            }
            
            console.log("UI elements initialized successfully");
            
            // Set up smart scroll detection
            chatMessages.addEventListener('scroll', detectUserScroll);
            
            // Set up event listeners
            sendButton.addEventListener('click', () => {
              if (chatInput.disabled) {
                vscode.postMessage({ type: 'cancelStream' });
              } else {
                sendMessage();
              }
            });
            
            clearButton.addEventListener('click', () => {
              vscode.postMessage({ type: 'clearChat' });
            });
            
            chatInput.addEventListener('input', () => {
              resizeInput();
              notifyInputChanged();
              
              // Directly check for slash commands here as well
              if (chatInput.value.startsWith('/')) {
                console.log('Slash command detected:', chatInput.value);
              }
            });
            
            chatInput.addEventListener('keydown', (e) => {
              if (suggestions.length > 0) {
                if (e.key === 'ArrowUp') {
                  if (navigateSuggestions('up')) {
                    e.preventDefault();
                    return;
                  }
                } else if (e.key === 'ArrowDown') {
                  if (navigateSuggestions('down')) {
                    e.preventDefault();
                    return;
                  }
                } else if (e.key === 'Enter' && activeSuggestionIndex >= 0) {
                  if (activeSuggestionIndex >= 0 && activeSuggestionIndex < suggestions.length) {
                    const suggestion = suggestions[activeSuggestionIndex];
                    insertSuggestion(suggestion);
                    
                    if (isStandAloneCommand(suggestion.insertText)) {
                      e.preventDefault();
                      sendMessage();
                    }
                    return;
                  }
                } else if (e.key === 'Escape') {
                  updateCommandSuggestions([]);
                  e.preventDefault();
                  return;
                }
              }
              
              if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
              } else if (e.key === '/' && chatInput.value === '') {
                // Special handling for slash key
                setTimeout(() => {
                  notifyInputChanged();
                  console.log('Slash key pressed on empty input');
                }, 10);
              }
            });
            
            modelSelector.addEventListener('click', () => {
              vscode.postMessage({ type: 'showModelSelector' });
            });

            // Smart Prompting toggle click handler
            smartPromptingToggle.addEventListener('click', () => {
              vscode.postMessage({ type: 'toggleSmartPrompting' });
            });
            
            // Set up code block action listeners
            setupCodeBlockListeners();
            
            // Initialize with stored messages
            const state = vscode.getState();
            if (state && state.messages) {
              updateMessages(state.messages, isStreaming);
            } else {
              updateMessages(initialMessages, isStreaming);
            }
            
            // Set initial input height
            resizeInput();
            
            // Set focus to input
            setTimeout(() => {
              if (chatInput) {
                chatInput.focus();
              }
            }, 300);
          }
          
          // Start the app when document is ready
          if (document.readyState === 'complete' || document.readyState === 'interactive') {
            console.log('Document already ready, initializing chat view immediately');
            setTimeout(init, 0);
          } else {
            console.log('Waiting for DOMContentLoaded before initializing chat view');
            document.addEventListener('DOMContentLoaded', () => {
              console.log('DOMContentLoaded fired, initializing chat view');
              init();
            });
          }
        })();
      </script>
    </body>
    </html>`;
    }
    /**
     * Generates a random nonce for CSP
     */
    _getNonce() {
        let text = '';
        const possible = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (let i = 0; i < 32; i++) {
            text += possible.charAt(Math.floor(Math.random() * possible.length));
        }
        return text;
    }
    /**
     * Updates the Smart Prompting UI with the current state
     * @param state The current SmartPromptingState
     */
    _updateSmartPromptingUI(state) {
        if (!this._view) {
            return;
        }
        // Send update message to webview
        this._view.webview.postMessage({
            type: 'updateSmartPrompting',
            enabled: state.enabled,
            mode: state.mode
        });
    }
    /**
     * Open attached file - required for interface compatibility
     * No-op in this implementation as we don't need this feature for the iPhone style
     */
    _openAttachedFile(filePath) {
        return Promise.resolve();
    }
}

;// ./src/plugins/core/api.ts

/**
 * Implementation of the LLM Service API
 */
class LLMServiceAPIImpl {
    _llmService;
    constructor(_llmService) {
        this._llmService = _llmService;
    }
    /**
     * Get currently active LLM model
     * @returns Active LLM model
     */
    getActiveModel() {
        return this._llmService.getActiveModel();
    }
    /**
     * Set active LLM model
     * @param model Model to set as active
     */
    setActiveModel(model) {
        this._llmService.setActiveModel(model);
    }
    /**
     * Get available LLM models
     * @returns Array of available models
     */
    getAvailableModels() {
        return this._llmService.getAvailableModels();
    }
    /**
     * Send a request to the LLM
     * @param messages Messages to send
     * @param options Request options
     * @returns Promise that resolves to a service result containing the response
     */
    async sendRequest(messages, options) {
        return await this._llmService.sendRequest(messages, options);
    }
    /**
     * Stream a response from the LLM
     * @param messages Messages to send
     * @param onChunk Callback for each chunk of the response
     * @param options Request options
     * @returns Promise that resolves to a service result indicating success
     */
    async streamResponse(messages, onChunk, options) {
        return await this._llmService.streamResponse(messages, onChunk, options);
    }
    /**
     * Cancel an ongoing streaming response
     */
    cancelStream() {
        this._llmService.cancelStream();
    }
}
/**
 * Implementation of the Memory Service API
 */
class MemoryServiceAPIImpl {
    _memoryService;
    constructor(_memoryService) {
        this._memoryService = _memoryService;
    }
    /**
     * Get current session ID
     * @returns Current session ID or null if no session is active
     */
    getCurrentSessionId() {
        return this._memoryService.getCurrentSessionId();
    }
    /**
     * Get messages from current session
     * @returns Promise that resolves to a service result containing messages
     */
    async getMessages() {
        return await this._memoryService.getMessages();
    }
    /**
     * Add a message to the current session
     * @param message Message to add
     * @returns Promise that resolves to a service result indicating success
     */
    async addMessage(message) {
        return await this._memoryService.addMessage(message);
    }
    /**
     * Create a new session
     * @param options Session creation options
     * @returns Promise that resolves to a service result containing the session ID
     */
    async createSession(options) {
        return await this._memoryService.createSession(options.name, { metadata: options.metadata });
    }
    /**
     * Switch to a different session
     * @param sessionId Session ID to switch to
     * @returns Promise that resolves to a service result indicating success
     */
    async switchSession(sessionId) {
        return await this._memoryService.switchSession(sessionId);
    }
    /**
     * Get all available sessions
     * @returns Promise that resolves to a service result containing session summaries
     */
    async getSessions() {
        const result = await this._memoryService.getSessions();
        if (result.success && result.data) {
            const simplifiedSessions = result.data.map(session => ({
                id: session.id,
                name: session.name,
                messageCount: session.messageCount,
                updatedAt: session.updatedAt
            }));
            return {
                success: true,
                data: simplifiedSessions
            };
        }
        return result;
    }
    /**
     * Clear messages from current session
     * @returns Promise that resolves to a service result indicating success
     */
    async clearMessages() {
        return await this._memoryService.clearMessages();
    }
}
/**
 * Implementation of the UI Service API
 */
class UIServiceAPIImpl {
    /**
     * Show an information message
     * @param message Message to show
     * @param items Items to include in the message
     * @returns Promise that resolves to the selected item
     */
    async showInformationMessage(message, ...items) {
        return await external_vscode_.window.showInformationMessage(message, ...items);
    }
    /**
     * Show a warning message
     * @param message Message to show
     * @param items Items to include in the message
     * @returns Promise that resolves to the selected item
     */
    async showWarningMessage(message, ...items) {
        return await external_vscode_.window.showWarningMessage(message, ...items);
    }
    /**
     * Show an error message
     * @param message Message to show
     * @param items Items to include in the message
     * @returns Promise that resolves to the selected item
     */
    async showErrorMessage(message, ...items) {
        return await external_vscode_.window.showErrorMessage(message, ...items);
    }
    /**
     * Show quick pick selection
     * @param items Items to show in the quick pick
     * @param options Quick pick options
     * @returns Promise that resolves to the selected item
     */
    async showQuickPick(items, options) {
        // Convert string items to QuickPickItems if needed
        const quickPickItems = Array.isArray(items) && items.length > 0 && typeof items[0] === 'string'
            ? items.map(item => ({ label: item }))
            : items;
        return await external_vscode_.window.showQuickPick(quickPickItems, options);
    }
    /**
     * Show input box
     * @param options Input box options
     * @returns Promise that resolves to the entered text
     */
    async showInputBox(options) {
        return await external_vscode_.window.showInputBox(options);
    }
    /**
     * Create and show a webview panel
     * @param viewType Type of the webview
     * @param title Title of the webview
     * @param options Webview options
     * @returns The created webview panel
     */
    createWebviewPanel(viewType, title, options) {
        const viewColumn = options?.viewColumn || external_vscode_.ViewColumn.Active;
        const preserveFocus = options?.preserveFocus || false;
        return external_vscode_.window.createWebviewPanel(viewType, title, { viewColumn, preserveFocus });
    }
    /**
     * Create status bar item
     * @param options Status bar item options
     * @returns The created status bar item
     */
    createStatusBarItem(options) {
        const alignment = options?.alignment || external_vscode_.StatusBarAlignment.Left;
        const priority = options?.priority || 0;
        return external_vscode_.window.createStatusBarItem(alignment, priority);
    }
}
/**
 * Implementation of the File System API
 */
class FileSystemAPIImpl {
    /**
     * Read file contents
     * @param uri File URI
     * @returns Promise that resolves to file contents
     */
    async readFile(uri) {
        return await external_vscode_.workspace.fs.readFile(uri);
    }
    /**
     * Read file as text
     * @param uri File URI
     * @returns Promise that resolves to file contents as text
     */
    async readFileAsText(uri) {
        const data = await external_vscode_.workspace.fs.readFile(uri);
        return new TextDecoder().decode(data);
    }
    /**
     * Write data to a file
     * @param uri File URI
     * @param content Content to write
     * @returns Promise that resolves when the file is written
     */
    async writeFile(uri, content) {
        await external_vscode_.workspace.fs.writeFile(uri, content);
    }
    /**
     * Write text to a file
     * @param uri File URI
     * @param content Content to write
     * @returns Promise that resolves when the file is written
     */
    async writeFileAsText(uri, content) {
        const data = new TextEncoder().encode(content);
        await external_vscode_.workspace.fs.writeFile(uri, data);
    }
    /**
     * Delete a file
     * @param uri File URI
     * @returns Promise that resolves when the file is deleted
     */
    async deleteFile(uri) {
        await external_vscode_.workspace.fs.delete(uri);
    }
    /**
     * Check if a file exists
     * @param uri File URI
     * @returns Promise that resolves to true if the file exists
     */
    async fileExists(uri) {
        try {
            await external_vscode_.workspace.fs.stat(uri);
            return true;
        }
        catch {
            return false;
        }
    }
    /**
     * List files in a directory
     * @param uri Directory URI
     * @returns Promise that resolves to an array of files and their types
     */
    async readDirectory(uri) {
        return await external_vscode_.workspace.fs.readDirectory(uri);
    }
    /**
     * Create a directory
     * @param uri Directory URI
     * @returns Promise that resolves when the directory is created
     */
    async createDirectory(uri) {
        await external_vscode_.workspace.fs.createDirectory(uri);
    }
    /**
     * Delete a directory
     * @param uri Directory URI
     * @param options Delete options
     * @returns Promise that resolves when the directory is deleted
     */
    async deleteDirectory(uri, options) {
        await external_vscode_.workspace.fs.delete(uri, {
            recursive: options?.recursive || false,
            useTrash: false
        });
    }
    /**
     * Rename a file or directory
     * @param oldUri Old URI
     * @param newUri New URI
     * @returns Promise that resolves when the rename is complete
     */
    async rename(oldUri, newUri) {
        await external_vscode_.workspace.fs.rename(oldUri, newUri);
    }
    /**
     * Copy a file or directory
     * @param source Source URI
     * @param target Target URI
     * @returns Promise that resolves when the copy is complete
     */
    async copy(source, target) {
        await external_vscode_.workspace.fs.copy(source, target);
    }
}
/**
 * Implementation of the Git Service API
 */
class GitServiceAPIImpl {
    /**
     * Get Git repositories in workspace
     * @returns Promise that resolves to an array of repository URIs
     */
    async getRepositories() {
        try {
            // Try to get git extension
            const gitExtension = external_vscode_.extensions.getExtension('vscode.git')?.exports;
            if (gitExtension) {
                const api = gitExtension.getAPI(1);
                if (api) {
                    // Return URIs for all repositories
                    return api.repositories.map((repo) => {
                        return external_vscode_.Uri.parse(repo.rootUri.toString());
                    });
                }
            }
            // If extension not available or no repositories, try to infer from workspace folders
            const workspaceFolders = external_vscode_.workspace.workspaceFolders;
            if (workspaceFolders && workspaceFolders.length > 0) {
                // Filter to include only folders that contain a .git directory
                const repoFolders = [];
                for (const folder of workspaceFolders) {
                    try {
                        const gitFolder = external_vscode_.Uri.joinPath(folder.uri, '.git');
                        const stat = await external_vscode_.workspace.fs.stat(gitFolder);
                        if (stat.type === external_vscode_.FileType.Directory) {
                            repoFolders.push(folder.uri);
                        }
                    }
                    catch (e) {
                        // No .git folder, skip
                    }
                }
                return repoFolders;
            }
        }
        catch (error) {
            console.error('Error getting Git repositories:', error);
        }
        return [];
    }
    /**
     * Get current branch name
     * @param repoUri Repository URI
     * @returns Promise that resolves to the branch name
     */
    async getCurrentBranch(repoUri) {
        try {
            // Try to get git extension
            const gitExtension = external_vscode_.extensions.getExtension('vscode.git')?.exports;
            if (gitExtension) {
                const api = gitExtension.getAPI(1);
                if (api) {
                    const repo = api.repositories.find((r) => r.rootUri.toString() === repoUri.toString());
                    if (repo) {
                        return repo.state.HEAD?.name || 'main';
                    }
                }
            }
            // If extension not available, try to read from .git/HEAD
            try {
                const headFile = external_vscode_.Uri.joinPath(repoUri, '.git', 'HEAD');
                const headContent = await external_vscode_.workspace.fs.readFile(headFile);
                const headText = new TextDecoder().decode(headContent);
                const match = /ref: refs\/heads\/(.+)/.exec(headText);
                if (match && match[1]) {
                    return match[1];
                }
            }
            catch (e) {
                // Failed to read HEAD file
            }
        }
        catch (error) {
            console.error('Error getting current branch:', error);
        }
        return 'main'; // Default fallback
    }
    /**
     * Get repository status
     * @param repoUri Repository URI
     * @returns Promise that resolves to an array of resource states
     */
    async getStatus(repoUri) {
        try {
            // Try to get git extension
            const gitExtension = external_vscode_.extensions.getExtension('vscode.git')?.exports;
            if (gitExtension) {
                const api = gitExtension.getAPI(1);
                if (api) {
                    const repo = api.repositories.find((r) => r.rootUri.toString() === repoUri.toString());
                    if (repo) {
                        // Combine working tree and index changes
                        return [
                            ...repo.state.workingTreeChanges,
                            ...repo.state.indexChanges
                        ];
                    }
                }
            }
        }
        catch (error) {
            console.error('Error getting repository status:', error);
        }
        return [];
    }
    /**
     * Commit changes
     * @param repoUri Repository URI
     * @param message Commit message
     * @param stagedOnly Whether to commit only staged changes
     * @returns Promise that resolves when the commit is complete
     */
    async commit(repoUri, message, stagedOnly) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await external_vscode_.commands.executeCommand('git.commit', {
                repository: repoUri.toString(),
                message: message,
                stagedOnly: stagedOnly || false
            });
        }
        catch (error) {
            console.error('Error committing changes:', error);
            // Fallback to default git command if the repository-specific command fails
            await external_vscode_.commands.executeCommand('git.commit', stagedOnly);
        }
    }
    /**
     * Create a new branch
     * @param repoUri Repository URI
     * @param name Branch name
     * @param checkout Whether to checkout the new branch
     * @returns Promise that resolves when the branch is created
     */
    async createBranch(repoUri, name, checkout) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await external_vscode_.commands.executeCommand('git.branch', {
                repository: repoUri.toString(),
                name: name,
                checkout: checkout || false
            });
        }
        catch (error) {
            console.error('Error creating branch:', error);
            // Fallback to default git command if the repository-specific command fails
            await external_vscode_.commands.executeCommand('git.createBranch', name);
        }
    }
    /**
     * Checkout a branch
     * @param repoUri Repository URI
     * @param name Branch name
     * @returns Promise that resolves when the branch is checked out
     */
    async checkoutBranch(repoUri, name) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await external_vscode_.commands.executeCommand('git.checkout', {
                repository: repoUri.toString(),
                name: name
            });
        }
        catch (error) {
            console.error('Error checking out branch:', error);
            // Fallback to default git command if the repository-specific command fails
            await external_vscode_.commands.executeCommand('git.checkout', name);
        }
    }
    /**
     * Pull changes
     * @param repoUri Repository URI
     * @returns Promise that resolves when the pull is complete
     */
    async pull(repoUri) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await external_vscode_.commands.executeCommand('git.pull', {
                repository: repoUri.toString()
            });
        }
        catch (error) {
            console.error('Error pulling changes:', error);
            // Fallback to default git command if the repository-specific command fails
            await external_vscode_.commands.executeCommand('git.pull');
        }
    }
    /**
     * Push changes
     * @param repoUri Repository URI
     * @param forcePush Whether to force push
     * @returns Promise that resolves when the push is complete
     */
    async push(repoUri, forcePush) {
        // This implementation now correctly handles the repository URI parameter
        try {
            await external_vscode_.commands.executeCommand('git.push', {
                repository: repoUri.toString(),
                forcePush: forcePush || false
            });
        }
        catch (error) {
            console.error('Error pushing changes:', error);
            // Fallback to default git command if the repository-specific command fails
            await external_vscode_.commands.executeCommand('git.push', forcePush ? '--force' : undefined);
        }
    }
}
/**
 * Implementation of the Workspace API
 */
class WorkspaceAPIImpl {
    /**
     * Get workspace folders
     * @returns Workspace folders or undefined if none
     */
    getWorkspaceFolders() {
        return external_vscode_.workspace.workspaceFolders;
    }
    /**
     * Find files matching a glob pattern
     * @param include Include pattern
     * @param exclude Exclude pattern
     * @returns Promise that resolves to an array of matching file URIs
     */
    async findFiles(include, exclude) {
        return await external_vscode_.workspace.findFiles(include, exclude);
    }
    /**
     * Save all dirty editors
     * @param includeUntitled Whether to include untitled documents
     * @returns Promise that resolves to true if all files were saved
     */
    async saveAll(includeUntitled) {
        return await external_vscode_.workspace.saveAll(includeUntitled);
    }
    /**
     * Open a text document
     * @param uri Document URI
     * @returns Promise that resolves to the opened document
     */
    async openTextDocument(uri) {
        return await external_vscode_.workspace.openTextDocument(uri);
    }
    /**
     * Create a file system watcher
     * @param globPattern Glob pattern to watch
     * @param ignoreCreateEvents Whether to ignore create events
     * @param ignoreChangeEvents Whether to ignore change events
     * @param ignoreDeleteEvents Whether to ignore delete events
     * @returns File system watcher
     */
    createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents) {
        return external_vscode_.workspace.createFileSystemWatcher(globPattern, ignoreCreateEvents, ignoreChangeEvents, ignoreDeleteEvents);
    }
    /**
     * Register a text document content provider
     * @param scheme URI scheme
     * @param provider Content provider
     * @returns Disposable for unregistering
     */
    registerTextDocumentContentProvider(scheme, provider) {
        return external_vscode_.workspace.registerTextDocumentContentProvider(scheme, provider);
    }
}
/**
 * Implementation of the Debug API
 */
class DebugAPIImpl {
    /**
     * Register a debug adapter descriptor factory
     * @param debugType Debug type
     * @param factory Factory implementation
     * @returns Disposable for unregistering
     */
    registerDebugAdapterDescriptorFactory(debugType, factory) {
        return external_vscode_.debug.registerDebugAdapterDescriptorFactory(debugType, factory);
    }
    /**
     * Start debugging
     * @param folder Workspace folder
     * @param nameOrConfig Debug configuration name or configuration object
     * @returns Promise that resolves to true if debugging started
     */
    async startDebugging(folder, nameOrConfig) {
        return await external_vscode_.debug.startDebugging(folder, nameOrConfig);
    }
    /**
     * Add breakpoints
     * @param breakpoints Breakpoints to add
     */
    addBreakpoints(breakpoints) {
        external_vscode_.debug.addBreakpoints(breakpoints);
    }
    /**
     * Remove breakpoints
     * @param breakpoints Breakpoints to remove
     */
    removeBreakpoints(breakpoints) {
        external_vscode_.debug.removeBreakpoints(breakpoints);
    }
    /**
     * Get current debug session
     * @returns Active debug session or undefined if none
     */
    getActiveDebugSession() {
        return external_vscode_.debug.activeDebugSession;
    }
}
/**
 * Implementation of the Plugin API
 */
class PluginAPIImpl {
    _llmService;
    _memoryService;
    events;
    vscode = external_vscode_;
    llm;
    memory;
    ui;
    fs;
    git;
    workspace;
    debug;
    /**
     * Creates a new Plugin API implementation
     * @param _llmService LLM service
     * @param _memoryService Memory service
     * @param _events Event emitter
     */
    constructor(_llmService, _memoryService, events) {
        this._llmService = _llmService;
        this._memoryService = _memoryService;
        this.events = events;
        // Initialize API implementations
        this.llm = new LLMServiceAPIImpl(_llmService);
        this.memory = new MemoryServiceAPIImpl(_memoryService);
        this.ui = new UIServiceAPIImpl();
        this.fs = new FileSystemAPIImpl();
        this.git = new GitServiceAPIImpl();
        this.workspace = new WorkspaceAPIImpl();
        this.debug = new DebugAPIImpl();
    }
    /**
     * Register a command with VSCode
     * @param command Command ID
     * @param callback Command implementation
     * @param thisArg 'this' context for the callback
     * @returns Disposable for unregistering the command
     */
    registerCommand(command, callback, thisArg) {
        return external_vscode_.commands.registerCommand(command, callback, thisArg);
    }
    /**
     * Execute a command
     * @param command Command ID
     * @param args Command arguments
     * @returns Promise that resolves to the command result
     */
    async executeCommand(command, ...args) {
        return await external_vscode_.commands.executeCommand(command, ...args);
    }
    /**
     * Get configuration section
     * @param section Configuration section name
     * @returns Configuration object
     */
    getConfiguration(section) {
        return external_vscode_.workspace.getConfiguration(section);
    }
}

;// ./src/plugins/core/events.ts
/**
 * Implementation of EventEmitter interface
 */
class EventEmitterImpl {
    _eventId = 0;
    _handlers = new Map();
    /**
     * Subscribe to events
     * @param filter Optional filter to limit which events are received
     * @param handler Event handler function
     * @returns Disposable for unsubscribing
     */
    on(filter, handler) {
        const handlerId = `handler_${++this._eventId}`;
        this._handlers.set(handlerId, { filter, handler });
        return {
            dispose: () => {
                this._handlers.delete(handlerId);
            }
        };
    }
    /**
     * Subscribe to a single event occurrence
     * @param filter Optional filter to limit which events are received
     * @param handler Event handler function
     * @returns Disposable for unsubscribing
     */
    once(filter, handler) {
        const handlerId = `once_handler_${++this._eventId}`;
        // Create a wrapper handler that self-disposes after one execution
        const onceHandler = (event) => {
            // Call the original handler
            handler(event);
            // Self-dispose after execution
            this._handlers.delete(handlerId);
        };
        this._handlers.set(handlerId, { filter, handler: onceHandler });
        return {
            dispose: () => {
                this._handlers.delete(handlerId);
            }
        };
    }
    /**
     * Emit an event
     * @param type Event type
     * @param payload Event payload
     * @param source Event source (defaults to 'system')
     * @returns The emitted event data
     */
    emit(type, payload, source = 'system') {
        // Create event data
        const event = {
            id: `event_${Date.now()}_${++this._eventId}`,
            source,
            type,
            timestamp: new Date(),
            payload
        };
        // Call all handlers that match the filter
        for (const { filter, handler } of this._handlers.values()) {
            if (this._matchesFilter(event, filter)) {
                try {
                    handler(event);
                }
                catch (error) {
                    console.error(`Error in event handler for ${event.type}:`, error);
                }
            }
        }
        return event;
    }
    /**
     * Check if an event matches a filter
     * @param event Event to check
     * @param filter Filter to apply (or null for all events)
     * @returns Whether the event matches the filter
     */
    _matchesFilter(event, filter) {
        // If no filter, match all events
        if (!filter) {
            return true;
        }
        // Check source filter
        if (filter.source !== undefined) {
            if (typeof filter.source === 'string') {
                if (event.source !== filter.source) {
                    return false;
                }
            }
            else if (filter.source instanceof RegExp) {
                if (!filter.source.test(event.source)) {
                    return false;
                }
            }
        }
        // Check type filter
        if (filter.type !== undefined) {
            if (typeof filter.type === 'string') {
                if (event.type !== filter.type) {
                    return false;
                }
            }
            else if (filter.type instanceof RegExp) {
                if (!filter.type.test(event.type)) {
                    return false;
                }
            }
        }
        // Passed all filters
        return true;
    }
}

;// ./src/plugins/types/plugin.ts
/**
 * Possible states for a plugin
 */
var PluginState;
(function (PluginState) {
    /** Plugin has been discovered but not registered yet */
    PluginState["Discovered"] = "discovered";
    /** Plugin is registered but not activated */
    PluginState["Registered"] = "registered";
    /** Plugin is currently being activated */
    PluginState["Activating"] = "activating";
    /** Plugin is active */
    PluginState["Active"] = "active";
    /** Plugin is currently being deactivated */
    PluginState["Deactivating"] = "deactivating";
    /** Plugin has been activated and is now deactivated */
    PluginState["Inactive"] = "inactive";
    /** Plugin activation failed */
    PluginState["ActivationFailed"] = "activation_failed";
    /** Plugin is disabled */
    PluginState["Disabled"] = "disabled";
})(PluginState || (PluginState = {}));
/**
 * Error thrown when plugin activation fails
 */
class PluginActivationError extends Error {
    pluginId;
    cause;
    constructor(pluginId, message, cause) {
        super(`Failed to activate plugin ${pluginId}: ${message}${cause ? ` (${cause.message})` : ''}`);
        this.pluginId = pluginId;
        this.cause = cause;
        this.name = 'PluginActivationError';
    }
}
/**
 * Supported plugin feature types
 */
var PluginFeatureType;
(function (PluginFeatureType) {
    // UI components
    PluginFeatureType["WebviewPanel"] = "webview_panel";
    PluginFeatureType["StatusBarItem"] = "status_bar_item";
    PluginFeatureType["TreeView"] = "tree_view";
    // Commands and actions
    PluginFeatureType["Command"] = "command";
    PluginFeatureType["ContextMenu"] = "context_menu";
    PluginFeatureType["KeyBinding"] = "key_binding";
    // Language features
    PluginFeatureType["CodeLens"] = "code_lens";
    PluginFeatureType["CompletionProvider"] = "completion_provider";
    PluginFeatureType["DiagnosticProvider"] = "diagnostic_provider";
    PluginFeatureType["FormattingProvider"] = "formatting_provider";
    // Other
    PluginFeatureType["Watcher"] = "watcher";
    PluginFeatureType["Task"] = "task";
    PluginFeatureType["Custom"] = "custom";
})(PluginFeatureType || (PluginFeatureType = {}));

;// ./src/plugins/core/loader.ts





/**
 * Manages loading and unloading of plugins
 */
class PluginLoader {
    _extensionContext;
    _registry;
    _pluginAPI;
    _internalPluginPath;
    _externalPluginPath = null;
    /**
     * Creates a new plugin loader
     * @param _extensionContext Extension context
     * @param _registry Plugin registry
     * @param _pluginAPI Plugin API
     */
    constructor(_extensionContext, _registry, _pluginAPI) {
        this._extensionContext = _extensionContext;
        this._registry = _registry;
        this._pluginAPI = _pluginAPI;
        // Set up plugin paths
        this._internalPluginPath = external_path_.join(_extensionContext.extensionPath, 'out', 'plugins', 'internal');
        // Load external plugin path from configuration
        const config = external_vscode_.workspace.getConfiguration('ape.plugins');
        const configuredPath = config.get('path', '');
        if (configuredPath) {
            this._externalPluginPath = configuredPath;
        }
        else {
            // Use default path in global storage
            this._externalPluginPath = external_path_.join(_extensionContext.globalStoragePath, 'plugins');
            // Create directory if it doesn't exist
            if (!(0,external_fs_.existsSync)(this._externalPluginPath)) {
                (0,external_fs_.mkdirSync)(this._externalPluginPath, { recursive: true });
            }
        }
        // Listen for configuration changes
        external_vscode_.workspace.onDidChangeConfiguration(event => {
            if (event.affectsConfiguration('ape.plugins.path')) {
                this._updateExternalPluginPath();
            }
        });
    }
    /**
     * Update external plugin path when configuration changes
     */
    _updateExternalPluginPath() {
        const config = external_vscode_.workspace.getConfiguration('ape.plugins');
        const configuredPath = config.get('path', '');
        if (configuredPath) {
            this._externalPluginPath = configuredPath;
        }
        else {
            this._externalPluginPath = external_path_.join(this._extensionContext.globalStoragePath, 'plugins');
        }
    }
    /**
     * Discover and load all internal plugins
     * @returns Promise that resolves to the number of plugins loaded
     */
    async loadInternalPlugins() {
        console.log('Loading internal plugins from:', this._internalPluginPath);
        try {
            const pluginDirs = await this._getDirectories(this._internalPluginPath);
            let loadedCount = 0;
            for (const dir of pluginDirs) {
                try {
                    const loaded = await this._loadPluginFromDirectory(external_path_.join(this._internalPluginPath, dir), true);
                    if (loaded) {
                        loadedCount++;
                    }
                }
                catch (error) {
                    console.error(`Error loading internal plugin from ${dir}:`, error);
                }
            }
            return loadedCount;
        }
        catch (error) {
            console.error('Error loading internal plugins:', error);
            return 0;
        }
    }
    /**
     * Discover and load all external plugins
     * @returns Promise that resolves to the number of plugins loaded
     */
    async loadExternalPlugins() {
        if (!this._externalPluginPath) {
            return 0;
        }
        console.log('Loading external plugins from:', this._externalPluginPath);
        try {
            const pluginDirs = await this._getDirectories(this._externalPluginPath);
            let loadedCount = 0;
            for (const dir of pluginDirs) {
                try {
                    const loaded = await this._loadPluginFromDirectory(external_path_.join(this._externalPluginPath, dir), false);
                    if (loaded) {
                        loadedCount++;
                    }
                }
                catch (error) {
                    console.error(`Error loading external plugin from ${dir}:`, error);
                }
            }
            return loadedCount;
        }
        catch (error) {
            console.error('Error loading external plugins:', error);
            return 0;
        }
    }
    /**
     * Load a plugin from a specific directory
     * @param pluginDir Plugin directory path
     * @param isInternal Whether this is an internal plugin
     * @returns Promise that resolves to true if the plugin was loaded
     */
    async _loadPluginFromDirectory(pluginDir, isInternal) {
        // Check for package.json
        const packageJsonPath = external_path_.join(pluginDir, 'package.json');
        if (!(0,external_fs_.existsSync)(packageJsonPath)) {
            console.log(`No package.json found in ${pluginDir}, skipping`);
            return false;
        }
        try {
            // Load package.json
            const packageJson = JSON.parse(await promises_namespaceObject.readFile(packageJsonPath, 'utf-8'));
            // Skip if this is not an APE plugin
            if (packageJson.apePlugin !== true) {
                console.log(`Directory ${pluginDir} is not an APE plugin, skipping`);
                return false;
            }
            // Extract metadata
            const metadata = {
                id: packageJson.name,
                name: packageJson.displayName || packageJson.name,
                version: packageJson.version || '0.0.1',
                description: packageJson.description,
                author: packageJson.author,
                dependencies: packageJson.apeDependencies || [],
                activationEvents: packageJson.activationEvents || [],
                features: packageJson.apeFeatures || [],
                configuration: packageJson.apeConfiguration,
                category: packageJson.category,
                isBuiltIn: isInternal,
                enabledByDefault: packageJson.enabledByDefault !== false
            };
            // Load the plugin implementation
            const mainModulePath = external_path_.join(pluginDir, packageJson.main || 'index.js');
            if (!(0,external_fs_.existsSync)(mainModulePath)) {
                throw new Error(`Plugin main module not found: ${mainModulePath}`);
            }
            // Use require() for webpack compatibility instead of dynamic import
            // This is still dynamic but uses CommonJS which webpack can handle better
            // eslint-disable-next-line @typescript-eslint/no-require-imports
            const pluginModule = __webpack_require__(2414)(mainModulePath);
            const pluginImpl = pluginModule.default || pluginModule;
            // Check if plugin implements required interface
            if (!pluginImpl || typeof pluginImpl.activate !== 'function') {
                throw new Error(`Plugin does not implement the required interface`);
            }
            // Register the plugin
            const pluginId = await this._registry.registerPlugin(pluginImpl, metadata);
            // Create storage path for the plugin
            const pluginStoragePath = external_path_.join(this._extensionContext.globalStoragePath, 'plugin-storage', pluginId);
            // Ensure storage directory exists
            if (!(0,external_fs_.existsSync)(pluginStoragePath)) {
                (0,external_fs_.mkdirSync)(pluginStoragePath, { recursive: true });
            }
            // Create plugin context
            const plugin = this._registry.getPlugin(pluginId);
            if (plugin) {
                const subscriptions = [];
                const context = {
                    extensionContext: this._extensionContext,
                    api: this._pluginAPI,
                    metadata,
                    storagePath: pluginStoragePath,
                    subscriptions,
                    log: (message, severity = 'info') => {
                        switch (severity) {
                            case 'info':
                                console.log(`[Plugin: ${pluginId}] ${message}`);
                                break;
                            case 'warn':
                                console.warn(`[Plugin: ${pluginId}] ${message}`);
                                break;
                            case 'error':
                                console.error(`[Plugin: ${pluginId}] ${message}`);
                                break;
                        }
                    },
                    getConfig: (key) => {
                        const config = external_vscode_.workspace.getConfiguration(`ape.plugins.${pluginId}`);
                        return config.get(key);
                    },
                    updateConfig: (key, value) => {
                        const config = external_vscode_.workspace.getConfiguration(`ape.plugins.${pluginId}`);
                        return Promise.resolve(config.update(key, value, external_vscode_.ConfigurationTarget.Global));
                    }
                };
                // Set the context on the plugin instance
                plugin.context = context;
                // Auto-activate if configured
                const autoActivate = external_vscode_.workspace.getConfiguration('ape.plugins')
                    .get('autoActivate', true);
                if (autoActivate && metadata.enabledByDefault !== false) {
                    // Queue activation to avoid blocking the loading process
                    setImmediate(() => {
                        this._registry.activatePlugin(pluginId).catch(error => {
                            console.error(`Error auto-activating plugin ${pluginId}:`, error);
                        });
                    });
                }
                return true;
            }
            return false;
        }
        catch (error) {
            console.error(`Error loading plugin from ${pluginDir}:`, error);
            return false;
        }
    }
    /**
     * Activate all plugins that match a specific activation event
     * @param activationEvent Activation event to match
     * @returns Promise that resolves to the number of plugins activated
     */
    async activatePluginsByEvent(activationEvent) {
        const plugins = this._registry.getAllPlugins().filter(plugin => plugin.state === PluginState.Registered &&
            plugin.metadata.activationEvents?.some(event => {
                // Exact match
                if (event === activationEvent) {
                    return true;
                }
                // Wildcard match
                if (event.endsWith('*')) {
                    const prefix = event.slice(0, -1);
                    return activationEvent.startsWith(prefix);
                }
                return false;
            }));
        let activatedCount = 0;
        for (const plugin of plugins) {
            try {
                const success = await this._registry.activatePlugin(plugin.id);
                if (success) {
                    activatedCount++;
                }
            }
            catch (error) {
                console.error(`Error activating plugin ${plugin.id} for event ${activationEvent}:`, error);
            }
        }
        return activatedCount;
    }
    /**
     * Activate all registered plugins
     * @returns Promise that resolves to the number of plugins activated
     */
    async activateAllPlugins() {
        const plugins = this._registry.getAllPlugins().filter(plugin => plugin.state === PluginState.Registered);
        let activatedCount = 0;
        for (const plugin of plugins) {
            try {
                const success = await this._registry.activatePlugin(plugin.id);
                if (success) {
                    activatedCount++;
                }
            }
            catch (error) {
                console.error(`Error activating plugin ${plugin.id}:`, error);
            }
        }
        return activatedCount;
    }
    /**
     * Deactivate all active plugins
     * @returns Promise that resolves to the number of plugins deactivated
     */
    async deactivateAllPlugins() {
        const activePlugins = this._registry.getActivePlugins();
        let deactivatedCount = 0;
        for (const plugin of activePlugins) {
            try {
                const success = await this._registry.deactivatePlugin(plugin.id);
                if (success) {
                    deactivatedCount++;
                }
            }
            catch (error) {
                console.error(`Error deactivating plugin ${plugin.id}:`, error);
            }
        }
        return deactivatedCount;
    }
    /**
     * Helper function to get directories in a path
     * @param dirPath Directory path to scan
     * @returns Promise that resolves to an array of directory names
     */
    async _getDirectories(dirPath) {
        try {
            const entries = await promises_namespaceObject.readdir(dirPath, { withFileTypes: true });
            return entries
                .filter(entry => entry.isDirectory())
                .map(entry => entry.name);
        }
        catch (error) {
            if (error.code === 'ENOENT') {
                // Directory doesn't exist, return empty array
                return [];
            }
            throw error;
        }
    }
}

;// ./src/plugins/core/registry.ts


/**
 * Implementation of the Plugin Registry
 */
class PluginRegistryImpl {
    _eventEmitter;
    /** Maps plugin IDs to plugin instances */
    _plugins = new Map();
    /** Event emitters for plugin state changes */
    _stateChangeEmitter = new external_vscode_.EventEmitter();
    /** Observable for plugin state changes */
    onDidChangePluginState = (listener) => {
        return this._stateChangeEmitter.event(e => listener(e.pluginId, e.oldState, e.newState));
    };
    /**
     * Creates a new plugin registry
     * @param _eventEmitter Event emitter for plugin events
     */
    constructor(_eventEmitter) {
        this._eventEmitter = _eventEmitter;
    }
    /**
     * Register a plugin with the registry
     * @param plugin Plugin implementation
     * @param metadata Plugin metadata
     * @returns Promise that resolves to the plugin ID
     */
    async registerPlugin(plugin, metadata) {
        // Check for duplicate plugin ID
        if (this._plugins.has(metadata.id)) {
            throw new Error(`Plugin with ID ${metadata.id} is already registered`);
        }
        // Create plugin instance
        const instance = {
            id: metadata.id,
            metadata,
            implementation: plugin,
            state: PluginState.Registered
        };
        // Add to registry
        this._plugins.set(metadata.id, instance);
        // Emit event
        this._eventEmitter.emit('plugin:registered', {
            pluginId: metadata.id,
            metadata
        });
        return metadata.id;
    }
    /**
     * Unregister a plugin from the registry
     * @param pluginId Plugin ID to unregister
     * @returns Promise that resolves to true if successful
     */
    async unregisterPlugin(pluginId) {
        const plugin = this._plugins.get(pluginId);
        if (!plugin) {
            return false;
        }
        // Deactivate plugin if it's active
        if (plugin.state === PluginState.Active) {
            await this.deactivatePlugin(pluginId);
        }
        // Remove from registry
        this._plugins.delete(pluginId);
        // Emit event
        this._eventEmitter.emit('plugin:unregistered', {
            pluginId
        });
        return true;
    }
    /**
     * Activate a plugin
     * @param pluginId Plugin ID to activate
     * @returns Promise that resolves to true if successful
     */
    async activatePlugin(pluginId) {
        const plugin = this._plugins.get(pluginId);
        if (!plugin) {
            return false;
        }
        // Check if already active or activating
        if (plugin.state === PluginState.Active) {
            return true;
        }
        if (plugin.state === PluginState.Activating) {
            return false; // Already activating
        }
        // Update state to activating
        this._changePluginState(plugin, PluginState.Activating);
        try {
            // Check and activate dependencies if needed
            if (plugin.metadata.dependencies?.length) {
                for (const depId of plugin.metadata.dependencies) {
                    const dependency = this._plugins.get(depId);
                    if (!dependency) {
                        throw new PluginActivationError(pluginId, `Missing dependency: ${depId}`);
                    }
                    if (dependency.state !== PluginState.Active) {
                        const success = await this.activatePlugin(depId);
                        if (!success) {
                            throw new PluginActivationError(pluginId, `Failed to activate dependency: ${depId}`);
                        }
                    }
                }
            }
            // Context will be provided by PluginLoader
            if (!plugin.context) {
                throw new PluginActivationError(pluginId, 'Plugin context not set. This is likely an internal error.');
            }
            // Activate the plugin
            await plugin.implementation.activate(plugin.context);
            // Update state to active
            this._changePluginState(plugin, PluginState.Active);
            // Emit event
            this._eventEmitter.emit('plugin:activated', {
                pluginId,
                metadata: plugin.metadata
            });
            return true;
        }
        catch (error) {
            // Update state to activation failed
            plugin.error = error instanceof Error ? error : new Error(String(error));
            this._changePluginState(plugin, PluginState.ActivationFailed);
            // Emit failure event
            this._eventEmitter.emit('plugin:activation:failed', {
                pluginId,
                error: plugin.error
            });
            return false;
        }
    }
    /**
     * Deactivate a plugin
     * @param pluginId Plugin ID to deactivate
     * @returns Promise that resolves to true if successful
     */
    async deactivatePlugin(pluginId) {
        const plugin = this._plugins.get(pluginId);
        if (!plugin) {
            return false;
        }
        // Check if already inactive or deactivating
        if (plugin.state === PluginState.Inactive ||
            plugin.state === PluginState.Registered ||
            plugin.state === PluginState.Discovered) {
            return true;
        }
        if (plugin.state === PluginState.Deactivating) {
            return false; // Already deactivating
        }
        // Check if this plugin is a dependency of any active plugins
        const activePlugins = this.getPluginsByState(PluginState.Active);
        const dependents = activePlugins.filter(p => p.metadata.dependencies?.includes(pluginId));
        // Deactivate dependents first
        for (const dependent of dependents) {
            await this.deactivatePlugin(dependent.id);
        }
        // Update state to deactivating
        this._changePluginState(plugin, PluginState.Deactivating);
        try {
            // Call deactivate if implemented
            if (plugin.implementation.deactivate) {
                await plugin.implementation.deactivate();
            }
            // Dispose context subscriptions
            if (plugin.context) {
                for (const subscription of plugin.context.subscriptions) {
                    try {
                        subscription.dispose();
                    }
                    catch (error) {
                        console.error(`Error disposing subscription for plugin ${pluginId}:`, error);
                    }
                }
            }
            // Update state to inactive
            this._changePluginState(plugin, PluginState.Inactive);
            // Clear error if previously failed
            delete plugin.error;
            // Emit event
            this._eventEmitter.emit('plugin:deactivated', {
                pluginId,
                metadata: plugin.metadata
            });
            return true;
        }
        catch (error) {
            // Still mark as inactive, but keep error
            plugin.error = error instanceof Error ? error : new Error(String(error));
            this._changePluginState(plugin, PluginState.Inactive);
            // Emit warning event
            this._eventEmitter.emit('plugin:deactivation:warning', {
                pluginId,
                error: plugin.error
            });
            // Still return true because the plugin is now inactive
            return true;
        }
    }
    /**
     * Check if a plugin is active
     * @param pluginId Plugin ID to check
     * @returns Whether the plugin is active
     */
    isPluginActive(pluginId) {
        const plugin = this._plugins.get(pluginId);
        return plugin?.state === PluginState.Active;
    }
    /**
     * Get a plugin instance by ID
     * @param pluginId Plugin ID to get
     * @returns Plugin instance or undefined if not found
     */
    getPlugin(pluginId) {
        return this._plugins.get(pluginId);
    }
    /**
     * Get all registered plugins
     * @returns Array of all plugin instances
     */
    getAllPlugins() {
        return Array.from(this._plugins.values());
    }
    /**
     * Get plugins by state
     * @param state State to filter by
     * @returns Array of matching plugin instances
     */
    getPluginsByState(state) {
        return Array.from(this._plugins.values()).filter(p => p.state === state);
    }
    /**
     * Get active plugins only
     * @returns Array of active plugin instances
     */
    getActivePlugins() {
        return this.getPluginsByState(PluginState.Active);
    }
    /**
     * Update a plugin's state and emit change event
     * @param plugin Plugin instance to update
     * @param newState New state to set
     */
    _changePluginState(plugin, newState) {
        const oldState = plugin.state;
        plugin.state = newState;
        // Emit event for state change
        this._stateChangeEmitter.fire({
            pluginId: plugin.id,
            oldState,
            newState
        });
    }
}

;// ./src/plugins/core/settings.ts

/**
 * Implementation of PluginSettingsManager
 */
class PluginSettingsManagerImpl {
    _extensionContext;
    // Map of registered schemas by plugin ID
    _schemas = new Map();
    // Map of configuration change listeners
    _listeners = new Map();
    /**
     * Creates a new PluginSettingsManager
     * @param _extensionContext Extension context
     */
    constructor(_extensionContext) {
        this._extensionContext = _extensionContext;
        // Listen for configuration changes
        external_vscode_.workspace.onDidChangeConfiguration(this._handleConfigChange, this);
    }
    /**
     * Register configuration schema for a plugin
     * @param pluginId Plugin ID
     * @param schema Settings schema
     */
    registerSettings(pluginId, schema) {
        this._schemas.set(pluginId, schema);
        // TODO: Register settings with VSCode dynamically
        // This is normally done via package.json, but for dynamically loaded plugins
        // we might need a different approach
    }
    /**
     * Get configuration for a plugin
     * @param pluginId Plugin ID
     * @returns Configuration object
     */
    getConfiguration(pluginId) {
        return external_vscode_.workspace.getConfiguration(`ape.plugins.${pluginId}`);
    }
    /**
     * Get a specific setting value
     * @param pluginId Plugin ID
     * @param key Setting key
     * @param defaultValue Default value if setting is not found
     * @returns Setting value or default value
     */
    get(pluginId, key, defaultValue) {
        const config = this.getConfiguration(pluginId);
        return config.get(key, defaultValue);
    }
    /**
     * Update a specific setting value
     * @param pluginId Plugin ID
     * @param key Setting key
     * @param value New value
     * @param configurationTarget Where to update the setting
     * @returns Promise that resolves when the update is complete
     */
    async update(pluginId, key, value, configurationTarget = external_vscode_.ConfigurationTarget.Global) {
        const config = this.getConfiguration(pluginId);
        await config.update(key, value, configurationTarget);
    }
    /**
     * Listen for setting changes
     * @param pluginId Plugin ID
     * @param key Setting key
     * @param callback Callback function invoked when the setting changes
     * @returns Disposable for unsubscribing
     */
    onDidChangeConfiguration(pluginId, key, callback) {
        // Get current value as baseline
        const initialValue = this.get(pluginId, key);
        // Create a disposable to manage this listener
        const disposable = {
            dispose: () => {
                // Remove this listener from our records
                const listeners = this._listeners.get(pluginId) || [];
                const index = listeners.findIndex(l => l === disposable);
                if (index !== -1) {
                    listeners.splice(index, 1);
                }
                this._listeners.set(pluginId, listeners);
            }
        };
        // Add to our listeners
        const listeners = this._listeners.get(pluginId) || [];
        listeners.push(disposable);
        this._listeners.set(pluginId, listeners);
        // Store state for this listener
        disposable._lastValue = initialValue;
        disposable._pluginId = pluginId;
        disposable._key = key;
        disposable._callback = callback;
        return disposable;
    }
    /**
     * Handle configuration changes
     * @param event Configuration change event
     */
    _handleConfigChange(event) {
        // Check each plugin and its listeners
        for (const [pluginId, listeners] of this._listeners.entries()) {
            const configSection = `ape.plugins.${pluginId}`;
            if (event.affectsConfiguration(configSection)) {
                // Configuration for this plugin has changed
                for (const listener of listeners) {
                    // Get stored properties
                    const key = listener._key;
                    const lastValue = listener._lastValue;
                    const callback = listener._callback;
                    // Check if this specific key was affected
                    if (event.affectsConfiguration(`${configSection}.${key}`)) {
                        // Get the new value
                        const newValue = this.get(pluginId, key);
                        // Only notify if value actually changed
                        if (JSON.stringify(newValue) !== JSON.stringify(lastValue)) {
                            // Update stored last value
                            listener._lastValue = newValue;
                            // Call the callback with the new value
                            try {
                                callback(newValue);
                            }
                            catch (error) {
                                console.error(`Error in settings change listener for ${pluginId}.${key}:`, error);
                            }
                        }
                    }
                }
            }
        }
    }
    /**
     * Dispose of all listeners
     */
    dispose() {
        // Clear all listeners
        this._listeners.clear();
        this._schemas.clear();
    }
}

;// ./src/plugins/core/index.ts
// Export plugin core components






;// ./src/core/services/rulesService.ts
/**
 * APE Rules ì„œë¹„ìŠ¤
 *
 * Rules íŒŒì¼ì„ ê´€ë¦¬í•˜ê³  LLM ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ì— ì ìš©í•˜ëŠ” ì„œë¹„ìŠ¤ìž…ë‹ˆë‹¤.
 * Rules ìƒì„±, ì‚­ì œ, í™œì„±í™”/ë¹„í™œì„±í™” ê¸°ëŠ¥ì„ ì œê³µí•©ë‹ˆë‹¤.
 */




/**
 * Rule í•­ëª© ìƒíƒœ
 */
var RuleStatus;
(function (RuleStatus) {
    RuleStatus["Active"] = "active";
    RuleStatus["Inactive"] = "inactive";
})(RuleStatus || (RuleStatus = {}));
/**
 * Rules ì„œë¹„ìŠ¤ í´ëž˜ìŠ¤
 */
class RulesService {
    context;
    configManager;
    _onDidChangeRules = new external_vscode_.EventEmitter();
    onDidChangeRules = this._onDidChangeRules.event;
    rules = new Map();
    disposables = [];
    rulesDir;
    /**
     * ìƒì„±ìž
     * @param context VSCode í™•ìž¥ ì»¨í…ìŠ¤íŠ¸
     * @param configManager ì„œë¹„ìŠ¤ ì„¤ì • ê´€ë¦¬ìž (ì˜µì…˜)
     */
    constructor(context, configManager) {
        this.context = context;
        this.configManager = configManager;
        // Rules ë””ë ‰í† ë¦¬ ì„¤ì •
        this.rulesDir = external_path_.join(this.context.globalStorageUri.fsPath, 'rules');
        // Rules ë””ë ‰í† ë¦¬ ìƒì„± (ì—†ëŠ” ê²½ìš°)
        this.ensureRulesDir();
        // ì„¤ì • ë³€ê²½ ì´ë²¤íŠ¸ êµ¬ë…
        this.disposables.push(external_vscode_.workspace.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('ape.rules')) {
                this.loadAllRules();
            }
        }));
        // íŒŒì¼ ì‹œìŠ¤í…œ ë³€ê²½ ê°ì§€
        const watcher = external_vscode_.workspace.createFileSystemWatcher(new external_vscode_.RelativePattern(this.rulesDir, '**/*.md'));
        this.disposables.push(watcher, watcher.onDidCreate(() => this.loadAllRules()), watcher.onDidDelete(() => this.loadAllRules()), watcher.onDidChange(() => this.loadAllRules()));
        // ì´ˆê¸° Rules ë¡œë“œ
        this.loadAllRules();
    }
    /**
     * Rules ë””ë ‰í† ë¦¬ í™•ì¸ ë° ìƒì„±
     */
    ensureRulesDir() {
        if (!external_fs_.existsSync(this.rulesDir)) {
            external_fs_.mkdirSync(this.rulesDir, { recursive: true });
        }
    }
    /**
     * ëª¨ë“  Rules ë¡œë“œ
     */
    async loadAllRules() {
        try {
            this.ensureRulesDir();
            this.rules.clear();
            // Rules ë””ë ‰í† ë¦¬ì˜ ëª¨ë“  .md íŒŒì¼ ì½ê¸°
            const files = external_fs_.readdirSync(this.rulesDir).filter(file => file.endsWith('.md'));
            // ì„¤ì •ì—ì„œ í™œì„±í™”ëœ Rules ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            const config = external_vscode_.workspace.getConfiguration('ape.rules');
            const activeRules = config.get('activeRules', []);
            // ê° íŒŒì¼ì„ Rule ê°ì²´ë¡œ ë³€í™˜
            for (const file of files) {
                const filePath = external_path_.join(this.rulesDir, file);
                const fileStats = external_fs_.statSync(filePath);
                const content = external_fs_.readFileSync(filePath, 'utf-8');
                // íŒŒì¼ëª…ì—ì„œ í™•ìž¥ìž ì œê±°í•˜ì—¬ ID ìƒì„±
                const id = external_path_.basename(file, '.md');
                // Rule ê°ì²´ ìƒì„±
                const rule = {
                    id,
                    name: this.extractNameFromContent(content) || id,
                    filePath,
                    content,
                    status: activeRules.includes(id) ? RuleStatus.Active : RuleStatus.Inactive,
                    createdAt: fileStats.birthtime,
                    updatedAt: fileStats.mtime
                };
                // Rules ë§µì— ì¶”ê°€
                this.rules.set(id, rule);
            }
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeRules.fire();
        }
        catch (error) {
            console.error('Rules ë¡œë“œ ì˜¤ë¥˜:', error);
            external_vscode_.window.showErrorMessage(`Rules ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`);
        }
    }
    /**
     * íŒŒì¼ ë‚´ìš©ì—ì„œ ì´ë¦„ ì¶”ì¶œ (ì²« ë²ˆì§¸ ì œëª© ì‚¬ìš©)
     * @param content íŒŒì¼ ë‚´ìš©
     */
    extractNameFromContent(content) {
        // ë§ˆí¬ë‹¤ìš´ ì œëª© í˜•ì‹(#ìœ¼ë¡œ ì‹œìž‘í•˜ëŠ” ë¼ì¸) ì°¾ê¸°
        const titleMatch = content.match(/^#\s+(.+)$/m);
        if (titleMatch && titleMatch[1]) {
            return titleMatch[1].trim();
        }
        return null;
    }
    /**
     * ëª¨ë“  Rules ê°€ì ¸ì˜¤ê¸°
     */
    getAllRules() {
        return Array.from(this.rules.values());
    }
    /**
     * í™œì„±í™”ëœ Rules ê°€ì ¸ì˜¤ê¸°
     */
    getActiveRules() {
        return this.getAllRules().filter(rule => rule.status === RuleStatus.Active);
    }
    /**
     * IDë¡œ Rule ê°€ì ¸ì˜¤ê¸°
     * @param id Rule ID
     */
    getRuleById(id) {
        return this.rules.get(id);
    }
    /**
     * Rule ìƒì„±
     * @param name Rule ì´ë¦„
     * @param content Rule ë‚´ìš©
     * @param activate ìƒì„± í›„ í™œì„±í™” ì—¬ë¶€
     */
    async createRule(name, content, activate = false) {
        try {
            this.ensureRulesDir();
            // íŒŒì¼ëª…ìœ¼ë¡œ ì‚¬ìš©í•  ID ìƒì„± (ê³µë°±ì€ í•˜ì´í”ˆìœ¼ë¡œ ë³€í™˜)
            const id = name.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '');
            // ì´ë¯¸ ì¡´ìž¬í•˜ëŠ” IDì¸ì§€ í™•ì¸
            if (this.rules.has(id)) {
                throw new ServiceError(`ì´ë¯¸ ì¡´ìž¬í•˜ëŠ” Rule ì´ë¦„ìž…ë‹ˆë‹¤: ${name}`, 'rule-already-exists');
            }
            // ë§ˆí¬ë‹¤ìš´ ë‚´ìš©ì´ ì œëª©ìœ¼ë¡œ ì‹œìž‘í•˜ì§€ ì•Šìœ¼ë©´ ì œëª© ì¶”ê°€
            let finalContent = content;
            if (!content.trim().startsWith('#')) {
                finalContent = `# ${name}\n\n${content}`;
            }
            // íŒŒì¼ ê²½ë¡œ ìƒì„±
            const filePath = external_path_.join(this.rulesDir, `${id}.md`);
            // íŒŒì¼ ìž‘ì„±
            external_fs_.writeFileSync(filePath, finalContent, 'utf-8');
            // Rule ê°ì²´ ìƒì„±
            const rule = {
                id,
                name,
                filePath,
                content: finalContent,
                status: RuleStatus.Inactive,
                createdAt: new Date(),
                updatedAt: new Date()
            };
            // Rules ë§µì— ì¶”ê°€
            this.rules.set(id, rule);
            // í™œì„±í™” ìš”ì²­ì´ ìžˆìœ¼ë©´ í™œì„±í™”
            if (activate) {
                await this.activateRule(id);
            }
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeRules.fire();
            return rule;
        }
        catch (error) {
            console.error('Rule ìƒì„± ì˜¤ë¥˜:', error);
            throw new ServiceError(`Rule ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'rule-creation-failed');
        }
    }
    /**
     * Rule ì—…ë°ì´íŠ¸
     * @param id Rule ID
     * @param updates ì—…ë°ì´íŠ¸í•  í•„ë“œ
     */
    async updateRule(id, updates) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new ServiceError(`IDê°€ ${id}ì¸ Ruleì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'rule-not-found');
            }
            // ì´ë¦„ ë˜ëŠ” ë‚´ìš© ì—…ë°ì´íŠ¸
            let updatedContent = rule.content;
            let updatedName = rule.name;
            if (updates.name) {
                updatedName = updates.name;
                // ë‚´ìš© ì—…ë°ì´íŠ¸ ì—†ì´ ì´ë¦„ë§Œ ë³€ê²½í•˜ëŠ” ê²½ìš° ë§ˆí¬ë‹¤ìš´ ì œëª© ì—…ë°ì´íŠ¸
                if (!updates.content) {
                    const titleRegex = /^#\s+(.+)$/m;
                    if (titleRegex.test(updatedContent)) {
                        updatedContent = updatedContent.replace(titleRegex, `# ${updatedName}`);
                    }
                    else {
                        updatedContent = `# ${updatedName}\n\n${updatedContent}`;
                    }
                }
            }
            if (updates.content) {
                updatedContent = updates.content;
                // ë‚´ìš©ì— ì œëª©ì´ ì—†ìœ¼ë©´ ì¶”ê°€
                if (!updatedContent.trim().startsWith('#')) {
                    updatedContent = `# ${updatedName}\n\n${updatedContent}`;
                }
            }
            // íŒŒì¼ ì—…ë°ì´íŠ¸
            external_fs_.writeFileSync(rule.filePath, updatedContent, 'utf-8');
            // Rule ê°ì²´ ì—…ë°ì´íŠ¸
            const updatedRule = {
                ...rule,
                name: updatedName,
                content: updatedContent,
                updatedAt: new Date()
            };
            // Rules ë§µ ì—…ë°ì´íŠ¸
            this.rules.set(id, updatedRule);
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeRules.fire();
            return updatedRule;
        }
        catch (error) {
            console.error('Rule ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
            throw new ServiceError(`Rule ì—…ë°ì´íŠ¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'rule-update-failed');
        }
    }
    /**
     * Rule ì‚­ì œ
     * @param id Rule ID
     */
    async deleteRule(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new ServiceError(`IDê°€ ${id}ì¸ Ruleì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'rule-not-found');
            }
            // í™œì„±í™”ëœ ê²½ìš° ë¹„í™œì„±í™”
            if (rule.status === RuleStatus.Active) {
                await this.deactivateRule(id);
            }
            // íŒŒì¼ ì‚­ì œ
            if (external_fs_.existsSync(rule.filePath)) {
                external_fs_.unlinkSync(rule.filePath);
            }
            // Rules ë§µì—ì„œ ì œê±°
            this.rules.delete(id);
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeRules.fire();
            return true;
        }
        catch (error) {
            console.error('Rule ì‚­ì œ ì˜¤ë¥˜:', error);
            throw new ServiceError(`Rule ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'rule-deletion-failed');
        }
    }
    /**
     * Rule í™œì„±í™”
     * @param id Rule ID
     */
    async activateRule(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new ServiceError(`IDê°€ ${id}ì¸ Ruleì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'rule-not-found');
            }
            // ì´ë¯¸ í™œì„±í™”ëœ ê²½ìš° ì²˜ë¦¬ ìƒëžµ
            if (rule.status === RuleStatus.Active) {
                return true;
            }
            // ì„¤ì •ì—ì„œ í™œì„±í™”ëœ Rules ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            const config = external_vscode_.workspace.getConfiguration('ape.rules');
            const activeRules = config.get('activeRules', []);
            // IDê°€ ëª©ë¡ì— ì—†ìœ¼ë©´ ì¶”ê°€
            if (!activeRules.includes(id)) {
                activeRules.push(id);
                await config.update('activeRules', activeRules, external_vscode_.ConfigurationTarget.Global);
            }
            // Rule ìƒíƒœ ì—…ë°ì´íŠ¸
            const updatedRule = {
                ...rule,
                status: RuleStatus.Active,
                updatedAt: new Date()
            };
            // Rules ë§µ ì—…ë°ì´íŠ¸
            this.rules.set(id, updatedRule);
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeRules.fire();
            return true;
        }
        catch (error) {
            console.error('Rule í™œì„±í™” ì˜¤ë¥˜:', error);
            throw new ServiceError(`Rule í™œì„±í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'rule-activation-failed');
        }
    }
    /**
     * Rule ë¹„í™œì„±í™”
     * @param id Rule ID
     */
    async deactivateRule(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new ServiceError(`IDê°€ ${id}ì¸ Ruleì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'rule-not-found');
            }
            // ì´ë¯¸ ë¹„í™œì„±í™”ëœ ê²½ìš° ì²˜ë¦¬ ìƒëžµ
            if (rule.status === RuleStatus.Inactive) {
                return true;
            }
            // ì„¤ì •ì—ì„œ í™œì„±í™”ëœ Rules ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            const config = external_vscode_.workspace.getConfiguration('ape.rules');
            const activeRules = config.get('activeRules', []);
            // IDê°€ ëª©ë¡ì— ìžˆìœ¼ë©´ ì œê±°
            const updatedActiveRules = activeRules.filter(activeId => activeId !== id);
            await config.update('activeRules', updatedActiveRules, external_vscode_.ConfigurationTarget.Global);
            // Rule ìƒíƒœ ì—…ë°ì´íŠ¸
            const updatedRule = {
                ...rule,
                status: RuleStatus.Inactive,
                updatedAt: new Date()
            };
            // Rules ë§µ ì—…ë°ì´íŠ¸
            this.rules.set(id, updatedRule);
            // ë³€ê²½ ì´ë²¤íŠ¸ ë°œìƒ
            this._onDidChangeRules.fire();
            return true;
        }
        catch (error) {
            console.error('Rule ë¹„í™œì„±í™” ì˜¤ë¥˜:', error);
            throw new ServiceError(`Rule ë¹„í™œì„±í™” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'rule-deactivation-failed');
        }
    }
    /**
     * Rules íŒŒì¼ ì—´ê¸°
     * @param id Rule ID
     */
    async openRuleFile(id) {
        try {
            const rule = this.rules.get(id);
            if (!rule) {
                throw new ServiceError(`IDê°€ ${id}ì¸ Ruleì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`, 'rule-not-found');
            }
            // VS Codeì—ì„œ íŒŒì¼ ì—´ê¸°
            const document = await external_vscode_.workspace.openTextDocument(rule.filePath);
            await external_vscode_.window.showTextDocument(document);
            return true;
        }
        catch (error) {
            console.error('Rule íŒŒì¼ ì—´ê¸° ì˜¤ë¥˜:', error);
            throw new ServiceError(`Rule íŒŒì¼ ì—´ê¸° ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error}`, 'rule-open-failed');
        }
    }
    /**
     * Rulesë¥¼ LLM ì‹œìŠ¤í…œ í”„ë¡¬í”„íŠ¸ë¡œ ë³€í™˜
     */
    getRulesAsSystemPrompt() {
        const activeRules = this.getActiveRules();
        if (activeRules.length === 0) {
            return '';
        }
        // í—¤ë” ì¶”ê°€
        let systemPrompt = '# APE Rules\n\n';
        systemPrompt += 'ë‹¤ìŒ ê·œì¹™ì„ í•­ìƒ ì¤€ìˆ˜í•˜ì„¸ìš”:\n\n';
        // ê° í™œì„±í™”ëœ Rule ë‚´ìš© ì¶”ê°€
        for (const rule of activeRules) {
            // ì œëª©ì´ ìžˆëŠ” ê²½ìš° ì œëª© ì œì™¸í•˜ê³  ë‚´ìš©ë§Œ ì¶”ê°€
            let content = rule.content;
            const titleMatch = content.match(/^#\s+(.+)$/m);
            if (titleMatch) {
                content = content.replace(titleMatch[0], '').trim();
            }
            systemPrompt += `## ${rule.name}\n\n${content}\n\n`;
        }
        return systemPrompt;
    }
    /**
     * ë¦¬ì†ŒìŠ¤ í•´ì œ
     */
    dispose() {
        this.disposables.forEach(d => d.dispose());
        this.disposables = [];
    }
}

;// ./src/extension.ts















// ê°œë°œ/í…ŒìŠ¤íŠ¸ í™˜ê²½ì—ì„œë§Œ ë¡œë”© (í”„ë¡œë•ì…˜ì—ì„œëŠ” ì¡°ê±´ë¶€ë¡œ ë¡œë”©)
let autoPermissionHandler = null;
if ( false || process.env.APE_TEST_MODE === 'true') {
    try {
        // ë™ì  ìž„í¬íŠ¸ë¡œ í…ŒìŠ¤íŠ¸ ëª¨ë“œì—ì„œë§Œ ë¡œë“œ
        __webpack_require__.e(/* import() */ 373).then(__webpack_require__.bind(__webpack_require__, 5373)).then(module => {
            autoPermissionHandler = module.autoPermissionHandler;
            console.log('ìžë™ ê¶Œí•œ í•¸ë“¤ëŸ¬ í™œì„±í™”ë¨ (í…ŒìŠ¤íŠ¸/ê°œë°œ ëª¨ë“œ)');
        }).catch(error => {
            console.error('ìžë™ ê¶Œí•œ í•¸ë“¤ëŸ¬ ë¡œë“œ ì‹¤íŒ¨:', error);
        });
    }
    catch (error) {
        console.log('ìžë™ ê¶Œí•œ í•¸ë“¤ëŸ¬ ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜ (ë¬´ì‹œë¨):', error);
    }
}
// Plugin system imports





/**
 * Initialize all core services
 * @param context Extension context
 * @returns ServiceContainer with all initialized services
 */
async function initializeServices(context) {
    // Create service config manager first
    const configManager = new ServiceConfigManager(context);
    // Create model manager (should be initialized before LLMService)
    const modelManager = new ModelManager(context);
    // Create core services with modelManager
    const llmService = new LLMService(context, modelManager); // Updated constructor
    const memoryService = new MemoryService(context);
    // Create objects in the correct initialization order
    // Create chatViewProvider
    const chatViewProvider = new MainChatViewProvider(context, llmService, memoryService, null, // Will be set after CommandManager is created
    modelManager);
    // Initialize Rules service
    const rulesService = new RulesService(context, configManager);
    // Initialize VAULT service
    const vaultService = new VaultService(context, configManager);
    // Initialize Jira service
    const jiraService = new JiraService(context, configManager);
    // Apply Rules and VAULT services to LLM service
    llmService.setRulesService(rulesService);
    llmService.setVaultService(vaultService);
    // Then create CommandManager with chatViewProvider and services
    const commandManager = new CommandManager(context, chatViewProvider, llmService, memoryService, modelManager, rulesService, vaultService, jiraService);
    // Now set the CommandManager reference in ChatViewProvider
    chatViewProvider._commandManager = commandManager;
    // Log debugging information
    console.log('ChatViewProvider ë° CommandManager ì´ˆê¸°í™” ì™„ë£Œ');
    // Initialize Git services
    const bitbucketService = new BitbucketService(context);
    const autoCommitService = new AutoCommitService(context, llmService, bitbucketService);
    const conflictSolver = new ConflictSolver(llmService);
    // Initialize completion providers
    const tabCompletionProvider = new TabCompletionProvider(llmService);
    const inlineCompletionProvider = new InlineCompletionProvider(llmService, context);
    // Initialize tree view data provider
    const treeDataProvider = new ApeTreeDataProvider(context, llmService, memoryService, undefined, // todoService
    vaultService, rulesService, jiraService);
    // Initialize version manager
    const versionManager = new VersionManager(context);
    // Initialize plugin system
    const pluginEventEmitter = new EventEmitterImpl();
    const pluginRegistry = new PluginRegistryImpl(pluginEventEmitter);
    const pluginAPI = new PluginAPIImpl(llmService, memoryService, pluginEventEmitter);
    const pluginLoader = new PluginLoader(context, pluginRegistry, pluginAPI);
    const pluginSettingsManager = new PluginSettingsManagerImpl(context);
    return {
        modelManager,
        llmService,
        memoryService,
        chatViewProvider,
        commandManager,
        bitbucketService,
        autoCommitService,
        conflictSolver,
        tabCompletionProvider,
        inlineCompletionProvider,
        treeDataProvider,
        versionManager,
        rulesService,
        vaultService,
        jiraService,
        configManager,
        pluginEventEmitter,
        pluginRegistry,
        pluginAPI,
        pluginLoader,
        pluginSettingsManager
    };
}
/**
 * Register VSCode components
 * @param context Extension context
 * @param services Service container
 */
function registerComponents(context, services) {
    // Register WebView provider
    const chatViewProviderRegistration = external_vscode_.window.registerWebviewViewProvider('apeChat', services.chatViewProvider, {
        webviewOptions: {
            retainContextWhenHidden: true
        }
    });
    // ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê·¸ ì¶”ê°€
    console.log('APE Chat View Providerê°€ ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤.');
    context.subscriptions.push(chatViewProviderRegistration);
    // ëª¨ë“  ëª…ë ¹ì–´ëŠ” CommandManagerë¥¼ í†µí•´ì„œë§Œ ë“±ë¡
    // ModelManagerì—ì„œ ëª…ë ¹ì–´ ë“±ë¡í•˜ëŠ” ë¶€ë¶„ ì œê±° (ì¤‘ë³µ ë“±ë¡ ë°©ì§€)
    services.commandManager.registerCommands();
    // Register code block insertion commands
    context.subscriptions.push(external_vscode_.commands.registerCommand('ape.insertCodeToEditor', (options) => {
        return CodeService.insertCodeToEditor(options);
    }), external_vscode_.commands.registerCommand('ape.createNewFileWithCode', (options) => {
        return CodeService.insertCodeToEditor({
            ...options,
            createNewFile: true
        });
    }));
    // Register Git commands
    context.subscriptions.push(external_vscode_.commands.registerCommand('ape.git.resolveConflict', async () => {
        const resolvedCount = await services.conflictSolver.resolveAllConflicts();
        external_vscode_.window.showInformationMessage(`${resolvedCount}ê°œ íŒŒì¼ì˜ ì¶©ëŒì„ í•´ê²°í–ˆìŠµë‹ˆë‹¤`);
    }));
    // Register tab completion for various languages
    context.subscriptions.push(external_vscode_.languages.registerCompletionItemProvider([
        { scheme: 'file', language: 'typescript' },
        { scheme: 'file', language: 'javascript' },
        { scheme: 'file', language: 'python' },
        { scheme: 'file', language: 'java' },
        { scheme: 'file', language: 'c' },
        { scheme: 'file', language: 'cpp' },
        { scheme: 'file', language: 'csharp' },
        { scheme: 'file', language: 'go' },
        { scheme: 'file', language: 'rust' },
        { scheme: 'file', language: 'php' },
        { scheme: 'file', language: 'ruby' },
        { scheme: 'file', language: 'html' },
        { scheme: 'file', language: 'css' },
        { scheme: 'file', language: 'json' },
        { scheme: 'file', language: 'markdown' }
    ], services.tabCompletionProvider, '\t' // Triggered by tab key
    ));
    // Register command completion
    context.subscriptions.push(external_vscode_.languages.registerCompletionItemProvider([{ scheme: 'file' }], services.tabCompletionProvider, '/' // Triggered by slash
    ));
    // Register inline completion provider
    context.subscriptions.push(external_vscode_.languages.registerInlineCompletionItemProvider([{ scheme: 'file' }], services.inlineCompletionProvider));
    // Register tree data provider with custom configuration
    const treeView = external_vscode_.window.createTreeView('apeNavigator', {
        treeDataProvider: services.treeDataProvider,
        showCollapseAll: true,
        canSelectMany: false // ë‹¤ì¤‘ ì„ íƒ ë°©ì§€ë¡œ UI ë‹¨ìˆœí™”
    });
    // Add command to set optimal view layout
    context.subscriptions.push(external_vscode_.commands.registerCommand('ape.setOptimalLayout', async () => {
        try {
            // ì‚¬ì´ë“œë°” í™•ì¸
            await external_vscode_.commands.executeCommand('workbench.view.extension.ape-sidebar');
            await new Promise(r => setTimeout(r, 100));
            // ì±„íŒ… ë·° í™œì„±í™”
            await external_vscode_.commands.executeCommand('apeChat.focus');
            await new Promise(r => setTimeout(r, 100));
            // ì‚¬ì´ë“œë°” í¬ê¸° ì¤„ì´ê¸° (íŠ¸ë¦¬ë·°ì— ë§žê²Œ)
            for (let i = 0; i < 6; i++) {
                await external_vscode_.commands.executeCommand('workbench.action.decreaseSideBarWidth');
                await new Promise(r => setTimeout(r, 30));
            }
            // ì±„íŒ…ë·° í¬ê¸° í‚¤ìš°ê¸°
            for (let i = 0; i < 3; i++) {
                await external_vscode_.commands.executeCommand('workbench.action.increaseViewSize');
                await new Promise(r => setTimeout(r, 30));
            }
            external_vscode_.window.showInformationMessage('APE ìµœì  ë ˆì´ì•„ì›ƒì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
        }
        catch (error) {
            console.error('ìµœì  ë ˆì´ì•„ì›ƒ ì„¤ì • ì‹¤íŒ¨:', error);
        }
    }));
    context.subscriptions.push(treeView);
    // Register version manager
    services.versionManager.registerCommands();
    // Register navigator commands
    context.subscriptions.push(external_vscode_.commands.registerCommand('ape.refreshNavigator', () => {
        services.treeDataProvider.refresh();
    }), external_vscode_.commands.registerCommand('ape.refreshTreeView', () => {
        services.treeDataProvider.refresh();
    }), external_vscode_.commands.registerCommand('ape.executeCommand', (commandInfo) => {
        if (!commandInfo || !commandInfo.name) {
            external_vscode_.window.showErrorMessage('ëª…ë ¹ì–´ ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
            return;
        }
        const commandText = commandInfo.args
            ? `/${commandInfo.name} ${commandInfo.args.join(' ')}`
            : `/${commandInfo.name}`;
        // ì§ì ‘ SlashCommandManagerë¡œ ëª…ë ¹ ì‹¤í–‰
        services.commandManager.slashCommandManager.executeCommand(commandText);
    }), external_vscode_.commands.registerCommand('ape.sendLlmResponse', (messageData) => {
        services.chatViewProvider.sendLlmResponse(messageData);
    }), external_vscode_.commands.registerCommand('ape.openSettings', (settingKey) => {
        if (settingKey) {
            external_vscode_.commands.executeCommand('workbench.action.openSettings', settingKey);
        }
        else {
            external_vscode_.commands.executeCommand('workbench.action.openSettings', 'ape');
        }
    }), external_vscode_.commands.registerCommand('ape.handleChatInput', (text) => {
        services.chatViewProvider.handleChatInput(text);
    }), external_vscode_.commands.registerCommand('ape.sendChatMessage', () => {
        external_vscode_.commands.executeCommand('ape.sendMessage');
    }), external_vscode_.commands.registerCommand('ape.showCommandSuggestions', (suggestions) => {
        // ì±„íŒ… ì¸í„°íŽ˜ì´ìŠ¤ì— ëª…ë ¹ì–´ ì œì•ˆ ì „ì†¡
        if (services.chatViewProvider && Array.isArray(suggestions)) {
            services.chatViewProvider.updateCommandSuggestions(suggestions);
        }
    }), external_vscode_.commands.registerCommand('ape.insertToChatInput', (text) => {
        // ì±„íŒ… ìž…ë ¥ì°½ì— í…ìŠ¤íŠ¸ ì‚½ìž…
        if (services.chatViewProvider && typeof text === 'string') {
            services.chatViewProvider.insertToChatInput(text);
        }
    }), 
    // VAULT ê´€ë ¨ ëª…ë ¹ì–´
    external_vscode_.commands.registerCommand('ape.vaultShowItem', (item) => {
        if (!item || !item.metadata) {
            external_vscode_.window.showErrorMessage('VAULT ì•„ì´í…œ ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
            return;
        }
        // ì•„ì´í…œ ë‚´ìš© í‘œì‹œ
        const content = item.metadata.content;
        const title = `VAULT ì•„ì´í…œ: ${item.label}`;
        // ì±„íŒ…ì°½ì— ë‚´ìš© í‘œì‹œ
        external_vscode_.commands.executeCommand('ape.sendLlmResponse', {
            role: 'assistant',
            content: `## ${title}\n\n${content}`
        });
    }));
    // Register Rules commands
    context.subscriptions.push(external_vscode_.commands.registerCommand('ape.rules.activate', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            external_vscode_.window.showErrorMessage('Rule ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
            return;
        }
        try {
            const success = await services.rulesService.activateRule(item.metadata.id);
            if (success) {
                external_vscode_.window.showInformationMessage(`Rule '${item.label}' í™œì„±í™” ì™„ë£Œ`);
                services.treeDataProvider.refresh();
            }
        }
        catch (error) {
            external_vscode_.window.showErrorMessage(`Rule í™œì„±í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
        }
    }), external_vscode_.commands.registerCommand('ape.rules.deactivate', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            external_vscode_.window.showErrorMessage('Rule ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
            return;
        }
        try {
            const success = await services.rulesService.deactivateRule(item.metadata.id);
            if (success) {
                external_vscode_.window.showInformationMessage(`Rule '${item.label}' ë¹„í™œì„±í™” ì™„ë£Œ`);
                services.treeDataProvider.refresh();
            }
        }
        catch (error) {
            external_vscode_.window.showErrorMessage(`Rule ë¹„í™œì„±í™” ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
        }
    }), external_vscode_.commands.registerCommand('ape.rules.openFile', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            external_vscode_.window.showErrorMessage('Rule ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
            return;
        }
        try {
            await services.rulesService.openRuleFile(item.metadata.id);
        }
        catch (error) {
            external_vscode_.window.showErrorMessage(`Rule íŒŒì¼ ì—´ê¸° ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
        }
    }), external_vscode_.commands.registerCommand('ape.rules.refresh', () => {
        try {
            services.rulesService.loadAllRules();
            services.treeDataProvider.refresh();
        }
        catch (error) {
            external_vscode_.window.showErrorMessage(`Rules ìƒˆë¡œê³ ì¹¨ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
        }
    }), external_vscode_.commands.registerCommand('ape.rules.create', async () => {
        try {
            // ê·œì¹™ ì´ë¦„ ìž…ë ¥ ë°›ê¸°
            const ruleName = await external_vscode_.window.showInputBox({
                prompt: 'ìƒˆë¡œìš´ Rule ì´ë¦„ì„ ìž…ë ¥í•˜ì„¸ìš”',
                placeHolder: 'ì˜ˆ: ì½”ë“œ ìž‘ì„± ê·œì¹™, API ì‚¬ìš© ì§€ì¹¨ ë“±',
                validateInput: (value) => {
                    if (!value || value.trim().length === 0) {
                        return 'ì´ë¦„ì€ ë¹„ì›Œë‘˜ ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
                    }
                    return null;
                }
            });
            if (!ruleName) {
                return; // ì‚¬ìš©ìžê°€ ì·¨ì†Œí•œ ê²½ìš°
            }
            // ìƒˆ ë¬¸ì„œ ìƒì„±
            const rulePath = external_path_.join(services.rulesService['rulesDir'], `${ruleName.toLowerCase().replace(/\s+/g, '-').replace(/[^a-z0-9-]/g, '')}.md`);
            const ruleContent = `# ${ruleName}\n\nì—¬ê¸°ì— LLMì— ì ìš©í•  ê·œì¹™ ë‚´ìš©ì„ ìž‘ì„±í•˜ì„¸ìš”.\n\nê·œì¹™ì€ ë§ˆí¬ë‹¤ìš´ í˜•ì‹ìœ¼ë¡œ ìž‘ì„±ë©ë‹ˆë‹¤.\n\n## ì˜ˆì‹œ\n\n1. í•­ìƒ ì½”ë“œì— ì£¼ì„ì„ ì¶”ê°€í•´ì£¼ì„¸ìš”.\n2. ì‘ë‹µì€ ê°„ê²°í•˜ê²Œ ìœ ì§€í•´ì£¼ì„¸ìš”.\n3. ì—ëŸ¬ ì²˜ë¦¬ë¥¼ í•­ìƒ í¬í•¨í•´ì£¼ì„¸ìš”.`;
            // ê·œì¹™ ìƒì„±
            const rule = await services.rulesService.createRule(ruleName, ruleContent, false);
            // ìƒì„±ëœ ê·œì¹™ íŒŒì¼ ì—´ê¸°
            await services.rulesService.openRuleFile(rule.id);
            // íŠ¸ë¦¬ë·° ìƒˆë¡œê³ ì¹¨
            services.treeDataProvider.refresh();
            external_vscode_.window.showInformationMessage(`Rule '${ruleName}' ìƒì„± ì™„ë£Œ. íŒŒì¼ì„ ìˆ˜ì •í•œ í›„ ì €ìž¥í•˜ì„¸ìš”.`);
        }
        catch (error) {
            external_vscode_.window.showErrorMessage(`Rule ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
        }
    }), external_vscode_.commands.registerCommand('ape.rules.delete', async (item) => {
        if (!item || !item.metadata || !item.metadata.id) {
            external_vscode_.window.showErrorMessage('Rule ì •ë³´ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤');
            return;
        }
        try {
            // ì‚­ì œ í™•ì¸
            const confirmation = await external_vscode_.window.showWarningMessage(`Rule '${item.label}'ì„(ë¥¼) ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?`, { modal: true }, 'ì‚­ì œ', 'ì·¨ì†Œ');
            if (confirmation !== 'ì‚­ì œ') {
                return;
            }
            // ê·œì¹™ ì‚­ì œ
            const success = await services.rulesService.deleteRule(item.metadata.id);
            if (success) {
                external_vscode_.window.showInformationMessage(`Rule '${item.label}' ì‚­ì œ ì™„ë£Œ`);
                services.treeDataProvider.refresh();
            }
        }
        catch (error) {
            external_vscode_.window.showErrorMessage(`Rule ì‚­ì œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ${error instanceof Error ? error.message : String(error)}`);
        }
    }));
    // Register plugin system commands
    context.subscriptions.push(external_vscode_.commands.registerCommand('ape.plugins.list', async () => {
        const plugins = services.pluginRegistry.getAllPlugins();
        const items = plugins.map(plugin => ({
            label: `${plugin.metadata.name} (${plugin.metadata.version})`,
            description: plugin.state,
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await external_vscode_.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to see details'
        });
        if (selected) {
            const actions = [];
            if (selected.plugin.state === 'active') {
                actions.push('Deactivate');
            }
            else if (selected.plugin.state === 'registered' || selected.plugin.state === 'inactive') {
                actions.push('Activate');
            }
            actions.push('View Details', 'Open Settings');
            const action = await external_vscode_.window.showQuickPick(actions, {
                placeHolder: 'Select an action'
            });
            if (action === 'Activate') {
                await services.pluginRegistry.activatePlugin(selected.plugin.id);
                external_vscode_.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} activated`);
            }
            else if (action === 'Deactivate') {
                await services.pluginRegistry.deactivatePlugin(selected.plugin.id);
                external_vscode_.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} deactivated`);
            }
            else if (action === 'View Details') {
                // Show details in output channel
                const outputChannel = external_vscode_.window.createOutputChannel(`APE Plugin: ${selected.plugin.metadata.name}`);
                outputChannel.appendLine(`ID: ${selected.plugin.id}`);
                outputChannel.appendLine(`Name: ${selected.plugin.metadata.name}`);
                outputChannel.appendLine(`Version: ${selected.plugin.metadata.version}`);
                outputChannel.appendLine(`Description: ${selected.plugin.metadata.description || 'No description'}`);
                outputChannel.appendLine(`Author: ${selected.plugin.metadata.author || 'Unknown'}`);
                outputChannel.appendLine(`State: ${selected.plugin.state}`);
                if (selected.plugin.metadata.dependencies?.length) {
                    outputChannel.appendLine(`Dependencies: ${selected.plugin.metadata.dependencies.join(', ')}`);
                }
                if (selected.plugin.error) {
                    outputChannel.appendLine(`\nError: ${selected.plugin.error.message}`);
                }
                outputChannel.show();
            }
            else if (action === 'Open Settings') {
                external_vscode_.commands.executeCommand('workbench.action.openSettings', `ape.plugins.${selected.plugin.id}`);
            }
        }
    }), external_vscode_.commands.registerCommand('ape.plugins.activate', async () => {
        const plugins = services.pluginRegistry.getAllPlugins()
            .filter(p => p.state !== 'active');
        const items = plugins.map(plugin => ({
            label: plugin.metadata.name,
            description: plugin.state,
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await external_vscode_.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to activate'
        });
        if (selected) {
            try {
                const success = await services.pluginRegistry.activatePlugin(selected.plugin.id);
                if (success) {
                    external_vscode_.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} activated`);
                }
                else {
                    external_vscode_.window.showErrorMessage(`Failed to activate plugin ${selected.plugin.metadata.name}`);
                }
            }
            catch (error) {
                external_vscode_.window.showErrorMessage(`Failed to activate plugin: ${error.message}`);
            }
        }
    }), external_vscode_.commands.registerCommand('ape.plugins.deactivate', async () => {
        const plugins = services.pluginRegistry.getActivePlugins();
        const items = plugins.map(plugin => ({
            label: plugin.metadata.name,
            description: 'active',
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await external_vscode_.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to deactivate'
        });
        if (selected) {
            try {
                const success = await services.pluginRegistry.deactivatePlugin(selected.plugin.id);
                if (success) {
                    external_vscode_.window.showInformationMessage(`Plugin ${selected.plugin.metadata.name} deactivated`);
                }
                else {
                    external_vscode_.window.showErrorMessage(`Failed to deactivate plugin ${selected.plugin.metadata.name}`);
                }
            }
            catch (error) {
                external_vscode_.window.showErrorMessage(`Failed to deactivate plugin: ${error.message}`);
            }
        }
    }), external_vscode_.commands.registerCommand('ape.plugins.openSettings', async () => {
        const plugins = services.pluginRegistry.getAllPlugins();
        const items = plugins.map(plugin => ({
            label: plugin.metadata.name,
            description: plugin.state,
            detail: plugin.metadata.description,
            plugin
        }));
        const selected = await external_vscode_.window.showQuickPick(items, {
            placeHolder: 'Select a plugin to open settings'
        });
        if (selected) {
            external_vscode_.commands.executeCommand('workbench.action.openSettings', `ape.plugins.${selected.plugin.id}`);
        }
    }));
    // Add all services to context subscriptions for proper disposal
    context.subscriptions.push(services.modelManager, services.llmService, services.memoryService, services.bitbucketService, services.autoCommitService, services.vaultService, services.rulesService, services.jiraService, services.configManager, {
        dispose: () => {
            // Dispose plugin system
            services.pluginLoader.deactivateAllPlugins().catch(error => {
                console.error('Error deactivating plugins during extension deactivation:', error);
            });
            services.pluginSettingsManager.dispose();
            // Event emitter doesn't need explicit disposal
        }
    });
}
/**
 * Extension activation point
 * @param context Extension context
 */
async function activate(context) {
    console.log('APE Extension is now active!');
    // í…ŒìŠ¤íŠ¸ ëª¨ë“œ ì—¬ë¶€ í™•ì¸ ë° í™˜ê²½ ë³€ìˆ˜ ì„¤ì •
    const isTestMode = external_vscode_.workspace.getConfiguration('ape').get('testing.enabled') ||
        process.env.APE_TEST_MODE === 'true';
    if (isTestMode) {
        process.env.APE_TEST_MODE = 'true';
        console.log('APE í…ŒìŠ¤íŠ¸ ëª¨ë“œ í™œì„±í™”ë¨: ìžë™ ê¶Œí•œ í—ˆìš©ì´ í™œì„±í™”ë©ë‹ˆë‹¤.');
        // ê¶Œí•œ ìš”ì²­ ìžë™ ìˆ˜ë½ ëª…ë ¹ ë“±ë¡
        context.subscriptions.push(external_vscode_.commands.registerCommand('ape.acceptAllPermissions', () => {
            external_vscode_.window.showInformationMessage('ëª¨ë“  ê¶Œí•œ ìš”ì²­ì´ ìžë™ìœ¼ë¡œ ìˆ˜ë½ë©ë‹ˆë‹¤.');
            return true;
        }));
    }
    // í˜„ìž¬ ë²„ì „ ì •ë³´ë¥¼ ìƒíƒœ í‘œì‹œì¤„ì— í‘œì‹œ
    try {
        const versionInfo = await context.extension.packageJSON.version;
        const statusBarItem = external_vscode_.window.createStatusBarItem(external_vscode_.StatusBarAlignment.Right, 100);
        statusBarItem.text = `$(tag) APE v${versionInfo}`;
        statusBarItem.tooltip = 'APE Extension Version';
        statusBarItem.show();
        context.subscriptions.push(statusBarItem);
    }
    catch (error) {
        console.error('Failed to display version in status bar:', error);
    }
    try {
        // Initialize all services
        const services = await initializeServices(context);
        // Register VSCode components
        registerComponents(context, services);
        // Load internal plugins
        try {
            const internalPluginCount = await services.pluginLoader.loadInternalPlugins();
            console.log(`Loaded ${internalPluginCount} internal plugins`);
            // Load external plugins
            const externalPluginCount = await services.pluginLoader.loadExternalPlugins();
            console.log(`Loaded ${externalPluginCount} external plugins`);
            // Auto-activate plugins based on extension activation event
            services.pluginLoader.activatePluginsByEvent('onExtensionActivate').catch(error => {
                console.error('Error activating plugins on extension activation:', error);
            });
        }
        catch (error) {
            console.error('Failed to initialize plugin system:', error);
            external_vscode_.window.showErrorMessage('Failed to initialize APE plugin system. Some features may not work properly.');
        }
        // Show welcome message on first activation
        const hasShownWelcome = context.globalState.get('ape.hasShownWelcome');
        // ì•± ì‹œìž‘ ì‹œ ì±„íŒ… í™”ë©´ê³¼ íŠ¸ë¦¬ë·° ë¹„ìœ¨(3:1)ë¡œ ì„¤ì •
        setTimeout(async () => {
            try {
                // VSCode ë ˆì´ì•„ì›ƒ ì´ˆê¸°í™”
                await external_vscode_.commands.executeCommand('workbench.action.resetLayout');
                await sleep(300);
                // ì‚¬ì´ë“œë°” ì—´ê¸° (íŠ¸ë¦¬ë·° í‘œì‹œ)
                await external_vscode_.commands.executeCommand('workbench.view.extension.ape-sidebar');
                console.log('APE Sidebar opened');
                await sleep(100);
                // ë¨¼ì € ì±„íŒ… ë·°ì— ì§ì ‘ ì ‘ê·¼
                await external_vscode_.commands.executeCommand('apeChat.focus');
                console.log('APE Chat view activated');
                await sleep(100);
                // ì±„íŒ…ë·°ì™€ íŠ¸ë¦¬ë·°ì˜ ë¹„ìœ¨ ì¡°ì • (3:1)ì„ ìœ„í•œ ìž‘ì—…
                // ë¨¼ì € ì‚¬ì´ë“œë°” í¬ê¸° ì¤„ì´ê¸° (VSCode APIëŠ” ìƒëŒ€ì ì¸ í¬ê¸° ì¡°ì •ë§Œ ì œê³µ)
                const decreaseCount = 6; // ì‚¬ì´ë“œë°”ë¥¼ ì¶©ë¶„ížˆ ì¢ê²Œ
                for (let i = 0; i < decreaseCount; i++) {
                    await external_vscode_.commands.executeCommand('workbench.action.decreaseSideBarWidth');
                    await sleep(30); // ê° ëª…ë ¹ ì‚¬ì´ì— ì•½ê°„ì˜ ì§€ì—°
                }
                // ì—ë””í„° ì˜ì—­ í¬ê¸° ì¦ê°€ (ì±„íŒ…ë·°ë¥¼ ìœ„í•´)
                const increaseCount = 3; // ì±„íŒ…ë·° ì˜ì—­ í™•ìž¥
                for (let i = 0; i < increaseCount; i++) {
                    await external_vscode_.commands.executeCommand('workbench.action.increaseViewSize');
                    await sleep(30);
                }
                // ì±„íŒ… ë·° í¬ì»¤ì‹± ë‹¤ì‹œ í•œë²ˆ í™•ì¸
                await sleep(100);
                await external_vscode_.commands.executeCommand('apeChat.focus');
            }
            catch (error) {
                console.error('ì±„íŒ… ë·° ë° íŠ¸ë¦¬ë·° ì´ˆê¸°í™” ì¤‘ ì˜¤ë¥˜:', error);
                // ì—ëŸ¬ ë°œìƒì‹œ ê¸°ë³¸ ì•¡ì…˜
                try {
                    await external_vscode_.commands.executeCommand('workbench.view.extension.ape-sidebar');
                    console.log('APE Sidebar opened as fallback');
                }
                catch (sidebarError) {
                    console.error('ì‚¬ì´ë“œë°” ì—´ê¸° ì‹¤íŒ¨:', sidebarError);
                }
            }
        }, 1500); // ì¶©ë¶„í•œ ì§€ì—° ì‹œê°„ìœ¼ë¡œ í™•ì‹¤ížˆ ì´ˆê¸°í™” í›„ ì‹¤í–‰
        // ì§§ì€ ì§€ì—°ì„ ìœ„í•œ í—¬í¼ í•¨ìˆ˜
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }
        if (!hasShownWelcome) {
            external_vscode_.window.showInformationMessage('APE Extension is now active! Open the APE sidebar to start using it.', 'Open APE Sidebar').then(selection => {
                if (selection === 'Open APE Sidebar') {
                    external_vscode_.commands.executeCommand('workbench.view.extension.ape-sidebar');
                }
            });
            context.globalState.update('ape.hasShownWelcome', true);
        }
    }
    catch (error) {
        console.error('Failed to activate APE extension:', error);
        external_vscode_.window.showErrorMessage(`Failed to activate APE extension: ${error instanceof Error ? error.message : String(error)}`);
    }
}
/**
 * Extension deactivation point
 *
 * í™•ìž¥ í”„ë¡œê·¸ëž¨ ë¹„í™œì„±í™” ì‹œ í˜¸ì¶œë˜ë©°, ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ë° ë©”ëª¨ë¦¬ í•´ì œë¥¼ ìˆ˜í–‰í•©ë‹ˆë‹¤.
 * - ì—´ë ¤ìžˆëŠ” ì—°ê²° ì¢…ë£Œ (LLM ìŠ¤íŠ¸ë¦¬ë° ë“±)
 * - ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ì œê±°
 * - ìºì‹œëœ ë°ì´í„° ì •ë¦¬
 * - ë¶ˆí•„ìš”í•œ ë©”ëª¨ë¦¬ í•´ì œ
 */
function deactivate() {
    console.log('APE Extension is deactivated');
}

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=extension.js.map